// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	m2 "github.com/aws/aws-sdk-go-v2/service/m2"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CancelBatchJobExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelBatchJobExecution(ctx context.Context, params *m2.CancelBatchJobExecutionInput, optFns ...func(*m2.Options)) (*m2.CancelBatchJobExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBatchJobExecution")
	}

	var r0 *m2.CancelBatchJobExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CancelBatchJobExecutionInput, ...func(*m2.Options)) (*m2.CancelBatchJobExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CancelBatchJobExecutionInput, ...func(*m2.Options)) *m2.CancelBatchJobExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.CancelBatchJobExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.CancelBatchJobExecutionInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApplication(ctx context.Context, params *m2.CreateApplicationInput, optFns ...func(*m2.Options)) (*m2.CreateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApplication")
	}

	var r0 *m2.CreateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateApplicationInput, ...func(*m2.Options)) (*m2.CreateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateApplicationInput, ...func(*m2.Options)) *m2.CreateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.CreateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.CreateApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataSetImportTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataSetImportTask(ctx context.Context, params *m2.CreateDataSetImportTaskInput, optFns ...func(*m2.Options)) (*m2.CreateDataSetImportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataSetImportTask")
	}

	var r0 *m2.CreateDataSetImportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateDataSetImportTaskInput, ...func(*m2.Options)) (*m2.CreateDataSetImportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateDataSetImportTaskInput, ...func(*m2.Options)) *m2.CreateDataSetImportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.CreateDataSetImportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.CreateDataSetImportTaskInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDeployment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDeployment(ctx context.Context, params *m2.CreateDeploymentInput, optFns ...func(*m2.Options)) (*m2.CreateDeploymentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDeployment")
	}

	var r0 *m2.CreateDeploymentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateDeploymentInput, ...func(*m2.Options)) (*m2.CreateDeploymentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateDeploymentInput, ...func(*m2.Options)) *m2.CreateDeploymentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.CreateDeploymentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.CreateDeploymentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEnvironment(ctx context.Context, params *m2.CreateEnvironmentInput, optFns ...func(*m2.Options)) (*m2.CreateEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEnvironment")
	}

	var r0 *m2.CreateEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateEnvironmentInput, ...func(*m2.Options)) (*m2.CreateEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.CreateEnvironmentInput, ...func(*m2.Options)) *m2.CreateEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.CreateEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.CreateEnvironmentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplication(ctx context.Context, params *m2.DeleteApplicationInput, optFns ...func(*m2.Options)) (*m2.DeleteApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplication")
	}

	var r0 *m2.DeleteApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteApplicationInput, ...func(*m2.Options)) (*m2.DeleteApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteApplicationInput, ...func(*m2.Options)) *m2.DeleteApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.DeleteApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.DeleteApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplicationFromEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplicationFromEnvironment(ctx context.Context, params *m2.DeleteApplicationFromEnvironmentInput, optFns ...func(*m2.Options)) (*m2.DeleteApplicationFromEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplicationFromEnvironment")
	}

	var r0 *m2.DeleteApplicationFromEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteApplicationFromEnvironmentInput, ...func(*m2.Options)) (*m2.DeleteApplicationFromEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteApplicationFromEnvironmentInput, ...func(*m2.Options)) *m2.DeleteApplicationFromEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.DeleteApplicationFromEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.DeleteApplicationFromEnvironmentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEnvironment(ctx context.Context, params *m2.DeleteEnvironmentInput, optFns ...func(*m2.Options)) (*m2.DeleteEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEnvironment")
	}

	var r0 *m2.DeleteEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteEnvironmentInput, ...func(*m2.Options)) (*m2.DeleteEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.DeleteEnvironmentInput, ...func(*m2.Options)) *m2.DeleteEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.DeleteEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.DeleteEnvironmentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetApplication(ctx context.Context, params *m2.GetApplicationInput, optFns ...func(*m2.Options)) (*m2.GetApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApplication")
	}

	var r0 *m2.GetApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetApplicationInput, ...func(*m2.Options)) (*m2.GetApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetApplicationInput, ...func(*m2.Options)) *m2.GetApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplicationVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetApplicationVersion(ctx context.Context, params *m2.GetApplicationVersionInput, optFns ...func(*m2.Options)) (*m2.GetApplicationVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApplicationVersion")
	}

	var r0 *m2.GetApplicationVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetApplicationVersionInput, ...func(*m2.Options)) (*m2.GetApplicationVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetApplicationVersionInput, ...func(*m2.Options)) *m2.GetApplicationVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetApplicationVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetApplicationVersionInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchJobExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBatchJobExecution(ctx context.Context, params *m2.GetBatchJobExecutionInput, optFns ...func(*m2.Options)) (*m2.GetBatchJobExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchJobExecution")
	}

	var r0 *m2.GetBatchJobExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetBatchJobExecutionInput, ...func(*m2.Options)) (*m2.GetBatchJobExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetBatchJobExecutionInput, ...func(*m2.Options)) *m2.GetBatchJobExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetBatchJobExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetBatchJobExecutionInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataSetDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataSetDetails(ctx context.Context, params *m2.GetDataSetDetailsInput, optFns ...func(*m2.Options)) (*m2.GetDataSetDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSetDetails")
	}

	var r0 *m2.GetDataSetDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDataSetDetailsInput, ...func(*m2.Options)) (*m2.GetDataSetDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDataSetDetailsInput, ...func(*m2.Options)) *m2.GetDataSetDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetDataSetDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetDataSetDetailsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataSetImportTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataSetImportTask(ctx context.Context, params *m2.GetDataSetImportTaskInput, optFns ...func(*m2.Options)) (*m2.GetDataSetImportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSetImportTask")
	}

	var r0 *m2.GetDataSetImportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDataSetImportTaskInput, ...func(*m2.Options)) (*m2.GetDataSetImportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDataSetImportTaskInput, ...func(*m2.Options)) *m2.GetDataSetImportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetDataSetImportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetDataSetImportTaskInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDeployment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDeployment(ctx context.Context, params *m2.GetDeploymentInput, optFns ...func(*m2.Options)) (*m2.GetDeploymentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDeployment")
	}

	var r0 *m2.GetDeploymentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDeploymentInput, ...func(*m2.Options)) (*m2.GetDeploymentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetDeploymentInput, ...func(*m2.Options)) *m2.GetDeploymentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetDeploymentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetDeploymentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEnvironment(ctx context.Context, params *m2.GetEnvironmentInput, optFns ...func(*m2.Options)) (*m2.GetEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEnvironment")
	}

	var r0 *m2.GetEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetEnvironmentInput, ...func(*m2.Options)) (*m2.GetEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetEnvironmentInput, ...func(*m2.Options)) *m2.GetEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetEnvironmentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSignedBluinsightsUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSignedBluinsightsUrl(ctx context.Context, params *m2.GetSignedBluinsightsUrlInput, optFns ...func(*m2.Options)) (*m2.GetSignedBluinsightsUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSignedBluinsightsUrl")
	}

	var r0 *m2.GetSignedBluinsightsUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetSignedBluinsightsUrlInput, ...func(*m2.Options)) (*m2.GetSignedBluinsightsUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.GetSignedBluinsightsUrlInput, ...func(*m2.Options)) *m2.GetSignedBluinsightsUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.GetSignedBluinsightsUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.GetSignedBluinsightsUrlInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplicationVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplicationVersions(ctx context.Context, params *m2.ListApplicationVersionsInput, optFns ...func(*m2.Options)) (*m2.ListApplicationVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplicationVersions")
	}

	var r0 *m2.ListApplicationVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListApplicationVersionsInput, ...func(*m2.Options)) (*m2.ListApplicationVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListApplicationVersionsInput, ...func(*m2.Options)) *m2.ListApplicationVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListApplicationVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListApplicationVersionsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplications(ctx context.Context, params *m2.ListApplicationsInput, optFns ...func(*m2.Options)) (*m2.ListApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplications")
	}

	var r0 *m2.ListApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListApplicationsInput, ...func(*m2.Options)) (*m2.ListApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListApplicationsInput, ...func(*m2.Options)) *m2.ListApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListApplicationsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBatchJobDefinitions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBatchJobDefinitions(ctx context.Context, params *m2.ListBatchJobDefinitionsInput, optFns ...func(*m2.Options)) (*m2.ListBatchJobDefinitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchJobDefinitions")
	}

	var r0 *m2.ListBatchJobDefinitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobDefinitionsInput, ...func(*m2.Options)) (*m2.ListBatchJobDefinitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobDefinitionsInput, ...func(*m2.Options)) *m2.ListBatchJobDefinitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListBatchJobDefinitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListBatchJobDefinitionsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBatchJobExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBatchJobExecutions(ctx context.Context, params *m2.ListBatchJobExecutionsInput, optFns ...func(*m2.Options)) (*m2.ListBatchJobExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchJobExecutions")
	}

	var r0 *m2.ListBatchJobExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobExecutionsInput, ...func(*m2.Options)) (*m2.ListBatchJobExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobExecutionsInput, ...func(*m2.Options)) *m2.ListBatchJobExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListBatchJobExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListBatchJobExecutionsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBatchJobRestartPoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBatchJobRestartPoints(ctx context.Context, params *m2.ListBatchJobRestartPointsInput, optFns ...func(*m2.Options)) (*m2.ListBatchJobRestartPointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchJobRestartPoints")
	}

	var r0 *m2.ListBatchJobRestartPointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobRestartPointsInput, ...func(*m2.Options)) (*m2.ListBatchJobRestartPointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListBatchJobRestartPointsInput, ...func(*m2.Options)) *m2.ListBatchJobRestartPointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListBatchJobRestartPointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListBatchJobRestartPointsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSetImportHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSetImportHistory(ctx context.Context, params *m2.ListDataSetImportHistoryInput, optFns ...func(*m2.Options)) (*m2.ListDataSetImportHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSetImportHistory")
	}

	var r0 *m2.ListDataSetImportHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDataSetImportHistoryInput, ...func(*m2.Options)) (*m2.ListDataSetImportHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDataSetImportHistoryInput, ...func(*m2.Options)) *m2.ListDataSetImportHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListDataSetImportHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListDataSetImportHistoryInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSets(ctx context.Context, params *m2.ListDataSetsInput, optFns ...func(*m2.Options)) (*m2.ListDataSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSets")
	}

	var r0 *m2.ListDataSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDataSetsInput, ...func(*m2.Options)) (*m2.ListDataSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDataSetsInput, ...func(*m2.Options)) *m2.ListDataSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListDataSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListDataSetsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDeployments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDeployments(ctx context.Context, params *m2.ListDeploymentsInput, optFns ...func(*m2.Options)) (*m2.ListDeploymentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDeployments")
	}

	var r0 *m2.ListDeploymentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDeploymentsInput, ...func(*m2.Options)) (*m2.ListDeploymentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListDeploymentsInput, ...func(*m2.Options)) *m2.ListDeploymentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListDeploymentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListDeploymentsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEngineVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEngineVersions(ctx context.Context, params *m2.ListEngineVersionsInput, optFns ...func(*m2.Options)) (*m2.ListEngineVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEngineVersions")
	}

	var r0 *m2.ListEngineVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListEngineVersionsInput, ...func(*m2.Options)) (*m2.ListEngineVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListEngineVersionsInput, ...func(*m2.Options)) *m2.ListEngineVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListEngineVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListEngineVersionsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEnvironments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEnvironments(ctx context.Context, params *m2.ListEnvironmentsInput, optFns ...func(*m2.Options)) (*m2.ListEnvironmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEnvironments")
	}

	var r0 *m2.ListEnvironmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListEnvironmentsInput, ...func(*m2.Options)) (*m2.ListEnvironmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListEnvironmentsInput, ...func(*m2.Options)) *m2.ListEnvironmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListEnvironmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListEnvironmentsInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *m2.ListTagsForResourceInput, optFns ...func(*m2.Options)) (*m2.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *m2.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListTagsForResourceInput, ...func(*m2.Options)) (*m2.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.ListTagsForResourceInput, ...func(*m2.Options)) *m2.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.ListTagsForResourceInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() m2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 m2.Options
	if rf, ok := ret.Get(0).(func() m2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(m2.Options)
	}

	return r0
}

// StartApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartApplication(ctx context.Context, params *m2.StartApplicationInput, optFns ...func(*m2.Options)) (*m2.StartApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartApplication")
	}

	var r0 *m2.StartApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StartApplicationInput, ...func(*m2.Options)) (*m2.StartApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StartApplicationInput, ...func(*m2.Options)) *m2.StartApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.StartApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.StartApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBatchJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBatchJob(ctx context.Context, params *m2.StartBatchJobInput, optFns ...func(*m2.Options)) (*m2.StartBatchJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBatchJob")
	}

	var r0 *m2.StartBatchJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StartBatchJobInput, ...func(*m2.Options)) (*m2.StartBatchJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StartBatchJobInput, ...func(*m2.Options)) *m2.StartBatchJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.StartBatchJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.StartBatchJobInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopApplication(ctx context.Context, params *m2.StopApplicationInput, optFns ...func(*m2.Options)) (*m2.StopApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopApplication")
	}

	var r0 *m2.StopApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StopApplicationInput, ...func(*m2.Options)) (*m2.StopApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.StopApplicationInput, ...func(*m2.Options)) *m2.StopApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.StopApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.StopApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *m2.TagResourceInput, optFns ...func(*m2.Options)) (*m2.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *m2.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.TagResourceInput, ...func(*m2.Options)) (*m2.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.TagResourceInput, ...func(*m2.Options)) *m2.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.TagResourceInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *m2.UntagResourceInput, optFns ...func(*m2.Options)) (*m2.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *m2.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UntagResourceInput, ...func(*m2.Options)) (*m2.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UntagResourceInput, ...func(*m2.Options)) *m2.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.UntagResourceInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApplication(ctx context.Context, params *m2.UpdateApplicationInput, optFns ...func(*m2.Options)) (*m2.UpdateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApplication")
	}

	var r0 *m2.UpdateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UpdateApplicationInput, ...func(*m2.Options)) (*m2.UpdateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UpdateApplicationInput, ...func(*m2.Options)) *m2.UpdateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.UpdateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.UpdateApplicationInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEnvironment(ctx context.Context, params *m2.UpdateEnvironmentInput, optFns ...func(*m2.Options)) (*m2.UpdateEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEnvironment")
	}

	var r0 *m2.UpdateEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UpdateEnvironmentInput, ...func(*m2.Options)) (*m2.UpdateEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *m2.UpdateEnvironmentInput, ...func(*m2.Options)) *m2.UpdateEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*m2.UpdateEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *m2.UpdateEnvironmentInput, ...func(*m2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
