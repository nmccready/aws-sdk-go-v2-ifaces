// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	frauddetector "github.com/aws/aws-sdk-go-v2/service/frauddetector"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchCreateVariable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreateVariable(ctx context.Context, params *frauddetector.BatchCreateVariableInput, optFns ...func(*frauddetector.Options)) (*frauddetector.BatchCreateVariableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreateVariable")
	}

	var r0 *frauddetector.BatchCreateVariableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.BatchCreateVariableInput, ...func(*frauddetector.Options)) (*frauddetector.BatchCreateVariableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.BatchCreateVariableInput, ...func(*frauddetector.Options)) *frauddetector.BatchCreateVariableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.BatchCreateVariableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.BatchCreateVariableInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetVariable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetVariable(ctx context.Context, params *frauddetector.BatchGetVariableInput, optFns ...func(*frauddetector.Options)) (*frauddetector.BatchGetVariableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetVariable")
	}

	var r0 *frauddetector.BatchGetVariableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.BatchGetVariableInput, ...func(*frauddetector.Options)) (*frauddetector.BatchGetVariableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.BatchGetVariableInput, ...func(*frauddetector.Options)) *frauddetector.BatchGetVariableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.BatchGetVariableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.BatchGetVariableInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBatchImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelBatchImportJob(ctx context.Context, params *frauddetector.CancelBatchImportJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CancelBatchImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBatchImportJob")
	}

	var r0 *frauddetector.CancelBatchImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CancelBatchImportJobInput, ...func(*frauddetector.Options)) (*frauddetector.CancelBatchImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CancelBatchImportJobInput, ...func(*frauddetector.Options)) *frauddetector.CancelBatchImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CancelBatchImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CancelBatchImportJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBatchPredictionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelBatchPredictionJob(ctx context.Context, params *frauddetector.CancelBatchPredictionJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CancelBatchPredictionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBatchPredictionJob")
	}

	var r0 *frauddetector.CancelBatchPredictionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CancelBatchPredictionJobInput, ...func(*frauddetector.Options)) (*frauddetector.CancelBatchPredictionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CancelBatchPredictionJobInput, ...func(*frauddetector.Options)) *frauddetector.CancelBatchPredictionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CancelBatchPredictionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CancelBatchPredictionJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBatchImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBatchImportJob(ctx context.Context, params *frauddetector.CreateBatchImportJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateBatchImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchImportJob")
	}

	var r0 *frauddetector.CreateBatchImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateBatchImportJobInput, ...func(*frauddetector.Options)) (*frauddetector.CreateBatchImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateBatchImportJobInput, ...func(*frauddetector.Options)) *frauddetector.CreateBatchImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateBatchImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateBatchImportJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBatchPredictionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBatchPredictionJob(ctx context.Context, params *frauddetector.CreateBatchPredictionJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateBatchPredictionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchPredictionJob")
	}

	var r0 *frauddetector.CreateBatchPredictionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateBatchPredictionJobInput, ...func(*frauddetector.Options)) (*frauddetector.CreateBatchPredictionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateBatchPredictionJobInput, ...func(*frauddetector.Options)) *frauddetector.CreateBatchPredictionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateBatchPredictionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateBatchPredictionJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDetectorVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDetectorVersion(ctx context.Context, params *frauddetector.CreateDetectorVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateDetectorVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDetectorVersion")
	}

	var r0 *frauddetector.CreateDetectorVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateDetectorVersionInput, ...func(*frauddetector.Options)) (*frauddetector.CreateDetectorVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateDetectorVersionInput, ...func(*frauddetector.Options)) *frauddetector.CreateDetectorVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateDetectorVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateDetectorVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateList(ctx context.Context, params *frauddetector.CreateListInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateList")
	}

	var r0 *frauddetector.CreateListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateListInput, ...func(*frauddetector.Options)) (*frauddetector.CreateListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateListInput, ...func(*frauddetector.Options)) *frauddetector.CreateListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateListInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateModel(ctx context.Context, params *frauddetector.CreateModelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateModel")
	}

	var r0 *frauddetector.CreateModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateModelInput, ...func(*frauddetector.Options)) (*frauddetector.CreateModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateModelInput, ...func(*frauddetector.Options)) *frauddetector.CreateModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateModelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateModelVersion(ctx context.Context, params *frauddetector.CreateModelVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateModelVersion")
	}

	var r0 *frauddetector.CreateModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateModelVersionInput, ...func(*frauddetector.Options)) (*frauddetector.CreateModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateModelVersionInput, ...func(*frauddetector.Options)) *frauddetector.CreateModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateModelVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRule(ctx context.Context, params *frauddetector.CreateRuleInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 *frauddetector.CreateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateRuleInput, ...func(*frauddetector.Options)) (*frauddetector.CreateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateRuleInput, ...func(*frauddetector.Options)) *frauddetector.CreateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateRuleInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVariable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVariable(ctx context.Context, params *frauddetector.CreateVariableInput, optFns ...func(*frauddetector.Options)) (*frauddetector.CreateVariableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVariable")
	}

	var r0 *frauddetector.CreateVariableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateVariableInput, ...func(*frauddetector.Options)) (*frauddetector.CreateVariableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.CreateVariableInput, ...func(*frauddetector.Options)) *frauddetector.CreateVariableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.CreateVariableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.CreateVariableInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBatchImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBatchImportJob(ctx context.Context, params *frauddetector.DeleteBatchImportJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteBatchImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBatchImportJob")
	}

	var r0 *frauddetector.DeleteBatchImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteBatchImportJobInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteBatchImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteBatchImportJobInput, ...func(*frauddetector.Options)) *frauddetector.DeleteBatchImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteBatchImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteBatchImportJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBatchPredictionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBatchPredictionJob(ctx context.Context, params *frauddetector.DeleteBatchPredictionJobInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteBatchPredictionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBatchPredictionJob")
	}

	var r0 *frauddetector.DeleteBatchPredictionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteBatchPredictionJobInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteBatchPredictionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteBatchPredictionJobInput, ...func(*frauddetector.Options)) *frauddetector.DeleteBatchPredictionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteBatchPredictionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteBatchPredictionJobInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDetector provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDetector(ctx context.Context, params *frauddetector.DeleteDetectorInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteDetectorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDetector")
	}

	var r0 *frauddetector.DeleteDetectorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteDetectorInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteDetectorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteDetectorInput, ...func(*frauddetector.Options)) *frauddetector.DeleteDetectorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteDetectorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteDetectorInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDetectorVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDetectorVersion(ctx context.Context, params *frauddetector.DeleteDetectorVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteDetectorVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDetectorVersion")
	}

	var r0 *frauddetector.DeleteDetectorVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteDetectorVersionInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteDetectorVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteDetectorVersionInput, ...func(*frauddetector.Options)) *frauddetector.DeleteDetectorVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteDetectorVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteDetectorVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEntityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEntityType(ctx context.Context, params *frauddetector.DeleteEntityTypeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteEntityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEntityType")
	}

	var r0 *frauddetector.DeleteEntityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEntityTypeInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteEntityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEntityTypeInput, ...func(*frauddetector.Options)) *frauddetector.DeleteEntityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteEntityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteEntityTypeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEvent(ctx context.Context, params *frauddetector.DeleteEventInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 *frauddetector.DeleteEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventInput, ...func(*frauddetector.Options)) *frauddetector.DeleteEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteEventInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventType(ctx context.Context, params *frauddetector.DeleteEventTypeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteEventTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventType")
	}

	var r0 *frauddetector.DeleteEventTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventTypeInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteEventTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventTypeInput, ...func(*frauddetector.Options)) *frauddetector.DeleteEventTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteEventTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteEventTypeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventsByEventType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventsByEventType(ctx context.Context, params *frauddetector.DeleteEventsByEventTypeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteEventsByEventTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventsByEventType")
	}

	var r0 *frauddetector.DeleteEventsByEventTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventsByEventTypeInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteEventsByEventTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteEventsByEventTypeInput, ...func(*frauddetector.Options)) *frauddetector.DeleteEventsByEventTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteEventsByEventTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteEventsByEventTypeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExternalModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteExternalModel(ctx context.Context, params *frauddetector.DeleteExternalModelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteExternalModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExternalModel")
	}

	var r0 *frauddetector.DeleteExternalModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteExternalModelInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteExternalModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteExternalModelInput, ...func(*frauddetector.Options)) *frauddetector.DeleteExternalModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteExternalModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteExternalModelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLabel(ctx context.Context, params *frauddetector.DeleteLabelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLabel")
	}

	var r0 *frauddetector.DeleteLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteLabelInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteLabelInput, ...func(*frauddetector.Options)) *frauddetector.DeleteLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteLabelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteList(ctx context.Context, params *frauddetector.DeleteListInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteList")
	}

	var r0 *frauddetector.DeleteListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteListInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteListInput, ...func(*frauddetector.Options)) *frauddetector.DeleteListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteListInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteModel(ctx context.Context, params *frauddetector.DeleteModelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteModel")
	}

	var r0 *frauddetector.DeleteModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteModelInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteModelInput, ...func(*frauddetector.Options)) *frauddetector.DeleteModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteModelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteModelVersion(ctx context.Context, params *frauddetector.DeleteModelVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteModelVersion")
	}

	var r0 *frauddetector.DeleteModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteModelVersionInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteModelVersionInput, ...func(*frauddetector.Options)) *frauddetector.DeleteModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteModelVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutcome provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteOutcome(ctx context.Context, params *frauddetector.DeleteOutcomeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteOutcomeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutcome")
	}

	var r0 *frauddetector.DeleteOutcomeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteOutcomeInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteOutcomeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteOutcomeInput, ...func(*frauddetector.Options)) *frauddetector.DeleteOutcomeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteOutcomeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteOutcomeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRule(ctx context.Context, params *frauddetector.DeleteRuleInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 *frauddetector.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteRuleInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteRuleInput, ...func(*frauddetector.Options)) *frauddetector.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteRuleInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVariable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVariable(ctx context.Context, params *frauddetector.DeleteVariableInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DeleteVariableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVariable")
	}

	var r0 *frauddetector.DeleteVariableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteVariableInput, ...func(*frauddetector.Options)) (*frauddetector.DeleteVariableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DeleteVariableInput, ...func(*frauddetector.Options)) *frauddetector.DeleteVariableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DeleteVariableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DeleteVariableInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDetector provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDetector(ctx context.Context, params *frauddetector.DescribeDetectorInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DescribeDetectorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDetector")
	}

	var r0 *frauddetector.DescribeDetectorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DescribeDetectorInput, ...func(*frauddetector.Options)) (*frauddetector.DescribeDetectorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DescribeDetectorInput, ...func(*frauddetector.Options)) *frauddetector.DescribeDetectorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DescribeDetectorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DescribeDetectorInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeModelVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeModelVersions(ctx context.Context, params *frauddetector.DescribeModelVersionsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.DescribeModelVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeModelVersions")
	}

	var r0 *frauddetector.DescribeModelVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DescribeModelVersionsInput, ...func(*frauddetector.Options)) (*frauddetector.DescribeModelVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.DescribeModelVersionsInput, ...func(*frauddetector.Options)) *frauddetector.DescribeModelVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.DescribeModelVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.DescribeModelVersionsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBatchImportJobs(ctx context.Context, params *frauddetector.GetBatchImportJobsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetBatchImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchImportJobs")
	}

	var r0 *frauddetector.GetBatchImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetBatchImportJobsInput, ...func(*frauddetector.Options)) (*frauddetector.GetBatchImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetBatchImportJobsInput, ...func(*frauddetector.Options)) *frauddetector.GetBatchImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetBatchImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetBatchImportJobsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchPredictionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBatchPredictionJobs(ctx context.Context, params *frauddetector.GetBatchPredictionJobsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetBatchPredictionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchPredictionJobs")
	}

	var r0 *frauddetector.GetBatchPredictionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetBatchPredictionJobsInput, ...func(*frauddetector.Options)) (*frauddetector.GetBatchPredictionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetBatchPredictionJobsInput, ...func(*frauddetector.Options)) *frauddetector.GetBatchPredictionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetBatchPredictionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetBatchPredictionJobsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDeleteEventsByEventTypeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDeleteEventsByEventTypeStatus(ctx context.Context, params *frauddetector.GetDeleteEventsByEventTypeStatusInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetDeleteEventsByEventTypeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDeleteEventsByEventTypeStatus")
	}

	var r0 *frauddetector.GetDeleteEventsByEventTypeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDeleteEventsByEventTypeStatusInput, ...func(*frauddetector.Options)) (*frauddetector.GetDeleteEventsByEventTypeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDeleteEventsByEventTypeStatusInput, ...func(*frauddetector.Options)) *frauddetector.GetDeleteEventsByEventTypeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetDeleteEventsByEventTypeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetDeleteEventsByEventTypeStatusInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDetectorVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDetectorVersion(ctx context.Context, params *frauddetector.GetDetectorVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetDetectorVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDetectorVersion")
	}

	var r0 *frauddetector.GetDetectorVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDetectorVersionInput, ...func(*frauddetector.Options)) (*frauddetector.GetDetectorVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDetectorVersionInput, ...func(*frauddetector.Options)) *frauddetector.GetDetectorVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetDetectorVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetDetectorVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDetectors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDetectors(ctx context.Context, params *frauddetector.GetDetectorsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetDetectorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDetectors")
	}

	var r0 *frauddetector.GetDetectorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDetectorsInput, ...func(*frauddetector.Options)) (*frauddetector.GetDetectorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetDetectorsInput, ...func(*frauddetector.Options)) *frauddetector.GetDetectorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetDetectorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetDetectorsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEntityTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEntityTypes(ctx context.Context, params *frauddetector.GetEntityTypesInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetEntityTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityTypes")
	}

	var r0 *frauddetector.GetEntityTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEntityTypesInput, ...func(*frauddetector.Options)) (*frauddetector.GetEntityTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEntityTypesInput, ...func(*frauddetector.Options)) *frauddetector.GetEntityTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetEntityTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetEntityTypesInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvent(ctx context.Context, params *frauddetector.GetEventInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvent")
	}

	var r0 *frauddetector.GetEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventInput, ...func(*frauddetector.Options)) (*frauddetector.GetEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventInput, ...func(*frauddetector.Options)) *frauddetector.GetEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetEventInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventPrediction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventPrediction(ctx context.Context, params *frauddetector.GetEventPredictionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetEventPredictionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventPrediction")
	}

	var r0 *frauddetector.GetEventPredictionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventPredictionInput, ...func(*frauddetector.Options)) (*frauddetector.GetEventPredictionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventPredictionInput, ...func(*frauddetector.Options)) *frauddetector.GetEventPredictionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetEventPredictionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetEventPredictionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventPredictionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventPredictionMetadata(ctx context.Context, params *frauddetector.GetEventPredictionMetadataInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetEventPredictionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventPredictionMetadata")
	}

	var r0 *frauddetector.GetEventPredictionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventPredictionMetadataInput, ...func(*frauddetector.Options)) (*frauddetector.GetEventPredictionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventPredictionMetadataInput, ...func(*frauddetector.Options)) *frauddetector.GetEventPredictionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetEventPredictionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetEventPredictionMetadataInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventTypes(ctx context.Context, params *frauddetector.GetEventTypesInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetEventTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventTypes")
	}

	var r0 *frauddetector.GetEventTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventTypesInput, ...func(*frauddetector.Options)) (*frauddetector.GetEventTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetEventTypesInput, ...func(*frauddetector.Options)) *frauddetector.GetEventTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetEventTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetEventTypesInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExternalModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetExternalModels(ctx context.Context, params *frauddetector.GetExternalModelsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetExternalModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExternalModels")
	}

	var r0 *frauddetector.GetExternalModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetExternalModelsInput, ...func(*frauddetector.Options)) (*frauddetector.GetExternalModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetExternalModelsInput, ...func(*frauddetector.Options)) *frauddetector.GetExternalModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetExternalModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetExternalModelsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKMSEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKMSEncryptionKey(ctx context.Context, params *frauddetector.GetKMSEncryptionKeyInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetKMSEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKMSEncryptionKey")
	}

	var r0 *frauddetector.GetKMSEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetKMSEncryptionKeyInput, ...func(*frauddetector.Options)) (*frauddetector.GetKMSEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetKMSEncryptionKeyInput, ...func(*frauddetector.Options)) *frauddetector.GetKMSEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetKMSEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetKMSEncryptionKeyInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLabels(ctx context.Context, params *frauddetector.GetLabelsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLabels")
	}

	var r0 *frauddetector.GetLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetLabelsInput, ...func(*frauddetector.Options)) (*frauddetector.GetLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetLabelsInput, ...func(*frauddetector.Options)) *frauddetector.GetLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetLabelsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetListElements provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetListElements(ctx context.Context, params *frauddetector.GetListElementsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetListElementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetListElements")
	}

	var r0 *frauddetector.GetListElementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetListElementsInput, ...func(*frauddetector.Options)) (*frauddetector.GetListElementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetListElementsInput, ...func(*frauddetector.Options)) *frauddetector.GetListElementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetListElementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetListElementsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetListsMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetListsMetadata(ctx context.Context, params *frauddetector.GetListsMetadataInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetListsMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetListsMetadata")
	}

	var r0 *frauddetector.GetListsMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetListsMetadataInput, ...func(*frauddetector.Options)) (*frauddetector.GetListsMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetListsMetadataInput, ...func(*frauddetector.Options)) *frauddetector.GetListsMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetListsMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetListsMetadataInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetModelVersion(ctx context.Context, params *frauddetector.GetModelVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetModelVersion")
	}

	var r0 *frauddetector.GetModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetModelVersionInput, ...func(*frauddetector.Options)) (*frauddetector.GetModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetModelVersionInput, ...func(*frauddetector.Options)) *frauddetector.GetModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetModelVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetModels(ctx context.Context, params *frauddetector.GetModelsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetModels")
	}

	var r0 *frauddetector.GetModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetModelsInput, ...func(*frauddetector.Options)) (*frauddetector.GetModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetModelsInput, ...func(*frauddetector.Options)) *frauddetector.GetModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetModelsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutcomes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetOutcomes(ctx context.Context, params *frauddetector.GetOutcomesInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetOutcomesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOutcomes")
	}

	var r0 *frauddetector.GetOutcomesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetOutcomesInput, ...func(*frauddetector.Options)) (*frauddetector.GetOutcomesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetOutcomesInput, ...func(*frauddetector.Options)) *frauddetector.GetOutcomesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetOutcomesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetOutcomesInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRules(ctx context.Context, params *frauddetector.GetRulesInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRules")
	}

	var r0 *frauddetector.GetRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetRulesInput, ...func(*frauddetector.Options)) (*frauddetector.GetRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetRulesInput, ...func(*frauddetector.Options)) *frauddetector.GetRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetRulesInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVariables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVariables(ctx context.Context, params *frauddetector.GetVariablesInput, optFns ...func(*frauddetector.Options)) (*frauddetector.GetVariablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVariables")
	}

	var r0 *frauddetector.GetVariablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetVariablesInput, ...func(*frauddetector.Options)) (*frauddetector.GetVariablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.GetVariablesInput, ...func(*frauddetector.Options)) *frauddetector.GetVariablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.GetVariablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.GetVariablesInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventPredictions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventPredictions(ctx context.Context, params *frauddetector.ListEventPredictionsInput, optFns ...func(*frauddetector.Options)) (*frauddetector.ListEventPredictionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventPredictions")
	}

	var r0 *frauddetector.ListEventPredictionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.ListEventPredictionsInput, ...func(*frauddetector.Options)) (*frauddetector.ListEventPredictionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.ListEventPredictionsInput, ...func(*frauddetector.Options)) *frauddetector.ListEventPredictionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.ListEventPredictionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.ListEventPredictionsInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *frauddetector.ListTagsForResourceInput, optFns ...func(*frauddetector.Options)) (*frauddetector.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *frauddetector.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.ListTagsForResourceInput, ...func(*frauddetector.Options)) (*frauddetector.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.ListTagsForResourceInput, ...func(*frauddetector.Options)) *frauddetector.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.ListTagsForResourceInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() frauddetector.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 frauddetector.Options
	if rf, ok := ret.Get(0).(func() frauddetector.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(frauddetector.Options)
	}

	return r0
}

// PutDetector provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutDetector(ctx context.Context, params *frauddetector.PutDetectorInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutDetectorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutDetector")
	}

	var r0 *frauddetector.PutDetectorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutDetectorInput, ...func(*frauddetector.Options)) (*frauddetector.PutDetectorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutDetectorInput, ...func(*frauddetector.Options)) *frauddetector.PutDetectorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutDetectorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutDetectorInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutEntityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutEntityType(ctx context.Context, params *frauddetector.PutEntityTypeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutEntityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEntityType")
	}

	var r0 *frauddetector.PutEntityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutEntityTypeInput, ...func(*frauddetector.Options)) (*frauddetector.PutEntityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutEntityTypeInput, ...func(*frauddetector.Options)) *frauddetector.PutEntityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutEntityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutEntityTypeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutEventType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutEventType(ctx context.Context, params *frauddetector.PutEventTypeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutEventTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEventType")
	}

	var r0 *frauddetector.PutEventTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutEventTypeInput, ...func(*frauddetector.Options)) (*frauddetector.PutEventTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutEventTypeInput, ...func(*frauddetector.Options)) *frauddetector.PutEventTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutEventTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutEventTypeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutExternalModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutExternalModel(ctx context.Context, params *frauddetector.PutExternalModelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutExternalModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutExternalModel")
	}

	var r0 *frauddetector.PutExternalModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutExternalModelInput, ...func(*frauddetector.Options)) (*frauddetector.PutExternalModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutExternalModelInput, ...func(*frauddetector.Options)) *frauddetector.PutExternalModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutExternalModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutExternalModelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutKMSEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutKMSEncryptionKey(ctx context.Context, params *frauddetector.PutKMSEncryptionKeyInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutKMSEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutKMSEncryptionKey")
	}

	var r0 *frauddetector.PutKMSEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutKMSEncryptionKeyInput, ...func(*frauddetector.Options)) (*frauddetector.PutKMSEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutKMSEncryptionKeyInput, ...func(*frauddetector.Options)) *frauddetector.PutKMSEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutKMSEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutKMSEncryptionKeyInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLabel(ctx context.Context, params *frauddetector.PutLabelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLabel")
	}

	var r0 *frauddetector.PutLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutLabelInput, ...func(*frauddetector.Options)) (*frauddetector.PutLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutLabelInput, ...func(*frauddetector.Options)) *frauddetector.PutLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutLabelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutOutcome provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutOutcome(ctx context.Context, params *frauddetector.PutOutcomeInput, optFns ...func(*frauddetector.Options)) (*frauddetector.PutOutcomeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutOutcome")
	}

	var r0 *frauddetector.PutOutcomeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutOutcomeInput, ...func(*frauddetector.Options)) (*frauddetector.PutOutcomeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.PutOutcomeInput, ...func(*frauddetector.Options)) *frauddetector.PutOutcomeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.PutOutcomeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.PutOutcomeInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendEvent(ctx context.Context, params *frauddetector.SendEventInput, optFns ...func(*frauddetector.Options)) (*frauddetector.SendEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendEvent")
	}

	var r0 *frauddetector.SendEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.SendEventInput, ...func(*frauddetector.Options)) (*frauddetector.SendEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.SendEventInput, ...func(*frauddetector.Options)) *frauddetector.SendEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.SendEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.SendEventInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *frauddetector.TagResourceInput, optFns ...func(*frauddetector.Options)) (*frauddetector.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *frauddetector.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.TagResourceInput, ...func(*frauddetector.Options)) (*frauddetector.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.TagResourceInput, ...func(*frauddetector.Options)) *frauddetector.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.TagResourceInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *frauddetector.UntagResourceInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *frauddetector.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UntagResourceInput, ...func(*frauddetector.Options)) (*frauddetector.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UntagResourceInput, ...func(*frauddetector.Options)) *frauddetector.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UntagResourceInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDetectorVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDetectorVersion(ctx context.Context, params *frauddetector.UpdateDetectorVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDetectorVersion")
	}

	var r0 *frauddetector.UpdateDetectorVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionInput, ...func(*frauddetector.Options)) *frauddetector.UpdateDetectorVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateDetectorVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateDetectorVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDetectorVersionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDetectorVersionMetadata(ctx context.Context, params *frauddetector.UpdateDetectorVersionMetadataInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDetectorVersionMetadata")
	}

	var r0 *frauddetector.UpdateDetectorVersionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionMetadataInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionMetadataInput, ...func(*frauddetector.Options)) *frauddetector.UpdateDetectorVersionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateDetectorVersionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateDetectorVersionMetadataInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDetectorVersionStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDetectorVersionStatus(ctx context.Context, params *frauddetector.UpdateDetectorVersionStatusInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDetectorVersionStatus")
	}

	var r0 *frauddetector.UpdateDetectorVersionStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionStatusInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateDetectorVersionStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateDetectorVersionStatusInput, ...func(*frauddetector.Options)) *frauddetector.UpdateDetectorVersionStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateDetectorVersionStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateDetectorVersionStatusInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventLabel(ctx context.Context, params *frauddetector.UpdateEventLabelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateEventLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventLabel")
	}

	var r0 *frauddetector.UpdateEventLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateEventLabelInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateEventLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateEventLabelInput, ...func(*frauddetector.Options)) *frauddetector.UpdateEventLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateEventLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateEventLabelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateList(ctx context.Context, params *frauddetector.UpdateListInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateList")
	}

	var r0 *frauddetector.UpdateListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateListInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateListInput, ...func(*frauddetector.Options)) *frauddetector.UpdateListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateListInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateModel(ctx context.Context, params *frauddetector.UpdateModelInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateModel")
	}

	var r0 *frauddetector.UpdateModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelInput, ...func(*frauddetector.Options)) *frauddetector.UpdateModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateModelInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateModelVersion(ctx context.Context, params *frauddetector.UpdateModelVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateModelVersion")
	}

	var r0 *frauddetector.UpdateModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelVersionInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelVersionInput, ...func(*frauddetector.Options)) *frauddetector.UpdateModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateModelVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateModelVersionStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateModelVersionStatus(ctx context.Context, params *frauddetector.UpdateModelVersionStatusInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateModelVersionStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateModelVersionStatus")
	}

	var r0 *frauddetector.UpdateModelVersionStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelVersionStatusInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateModelVersionStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateModelVersionStatusInput, ...func(*frauddetector.Options)) *frauddetector.UpdateModelVersionStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateModelVersionStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateModelVersionStatusInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleMetadata(ctx context.Context, params *frauddetector.UpdateRuleMetadataInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateRuleMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleMetadata")
	}

	var r0 *frauddetector.UpdateRuleMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateRuleMetadataInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateRuleMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateRuleMetadataInput, ...func(*frauddetector.Options)) *frauddetector.UpdateRuleMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateRuleMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateRuleMetadataInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleVersion(ctx context.Context, params *frauddetector.UpdateRuleVersionInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateRuleVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleVersion")
	}

	var r0 *frauddetector.UpdateRuleVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateRuleVersionInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateRuleVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateRuleVersionInput, ...func(*frauddetector.Options)) *frauddetector.UpdateRuleVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateRuleVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateRuleVersionInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVariable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVariable(ctx context.Context, params *frauddetector.UpdateVariableInput, optFns ...func(*frauddetector.Options)) (*frauddetector.UpdateVariableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVariable")
	}

	var r0 *frauddetector.UpdateVariableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateVariableInput, ...func(*frauddetector.Options)) (*frauddetector.UpdateVariableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *frauddetector.UpdateVariableInput, ...func(*frauddetector.Options)) *frauddetector.UpdateVariableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frauddetector.UpdateVariableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *frauddetector.UpdateVariableInput, ...func(*frauddetector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
