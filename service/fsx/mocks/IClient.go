// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	fsx "github.com/aws/aws-sdk-go-v2/service/fsx"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateFileSystemAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateFileSystemAliases(ctx context.Context, params *fsx.AssociateFileSystemAliasesInput, optFns ...func(*fsx.Options)) (*fsx.AssociateFileSystemAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateFileSystemAliases")
	}

	var r0 *fsx.AssociateFileSystemAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.AssociateFileSystemAliasesInput, ...func(*fsx.Options)) (*fsx.AssociateFileSystemAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.AssociateFileSystemAliasesInput, ...func(*fsx.Options)) *fsx.AssociateFileSystemAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.AssociateFileSystemAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.AssociateFileSystemAliasesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDataRepositoryTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDataRepositoryTask(ctx context.Context, params *fsx.CancelDataRepositoryTaskInput, optFns ...func(*fsx.Options)) (*fsx.CancelDataRepositoryTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDataRepositoryTask")
	}

	var r0 *fsx.CancelDataRepositoryTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CancelDataRepositoryTaskInput, ...func(*fsx.Options)) (*fsx.CancelDataRepositoryTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CancelDataRepositoryTaskInput, ...func(*fsx.Options)) *fsx.CancelDataRepositoryTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CancelDataRepositoryTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CancelDataRepositoryTaskInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyBackup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyBackup(ctx context.Context, params *fsx.CopyBackupInput, optFns ...func(*fsx.Options)) (*fsx.CopyBackupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyBackup")
	}

	var r0 *fsx.CopyBackupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CopyBackupInput, ...func(*fsx.Options)) (*fsx.CopyBackupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CopyBackupInput, ...func(*fsx.Options)) *fsx.CopyBackupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CopyBackupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CopyBackupInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshotAndUpdateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopySnapshotAndUpdateVolume(ctx context.Context, params *fsx.CopySnapshotAndUpdateVolumeInput, optFns ...func(*fsx.Options)) (*fsx.CopySnapshotAndUpdateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopySnapshotAndUpdateVolume")
	}

	var r0 *fsx.CopySnapshotAndUpdateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CopySnapshotAndUpdateVolumeInput, ...func(*fsx.Options)) (*fsx.CopySnapshotAndUpdateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CopySnapshotAndUpdateVolumeInput, ...func(*fsx.Options)) *fsx.CopySnapshotAndUpdateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CopySnapshotAndUpdateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CopySnapshotAndUpdateVolumeInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBackup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBackup(ctx context.Context, params *fsx.CreateBackupInput, optFns ...func(*fsx.Options)) (*fsx.CreateBackupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBackup")
	}

	var r0 *fsx.CreateBackupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateBackupInput, ...func(*fsx.Options)) (*fsx.CreateBackupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateBackupInput, ...func(*fsx.Options)) *fsx.CreateBackupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateBackupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateBackupInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataRepositoryAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataRepositoryAssociation(ctx context.Context, params *fsx.CreateDataRepositoryAssociationInput, optFns ...func(*fsx.Options)) (*fsx.CreateDataRepositoryAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataRepositoryAssociation")
	}

	var r0 *fsx.CreateDataRepositoryAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateDataRepositoryAssociationInput, ...func(*fsx.Options)) (*fsx.CreateDataRepositoryAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateDataRepositoryAssociationInput, ...func(*fsx.Options)) *fsx.CreateDataRepositoryAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateDataRepositoryAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateDataRepositoryAssociationInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataRepositoryTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataRepositoryTask(ctx context.Context, params *fsx.CreateDataRepositoryTaskInput, optFns ...func(*fsx.Options)) (*fsx.CreateDataRepositoryTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataRepositoryTask")
	}

	var r0 *fsx.CreateDataRepositoryTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateDataRepositoryTaskInput, ...func(*fsx.Options)) (*fsx.CreateDataRepositoryTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateDataRepositoryTaskInput, ...func(*fsx.Options)) *fsx.CreateDataRepositoryTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateDataRepositoryTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateDataRepositoryTaskInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFileCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFileCache(ctx context.Context, params *fsx.CreateFileCacheInput, optFns ...func(*fsx.Options)) (*fsx.CreateFileCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFileCache")
	}

	var r0 *fsx.CreateFileCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileCacheInput, ...func(*fsx.Options)) (*fsx.CreateFileCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileCacheInput, ...func(*fsx.Options)) *fsx.CreateFileCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateFileCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateFileCacheInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFileSystem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFileSystem(ctx context.Context, params *fsx.CreateFileSystemInput, optFns ...func(*fsx.Options)) (*fsx.CreateFileSystemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFileSystem")
	}

	var r0 *fsx.CreateFileSystemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileSystemInput, ...func(*fsx.Options)) (*fsx.CreateFileSystemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileSystemInput, ...func(*fsx.Options)) *fsx.CreateFileSystemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateFileSystemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateFileSystemInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFileSystemFromBackup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFileSystemFromBackup(ctx context.Context, params *fsx.CreateFileSystemFromBackupInput, optFns ...func(*fsx.Options)) (*fsx.CreateFileSystemFromBackupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFileSystemFromBackup")
	}

	var r0 *fsx.CreateFileSystemFromBackupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileSystemFromBackupInput, ...func(*fsx.Options)) (*fsx.CreateFileSystemFromBackupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateFileSystemFromBackupInput, ...func(*fsx.Options)) *fsx.CreateFileSystemFromBackupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateFileSystemFromBackupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateFileSystemFromBackupInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshot(ctx context.Context, params *fsx.CreateSnapshotInput, optFns ...func(*fsx.Options)) (*fsx.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *fsx.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateSnapshotInput, ...func(*fsx.Options)) (*fsx.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateSnapshotInput, ...func(*fsx.Options)) *fsx.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateSnapshotInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStorageVirtualMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStorageVirtualMachine(ctx context.Context, params *fsx.CreateStorageVirtualMachineInput, optFns ...func(*fsx.Options)) (*fsx.CreateStorageVirtualMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStorageVirtualMachine")
	}

	var r0 *fsx.CreateStorageVirtualMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateStorageVirtualMachineInput, ...func(*fsx.Options)) (*fsx.CreateStorageVirtualMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateStorageVirtualMachineInput, ...func(*fsx.Options)) *fsx.CreateStorageVirtualMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateStorageVirtualMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateStorageVirtualMachineInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVolume(ctx context.Context, params *fsx.CreateVolumeInput, optFns ...func(*fsx.Options)) (*fsx.CreateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVolume")
	}

	var r0 *fsx.CreateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateVolumeInput, ...func(*fsx.Options)) (*fsx.CreateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateVolumeInput, ...func(*fsx.Options)) *fsx.CreateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateVolumeInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVolumeFromBackup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVolumeFromBackup(ctx context.Context, params *fsx.CreateVolumeFromBackupInput, optFns ...func(*fsx.Options)) (*fsx.CreateVolumeFromBackupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVolumeFromBackup")
	}

	var r0 *fsx.CreateVolumeFromBackupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateVolumeFromBackupInput, ...func(*fsx.Options)) (*fsx.CreateVolumeFromBackupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.CreateVolumeFromBackupInput, ...func(*fsx.Options)) *fsx.CreateVolumeFromBackupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.CreateVolumeFromBackupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.CreateVolumeFromBackupInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBackup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBackup(ctx context.Context, params *fsx.DeleteBackupInput, optFns ...func(*fsx.Options)) (*fsx.DeleteBackupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBackup")
	}

	var r0 *fsx.DeleteBackupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteBackupInput, ...func(*fsx.Options)) (*fsx.DeleteBackupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteBackupInput, ...func(*fsx.Options)) *fsx.DeleteBackupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteBackupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteBackupInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataRepositoryAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataRepositoryAssociation(ctx context.Context, params *fsx.DeleteDataRepositoryAssociationInput, optFns ...func(*fsx.Options)) (*fsx.DeleteDataRepositoryAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataRepositoryAssociation")
	}

	var r0 *fsx.DeleteDataRepositoryAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteDataRepositoryAssociationInput, ...func(*fsx.Options)) (*fsx.DeleteDataRepositoryAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteDataRepositoryAssociationInput, ...func(*fsx.Options)) *fsx.DeleteDataRepositoryAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteDataRepositoryAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteDataRepositoryAssociationInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFileCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFileCache(ctx context.Context, params *fsx.DeleteFileCacheInput, optFns ...func(*fsx.Options)) (*fsx.DeleteFileCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFileCache")
	}

	var r0 *fsx.DeleteFileCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteFileCacheInput, ...func(*fsx.Options)) (*fsx.DeleteFileCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteFileCacheInput, ...func(*fsx.Options)) *fsx.DeleteFileCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteFileCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteFileCacheInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFileSystem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFileSystem(ctx context.Context, params *fsx.DeleteFileSystemInput, optFns ...func(*fsx.Options)) (*fsx.DeleteFileSystemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFileSystem")
	}

	var r0 *fsx.DeleteFileSystemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteFileSystemInput, ...func(*fsx.Options)) (*fsx.DeleteFileSystemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteFileSystemInput, ...func(*fsx.Options)) *fsx.DeleteFileSystemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteFileSystemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteFileSystemInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshot(ctx context.Context, params *fsx.DeleteSnapshotInput, optFns ...func(*fsx.Options)) (*fsx.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshot")
	}

	var r0 *fsx.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteSnapshotInput, ...func(*fsx.Options)) (*fsx.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteSnapshotInput, ...func(*fsx.Options)) *fsx.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteSnapshotInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStorageVirtualMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStorageVirtualMachine(ctx context.Context, params *fsx.DeleteStorageVirtualMachineInput, optFns ...func(*fsx.Options)) (*fsx.DeleteStorageVirtualMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStorageVirtualMachine")
	}

	var r0 *fsx.DeleteStorageVirtualMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteStorageVirtualMachineInput, ...func(*fsx.Options)) (*fsx.DeleteStorageVirtualMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteStorageVirtualMachineInput, ...func(*fsx.Options)) *fsx.DeleteStorageVirtualMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteStorageVirtualMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteStorageVirtualMachineInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVolume(ctx context.Context, params *fsx.DeleteVolumeInput, optFns ...func(*fsx.Options)) (*fsx.DeleteVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVolume")
	}

	var r0 *fsx.DeleteVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteVolumeInput, ...func(*fsx.Options)) (*fsx.DeleteVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DeleteVolumeInput, ...func(*fsx.Options)) *fsx.DeleteVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DeleteVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DeleteVolumeInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBackups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBackups(ctx context.Context, params *fsx.DescribeBackupsInput, optFns ...func(*fsx.Options)) (*fsx.DescribeBackupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBackups")
	}

	var r0 *fsx.DescribeBackupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeBackupsInput, ...func(*fsx.Options)) (*fsx.DescribeBackupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeBackupsInput, ...func(*fsx.Options)) *fsx.DescribeBackupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeBackupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeBackupsInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataRepositoryAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataRepositoryAssociations(ctx context.Context, params *fsx.DescribeDataRepositoryAssociationsInput, optFns ...func(*fsx.Options)) (*fsx.DescribeDataRepositoryAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataRepositoryAssociations")
	}

	var r0 *fsx.DescribeDataRepositoryAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeDataRepositoryAssociationsInput, ...func(*fsx.Options)) (*fsx.DescribeDataRepositoryAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeDataRepositoryAssociationsInput, ...func(*fsx.Options)) *fsx.DescribeDataRepositoryAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeDataRepositoryAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeDataRepositoryAssociationsInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataRepositoryTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataRepositoryTasks(ctx context.Context, params *fsx.DescribeDataRepositoryTasksInput, optFns ...func(*fsx.Options)) (*fsx.DescribeDataRepositoryTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataRepositoryTasks")
	}

	var r0 *fsx.DescribeDataRepositoryTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeDataRepositoryTasksInput, ...func(*fsx.Options)) (*fsx.DescribeDataRepositoryTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeDataRepositoryTasksInput, ...func(*fsx.Options)) *fsx.DescribeDataRepositoryTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeDataRepositoryTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeDataRepositoryTasksInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFileCaches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFileCaches(ctx context.Context, params *fsx.DescribeFileCachesInput, optFns ...func(*fsx.Options)) (*fsx.DescribeFileCachesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFileCaches")
	}

	var r0 *fsx.DescribeFileCachesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileCachesInput, ...func(*fsx.Options)) (*fsx.DescribeFileCachesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileCachesInput, ...func(*fsx.Options)) *fsx.DescribeFileCachesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeFileCachesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeFileCachesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFileSystemAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFileSystemAliases(ctx context.Context, params *fsx.DescribeFileSystemAliasesInput, optFns ...func(*fsx.Options)) (*fsx.DescribeFileSystemAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFileSystemAliases")
	}

	var r0 *fsx.DescribeFileSystemAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileSystemAliasesInput, ...func(*fsx.Options)) (*fsx.DescribeFileSystemAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileSystemAliasesInput, ...func(*fsx.Options)) *fsx.DescribeFileSystemAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeFileSystemAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeFileSystemAliasesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFileSystems provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFileSystems(ctx context.Context, params *fsx.DescribeFileSystemsInput, optFns ...func(*fsx.Options)) (*fsx.DescribeFileSystemsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFileSystems")
	}

	var r0 *fsx.DescribeFileSystemsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileSystemsInput, ...func(*fsx.Options)) (*fsx.DescribeFileSystemsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeFileSystemsInput, ...func(*fsx.Options)) *fsx.DescribeFileSystemsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeFileSystemsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeFileSystemsInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSharedVpcConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSharedVpcConfiguration(ctx context.Context, params *fsx.DescribeSharedVpcConfigurationInput, optFns ...func(*fsx.Options)) (*fsx.DescribeSharedVpcConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSharedVpcConfiguration")
	}

	var r0 *fsx.DescribeSharedVpcConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeSharedVpcConfigurationInput, ...func(*fsx.Options)) (*fsx.DescribeSharedVpcConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeSharedVpcConfigurationInput, ...func(*fsx.Options)) *fsx.DescribeSharedVpcConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeSharedVpcConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeSharedVpcConfigurationInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshots(ctx context.Context, params *fsx.DescribeSnapshotsInput, optFns ...func(*fsx.Options)) (*fsx.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshots")
	}

	var r0 *fsx.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeSnapshotsInput, ...func(*fsx.Options)) (*fsx.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeSnapshotsInput, ...func(*fsx.Options)) *fsx.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeSnapshotsInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStorageVirtualMachines provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStorageVirtualMachines(ctx context.Context, params *fsx.DescribeStorageVirtualMachinesInput, optFns ...func(*fsx.Options)) (*fsx.DescribeStorageVirtualMachinesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStorageVirtualMachines")
	}

	var r0 *fsx.DescribeStorageVirtualMachinesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeStorageVirtualMachinesInput, ...func(*fsx.Options)) (*fsx.DescribeStorageVirtualMachinesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeStorageVirtualMachinesInput, ...func(*fsx.Options)) *fsx.DescribeStorageVirtualMachinesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeStorageVirtualMachinesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeStorageVirtualMachinesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVolumes(ctx context.Context, params *fsx.DescribeVolumesInput, optFns ...func(*fsx.Options)) (*fsx.DescribeVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumes")
	}

	var r0 *fsx.DescribeVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeVolumesInput, ...func(*fsx.Options)) (*fsx.DescribeVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DescribeVolumesInput, ...func(*fsx.Options)) *fsx.DescribeVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DescribeVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DescribeVolumesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateFileSystemAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateFileSystemAliases(ctx context.Context, params *fsx.DisassociateFileSystemAliasesInput, optFns ...func(*fsx.Options)) (*fsx.DisassociateFileSystemAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateFileSystemAliases")
	}

	var r0 *fsx.DisassociateFileSystemAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DisassociateFileSystemAliasesInput, ...func(*fsx.Options)) (*fsx.DisassociateFileSystemAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.DisassociateFileSystemAliasesInput, ...func(*fsx.Options)) *fsx.DisassociateFileSystemAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.DisassociateFileSystemAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.DisassociateFileSystemAliasesInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *fsx.ListTagsForResourceInput, optFns ...func(*fsx.Options)) (*fsx.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *fsx.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.ListTagsForResourceInput, ...func(*fsx.Options)) (*fsx.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.ListTagsForResourceInput, ...func(*fsx.Options)) *fsx.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.ListTagsForResourceInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() fsx.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 fsx.Options
	if rf, ok := ret.Get(0).(func() fsx.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(fsx.Options)
	}

	return r0
}

// ReleaseFileSystemNfsV3Locks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReleaseFileSystemNfsV3Locks(ctx context.Context, params *fsx.ReleaseFileSystemNfsV3LocksInput, optFns ...func(*fsx.Options)) (*fsx.ReleaseFileSystemNfsV3LocksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseFileSystemNfsV3Locks")
	}

	var r0 *fsx.ReleaseFileSystemNfsV3LocksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.ReleaseFileSystemNfsV3LocksInput, ...func(*fsx.Options)) (*fsx.ReleaseFileSystemNfsV3LocksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.ReleaseFileSystemNfsV3LocksInput, ...func(*fsx.Options)) *fsx.ReleaseFileSystemNfsV3LocksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.ReleaseFileSystemNfsV3LocksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.ReleaseFileSystemNfsV3LocksInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreVolumeFromSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreVolumeFromSnapshot(ctx context.Context, params *fsx.RestoreVolumeFromSnapshotInput, optFns ...func(*fsx.Options)) (*fsx.RestoreVolumeFromSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreVolumeFromSnapshot")
	}

	var r0 *fsx.RestoreVolumeFromSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.RestoreVolumeFromSnapshotInput, ...func(*fsx.Options)) (*fsx.RestoreVolumeFromSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.RestoreVolumeFromSnapshotInput, ...func(*fsx.Options)) *fsx.RestoreVolumeFromSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.RestoreVolumeFromSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.RestoreVolumeFromSnapshotInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMisconfiguredStateRecovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMisconfiguredStateRecovery(ctx context.Context, params *fsx.StartMisconfiguredStateRecoveryInput, optFns ...func(*fsx.Options)) (*fsx.StartMisconfiguredStateRecoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMisconfiguredStateRecovery")
	}

	var r0 *fsx.StartMisconfiguredStateRecoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.StartMisconfiguredStateRecoveryInput, ...func(*fsx.Options)) (*fsx.StartMisconfiguredStateRecoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.StartMisconfiguredStateRecoveryInput, ...func(*fsx.Options)) *fsx.StartMisconfiguredStateRecoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.StartMisconfiguredStateRecoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.StartMisconfiguredStateRecoveryInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *fsx.TagResourceInput, optFns ...func(*fsx.Options)) (*fsx.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *fsx.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.TagResourceInput, ...func(*fsx.Options)) (*fsx.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.TagResourceInput, ...func(*fsx.Options)) *fsx.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.TagResourceInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *fsx.UntagResourceInput, optFns ...func(*fsx.Options)) (*fsx.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *fsx.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UntagResourceInput, ...func(*fsx.Options)) (*fsx.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UntagResourceInput, ...func(*fsx.Options)) *fsx.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UntagResourceInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataRepositoryAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataRepositoryAssociation(ctx context.Context, params *fsx.UpdateDataRepositoryAssociationInput, optFns ...func(*fsx.Options)) (*fsx.UpdateDataRepositoryAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataRepositoryAssociation")
	}

	var r0 *fsx.UpdateDataRepositoryAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateDataRepositoryAssociationInput, ...func(*fsx.Options)) (*fsx.UpdateDataRepositoryAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateDataRepositoryAssociationInput, ...func(*fsx.Options)) *fsx.UpdateDataRepositoryAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateDataRepositoryAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateDataRepositoryAssociationInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFileCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFileCache(ctx context.Context, params *fsx.UpdateFileCacheInput, optFns ...func(*fsx.Options)) (*fsx.UpdateFileCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFileCache")
	}

	var r0 *fsx.UpdateFileCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateFileCacheInput, ...func(*fsx.Options)) (*fsx.UpdateFileCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateFileCacheInput, ...func(*fsx.Options)) *fsx.UpdateFileCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateFileCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateFileCacheInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFileSystem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFileSystem(ctx context.Context, params *fsx.UpdateFileSystemInput, optFns ...func(*fsx.Options)) (*fsx.UpdateFileSystemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFileSystem")
	}

	var r0 *fsx.UpdateFileSystemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateFileSystemInput, ...func(*fsx.Options)) (*fsx.UpdateFileSystemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateFileSystemInput, ...func(*fsx.Options)) *fsx.UpdateFileSystemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateFileSystemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateFileSystemInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSharedVpcConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSharedVpcConfiguration(ctx context.Context, params *fsx.UpdateSharedVpcConfigurationInput, optFns ...func(*fsx.Options)) (*fsx.UpdateSharedVpcConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSharedVpcConfiguration")
	}

	var r0 *fsx.UpdateSharedVpcConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateSharedVpcConfigurationInput, ...func(*fsx.Options)) (*fsx.UpdateSharedVpcConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateSharedVpcConfigurationInput, ...func(*fsx.Options)) *fsx.UpdateSharedVpcConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateSharedVpcConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateSharedVpcConfigurationInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSnapshot(ctx context.Context, params *fsx.UpdateSnapshotInput, optFns ...func(*fsx.Options)) (*fsx.UpdateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSnapshot")
	}

	var r0 *fsx.UpdateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateSnapshotInput, ...func(*fsx.Options)) (*fsx.UpdateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateSnapshotInput, ...func(*fsx.Options)) *fsx.UpdateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateSnapshotInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStorageVirtualMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStorageVirtualMachine(ctx context.Context, params *fsx.UpdateStorageVirtualMachineInput, optFns ...func(*fsx.Options)) (*fsx.UpdateStorageVirtualMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStorageVirtualMachine")
	}

	var r0 *fsx.UpdateStorageVirtualMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateStorageVirtualMachineInput, ...func(*fsx.Options)) (*fsx.UpdateStorageVirtualMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateStorageVirtualMachineInput, ...func(*fsx.Options)) *fsx.UpdateStorageVirtualMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateStorageVirtualMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateStorageVirtualMachineInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVolume(ctx context.Context, params *fsx.UpdateVolumeInput, optFns ...func(*fsx.Options)) (*fsx.UpdateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVolume")
	}

	var r0 *fsx.UpdateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateVolumeInput, ...func(*fsx.Options)) (*fsx.UpdateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fsx.UpdateVolumeInput, ...func(*fsx.Options)) *fsx.UpdateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsx.UpdateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fsx.UpdateVolumeInput, ...func(*fsx.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
