// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	wickr "github.com/aws/aws-sdk-go-v2/service/wickr"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchCreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreateUser(ctx context.Context, params *wickr.BatchCreateUserInput, optFns ...func(*wickr.Options)) (*wickr.BatchCreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreateUser")
	}

	var r0 *wickr.BatchCreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchCreateUserInput, ...func(*wickr.Options)) (*wickr.BatchCreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchCreateUserInput, ...func(*wickr.Options)) *wickr.BatchCreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchCreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchCreateUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteUser(ctx context.Context, params *wickr.BatchDeleteUserInput, optFns ...func(*wickr.Options)) (*wickr.BatchDeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteUser")
	}

	var r0 *wickr.BatchDeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchDeleteUserInput, ...func(*wickr.Options)) (*wickr.BatchDeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchDeleteUserInput, ...func(*wickr.Options)) *wickr.BatchDeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchDeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchDeleteUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchLookupUserUname provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchLookupUserUname(ctx context.Context, params *wickr.BatchLookupUserUnameInput, optFns ...func(*wickr.Options)) (*wickr.BatchLookupUserUnameOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchLookupUserUname")
	}

	var r0 *wickr.BatchLookupUserUnameOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchLookupUserUnameInput, ...func(*wickr.Options)) (*wickr.BatchLookupUserUnameOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchLookupUserUnameInput, ...func(*wickr.Options)) *wickr.BatchLookupUserUnameOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchLookupUserUnameOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchLookupUserUnameInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchReinviteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchReinviteUser(ctx context.Context, params *wickr.BatchReinviteUserInput, optFns ...func(*wickr.Options)) (*wickr.BatchReinviteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchReinviteUser")
	}

	var r0 *wickr.BatchReinviteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchReinviteUserInput, ...func(*wickr.Options)) (*wickr.BatchReinviteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchReinviteUserInput, ...func(*wickr.Options)) *wickr.BatchReinviteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchReinviteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchReinviteUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchResetDevicesForUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchResetDevicesForUser(ctx context.Context, params *wickr.BatchResetDevicesForUserInput, optFns ...func(*wickr.Options)) (*wickr.BatchResetDevicesForUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchResetDevicesForUser")
	}

	var r0 *wickr.BatchResetDevicesForUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchResetDevicesForUserInput, ...func(*wickr.Options)) (*wickr.BatchResetDevicesForUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchResetDevicesForUserInput, ...func(*wickr.Options)) *wickr.BatchResetDevicesForUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchResetDevicesForUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchResetDevicesForUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchToggleUserSuspendStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchToggleUserSuspendStatus(ctx context.Context, params *wickr.BatchToggleUserSuspendStatusInput, optFns ...func(*wickr.Options)) (*wickr.BatchToggleUserSuspendStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchToggleUserSuspendStatus")
	}

	var r0 *wickr.BatchToggleUserSuspendStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchToggleUserSuspendStatusInput, ...func(*wickr.Options)) (*wickr.BatchToggleUserSuspendStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.BatchToggleUserSuspendStatusInput, ...func(*wickr.Options)) *wickr.BatchToggleUserSuspendStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.BatchToggleUserSuspendStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.BatchToggleUserSuspendStatusInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBot(ctx context.Context, params *wickr.CreateBotInput, optFns ...func(*wickr.Options)) (*wickr.CreateBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBot")
	}

	var r0 *wickr.CreateBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateBotInput, ...func(*wickr.Options)) (*wickr.CreateBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateBotInput, ...func(*wickr.Options)) *wickr.CreateBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.CreateBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.CreateBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataRetentionBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataRetentionBot(ctx context.Context, params *wickr.CreateDataRetentionBotInput, optFns ...func(*wickr.Options)) (*wickr.CreateDataRetentionBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataRetentionBot")
	}

	var r0 *wickr.CreateDataRetentionBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateDataRetentionBotInput, ...func(*wickr.Options)) (*wickr.CreateDataRetentionBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateDataRetentionBotInput, ...func(*wickr.Options)) *wickr.CreateDataRetentionBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.CreateDataRetentionBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.CreateDataRetentionBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataRetentionBotChallenge provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataRetentionBotChallenge(ctx context.Context, params *wickr.CreateDataRetentionBotChallengeInput, optFns ...func(*wickr.Options)) (*wickr.CreateDataRetentionBotChallengeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataRetentionBotChallenge")
	}

	var r0 *wickr.CreateDataRetentionBotChallengeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateDataRetentionBotChallengeInput, ...func(*wickr.Options)) (*wickr.CreateDataRetentionBotChallengeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateDataRetentionBotChallengeInput, ...func(*wickr.Options)) *wickr.CreateDataRetentionBotChallengeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.CreateDataRetentionBotChallengeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.CreateDataRetentionBotChallengeInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetwork(ctx context.Context, params *wickr.CreateNetworkInput, optFns ...func(*wickr.Options)) (*wickr.CreateNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetwork")
	}

	var r0 *wickr.CreateNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateNetworkInput, ...func(*wickr.Options)) (*wickr.CreateNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateNetworkInput, ...func(*wickr.Options)) *wickr.CreateNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.CreateNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.CreateNetworkInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSecurityGroup(ctx context.Context, params *wickr.CreateSecurityGroupInput, optFns ...func(*wickr.Options)) (*wickr.CreateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityGroup")
	}

	var r0 *wickr.CreateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateSecurityGroupInput, ...func(*wickr.Options)) (*wickr.CreateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.CreateSecurityGroupInput, ...func(*wickr.Options)) *wickr.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.CreateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.CreateSecurityGroupInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBot(ctx context.Context, params *wickr.DeleteBotInput, optFns ...func(*wickr.Options)) (*wickr.DeleteBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBot")
	}

	var r0 *wickr.DeleteBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteBotInput, ...func(*wickr.Options)) (*wickr.DeleteBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteBotInput, ...func(*wickr.Options)) *wickr.DeleteBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.DeleteBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.DeleteBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataRetentionBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataRetentionBot(ctx context.Context, params *wickr.DeleteDataRetentionBotInput, optFns ...func(*wickr.Options)) (*wickr.DeleteDataRetentionBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataRetentionBot")
	}

	var r0 *wickr.DeleteDataRetentionBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteDataRetentionBotInput, ...func(*wickr.Options)) (*wickr.DeleteDataRetentionBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteDataRetentionBotInput, ...func(*wickr.Options)) *wickr.DeleteDataRetentionBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.DeleteDataRetentionBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.DeleteDataRetentionBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetwork(ctx context.Context, params *wickr.DeleteNetworkInput, optFns ...func(*wickr.Options)) (*wickr.DeleteNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetwork")
	}

	var r0 *wickr.DeleteNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteNetworkInput, ...func(*wickr.Options)) (*wickr.DeleteNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteNetworkInput, ...func(*wickr.Options)) *wickr.DeleteNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.DeleteNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.DeleteNetworkInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSecurityGroup(ctx context.Context, params *wickr.DeleteSecurityGroupInput, optFns ...func(*wickr.Options)) (*wickr.DeleteSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityGroup")
	}

	var r0 *wickr.DeleteSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteSecurityGroupInput, ...func(*wickr.Options)) (*wickr.DeleteSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.DeleteSecurityGroupInput, ...func(*wickr.Options)) *wickr.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.DeleteSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.DeleteSecurityGroupInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBot(ctx context.Context, params *wickr.GetBotInput, optFns ...func(*wickr.Options)) (*wickr.GetBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBot")
	}

	var r0 *wickr.GetBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetBotInput, ...func(*wickr.Options)) (*wickr.GetBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetBotInput, ...func(*wickr.Options)) *wickr.GetBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBotsCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBotsCount(ctx context.Context, params *wickr.GetBotsCountInput, optFns ...func(*wickr.Options)) (*wickr.GetBotsCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBotsCount")
	}

	var r0 *wickr.GetBotsCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetBotsCountInput, ...func(*wickr.Options)) (*wickr.GetBotsCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetBotsCountInput, ...func(*wickr.Options)) *wickr.GetBotsCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetBotsCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetBotsCountInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRetentionBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataRetentionBot(ctx context.Context, params *wickr.GetDataRetentionBotInput, optFns ...func(*wickr.Options)) (*wickr.GetDataRetentionBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataRetentionBot")
	}

	var r0 *wickr.GetDataRetentionBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetDataRetentionBotInput, ...func(*wickr.Options)) (*wickr.GetDataRetentionBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetDataRetentionBotInput, ...func(*wickr.Options)) *wickr.GetDataRetentionBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetDataRetentionBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetDataRetentionBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGuestUserHistoryCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGuestUserHistoryCount(ctx context.Context, params *wickr.GetGuestUserHistoryCountInput, optFns ...func(*wickr.Options)) (*wickr.GetGuestUserHistoryCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGuestUserHistoryCount")
	}

	var r0 *wickr.GetGuestUserHistoryCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetGuestUserHistoryCountInput, ...func(*wickr.Options)) (*wickr.GetGuestUserHistoryCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetGuestUserHistoryCountInput, ...func(*wickr.Options)) *wickr.GetGuestUserHistoryCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetGuestUserHistoryCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetGuestUserHistoryCountInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNetwork(ctx context.Context, params *wickr.GetNetworkInput, optFns ...func(*wickr.Options)) (*wickr.GetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetwork")
	}

	var r0 *wickr.GetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetNetworkInput, ...func(*wickr.Options)) (*wickr.GetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetNetworkInput, ...func(*wickr.Options)) *wickr.GetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetNetworkInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNetworkSettings(ctx context.Context, params *wickr.GetNetworkSettingsInput, optFns ...func(*wickr.Options)) (*wickr.GetNetworkSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkSettings")
	}

	var r0 *wickr.GetNetworkSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetNetworkSettingsInput, ...func(*wickr.Options)) (*wickr.GetNetworkSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetNetworkSettingsInput, ...func(*wickr.Options)) *wickr.GetNetworkSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetNetworkSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetNetworkSettingsInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOidcInfo provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetOidcInfo(ctx context.Context, params *wickr.GetOidcInfoInput, optFns ...func(*wickr.Options)) (*wickr.GetOidcInfoOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOidcInfo")
	}

	var r0 *wickr.GetOidcInfoOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetOidcInfoInput, ...func(*wickr.Options)) (*wickr.GetOidcInfoOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetOidcInfoInput, ...func(*wickr.Options)) *wickr.GetOidcInfoOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetOidcInfoOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetOidcInfoInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSecurityGroup(ctx context.Context, params *wickr.GetSecurityGroupInput, optFns ...func(*wickr.Options)) (*wickr.GetSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSecurityGroup")
	}

	var r0 *wickr.GetSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetSecurityGroupInput, ...func(*wickr.Options)) (*wickr.GetSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetSecurityGroupInput, ...func(*wickr.Options)) *wickr.GetSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetSecurityGroupInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUser(ctx context.Context, params *wickr.GetUserInput, optFns ...func(*wickr.Options)) (*wickr.GetUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *wickr.GetUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetUserInput, ...func(*wickr.Options)) (*wickr.GetUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetUserInput, ...func(*wickr.Options)) *wickr.GetUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUsersCount(ctx context.Context, params *wickr.GetUsersCountInput, optFns ...func(*wickr.Options)) (*wickr.GetUsersCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersCount")
	}

	var r0 *wickr.GetUsersCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetUsersCountInput, ...func(*wickr.Options)) (*wickr.GetUsersCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.GetUsersCountInput, ...func(*wickr.Options)) *wickr.GetUsersCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.GetUsersCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.GetUsersCountInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBlockedGuestUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBlockedGuestUsers(ctx context.Context, params *wickr.ListBlockedGuestUsersInput, optFns ...func(*wickr.Options)) (*wickr.ListBlockedGuestUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBlockedGuestUsers")
	}

	var r0 *wickr.ListBlockedGuestUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListBlockedGuestUsersInput, ...func(*wickr.Options)) (*wickr.ListBlockedGuestUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListBlockedGuestUsersInput, ...func(*wickr.Options)) *wickr.ListBlockedGuestUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListBlockedGuestUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListBlockedGuestUsersInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBots(ctx context.Context, params *wickr.ListBotsInput, optFns ...func(*wickr.Options)) (*wickr.ListBotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBots")
	}

	var r0 *wickr.ListBotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListBotsInput, ...func(*wickr.Options)) (*wickr.ListBotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListBotsInput, ...func(*wickr.Options)) *wickr.ListBotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListBotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListBotsInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDevicesForUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDevicesForUser(ctx context.Context, params *wickr.ListDevicesForUserInput, optFns ...func(*wickr.Options)) (*wickr.ListDevicesForUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevicesForUser")
	}

	var r0 *wickr.ListDevicesForUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListDevicesForUserInput, ...func(*wickr.Options)) (*wickr.ListDevicesForUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListDevicesForUserInput, ...func(*wickr.Options)) *wickr.ListDevicesForUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListDevicesForUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListDevicesForUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGuestUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGuestUsers(ctx context.Context, params *wickr.ListGuestUsersInput, optFns ...func(*wickr.Options)) (*wickr.ListGuestUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGuestUsers")
	}

	var r0 *wickr.ListGuestUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListGuestUsersInput, ...func(*wickr.Options)) (*wickr.ListGuestUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListGuestUsersInput, ...func(*wickr.Options)) *wickr.ListGuestUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListGuestUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListGuestUsersInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNetworks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNetworks(ctx context.Context, params *wickr.ListNetworksInput, optFns ...func(*wickr.Options)) (*wickr.ListNetworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNetworks")
	}

	var r0 *wickr.ListNetworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListNetworksInput, ...func(*wickr.Options)) (*wickr.ListNetworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListNetworksInput, ...func(*wickr.Options)) *wickr.ListNetworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListNetworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListNetworksInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSecurityGroupUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSecurityGroupUsers(ctx context.Context, params *wickr.ListSecurityGroupUsersInput, optFns ...func(*wickr.Options)) (*wickr.ListSecurityGroupUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSecurityGroupUsers")
	}

	var r0 *wickr.ListSecurityGroupUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListSecurityGroupUsersInput, ...func(*wickr.Options)) (*wickr.ListSecurityGroupUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListSecurityGroupUsersInput, ...func(*wickr.Options)) *wickr.ListSecurityGroupUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListSecurityGroupUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListSecurityGroupUsersInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSecurityGroups(ctx context.Context, params *wickr.ListSecurityGroupsInput, optFns ...func(*wickr.Options)) (*wickr.ListSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSecurityGroups")
	}

	var r0 *wickr.ListSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListSecurityGroupsInput, ...func(*wickr.Options)) (*wickr.ListSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListSecurityGroupsInput, ...func(*wickr.Options)) *wickr.ListSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListSecurityGroupsInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUsers(ctx context.Context, params *wickr.ListUsersInput, optFns ...func(*wickr.Options)) (*wickr.ListUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *wickr.ListUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListUsersInput, ...func(*wickr.Options)) (*wickr.ListUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.ListUsersInput, ...func(*wickr.Options)) *wickr.ListUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.ListUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.ListUsersInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() wickr.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 wickr.Options
	if rf, ok := ret.Get(0).(func() wickr.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wickr.Options)
	}

	return r0
}

// RegisterOidcConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterOidcConfig(ctx context.Context, params *wickr.RegisterOidcConfigInput, optFns ...func(*wickr.Options)) (*wickr.RegisterOidcConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterOidcConfig")
	}

	var r0 *wickr.RegisterOidcConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.RegisterOidcConfigInput, ...func(*wickr.Options)) (*wickr.RegisterOidcConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.RegisterOidcConfigInput, ...func(*wickr.Options)) *wickr.RegisterOidcConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.RegisterOidcConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.RegisterOidcConfigInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterOidcConfigTest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterOidcConfigTest(ctx context.Context, params *wickr.RegisterOidcConfigTestInput, optFns ...func(*wickr.Options)) (*wickr.RegisterOidcConfigTestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterOidcConfigTest")
	}

	var r0 *wickr.RegisterOidcConfigTestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.RegisterOidcConfigTestInput, ...func(*wickr.Options)) (*wickr.RegisterOidcConfigTestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.RegisterOidcConfigTestInput, ...func(*wickr.Options)) *wickr.RegisterOidcConfigTestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.RegisterOidcConfigTestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.RegisterOidcConfigTestInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBot(ctx context.Context, params *wickr.UpdateBotInput, optFns ...func(*wickr.Options)) (*wickr.UpdateBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBot")
	}

	var r0 *wickr.UpdateBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateBotInput, ...func(*wickr.Options)) (*wickr.UpdateBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateBotInput, ...func(*wickr.Options)) *wickr.UpdateBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateBotInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataRetention provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataRetention(ctx context.Context, params *wickr.UpdateDataRetentionInput, optFns ...func(*wickr.Options)) (*wickr.UpdateDataRetentionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataRetention")
	}

	var r0 *wickr.UpdateDataRetentionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateDataRetentionInput, ...func(*wickr.Options)) (*wickr.UpdateDataRetentionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateDataRetentionInput, ...func(*wickr.Options)) *wickr.UpdateDataRetentionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateDataRetentionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateDataRetentionInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGuestUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGuestUser(ctx context.Context, params *wickr.UpdateGuestUserInput, optFns ...func(*wickr.Options)) (*wickr.UpdateGuestUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGuestUser")
	}

	var r0 *wickr.UpdateGuestUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateGuestUserInput, ...func(*wickr.Options)) (*wickr.UpdateGuestUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateGuestUserInput, ...func(*wickr.Options)) *wickr.UpdateGuestUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateGuestUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateGuestUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateNetwork(ctx context.Context, params *wickr.UpdateNetworkInput, optFns ...func(*wickr.Options)) (*wickr.UpdateNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNetwork")
	}

	var r0 *wickr.UpdateNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateNetworkInput, ...func(*wickr.Options)) (*wickr.UpdateNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateNetworkInput, ...func(*wickr.Options)) *wickr.UpdateNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateNetworkInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNetworkSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateNetworkSettings(ctx context.Context, params *wickr.UpdateNetworkSettingsInput, optFns ...func(*wickr.Options)) (*wickr.UpdateNetworkSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNetworkSettings")
	}

	var r0 *wickr.UpdateNetworkSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateNetworkSettingsInput, ...func(*wickr.Options)) (*wickr.UpdateNetworkSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateNetworkSettingsInput, ...func(*wickr.Options)) *wickr.UpdateNetworkSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateNetworkSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateNetworkSettingsInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSecurityGroup(ctx context.Context, params *wickr.UpdateSecurityGroupInput, optFns ...func(*wickr.Options)) (*wickr.UpdateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurityGroup")
	}

	var r0 *wickr.UpdateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateSecurityGroupInput, ...func(*wickr.Options)) (*wickr.UpdateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateSecurityGroupInput, ...func(*wickr.Options)) *wickr.UpdateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateSecurityGroupInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateUser(ctx context.Context, params *wickr.UpdateUserInput, optFns ...func(*wickr.Options)) (*wickr.UpdateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *wickr.UpdateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateUserInput, ...func(*wickr.Options)) (*wickr.UpdateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wickr.UpdateUserInput, ...func(*wickr.Options)) *wickr.UpdateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wickr.UpdateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wickr.UpdateUserInput, ...func(*wickr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
