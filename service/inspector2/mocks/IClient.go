// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	inspector2 "github.com/aws/aws-sdk-go-v2/service/inspector2"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateMember(ctx context.Context, params *inspector2.AssociateMemberInput, optFns ...func(*inspector2.Options)) (*inspector2.AssociateMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateMember")
	}

	var r0 *inspector2.AssociateMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.AssociateMemberInput, ...func(*inspector2.Options)) (*inspector2.AssociateMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.AssociateMemberInput, ...func(*inspector2.Options)) *inspector2.AssociateMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.AssociateMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.AssociateMemberInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetAccountStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetAccountStatus(ctx context.Context, params *inspector2.BatchGetAccountStatusInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchGetAccountStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetAccountStatus")
	}

	var r0 *inspector2.BatchGetAccountStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetAccountStatusInput, ...func(*inspector2.Options)) (*inspector2.BatchGetAccountStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetAccountStatusInput, ...func(*inspector2.Options)) *inspector2.BatchGetAccountStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchGetAccountStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchGetAccountStatusInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetCodeSnippet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetCodeSnippet(ctx context.Context, params *inspector2.BatchGetCodeSnippetInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchGetCodeSnippetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetCodeSnippet")
	}

	var r0 *inspector2.BatchGetCodeSnippetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetCodeSnippetInput, ...func(*inspector2.Options)) (*inspector2.BatchGetCodeSnippetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetCodeSnippetInput, ...func(*inspector2.Options)) *inspector2.BatchGetCodeSnippetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchGetCodeSnippetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchGetCodeSnippetInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetFindingDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetFindingDetails(ctx context.Context, params *inspector2.BatchGetFindingDetailsInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchGetFindingDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetFindingDetails")
	}

	var r0 *inspector2.BatchGetFindingDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetFindingDetailsInput, ...func(*inspector2.Options)) (*inspector2.BatchGetFindingDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetFindingDetailsInput, ...func(*inspector2.Options)) *inspector2.BatchGetFindingDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchGetFindingDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchGetFindingDetailsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetFreeTrialInfo provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetFreeTrialInfo(ctx context.Context, params *inspector2.BatchGetFreeTrialInfoInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchGetFreeTrialInfoOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetFreeTrialInfo")
	}

	var r0 *inspector2.BatchGetFreeTrialInfoOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetFreeTrialInfoInput, ...func(*inspector2.Options)) (*inspector2.BatchGetFreeTrialInfoOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetFreeTrialInfoInput, ...func(*inspector2.Options)) *inspector2.BatchGetFreeTrialInfoOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchGetFreeTrialInfoOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchGetFreeTrialInfoInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetMemberEc2DeepInspectionStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetMemberEc2DeepInspectionStatus(ctx context.Context, params *inspector2.BatchGetMemberEc2DeepInspectionStatusInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchGetMemberEc2DeepInspectionStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetMemberEc2DeepInspectionStatus")
	}

	var r0 *inspector2.BatchGetMemberEc2DeepInspectionStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) (*inspector2.BatchGetMemberEc2DeepInspectionStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchGetMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) *inspector2.BatchGetMemberEc2DeepInspectionStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchGetMemberEc2DeepInspectionStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchGetMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchUpdateMemberEc2DeepInspectionStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdateMemberEc2DeepInspectionStatus(ctx context.Context, params *inspector2.BatchUpdateMemberEc2DeepInspectionStatusInput, optFns ...func(*inspector2.Options)) (*inspector2.BatchUpdateMemberEc2DeepInspectionStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateMemberEc2DeepInspectionStatus")
	}

	var r0 *inspector2.BatchUpdateMemberEc2DeepInspectionStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchUpdateMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) (*inspector2.BatchUpdateMemberEc2DeepInspectionStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.BatchUpdateMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) *inspector2.BatchUpdateMemberEc2DeepInspectionStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.BatchUpdateMemberEc2DeepInspectionStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.BatchUpdateMemberEc2DeepInspectionStatusInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelFindingsReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelFindingsReport(ctx context.Context, params *inspector2.CancelFindingsReportInput, optFns ...func(*inspector2.Options)) (*inspector2.CancelFindingsReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelFindingsReport")
	}

	var r0 *inspector2.CancelFindingsReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CancelFindingsReportInput, ...func(*inspector2.Options)) (*inspector2.CancelFindingsReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CancelFindingsReportInput, ...func(*inspector2.Options)) *inspector2.CancelFindingsReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CancelFindingsReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CancelFindingsReportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSbomExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSbomExport(ctx context.Context, params *inspector2.CancelSbomExportInput, optFns ...func(*inspector2.Options)) (*inspector2.CancelSbomExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSbomExport")
	}

	var r0 *inspector2.CancelSbomExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CancelSbomExportInput, ...func(*inspector2.Options)) (*inspector2.CancelSbomExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CancelSbomExportInput, ...func(*inspector2.Options)) *inspector2.CancelSbomExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CancelSbomExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CancelSbomExportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCisScanConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCisScanConfiguration(ctx context.Context, params *inspector2.CreateCisScanConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.CreateCisScanConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCisScanConfiguration")
	}

	var r0 *inspector2.CreateCisScanConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateCisScanConfigurationInput, ...func(*inspector2.Options)) (*inspector2.CreateCisScanConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateCisScanConfigurationInput, ...func(*inspector2.Options)) *inspector2.CreateCisScanConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CreateCisScanConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CreateCisScanConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFilter(ctx context.Context, params *inspector2.CreateFilterInput, optFns ...func(*inspector2.Options)) (*inspector2.CreateFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFilter")
	}

	var r0 *inspector2.CreateFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateFilterInput, ...func(*inspector2.Options)) (*inspector2.CreateFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateFilterInput, ...func(*inspector2.Options)) *inspector2.CreateFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CreateFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CreateFilterInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFindingsReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFindingsReport(ctx context.Context, params *inspector2.CreateFindingsReportInput, optFns ...func(*inspector2.Options)) (*inspector2.CreateFindingsReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFindingsReport")
	}

	var r0 *inspector2.CreateFindingsReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateFindingsReportInput, ...func(*inspector2.Options)) (*inspector2.CreateFindingsReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateFindingsReportInput, ...func(*inspector2.Options)) *inspector2.CreateFindingsReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CreateFindingsReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CreateFindingsReportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSbomExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSbomExport(ctx context.Context, params *inspector2.CreateSbomExportInput, optFns ...func(*inspector2.Options)) (*inspector2.CreateSbomExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSbomExport")
	}

	var r0 *inspector2.CreateSbomExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateSbomExportInput, ...func(*inspector2.Options)) (*inspector2.CreateSbomExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.CreateSbomExportInput, ...func(*inspector2.Options)) *inspector2.CreateSbomExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.CreateSbomExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.CreateSbomExportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCisScanConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCisScanConfiguration(ctx context.Context, params *inspector2.DeleteCisScanConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.DeleteCisScanConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCisScanConfiguration")
	}

	var r0 *inspector2.DeleteCisScanConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DeleteCisScanConfigurationInput, ...func(*inspector2.Options)) (*inspector2.DeleteCisScanConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DeleteCisScanConfigurationInput, ...func(*inspector2.Options)) *inspector2.DeleteCisScanConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DeleteCisScanConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DeleteCisScanConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFilter(ctx context.Context, params *inspector2.DeleteFilterInput, optFns ...func(*inspector2.Options)) (*inspector2.DeleteFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFilter")
	}

	var r0 *inspector2.DeleteFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DeleteFilterInput, ...func(*inspector2.Options)) (*inspector2.DeleteFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DeleteFilterInput, ...func(*inspector2.Options)) *inspector2.DeleteFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DeleteFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DeleteFilterInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOrganizationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeOrganizationConfiguration(ctx context.Context, params *inspector2.DescribeOrganizationConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.DescribeOrganizationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOrganizationConfiguration")
	}

	var r0 *inspector2.DescribeOrganizationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DescribeOrganizationConfigurationInput, ...func(*inspector2.Options)) (*inspector2.DescribeOrganizationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DescribeOrganizationConfigurationInput, ...func(*inspector2.Options)) *inspector2.DescribeOrganizationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DescribeOrganizationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DescribeOrganizationConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Disable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Disable(ctx context.Context, params *inspector2.DisableInput, optFns ...func(*inspector2.Options)) (*inspector2.DisableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Disable")
	}

	var r0 *inspector2.DisableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisableInput, ...func(*inspector2.Options)) (*inspector2.DisableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisableInput, ...func(*inspector2.Options)) *inspector2.DisableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DisableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DisableInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableDelegatedAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableDelegatedAdminAccount(ctx context.Context, params *inspector2.DisableDelegatedAdminAccountInput, optFns ...func(*inspector2.Options)) (*inspector2.DisableDelegatedAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableDelegatedAdminAccount")
	}

	var r0 *inspector2.DisableDelegatedAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisableDelegatedAdminAccountInput, ...func(*inspector2.Options)) (*inspector2.DisableDelegatedAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisableDelegatedAdminAccountInput, ...func(*inspector2.Options)) *inspector2.DisableDelegatedAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DisableDelegatedAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DisableDelegatedAdminAccountInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateMember(ctx context.Context, params *inspector2.DisassociateMemberInput, optFns ...func(*inspector2.Options)) (*inspector2.DisassociateMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateMember")
	}

	var r0 *inspector2.DisassociateMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisassociateMemberInput, ...func(*inspector2.Options)) (*inspector2.DisassociateMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.DisassociateMemberInput, ...func(*inspector2.Options)) *inspector2.DisassociateMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.DisassociateMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.DisassociateMemberInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Enable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Enable(ctx context.Context, params *inspector2.EnableInput, optFns ...func(*inspector2.Options)) (*inspector2.EnableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Enable")
	}

	var r0 *inspector2.EnableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.EnableInput, ...func(*inspector2.Options)) (*inspector2.EnableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.EnableInput, ...func(*inspector2.Options)) *inspector2.EnableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.EnableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.EnableInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableDelegatedAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableDelegatedAdminAccount(ctx context.Context, params *inspector2.EnableDelegatedAdminAccountInput, optFns ...func(*inspector2.Options)) (*inspector2.EnableDelegatedAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableDelegatedAdminAccount")
	}

	var r0 *inspector2.EnableDelegatedAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.EnableDelegatedAdminAccountInput, ...func(*inspector2.Options)) (*inspector2.EnableDelegatedAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.EnableDelegatedAdminAccountInput, ...func(*inspector2.Options)) *inspector2.EnableDelegatedAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.EnableDelegatedAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.EnableDelegatedAdminAccountInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCisScanReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCisScanReport(ctx context.Context, params *inspector2.GetCisScanReportInput, optFns ...func(*inspector2.Options)) (*inspector2.GetCisScanReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCisScanReport")
	}

	var r0 *inspector2.GetCisScanReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetCisScanReportInput, ...func(*inspector2.Options)) (*inspector2.GetCisScanReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetCisScanReportInput, ...func(*inspector2.Options)) *inspector2.GetCisScanReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetCisScanReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetCisScanReportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCisScanResultDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCisScanResultDetails(ctx context.Context, params *inspector2.GetCisScanResultDetailsInput, optFns ...func(*inspector2.Options)) (*inspector2.GetCisScanResultDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCisScanResultDetails")
	}

	var r0 *inspector2.GetCisScanResultDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetCisScanResultDetailsInput, ...func(*inspector2.Options)) (*inspector2.GetCisScanResultDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetCisScanResultDetailsInput, ...func(*inspector2.Options)) *inspector2.GetCisScanResultDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetCisScanResultDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetCisScanResultDetailsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguration(ctx context.Context, params *inspector2.GetConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.GetConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguration")
	}

	var r0 *inspector2.GetConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetConfigurationInput, ...func(*inspector2.Options)) (*inspector2.GetConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetConfigurationInput, ...func(*inspector2.Options)) *inspector2.GetConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDelegatedAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDelegatedAdminAccount(ctx context.Context, params *inspector2.GetDelegatedAdminAccountInput, optFns ...func(*inspector2.Options)) (*inspector2.GetDelegatedAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDelegatedAdminAccount")
	}

	var r0 *inspector2.GetDelegatedAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetDelegatedAdminAccountInput, ...func(*inspector2.Options)) (*inspector2.GetDelegatedAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetDelegatedAdminAccountInput, ...func(*inspector2.Options)) *inspector2.GetDelegatedAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetDelegatedAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetDelegatedAdminAccountInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEc2DeepInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEc2DeepInspectionConfiguration(ctx context.Context, params *inspector2.GetEc2DeepInspectionConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.GetEc2DeepInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEc2DeepInspectionConfiguration")
	}

	var r0 *inspector2.GetEc2DeepInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) (*inspector2.GetEc2DeepInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) *inspector2.GetEc2DeepInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetEc2DeepInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEncryptionKey(ctx context.Context, params *inspector2.GetEncryptionKeyInput, optFns ...func(*inspector2.Options)) (*inspector2.GetEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEncryptionKey")
	}

	var r0 *inspector2.GetEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetEncryptionKeyInput, ...func(*inspector2.Options)) (*inspector2.GetEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetEncryptionKeyInput, ...func(*inspector2.Options)) *inspector2.GetEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetEncryptionKeyInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFindingsReportStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFindingsReportStatus(ctx context.Context, params *inspector2.GetFindingsReportStatusInput, optFns ...func(*inspector2.Options)) (*inspector2.GetFindingsReportStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFindingsReportStatus")
	}

	var r0 *inspector2.GetFindingsReportStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetFindingsReportStatusInput, ...func(*inspector2.Options)) (*inspector2.GetFindingsReportStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetFindingsReportStatusInput, ...func(*inspector2.Options)) *inspector2.GetFindingsReportStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetFindingsReportStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetFindingsReportStatusInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMember(ctx context.Context, params *inspector2.GetMemberInput, optFns ...func(*inspector2.Options)) (*inspector2.GetMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMember")
	}

	var r0 *inspector2.GetMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetMemberInput, ...func(*inspector2.Options)) (*inspector2.GetMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetMemberInput, ...func(*inspector2.Options)) *inspector2.GetMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetMemberInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSbomExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSbomExport(ctx context.Context, params *inspector2.GetSbomExportInput, optFns ...func(*inspector2.Options)) (*inspector2.GetSbomExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSbomExport")
	}

	var r0 *inspector2.GetSbomExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetSbomExportInput, ...func(*inspector2.Options)) (*inspector2.GetSbomExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.GetSbomExportInput, ...func(*inspector2.Options)) *inspector2.GetSbomExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.GetSbomExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.GetSbomExportInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccountPermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccountPermissions(ctx context.Context, params *inspector2.ListAccountPermissionsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListAccountPermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccountPermissions")
	}

	var r0 *inspector2.ListAccountPermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListAccountPermissionsInput, ...func(*inspector2.Options)) (*inspector2.ListAccountPermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListAccountPermissionsInput, ...func(*inspector2.Options)) *inspector2.ListAccountPermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListAccountPermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListAccountPermissionsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCisScanConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCisScanConfigurations(ctx context.Context, params *inspector2.ListCisScanConfigurationsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCisScanConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCisScanConfigurations")
	}

	var r0 *inspector2.ListCisScanConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanConfigurationsInput, ...func(*inspector2.Options)) (*inspector2.ListCisScanConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanConfigurationsInput, ...func(*inspector2.Options)) *inspector2.ListCisScanConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCisScanConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCisScanConfigurationsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCisScanResultsAggregatedByChecks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCisScanResultsAggregatedByChecks(ctx context.Context, params *inspector2.ListCisScanResultsAggregatedByChecksInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCisScanResultsAggregatedByChecksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCisScanResultsAggregatedByChecks")
	}

	var r0 *inspector2.ListCisScanResultsAggregatedByChecksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByChecksInput, ...func(*inspector2.Options)) (*inspector2.ListCisScanResultsAggregatedByChecksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByChecksInput, ...func(*inspector2.Options)) *inspector2.ListCisScanResultsAggregatedByChecksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCisScanResultsAggregatedByChecksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByChecksInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCisScanResultsAggregatedByTargetResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCisScanResultsAggregatedByTargetResource(ctx context.Context, params *inspector2.ListCisScanResultsAggregatedByTargetResourceInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCisScanResultsAggregatedByTargetResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCisScanResultsAggregatedByTargetResource")
	}

	var r0 *inspector2.ListCisScanResultsAggregatedByTargetResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByTargetResourceInput, ...func(*inspector2.Options)) (*inspector2.ListCisScanResultsAggregatedByTargetResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByTargetResourceInput, ...func(*inspector2.Options)) *inspector2.ListCisScanResultsAggregatedByTargetResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCisScanResultsAggregatedByTargetResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCisScanResultsAggregatedByTargetResourceInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCisScans provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCisScans(ctx context.Context, params *inspector2.ListCisScansInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCisScansOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCisScans")
	}

	var r0 *inspector2.ListCisScansOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScansInput, ...func(*inspector2.Options)) (*inspector2.ListCisScansOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCisScansInput, ...func(*inspector2.Options)) *inspector2.ListCisScansOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCisScansOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCisScansInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCoverage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCoverage(ctx context.Context, params *inspector2.ListCoverageInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCoverageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCoverage")
	}

	var r0 *inspector2.ListCoverageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCoverageInput, ...func(*inspector2.Options)) (*inspector2.ListCoverageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCoverageInput, ...func(*inspector2.Options)) *inspector2.ListCoverageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCoverageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCoverageInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCoverageStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCoverageStatistics(ctx context.Context, params *inspector2.ListCoverageStatisticsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListCoverageStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCoverageStatistics")
	}

	var r0 *inspector2.ListCoverageStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCoverageStatisticsInput, ...func(*inspector2.Options)) (*inspector2.ListCoverageStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListCoverageStatisticsInput, ...func(*inspector2.Options)) *inspector2.ListCoverageStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListCoverageStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListCoverageStatisticsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDelegatedAdminAccounts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDelegatedAdminAccounts(ctx context.Context, params *inspector2.ListDelegatedAdminAccountsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListDelegatedAdminAccountsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDelegatedAdminAccounts")
	}

	var r0 *inspector2.ListDelegatedAdminAccountsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListDelegatedAdminAccountsInput, ...func(*inspector2.Options)) (*inspector2.ListDelegatedAdminAccountsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListDelegatedAdminAccountsInput, ...func(*inspector2.Options)) *inspector2.ListDelegatedAdminAccountsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListDelegatedAdminAccountsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListDelegatedAdminAccountsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFilters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFilters(ctx context.Context, params *inspector2.ListFiltersInput, optFns ...func(*inspector2.Options)) (*inspector2.ListFiltersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFilters")
	}

	var r0 *inspector2.ListFiltersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFiltersInput, ...func(*inspector2.Options)) (*inspector2.ListFiltersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFiltersInput, ...func(*inspector2.Options)) *inspector2.ListFiltersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListFiltersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListFiltersInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFindingAggregations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFindingAggregations(ctx context.Context, params *inspector2.ListFindingAggregationsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListFindingAggregationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFindingAggregations")
	}

	var r0 *inspector2.ListFindingAggregationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFindingAggregationsInput, ...func(*inspector2.Options)) (*inspector2.ListFindingAggregationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFindingAggregationsInput, ...func(*inspector2.Options)) *inspector2.ListFindingAggregationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListFindingAggregationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListFindingAggregationsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFindings(ctx context.Context, params *inspector2.ListFindingsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFindings")
	}

	var r0 *inspector2.ListFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFindingsInput, ...func(*inspector2.Options)) (*inspector2.ListFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListFindingsInput, ...func(*inspector2.Options)) *inspector2.ListFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListFindingsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMembers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMembers(ctx context.Context, params *inspector2.ListMembersInput, optFns ...func(*inspector2.Options)) (*inspector2.ListMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMembers")
	}

	var r0 *inspector2.ListMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListMembersInput, ...func(*inspector2.Options)) (*inspector2.ListMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListMembersInput, ...func(*inspector2.Options)) *inspector2.ListMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListMembersInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *inspector2.ListTagsForResourceInput, optFns ...func(*inspector2.Options)) (*inspector2.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *inspector2.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListTagsForResourceInput, ...func(*inspector2.Options)) (*inspector2.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListTagsForResourceInput, ...func(*inspector2.Options)) *inspector2.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListTagsForResourceInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsageTotals provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUsageTotals(ctx context.Context, params *inspector2.ListUsageTotalsInput, optFns ...func(*inspector2.Options)) (*inspector2.ListUsageTotalsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsageTotals")
	}

	var r0 *inspector2.ListUsageTotalsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListUsageTotalsInput, ...func(*inspector2.Options)) (*inspector2.ListUsageTotalsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ListUsageTotalsInput, ...func(*inspector2.Options)) *inspector2.ListUsageTotalsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ListUsageTotalsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ListUsageTotalsInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() inspector2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 inspector2.Options
	if rf, ok := ret.Get(0).(func() inspector2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(inspector2.Options)
	}

	return r0
}

// ResetEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetEncryptionKey(ctx context.Context, params *inspector2.ResetEncryptionKeyInput, optFns ...func(*inspector2.Options)) (*inspector2.ResetEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetEncryptionKey")
	}

	var r0 *inspector2.ResetEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ResetEncryptionKeyInput, ...func(*inspector2.Options)) (*inspector2.ResetEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.ResetEncryptionKeyInput, ...func(*inspector2.Options)) *inspector2.ResetEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.ResetEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.ResetEncryptionKeyInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchVulnerabilities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchVulnerabilities(ctx context.Context, params *inspector2.SearchVulnerabilitiesInput, optFns ...func(*inspector2.Options)) (*inspector2.SearchVulnerabilitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchVulnerabilities")
	}

	var r0 *inspector2.SearchVulnerabilitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SearchVulnerabilitiesInput, ...func(*inspector2.Options)) (*inspector2.SearchVulnerabilitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SearchVulnerabilitiesInput, ...func(*inspector2.Options)) *inspector2.SearchVulnerabilitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.SearchVulnerabilitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.SearchVulnerabilitiesInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendCisSessionHealth provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendCisSessionHealth(ctx context.Context, params *inspector2.SendCisSessionHealthInput, optFns ...func(*inspector2.Options)) (*inspector2.SendCisSessionHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendCisSessionHealth")
	}

	var r0 *inspector2.SendCisSessionHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SendCisSessionHealthInput, ...func(*inspector2.Options)) (*inspector2.SendCisSessionHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SendCisSessionHealthInput, ...func(*inspector2.Options)) *inspector2.SendCisSessionHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.SendCisSessionHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.SendCisSessionHealthInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendCisSessionTelemetry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendCisSessionTelemetry(ctx context.Context, params *inspector2.SendCisSessionTelemetryInput, optFns ...func(*inspector2.Options)) (*inspector2.SendCisSessionTelemetryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendCisSessionTelemetry")
	}

	var r0 *inspector2.SendCisSessionTelemetryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SendCisSessionTelemetryInput, ...func(*inspector2.Options)) (*inspector2.SendCisSessionTelemetryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.SendCisSessionTelemetryInput, ...func(*inspector2.Options)) *inspector2.SendCisSessionTelemetryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.SendCisSessionTelemetryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.SendCisSessionTelemetryInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartCisSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCisSession(ctx context.Context, params *inspector2.StartCisSessionInput, optFns ...func(*inspector2.Options)) (*inspector2.StartCisSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCisSession")
	}

	var r0 *inspector2.StartCisSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.StartCisSessionInput, ...func(*inspector2.Options)) (*inspector2.StartCisSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.StartCisSessionInput, ...func(*inspector2.Options)) *inspector2.StartCisSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.StartCisSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.StartCisSessionInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopCisSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopCisSession(ctx context.Context, params *inspector2.StopCisSessionInput, optFns ...func(*inspector2.Options)) (*inspector2.StopCisSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopCisSession")
	}

	var r0 *inspector2.StopCisSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.StopCisSessionInput, ...func(*inspector2.Options)) (*inspector2.StopCisSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.StopCisSessionInput, ...func(*inspector2.Options)) *inspector2.StopCisSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.StopCisSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.StopCisSessionInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *inspector2.TagResourceInput, optFns ...func(*inspector2.Options)) (*inspector2.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *inspector2.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.TagResourceInput, ...func(*inspector2.Options)) (*inspector2.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.TagResourceInput, ...func(*inspector2.Options)) *inspector2.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.TagResourceInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *inspector2.UntagResourceInput, optFns ...func(*inspector2.Options)) (*inspector2.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *inspector2.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UntagResourceInput, ...func(*inspector2.Options)) (*inspector2.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UntagResourceInput, ...func(*inspector2.Options)) *inspector2.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UntagResourceInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCisScanConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCisScanConfiguration(ctx context.Context, params *inspector2.UpdateCisScanConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateCisScanConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCisScanConfiguration")
	}

	var r0 *inspector2.UpdateCisScanConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateCisScanConfigurationInput, ...func(*inspector2.Options)) (*inspector2.UpdateCisScanConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateCisScanConfigurationInput, ...func(*inspector2.Options)) *inspector2.UpdateCisScanConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateCisScanConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateCisScanConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguration(ctx context.Context, params *inspector2.UpdateConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguration")
	}

	var r0 *inspector2.UpdateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateConfigurationInput, ...func(*inspector2.Options)) (*inspector2.UpdateConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateConfigurationInput, ...func(*inspector2.Options)) *inspector2.UpdateConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEc2DeepInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEc2DeepInspectionConfiguration(ctx context.Context, params *inspector2.UpdateEc2DeepInspectionConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateEc2DeepInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEc2DeepInspectionConfiguration")
	}

	var r0 *inspector2.UpdateEc2DeepInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) (*inspector2.UpdateEc2DeepInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) *inspector2.UpdateEc2DeepInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateEc2DeepInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEncryptionKey(ctx context.Context, params *inspector2.UpdateEncryptionKeyInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEncryptionKey")
	}

	var r0 *inspector2.UpdateEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateEncryptionKeyInput, ...func(*inspector2.Options)) (*inspector2.UpdateEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateEncryptionKeyInput, ...func(*inspector2.Options)) *inspector2.UpdateEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateEncryptionKeyInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFilter(ctx context.Context, params *inspector2.UpdateFilterInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFilter")
	}

	var r0 *inspector2.UpdateFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateFilterInput, ...func(*inspector2.Options)) (*inspector2.UpdateFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateFilterInput, ...func(*inspector2.Options)) *inspector2.UpdateFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateFilterInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOrgEc2DeepInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateOrgEc2DeepInspectionConfiguration(ctx context.Context, params *inspector2.UpdateOrgEc2DeepInspectionConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateOrgEc2DeepInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrgEc2DeepInspectionConfiguration")
	}

	var r0 *inspector2.UpdateOrgEc2DeepInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateOrgEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) (*inspector2.UpdateOrgEc2DeepInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateOrgEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) *inspector2.UpdateOrgEc2DeepInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateOrgEc2DeepInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateOrgEc2DeepInspectionConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOrganizationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateOrganizationConfiguration(ctx context.Context, params *inspector2.UpdateOrganizationConfigurationInput, optFns ...func(*inspector2.Options)) (*inspector2.UpdateOrganizationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrganizationConfiguration")
	}

	var r0 *inspector2.UpdateOrganizationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateOrganizationConfigurationInput, ...func(*inspector2.Options)) (*inspector2.UpdateOrganizationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector2.UpdateOrganizationConfigurationInput, ...func(*inspector2.Options)) *inspector2.UpdateOrganizationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector2.UpdateOrganizationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector2.UpdateOrganizationConfigurationInput, ...func(*inspector2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
