// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	ivsrealtime "github.com/aws/aws-sdk-go-v2/service/ivsrealtime"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateEncoderConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEncoderConfiguration(ctx context.Context, params *ivsrealtime.CreateEncoderConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateEncoderConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEncoderConfiguration")
	}

	var r0 *ivsrealtime.CreateEncoderConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateEncoderConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateEncoderConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateEncoderConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.CreateEncoderConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.CreateEncoderConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.CreateEncoderConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIngestConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIngestConfiguration(ctx context.Context, params *ivsrealtime.CreateIngestConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateIngestConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIngestConfiguration")
	}

	var r0 *ivsrealtime.CreateIngestConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateIngestConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateIngestConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateIngestConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.CreateIngestConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.CreateIngestConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.CreateIngestConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateParticipantToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateParticipantToken(ctx context.Context, params *ivsrealtime.CreateParticipantTokenInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateParticipantTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParticipantToken")
	}

	var r0 *ivsrealtime.CreateParticipantTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateParticipantTokenInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateParticipantTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateParticipantTokenInput, ...func(*ivsrealtime.Options)) *ivsrealtime.CreateParticipantTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.CreateParticipantTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.CreateParticipantTokenInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStage(ctx context.Context, params *ivsrealtime.CreateStageInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateStageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStage")
	}

	var r0 *ivsrealtime.CreateStageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateStageInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateStageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateStageInput, ...func(*ivsrealtime.Options)) *ivsrealtime.CreateStageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.CreateStageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.CreateStageInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStorageConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStorageConfiguration(ctx context.Context, params *ivsrealtime.CreateStorageConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateStorageConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStorageConfiguration")
	}

	var r0 *ivsrealtime.CreateStorageConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateStorageConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.CreateStorageConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.CreateStorageConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.CreateStorageConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.CreateStorageConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.CreateStorageConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEncoderConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEncoderConfiguration(ctx context.Context, params *ivsrealtime.DeleteEncoderConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteEncoderConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEncoderConfiguration")
	}

	var r0 *ivsrealtime.DeleteEncoderConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteEncoderConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteEncoderConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteEncoderConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DeleteEncoderConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DeleteEncoderConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DeleteEncoderConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIngestConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIngestConfiguration(ctx context.Context, params *ivsrealtime.DeleteIngestConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteIngestConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIngestConfiguration")
	}

	var r0 *ivsrealtime.DeleteIngestConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteIngestConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteIngestConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteIngestConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DeleteIngestConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DeleteIngestConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DeleteIngestConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePublicKey(ctx context.Context, params *ivsrealtime.DeletePublicKeyInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DeletePublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicKey")
	}

	var r0 *ivsrealtime.DeletePublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeletePublicKeyInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DeletePublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeletePublicKeyInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DeletePublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DeletePublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DeletePublicKeyInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStage(ctx context.Context, params *ivsrealtime.DeleteStageInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteStageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStage")
	}

	var r0 *ivsrealtime.DeleteStageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteStageInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteStageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteStageInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DeleteStageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DeleteStageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DeleteStageInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStorageConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStorageConfiguration(ctx context.Context, params *ivsrealtime.DeleteStorageConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteStorageConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStorageConfiguration")
	}

	var r0 *ivsrealtime.DeleteStorageConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteStorageConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DeleteStorageConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DeleteStorageConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DeleteStorageConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DeleteStorageConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DeleteStorageConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisconnectParticipant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisconnectParticipant(ctx context.Context, params *ivsrealtime.DisconnectParticipantInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.DisconnectParticipantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectParticipant")
	}

	var r0 *ivsrealtime.DisconnectParticipantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DisconnectParticipantInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.DisconnectParticipantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.DisconnectParticipantInput, ...func(*ivsrealtime.Options)) *ivsrealtime.DisconnectParticipantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.DisconnectParticipantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.DisconnectParticipantInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComposition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetComposition(ctx context.Context, params *ivsrealtime.GetCompositionInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetCompositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetComposition")
	}

	var r0 *ivsrealtime.GetCompositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetCompositionInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetCompositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetCompositionInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetCompositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetCompositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetCompositionInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEncoderConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEncoderConfiguration(ctx context.Context, params *ivsrealtime.GetEncoderConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetEncoderConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEncoderConfiguration")
	}

	var r0 *ivsrealtime.GetEncoderConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetEncoderConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetEncoderConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetEncoderConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetEncoderConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetEncoderConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetEncoderConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIngestConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIngestConfiguration(ctx context.Context, params *ivsrealtime.GetIngestConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetIngestConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIngestConfiguration")
	}

	var r0 *ivsrealtime.GetIngestConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetIngestConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetIngestConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetIngestConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetIngestConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetIngestConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetIngestConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParticipant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetParticipant(ctx context.Context, params *ivsrealtime.GetParticipantInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetParticipantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParticipant")
	}

	var r0 *ivsrealtime.GetParticipantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetParticipantInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetParticipantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetParticipantInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetParticipantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetParticipantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetParticipantInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPublicKey(ctx context.Context, params *ivsrealtime.GetPublicKeyInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKey")
	}

	var r0 *ivsrealtime.GetPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetPublicKeyInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetPublicKeyInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetPublicKeyInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStage(ctx context.Context, params *ivsrealtime.GetStageInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStage")
	}

	var r0 *ivsrealtime.GetStageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStageInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStageInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetStageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetStageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetStageInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStageSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStageSession(ctx context.Context, params *ivsrealtime.GetStageSessionInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStageSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStageSession")
	}

	var r0 *ivsrealtime.GetStageSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStageSessionInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStageSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStageSessionInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetStageSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetStageSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetStageSessionInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStorageConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStorageConfiguration(ctx context.Context, params *ivsrealtime.GetStorageConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStorageConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageConfiguration")
	}

	var r0 *ivsrealtime.GetStorageConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStorageConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.GetStorageConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.GetStorageConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.GetStorageConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.GetStorageConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.GetStorageConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportPublicKey(ctx context.Context, params *ivsrealtime.ImportPublicKeyInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ImportPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportPublicKey")
	}

	var r0 *ivsrealtime.ImportPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ImportPublicKeyInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ImportPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ImportPublicKeyInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ImportPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ImportPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ImportPublicKeyInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCompositions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCompositions(ctx context.Context, params *ivsrealtime.ListCompositionsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListCompositionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCompositions")
	}

	var r0 *ivsrealtime.ListCompositionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListCompositionsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListCompositionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListCompositionsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListCompositionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListCompositionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListCompositionsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEncoderConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEncoderConfigurations(ctx context.Context, params *ivsrealtime.ListEncoderConfigurationsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListEncoderConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEncoderConfigurations")
	}

	var r0 *ivsrealtime.ListEncoderConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListEncoderConfigurationsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListEncoderConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListEncoderConfigurationsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListEncoderConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListEncoderConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListEncoderConfigurationsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIngestConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIngestConfigurations(ctx context.Context, params *ivsrealtime.ListIngestConfigurationsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListIngestConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIngestConfigurations")
	}

	var r0 *ivsrealtime.ListIngestConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListIngestConfigurationsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListIngestConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListIngestConfigurationsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListIngestConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListIngestConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListIngestConfigurationsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListParticipantEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListParticipantEvents(ctx context.Context, params *ivsrealtime.ListParticipantEventsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListParticipantEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParticipantEvents")
	}

	var r0 *ivsrealtime.ListParticipantEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListParticipantEventsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListParticipantEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListParticipantEventsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListParticipantEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListParticipantEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListParticipantEventsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListParticipants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListParticipants(ctx context.Context, params *ivsrealtime.ListParticipantsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListParticipantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParticipants")
	}

	var r0 *ivsrealtime.ListParticipantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListParticipantsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListParticipantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListParticipantsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListParticipantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListParticipantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListParticipantsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPublicKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPublicKeys(ctx context.Context, params *ivsrealtime.ListPublicKeysInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListPublicKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPublicKeys")
	}

	var r0 *ivsrealtime.ListPublicKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListPublicKeysInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListPublicKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListPublicKeysInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListPublicKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListPublicKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListPublicKeysInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStageSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStageSessions(ctx context.Context, params *ivsrealtime.ListStageSessionsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStageSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStageSessions")
	}

	var r0 *ivsrealtime.ListStageSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStageSessionsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStageSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStageSessionsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListStageSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListStageSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListStageSessionsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStages(ctx context.Context, params *ivsrealtime.ListStagesInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStages")
	}

	var r0 *ivsrealtime.ListStagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStagesInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStagesInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListStagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListStagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListStagesInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStorageConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStorageConfigurations(ctx context.Context, params *ivsrealtime.ListStorageConfigurationsInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStorageConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStorageConfigurations")
	}

	var r0 *ivsrealtime.ListStorageConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStorageConfigurationsInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListStorageConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListStorageConfigurationsInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListStorageConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListStorageConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListStorageConfigurationsInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *ivsrealtime.ListTagsForResourceInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *ivsrealtime.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListTagsForResourceInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.ListTagsForResourceInput, ...func(*ivsrealtime.Options)) *ivsrealtime.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.ListTagsForResourceInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() ivsrealtime.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 ivsrealtime.Options
	if rf, ok := ret.Get(0).(func() ivsrealtime.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ivsrealtime.Options)
	}

	return r0
}

// StartComposition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartComposition(ctx context.Context, params *ivsrealtime.StartCompositionInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.StartCompositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartComposition")
	}

	var r0 *ivsrealtime.StartCompositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.StartCompositionInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.StartCompositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.StartCompositionInput, ...func(*ivsrealtime.Options)) *ivsrealtime.StartCompositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.StartCompositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.StartCompositionInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopComposition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopComposition(ctx context.Context, params *ivsrealtime.StopCompositionInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.StopCompositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopComposition")
	}

	var r0 *ivsrealtime.StopCompositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.StopCompositionInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.StopCompositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.StopCompositionInput, ...func(*ivsrealtime.Options)) *ivsrealtime.StopCompositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.StopCompositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.StopCompositionInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *ivsrealtime.TagResourceInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *ivsrealtime.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.TagResourceInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.TagResourceInput, ...func(*ivsrealtime.Options)) *ivsrealtime.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.TagResourceInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *ivsrealtime.UntagResourceInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *ivsrealtime.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UntagResourceInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UntagResourceInput, ...func(*ivsrealtime.Options)) *ivsrealtime.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.UntagResourceInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIngestConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIngestConfiguration(ctx context.Context, params *ivsrealtime.UpdateIngestConfigurationInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.UpdateIngestConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIngestConfiguration")
	}

	var r0 *ivsrealtime.UpdateIngestConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UpdateIngestConfigurationInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.UpdateIngestConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UpdateIngestConfigurationInput, ...func(*ivsrealtime.Options)) *ivsrealtime.UpdateIngestConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.UpdateIngestConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.UpdateIngestConfigurationInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStage(ctx context.Context, params *ivsrealtime.UpdateStageInput, optFns ...func(*ivsrealtime.Options)) (*ivsrealtime.UpdateStageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStage")
	}

	var r0 *ivsrealtime.UpdateStageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UpdateStageInput, ...func(*ivsrealtime.Options)) (*ivsrealtime.UpdateStageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivsrealtime.UpdateStageInput, ...func(*ivsrealtime.Options)) *ivsrealtime.UpdateStageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivsrealtime.UpdateStageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivsrealtime.UpdateStageInput, ...func(*ivsrealtime.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
