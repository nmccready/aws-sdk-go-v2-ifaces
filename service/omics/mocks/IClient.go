// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	omics "github.com/aws/aws-sdk-go-v2/service/omics"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AbortMultipartReadSetUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AbortMultipartReadSetUpload(ctx context.Context, params *omics.AbortMultipartReadSetUploadInput, optFns ...func(*omics.Options)) (*omics.AbortMultipartReadSetUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AbortMultipartReadSetUpload")
	}

	var r0 *omics.AbortMultipartReadSetUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.AbortMultipartReadSetUploadInput, ...func(*omics.Options)) (*omics.AbortMultipartReadSetUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.AbortMultipartReadSetUploadInput, ...func(*omics.Options)) *omics.AbortMultipartReadSetUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.AbortMultipartReadSetUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.AbortMultipartReadSetUploadInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptShare(ctx context.Context, params *omics.AcceptShareInput, optFns ...func(*omics.Options)) (*omics.AcceptShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptShare")
	}

	var r0 *omics.AcceptShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.AcceptShareInput, ...func(*omics.Options)) (*omics.AcceptShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.AcceptShareInput, ...func(*omics.Options)) *omics.AcceptShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.AcceptShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.AcceptShareInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteReadSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteReadSet(ctx context.Context, params *omics.BatchDeleteReadSetInput, optFns ...func(*omics.Options)) (*omics.BatchDeleteReadSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteReadSet")
	}

	var r0 *omics.BatchDeleteReadSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.BatchDeleteReadSetInput, ...func(*omics.Options)) (*omics.BatchDeleteReadSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.BatchDeleteReadSetInput, ...func(*omics.Options)) *omics.BatchDeleteReadSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.BatchDeleteReadSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.BatchDeleteReadSetInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelAnnotationImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelAnnotationImportJob(ctx context.Context, params *omics.CancelAnnotationImportJobInput, optFns ...func(*omics.Options)) (*omics.CancelAnnotationImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelAnnotationImportJob")
	}

	var r0 *omics.CancelAnnotationImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelAnnotationImportJobInput, ...func(*omics.Options)) (*omics.CancelAnnotationImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelAnnotationImportJobInput, ...func(*omics.Options)) *omics.CancelAnnotationImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CancelAnnotationImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CancelAnnotationImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelRun(ctx context.Context, params *omics.CancelRunInput, optFns ...func(*omics.Options)) (*omics.CancelRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelRun")
	}

	var r0 *omics.CancelRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelRunInput, ...func(*omics.Options)) (*omics.CancelRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelRunInput, ...func(*omics.Options)) *omics.CancelRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CancelRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CancelRunInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelVariantImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelVariantImportJob(ctx context.Context, params *omics.CancelVariantImportJobInput, optFns ...func(*omics.Options)) (*omics.CancelVariantImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelVariantImportJob")
	}

	var r0 *omics.CancelVariantImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelVariantImportJobInput, ...func(*omics.Options)) (*omics.CancelVariantImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CancelVariantImportJobInput, ...func(*omics.Options)) *omics.CancelVariantImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CancelVariantImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CancelVariantImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteMultipartReadSetUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompleteMultipartReadSetUpload(ctx context.Context, params *omics.CompleteMultipartReadSetUploadInput, optFns ...func(*omics.Options)) (*omics.CompleteMultipartReadSetUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompleteMultipartReadSetUpload")
	}

	var r0 *omics.CompleteMultipartReadSetUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CompleteMultipartReadSetUploadInput, ...func(*omics.Options)) (*omics.CompleteMultipartReadSetUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CompleteMultipartReadSetUploadInput, ...func(*omics.Options)) *omics.CompleteMultipartReadSetUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CompleteMultipartReadSetUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CompleteMultipartReadSetUploadInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAnnotationStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAnnotationStore(ctx context.Context, params *omics.CreateAnnotationStoreInput, optFns ...func(*omics.Options)) (*omics.CreateAnnotationStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAnnotationStore")
	}

	var r0 *omics.CreateAnnotationStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateAnnotationStoreInput, ...func(*omics.Options)) (*omics.CreateAnnotationStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateAnnotationStoreInput, ...func(*omics.Options)) *omics.CreateAnnotationStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateAnnotationStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateAnnotationStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAnnotationStoreVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAnnotationStoreVersion(ctx context.Context, params *omics.CreateAnnotationStoreVersionInput, optFns ...func(*omics.Options)) (*omics.CreateAnnotationStoreVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAnnotationStoreVersion")
	}

	var r0 *omics.CreateAnnotationStoreVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateAnnotationStoreVersionInput, ...func(*omics.Options)) (*omics.CreateAnnotationStoreVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateAnnotationStoreVersionInput, ...func(*omics.Options)) *omics.CreateAnnotationStoreVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateAnnotationStoreVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateAnnotationStoreVersionInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMultipartReadSetUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMultipartReadSetUpload(ctx context.Context, params *omics.CreateMultipartReadSetUploadInput, optFns ...func(*omics.Options)) (*omics.CreateMultipartReadSetUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMultipartReadSetUpload")
	}

	var r0 *omics.CreateMultipartReadSetUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateMultipartReadSetUploadInput, ...func(*omics.Options)) (*omics.CreateMultipartReadSetUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateMultipartReadSetUploadInput, ...func(*omics.Options)) *omics.CreateMultipartReadSetUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateMultipartReadSetUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateMultipartReadSetUploadInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReferenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReferenceStore(ctx context.Context, params *omics.CreateReferenceStoreInput, optFns ...func(*omics.Options)) (*omics.CreateReferenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReferenceStore")
	}

	var r0 *omics.CreateReferenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateReferenceStoreInput, ...func(*omics.Options)) (*omics.CreateReferenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateReferenceStoreInput, ...func(*omics.Options)) *omics.CreateReferenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateReferenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateReferenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRunCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRunCache(ctx context.Context, params *omics.CreateRunCacheInput, optFns ...func(*omics.Options)) (*omics.CreateRunCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRunCache")
	}

	var r0 *omics.CreateRunCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateRunCacheInput, ...func(*omics.Options)) (*omics.CreateRunCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateRunCacheInput, ...func(*omics.Options)) *omics.CreateRunCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateRunCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateRunCacheInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRunGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRunGroup(ctx context.Context, params *omics.CreateRunGroupInput, optFns ...func(*omics.Options)) (*omics.CreateRunGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRunGroup")
	}

	var r0 *omics.CreateRunGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateRunGroupInput, ...func(*omics.Options)) (*omics.CreateRunGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateRunGroupInput, ...func(*omics.Options)) *omics.CreateRunGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateRunGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateRunGroupInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSequenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSequenceStore(ctx context.Context, params *omics.CreateSequenceStoreInput, optFns ...func(*omics.Options)) (*omics.CreateSequenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSequenceStore")
	}

	var r0 *omics.CreateSequenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateSequenceStoreInput, ...func(*omics.Options)) (*omics.CreateSequenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateSequenceStoreInput, ...func(*omics.Options)) *omics.CreateSequenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateSequenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateSequenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateShare(ctx context.Context, params *omics.CreateShareInput, optFns ...func(*omics.Options)) (*omics.CreateShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateShare")
	}

	var r0 *omics.CreateShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateShareInput, ...func(*omics.Options)) (*omics.CreateShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateShareInput, ...func(*omics.Options)) *omics.CreateShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateShareInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVariantStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVariantStore(ctx context.Context, params *omics.CreateVariantStoreInput, optFns ...func(*omics.Options)) (*omics.CreateVariantStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVariantStore")
	}

	var r0 *omics.CreateVariantStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateVariantStoreInput, ...func(*omics.Options)) (*omics.CreateVariantStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateVariantStoreInput, ...func(*omics.Options)) *omics.CreateVariantStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateVariantStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateVariantStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkflow(ctx context.Context, params *omics.CreateWorkflowInput, optFns ...func(*omics.Options)) (*omics.CreateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflow")
	}

	var r0 *omics.CreateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateWorkflowInput, ...func(*omics.Options)) (*omics.CreateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.CreateWorkflowInput, ...func(*omics.Options)) *omics.CreateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.CreateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.CreateWorkflowInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAnnotationStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAnnotationStore(ctx context.Context, params *omics.DeleteAnnotationStoreInput, optFns ...func(*omics.Options)) (*omics.DeleteAnnotationStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAnnotationStore")
	}

	var r0 *omics.DeleteAnnotationStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteAnnotationStoreInput, ...func(*omics.Options)) (*omics.DeleteAnnotationStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteAnnotationStoreInput, ...func(*omics.Options)) *omics.DeleteAnnotationStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteAnnotationStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteAnnotationStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAnnotationStoreVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAnnotationStoreVersions(ctx context.Context, params *omics.DeleteAnnotationStoreVersionsInput, optFns ...func(*omics.Options)) (*omics.DeleteAnnotationStoreVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAnnotationStoreVersions")
	}

	var r0 *omics.DeleteAnnotationStoreVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteAnnotationStoreVersionsInput, ...func(*omics.Options)) (*omics.DeleteAnnotationStoreVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteAnnotationStoreVersionsInput, ...func(*omics.Options)) *omics.DeleteAnnotationStoreVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteAnnotationStoreVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteAnnotationStoreVersionsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReference provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReference(ctx context.Context, params *omics.DeleteReferenceInput, optFns ...func(*omics.Options)) (*omics.DeleteReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReference")
	}

	var r0 *omics.DeleteReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteReferenceInput, ...func(*omics.Options)) (*omics.DeleteReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteReferenceInput, ...func(*omics.Options)) *omics.DeleteReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteReferenceInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReferenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReferenceStore(ctx context.Context, params *omics.DeleteReferenceStoreInput, optFns ...func(*omics.Options)) (*omics.DeleteReferenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReferenceStore")
	}

	var r0 *omics.DeleteReferenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteReferenceStoreInput, ...func(*omics.Options)) (*omics.DeleteReferenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteReferenceStoreInput, ...func(*omics.Options)) *omics.DeleteReferenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteReferenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteReferenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRun(ctx context.Context, params *omics.DeleteRunInput, optFns ...func(*omics.Options)) (*omics.DeleteRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRun")
	}

	var r0 *omics.DeleteRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunInput, ...func(*omics.Options)) (*omics.DeleteRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunInput, ...func(*omics.Options)) *omics.DeleteRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteRunInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRunCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRunCache(ctx context.Context, params *omics.DeleteRunCacheInput, optFns ...func(*omics.Options)) (*omics.DeleteRunCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRunCache")
	}

	var r0 *omics.DeleteRunCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunCacheInput, ...func(*omics.Options)) (*omics.DeleteRunCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunCacheInput, ...func(*omics.Options)) *omics.DeleteRunCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteRunCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteRunCacheInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRunGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRunGroup(ctx context.Context, params *omics.DeleteRunGroupInput, optFns ...func(*omics.Options)) (*omics.DeleteRunGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRunGroup")
	}

	var r0 *omics.DeleteRunGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunGroupInput, ...func(*omics.Options)) (*omics.DeleteRunGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteRunGroupInput, ...func(*omics.Options)) *omics.DeleteRunGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteRunGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteRunGroupInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteS3AccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteS3AccessPolicy(ctx context.Context, params *omics.DeleteS3AccessPolicyInput, optFns ...func(*omics.Options)) (*omics.DeleteS3AccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteS3AccessPolicy")
	}

	var r0 *omics.DeleteS3AccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteS3AccessPolicyInput, ...func(*omics.Options)) (*omics.DeleteS3AccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteS3AccessPolicyInput, ...func(*omics.Options)) *omics.DeleteS3AccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteS3AccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteS3AccessPolicyInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSequenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSequenceStore(ctx context.Context, params *omics.DeleteSequenceStoreInput, optFns ...func(*omics.Options)) (*omics.DeleteSequenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSequenceStore")
	}

	var r0 *omics.DeleteSequenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteSequenceStoreInput, ...func(*omics.Options)) (*omics.DeleteSequenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteSequenceStoreInput, ...func(*omics.Options)) *omics.DeleteSequenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteSequenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteSequenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteShare(ctx context.Context, params *omics.DeleteShareInput, optFns ...func(*omics.Options)) (*omics.DeleteShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteShare")
	}

	var r0 *omics.DeleteShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteShareInput, ...func(*omics.Options)) (*omics.DeleteShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteShareInput, ...func(*omics.Options)) *omics.DeleteShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteShareInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVariantStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVariantStore(ctx context.Context, params *omics.DeleteVariantStoreInput, optFns ...func(*omics.Options)) (*omics.DeleteVariantStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVariantStore")
	}

	var r0 *omics.DeleteVariantStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteVariantStoreInput, ...func(*omics.Options)) (*omics.DeleteVariantStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteVariantStoreInput, ...func(*omics.Options)) *omics.DeleteVariantStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteVariantStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteVariantStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflow(ctx context.Context, params *omics.DeleteWorkflowInput, optFns ...func(*omics.Options)) (*omics.DeleteWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 *omics.DeleteWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteWorkflowInput, ...func(*omics.Options)) (*omics.DeleteWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.DeleteWorkflowInput, ...func(*omics.Options)) *omics.DeleteWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.DeleteWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.DeleteWorkflowInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnnotationImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnnotationImportJob(ctx context.Context, params *omics.GetAnnotationImportJobInput, optFns ...func(*omics.Options)) (*omics.GetAnnotationImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnnotationImportJob")
	}

	var r0 *omics.GetAnnotationImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationImportJobInput, ...func(*omics.Options)) (*omics.GetAnnotationImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationImportJobInput, ...func(*omics.Options)) *omics.GetAnnotationImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetAnnotationImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetAnnotationImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnnotationStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnnotationStore(ctx context.Context, params *omics.GetAnnotationStoreInput, optFns ...func(*omics.Options)) (*omics.GetAnnotationStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnnotationStore")
	}

	var r0 *omics.GetAnnotationStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationStoreInput, ...func(*omics.Options)) (*omics.GetAnnotationStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationStoreInput, ...func(*omics.Options)) *omics.GetAnnotationStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetAnnotationStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetAnnotationStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnnotationStoreVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnnotationStoreVersion(ctx context.Context, params *omics.GetAnnotationStoreVersionInput, optFns ...func(*omics.Options)) (*omics.GetAnnotationStoreVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnnotationStoreVersion")
	}

	var r0 *omics.GetAnnotationStoreVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationStoreVersionInput, ...func(*omics.Options)) (*omics.GetAnnotationStoreVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetAnnotationStoreVersionInput, ...func(*omics.Options)) *omics.GetAnnotationStoreVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetAnnotationStoreVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetAnnotationStoreVersionInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReadSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReadSet(ctx context.Context, params *omics.GetReadSetInput, optFns ...func(*omics.Options)) (*omics.GetReadSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReadSet")
	}

	var r0 *omics.GetReadSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetInput, ...func(*omics.Options)) (*omics.GetReadSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetInput, ...func(*omics.Options)) *omics.GetReadSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReadSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReadSetInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReadSetActivationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReadSetActivationJob(ctx context.Context, params *omics.GetReadSetActivationJobInput, optFns ...func(*omics.Options)) (*omics.GetReadSetActivationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReadSetActivationJob")
	}

	var r0 *omics.GetReadSetActivationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetActivationJobInput, ...func(*omics.Options)) (*omics.GetReadSetActivationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetActivationJobInput, ...func(*omics.Options)) *omics.GetReadSetActivationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReadSetActivationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReadSetActivationJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReadSetExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReadSetExportJob(ctx context.Context, params *omics.GetReadSetExportJobInput, optFns ...func(*omics.Options)) (*omics.GetReadSetExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReadSetExportJob")
	}

	var r0 *omics.GetReadSetExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetExportJobInput, ...func(*omics.Options)) (*omics.GetReadSetExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetExportJobInput, ...func(*omics.Options)) *omics.GetReadSetExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReadSetExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReadSetExportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReadSetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReadSetImportJob(ctx context.Context, params *omics.GetReadSetImportJobInput, optFns ...func(*omics.Options)) (*omics.GetReadSetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReadSetImportJob")
	}

	var r0 *omics.GetReadSetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetImportJobInput, ...func(*omics.Options)) (*omics.GetReadSetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetImportJobInput, ...func(*omics.Options)) *omics.GetReadSetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReadSetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReadSetImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReadSetMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReadSetMetadata(ctx context.Context, params *omics.GetReadSetMetadataInput, optFns ...func(*omics.Options)) (*omics.GetReadSetMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReadSetMetadata")
	}

	var r0 *omics.GetReadSetMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetMetadataInput, ...func(*omics.Options)) (*omics.GetReadSetMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReadSetMetadataInput, ...func(*omics.Options)) *omics.GetReadSetMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReadSetMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReadSetMetadataInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReference provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReference(ctx context.Context, params *omics.GetReferenceInput, optFns ...func(*omics.Options)) (*omics.GetReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReference")
	}

	var r0 *omics.GetReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceInput, ...func(*omics.Options)) (*omics.GetReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceInput, ...func(*omics.Options)) *omics.GetReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReferenceInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReferenceImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReferenceImportJob(ctx context.Context, params *omics.GetReferenceImportJobInput, optFns ...func(*omics.Options)) (*omics.GetReferenceImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReferenceImportJob")
	}

	var r0 *omics.GetReferenceImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceImportJobInput, ...func(*omics.Options)) (*omics.GetReferenceImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceImportJobInput, ...func(*omics.Options)) *omics.GetReferenceImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReferenceImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReferenceImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReferenceMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReferenceMetadata(ctx context.Context, params *omics.GetReferenceMetadataInput, optFns ...func(*omics.Options)) (*omics.GetReferenceMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReferenceMetadata")
	}

	var r0 *omics.GetReferenceMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceMetadataInput, ...func(*omics.Options)) (*omics.GetReferenceMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceMetadataInput, ...func(*omics.Options)) *omics.GetReferenceMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReferenceMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReferenceMetadataInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReferenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReferenceStore(ctx context.Context, params *omics.GetReferenceStoreInput, optFns ...func(*omics.Options)) (*omics.GetReferenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReferenceStore")
	}

	var r0 *omics.GetReferenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceStoreInput, ...func(*omics.Options)) (*omics.GetReferenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetReferenceStoreInput, ...func(*omics.Options)) *omics.GetReferenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetReferenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetReferenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRun(ctx context.Context, params *omics.GetRunInput, optFns ...func(*omics.Options)) (*omics.GetRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRun")
	}

	var r0 *omics.GetRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunInput, ...func(*omics.Options)) (*omics.GetRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunInput, ...func(*omics.Options)) *omics.GetRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetRunInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRunCache(ctx context.Context, params *omics.GetRunCacheInput, optFns ...func(*omics.Options)) (*omics.GetRunCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRunCache")
	}

	var r0 *omics.GetRunCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunCacheInput, ...func(*omics.Options)) (*omics.GetRunCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunCacheInput, ...func(*omics.Options)) *omics.GetRunCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetRunCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetRunCacheInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRunGroup(ctx context.Context, params *omics.GetRunGroupInput, optFns ...func(*omics.Options)) (*omics.GetRunGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRunGroup")
	}

	var r0 *omics.GetRunGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunGroupInput, ...func(*omics.Options)) (*omics.GetRunGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunGroupInput, ...func(*omics.Options)) *omics.GetRunGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetRunGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetRunGroupInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRunTask(ctx context.Context, params *omics.GetRunTaskInput, optFns ...func(*omics.Options)) (*omics.GetRunTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRunTask")
	}

	var r0 *omics.GetRunTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunTaskInput, ...func(*omics.Options)) (*omics.GetRunTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetRunTaskInput, ...func(*omics.Options)) *omics.GetRunTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetRunTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetRunTaskInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetS3AccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetS3AccessPolicy(ctx context.Context, params *omics.GetS3AccessPolicyInput, optFns ...func(*omics.Options)) (*omics.GetS3AccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetS3AccessPolicy")
	}

	var r0 *omics.GetS3AccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetS3AccessPolicyInput, ...func(*omics.Options)) (*omics.GetS3AccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetS3AccessPolicyInput, ...func(*omics.Options)) *omics.GetS3AccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetS3AccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetS3AccessPolicyInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSequenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSequenceStore(ctx context.Context, params *omics.GetSequenceStoreInput, optFns ...func(*omics.Options)) (*omics.GetSequenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSequenceStore")
	}

	var r0 *omics.GetSequenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetSequenceStoreInput, ...func(*omics.Options)) (*omics.GetSequenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetSequenceStoreInput, ...func(*omics.Options)) *omics.GetSequenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetSequenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetSequenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetShare(ctx context.Context, params *omics.GetShareInput, optFns ...func(*omics.Options)) (*omics.GetShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetShare")
	}

	var r0 *omics.GetShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetShareInput, ...func(*omics.Options)) (*omics.GetShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetShareInput, ...func(*omics.Options)) *omics.GetShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetShareInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVariantImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVariantImportJob(ctx context.Context, params *omics.GetVariantImportJobInput, optFns ...func(*omics.Options)) (*omics.GetVariantImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVariantImportJob")
	}

	var r0 *omics.GetVariantImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetVariantImportJobInput, ...func(*omics.Options)) (*omics.GetVariantImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetVariantImportJobInput, ...func(*omics.Options)) *omics.GetVariantImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetVariantImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetVariantImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVariantStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVariantStore(ctx context.Context, params *omics.GetVariantStoreInput, optFns ...func(*omics.Options)) (*omics.GetVariantStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVariantStore")
	}

	var r0 *omics.GetVariantStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetVariantStoreInput, ...func(*omics.Options)) (*omics.GetVariantStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetVariantStoreInput, ...func(*omics.Options)) *omics.GetVariantStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetVariantStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetVariantStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflow(ctx context.Context, params *omics.GetWorkflowInput, optFns ...func(*omics.Options)) (*omics.GetWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *omics.GetWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetWorkflowInput, ...func(*omics.Options)) (*omics.GetWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.GetWorkflowInput, ...func(*omics.Options)) *omics.GetWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.GetWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.GetWorkflowInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnnotationImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnnotationImportJobs(ctx context.Context, params *omics.ListAnnotationImportJobsInput, optFns ...func(*omics.Options)) (*omics.ListAnnotationImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnnotationImportJobs")
	}

	var r0 *omics.ListAnnotationImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationImportJobsInput, ...func(*omics.Options)) (*omics.ListAnnotationImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationImportJobsInput, ...func(*omics.Options)) *omics.ListAnnotationImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListAnnotationImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListAnnotationImportJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnnotationStoreVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnnotationStoreVersions(ctx context.Context, params *omics.ListAnnotationStoreVersionsInput, optFns ...func(*omics.Options)) (*omics.ListAnnotationStoreVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnnotationStoreVersions")
	}

	var r0 *omics.ListAnnotationStoreVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationStoreVersionsInput, ...func(*omics.Options)) (*omics.ListAnnotationStoreVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationStoreVersionsInput, ...func(*omics.Options)) *omics.ListAnnotationStoreVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListAnnotationStoreVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListAnnotationStoreVersionsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnnotationStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnnotationStores(ctx context.Context, params *omics.ListAnnotationStoresInput, optFns ...func(*omics.Options)) (*omics.ListAnnotationStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnnotationStores")
	}

	var r0 *omics.ListAnnotationStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationStoresInput, ...func(*omics.Options)) (*omics.ListAnnotationStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListAnnotationStoresInput, ...func(*omics.Options)) *omics.ListAnnotationStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListAnnotationStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListAnnotationStoresInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMultipartReadSetUploads provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMultipartReadSetUploads(ctx context.Context, params *omics.ListMultipartReadSetUploadsInput, optFns ...func(*omics.Options)) (*omics.ListMultipartReadSetUploadsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMultipartReadSetUploads")
	}

	var r0 *omics.ListMultipartReadSetUploadsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListMultipartReadSetUploadsInput, ...func(*omics.Options)) (*omics.ListMultipartReadSetUploadsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListMultipartReadSetUploadsInput, ...func(*omics.Options)) *omics.ListMultipartReadSetUploadsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListMultipartReadSetUploadsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListMultipartReadSetUploadsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReadSetActivationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReadSetActivationJobs(ctx context.Context, params *omics.ListReadSetActivationJobsInput, optFns ...func(*omics.Options)) (*omics.ListReadSetActivationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReadSetActivationJobs")
	}

	var r0 *omics.ListReadSetActivationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetActivationJobsInput, ...func(*omics.Options)) (*omics.ListReadSetActivationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetActivationJobsInput, ...func(*omics.Options)) *omics.ListReadSetActivationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReadSetActivationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReadSetActivationJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReadSetExportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReadSetExportJobs(ctx context.Context, params *omics.ListReadSetExportJobsInput, optFns ...func(*omics.Options)) (*omics.ListReadSetExportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReadSetExportJobs")
	}

	var r0 *omics.ListReadSetExportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetExportJobsInput, ...func(*omics.Options)) (*omics.ListReadSetExportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetExportJobsInput, ...func(*omics.Options)) *omics.ListReadSetExportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReadSetExportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReadSetExportJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReadSetImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReadSetImportJobs(ctx context.Context, params *omics.ListReadSetImportJobsInput, optFns ...func(*omics.Options)) (*omics.ListReadSetImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReadSetImportJobs")
	}

	var r0 *omics.ListReadSetImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetImportJobsInput, ...func(*omics.Options)) (*omics.ListReadSetImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetImportJobsInput, ...func(*omics.Options)) *omics.ListReadSetImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReadSetImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReadSetImportJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReadSetUploadParts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReadSetUploadParts(ctx context.Context, params *omics.ListReadSetUploadPartsInput, optFns ...func(*omics.Options)) (*omics.ListReadSetUploadPartsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReadSetUploadParts")
	}

	var r0 *omics.ListReadSetUploadPartsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetUploadPartsInput, ...func(*omics.Options)) (*omics.ListReadSetUploadPartsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetUploadPartsInput, ...func(*omics.Options)) *omics.ListReadSetUploadPartsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReadSetUploadPartsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReadSetUploadPartsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReadSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReadSets(ctx context.Context, params *omics.ListReadSetsInput, optFns ...func(*omics.Options)) (*omics.ListReadSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReadSets")
	}

	var r0 *omics.ListReadSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetsInput, ...func(*omics.Options)) (*omics.ListReadSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReadSetsInput, ...func(*omics.Options)) *omics.ListReadSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReadSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReadSetsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReferenceImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReferenceImportJobs(ctx context.Context, params *omics.ListReferenceImportJobsInput, optFns ...func(*omics.Options)) (*omics.ListReferenceImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReferenceImportJobs")
	}

	var r0 *omics.ListReferenceImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferenceImportJobsInput, ...func(*omics.Options)) (*omics.ListReferenceImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferenceImportJobsInput, ...func(*omics.Options)) *omics.ListReferenceImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReferenceImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReferenceImportJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReferenceStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReferenceStores(ctx context.Context, params *omics.ListReferenceStoresInput, optFns ...func(*omics.Options)) (*omics.ListReferenceStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReferenceStores")
	}

	var r0 *omics.ListReferenceStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferenceStoresInput, ...func(*omics.Options)) (*omics.ListReferenceStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferenceStoresInput, ...func(*omics.Options)) *omics.ListReferenceStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReferenceStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReferenceStoresInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReferences(ctx context.Context, params *omics.ListReferencesInput, optFns ...func(*omics.Options)) (*omics.ListReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReferences")
	}

	var r0 *omics.ListReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferencesInput, ...func(*omics.Options)) (*omics.ListReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListReferencesInput, ...func(*omics.Options)) *omics.ListReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListReferencesInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRunCaches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRunCaches(ctx context.Context, params *omics.ListRunCachesInput, optFns ...func(*omics.Options)) (*omics.ListRunCachesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRunCaches")
	}

	var r0 *omics.ListRunCachesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunCachesInput, ...func(*omics.Options)) (*omics.ListRunCachesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunCachesInput, ...func(*omics.Options)) *omics.ListRunCachesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListRunCachesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListRunCachesInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRunGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRunGroups(ctx context.Context, params *omics.ListRunGroupsInput, optFns ...func(*omics.Options)) (*omics.ListRunGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRunGroups")
	}

	var r0 *omics.ListRunGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunGroupsInput, ...func(*omics.Options)) (*omics.ListRunGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunGroupsInput, ...func(*omics.Options)) *omics.ListRunGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListRunGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListRunGroupsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRunTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRunTasks(ctx context.Context, params *omics.ListRunTasksInput, optFns ...func(*omics.Options)) (*omics.ListRunTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRunTasks")
	}

	var r0 *omics.ListRunTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunTasksInput, ...func(*omics.Options)) (*omics.ListRunTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunTasksInput, ...func(*omics.Options)) *omics.ListRunTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListRunTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListRunTasksInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuns(ctx context.Context, params *omics.ListRunsInput, optFns ...func(*omics.Options)) (*omics.ListRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuns")
	}

	var r0 *omics.ListRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunsInput, ...func(*omics.Options)) (*omics.ListRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListRunsInput, ...func(*omics.Options)) *omics.ListRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListRunsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSequenceStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSequenceStores(ctx context.Context, params *omics.ListSequenceStoresInput, optFns ...func(*omics.Options)) (*omics.ListSequenceStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSequenceStores")
	}

	var r0 *omics.ListSequenceStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListSequenceStoresInput, ...func(*omics.Options)) (*omics.ListSequenceStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListSequenceStoresInput, ...func(*omics.Options)) *omics.ListSequenceStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListSequenceStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListSequenceStoresInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListShares provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListShares(ctx context.Context, params *omics.ListSharesInput, optFns ...func(*omics.Options)) (*omics.ListSharesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListShares")
	}

	var r0 *omics.ListSharesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListSharesInput, ...func(*omics.Options)) (*omics.ListSharesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListSharesInput, ...func(*omics.Options)) *omics.ListSharesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListSharesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListSharesInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *omics.ListTagsForResourceInput, optFns ...func(*omics.Options)) (*omics.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *omics.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListTagsForResourceInput, ...func(*omics.Options)) (*omics.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListTagsForResourceInput, ...func(*omics.Options)) *omics.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListTagsForResourceInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVariantImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVariantImportJobs(ctx context.Context, params *omics.ListVariantImportJobsInput, optFns ...func(*omics.Options)) (*omics.ListVariantImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVariantImportJobs")
	}

	var r0 *omics.ListVariantImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListVariantImportJobsInput, ...func(*omics.Options)) (*omics.ListVariantImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListVariantImportJobsInput, ...func(*omics.Options)) *omics.ListVariantImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListVariantImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListVariantImportJobsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVariantStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVariantStores(ctx context.Context, params *omics.ListVariantStoresInput, optFns ...func(*omics.Options)) (*omics.ListVariantStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVariantStores")
	}

	var r0 *omics.ListVariantStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListVariantStoresInput, ...func(*omics.Options)) (*omics.ListVariantStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListVariantStoresInput, ...func(*omics.Options)) *omics.ListVariantStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListVariantStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListVariantStoresInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflows(ctx context.Context, params *omics.ListWorkflowsInput, optFns ...func(*omics.Options)) (*omics.ListWorkflowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *omics.ListWorkflowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListWorkflowsInput, ...func(*omics.Options)) (*omics.ListWorkflowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.ListWorkflowsInput, ...func(*omics.Options)) *omics.ListWorkflowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.ListWorkflowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.ListWorkflowsInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() omics.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 omics.Options
	if rf, ok := ret.Get(0).(func() omics.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(omics.Options)
	}

	return r0
}

// PutS3AccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutS3AccessPolicy(ctx context.Context, params *omics.PutS3AccessPolicyInput, optFns ...func(*omics.Options)) (*omics.PutS3AccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutS3AccessPolicy")
	}

	var r0 *omics.PutS3AccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.PutS3AccessPolicyInput, ...func(*omics.Options)) (*omics.PutS3AccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.PutS3AccessPolicyInput, ...func(*omics.Options)) *omics.PutS3AccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.PutS3AccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.PutS3AccessPolicyInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartAnnotationImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartAnnotationImportJob(ctx context.Context, params *omics.StartAnnotationImportJobInput, optFns ...func(*omics.Options)) (*omics.StartAnnotationImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartAnnotationImportJob")
	}

	var r0 *omics.StartAnnotationImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartAnnotationImportJobInput, ...func(*omics.Options)) (*omics.StartAnnotationImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartAnnotationImportJobInput, ...func(*omics.Options)) *omics.StartAnnotationImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartAnnotationImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartAnnotationImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartReadSetActivationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartReadSetActivationJob(ctx context.Context, params *omics.StartReadSetActivationJobInput, optFns ...func(*omics.Options)) (*omics.StartReadSetActivationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartReadSetActivationJob")
	}

	var r0 *omics.StartReadSetActivationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetActivationJobInput, ...func(*omics.Options)) (*omics.StartReadSetActivationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetActivationJobInput, ...func(*omics.Options)) *omics.StartReadSetActivationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartReadSetActivationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartReadSetActivationJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartReadSetExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartReadSetExportJob(ctx context.Context, params *omics.StartReadSetExportJobInput, optFns ...func(*omics.Options)) (*omics.StartReadSetExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartReadSetExportJob")
	}

	var r0 *omics.StartReadSetExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetExportJobInput, ...func(*omics.Options)) (*omics.StartReadSetExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetExportJobInput, ...func(*omics.Options)) *omics.StartReadSetExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartReadSetExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartReadSetExportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartReadSetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartReadSetImportJob(ctx context.Context, params *omics.StartReadSetImportJobInput, optFns ...func(*omics.Options)) (*omics.StartReadSetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartReadSetImportJob")
	}

	var r0 *omics.StartReadSetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetImportJobInput, ...func(*omics.Options)) (*omics.StartReadSetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReadSetImportJobInput, ...func(*omics.Options)) *omics.StartReadSetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartReadSetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartReadSetImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartReferenceImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartReferenceImportJob(ctx context.Context, params *omics.StartReferenceImportJobInput, optFns ...func(*omics.Options)) (*omics.StartReferenceImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartReferenceImportJob")
	}

	var r0 *omics.StartReferenceImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReferenceImportJobInput, ...func(*omics.Options)) (*omics.StartReferenceImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartReferenceImportJobInput, ...func(*omics.Options)) *omics.StartReferenceImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartReferenceImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartReferenceImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartRun(ctx context.Context, params *omics.StartRunInput, optFns ...func(*omics.Options)) (*omics.StartRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartRun")
	}

	var r0 *omics.StartRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartRunInput, ...func(*omics.Options)) (*omics.StartRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartRunInput, ...func(*omics.Options)) *omics.StartRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartRunInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartVariantImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartVariantImportJob(ctx context.Context, params *omics.StartVariantImportJobInput, optFns ...func(*omics.Options)) (*omics.StartVariantImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartVariantImportJob")
	}

	var r0 *omics.StartVariantImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartVariantImportJobInput, ...func(*omics.Options)) (*omics.StartVariantImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.StartVariantImportJobInput, ...func(*omics.Options)) *omics.StartVariantImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.StartVariantImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.StartVariantImportJobInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *omics.TagResourceInput, optFns ...func(*omics.Options)) (*omics.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *omics.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.TagResourceInput, ...func(*omics.Options)) (*omics.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.TagResourceInput, ...func(*omics.Options)) *omics.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.TagResourceInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *omics.UntagResourceInput, optFns ...func(*omics.Options)) (*omics.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *omics.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UntagResourceInput, ...func(*omics.Options)) (*omics.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UntagResourceInput, ...func(*omics.Options)) *omics.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UntagResourceInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAnnotationStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAnnotationStore(ctx context.Context, params *omics.UpdateAnnotationStoreInput, optFns ...func(*omics.Options)) (*omics.UpdateAnnotationStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnnotationStore")
	}

	var r0 *omics.UpdateAnnotationStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateAnnotationStoreInput, ...func(*omics.Options)) (*omics.UpdateAnnotationStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateAnnotationStoreInput, ...func(*omics.Options)) *omics.UpdateAnnotationStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateAnnotationStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateAnnotationStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAnnotationStoreVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAnnotationStoreVersion(ctx context.Context, params *omics.UpdateAnnotationStoreVersionInput, optFns ...func(*omics.Options)) (*omics.UpdateAnnotationStoreVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnnotationStoreVersion")
	}

	var r0 *omics.UpdateAnnotationStoreVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateAnnotationStoreVersionInput, ...func(*omics.Options)) (*omics.UpdateAnnotationStoreVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateAnnotationStoreVersionInput, ...func(*omics.Options)) *omics.UpdateAnnotationStoreVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateAnnotationStoreVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateAnnotationStoreVersionInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRunCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRunCache(ctx context.Context, params *omics.UpdateRunCacheInput, optFns ...func(*omics.Options)) (*omics.UpdateRunCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRunCache")
	}

	var r0 *omics.UpdateRunCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateRunCacheInput, ...func(*omics.Options)) (*omics.UpdateRunCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateRunCacheInput, ...func(*omics.Options)) *omics.UpdateRunCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateRunCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateRunCacheInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRunGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRunGroup(ctx context.Context, params *omics.UpdateRunGroupInput, optFns ...func(*omics.Options)) (*omics.UpdateRunGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRunGroup")
	}

	var r0 *omics.UpdateRunGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateRunGroupInput, ...func(*omics.Options)) (*omics.UpdateRunGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateRunGroupInput, ...func(*omics.Options)) *omics.UpdateRunGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateRunGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateRunGroupInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSequenceStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSequenceStore(ctx context.Context, params *omics.UpdateSequenceStoreInput, optFns ...func(*omics.Options)) (*omics.UpdateSequenceStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSequenceStore")
	}

	var r0 *omics.UpdateSequenceStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateSequenceStoreInput, ...func(*omics.Options)) (*omics.UpdateSequenceStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateSequenceStoreInput, ...func(*omics.Options)) *omics.UpdateSequenceStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateSequenceStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateSequenceStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVariantStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVariantStore(ctx context.Context, params *omics.UpdateVariantStoreInput, optFns ...func(*omics.Options)) (*omics.UpdateVariantStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVariantStore")
	}

	var r0 *omics.UpdateVariantStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateVariantStoreInput, ...func(*omics.Options)) (*omics.UpdateVariantStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateVariantStoreInput, ...func(*omics.Options)) *omics.UpdateVariantStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateVariantStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateVariantStoreInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorkflow(ctx context.Context, params *omics.UpdateWorkflowInput, optFns ...func(*omics.Options)) (*omics.UpdateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflow")
	}

	var r0 *omics.UpdateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateWorkflowInput, ...func(*omics.Options)) (*omics.UpdateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UpdateWorkflowInput, ...func(*omics.Options)) *omics.UpdateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UpdateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UpdateWorkflowInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadReadSetPart provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UploadReadSetPart(ctx context.Context, params *omics.UploadReadSetPartInput, optFns ...func(*omics.Options)) (*omics.UploadReadSetPartOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadReadSetPart")
	}

	var r0 *omics.UploadReadSetPartOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UploadReadSetPartInput, ...func(*omics.Options)) (*omics.UploadReadSetPartOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *omics.UploadReadSetPartInput, ...func(*omics.Options)) *omics.UploadReadSetPartOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*omics.UploadReadSetPartOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *omics.UploadReadSetPartInput, ...func(*omics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
