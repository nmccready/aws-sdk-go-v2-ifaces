// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	lambda "github.com/aws/aws-sdk-go-v2/service/lambda"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddLayerVersionPermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddLayerVersionPermission(ctx context.Context, params *lambda.AddLayerVersionPermissionInput, optFns ...func(*lambda.Options)) (*lambda.AddLayerVersionPermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddLayerVersionPermission")
	}

	var r0 *lambda.AddLayerVersionPermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.AddLayerVersionPermissionInput, ...func(*lambda.Options)) (*lambda.AddLayerVersionPermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.AddLayerVersionPermissionInput, ...func(*lambda.Options)) *lambda.AddLayerVersionPermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.AddLayerVersionPermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.AddLayerVersionPermissionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddPermission(ctx context.Context, params *lambda.AddPermissionInput, optFns ...func(*lambda.Options)) (*lambda.AddPermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermission")
	}

	var r0 *lambda.AddPermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.AddPermissionInput, ...func(*lambda.Options)) (*lambda.AddPermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.AddPermissionInput, ...func(*lambda.Options)) *lambda.AddPermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.AddPermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.AddPermissionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAlias(ctx context.Context, params *lambda.CreateAliasInput, optFns ...func(*lambda.Options)) (*lambda.CreateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 *lambda.CreateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateAliasInput, ...func(*lambda.Options)) (*lambda.CreateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateAliasInput, ...func(*lambda.Options)) *lambda.CreateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.CreateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.CreateAliasInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCodeSigningConfig(ctx context.Context, params *lambda.CreateCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.CreateCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCodeSigningConfig")
	}

	var r0 *lambda.CreateCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.CreateCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.CreateCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.CreateCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.CreateCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventSourceMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventSourceMapping(ctx context.Context, params *lambda.CreateEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.CreateEventSourceMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventSourceMapping")
	}

	var r0 *lambda.CreateEventSourceMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateEventSourceMappingInput, ...func(*lambda.Options)) (*lambda.CreateEventSourceMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateEventSourceMappingInput, ...func(*lambda.Options)) *lambda.CreateEventSourceMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.CreateEventSourceMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.CreateEventSourceMappingInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFunction(ctx context.Context, params *lambda.CreateFunctionInput, optFns ...func(*lambda.Options)) (*lambda.CreateFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFunction")
	}

	var r0 *lambda.CreateFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateFunctionInput, ...func(*lambda.Options)) (*lambda.CreateFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateFunctionInput, ...func(*lambda.Options)) *lambda.CreateFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.CreateFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.CreateFunctionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFunctionUrlConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFunctionUrlConfig(ctx context.Context, params *lambda.CreateFunctionUrlConfigInput, optFns ...func(*lambda.Options)) (*lambda.CreateFunctionUrlConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFunctionUrlConfig")
	}

	var r0 *lambda.CreateFunctionUrlConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateFunctionUrlConfigInput, ...func(*lambda.Options)) (*lambda.CreateFunctionUrlConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.CreateFunctionUrlConfigInput, ...func(*lambda.Options)) *lambda.CreateFunctionUrlConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.CreateFunctionUrlConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.CreateFunctionUrlConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAlias(ctx context.Context, params *lambda.DeleteAliasInput, optFns ...func(*lambda.Options)) (*lambda.DeleteAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAlias")
	}

	var r0 *lambda.DeleteAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteAliasInput, ...func(*lambda.Options)) (*lambda.DeleteAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteAliasInput, ...func(*lambda.Options)) *lambda.DeleteAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteAliasInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCodeSigningConfig(ctx context.Context, params *lambda.DeleteCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.DeleteCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCodeSigningConfig")
	}

	var r0 *lambda.DeleteCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.DeleteCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.DeleteCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventSourceMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventSourceMapping(ctx context.Context, params *lambda.DeleteEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.DeleteEventSourceMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventSourceMapping")
	}

	var r0 *lambda.DeleteEventSourceMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteEventSourceMappingInput, ...func(*lambda.Options)) (*lambda.DeleteEventSourceMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteEventSourceMappingInput, ...func(*lambda.Options)) *lambda.DeleteEventSourceMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteEventSourceMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteEventSourceMappingInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFunction(ctx context.Context, params *lambda.DeleteFunctionInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFunction")
	}

	var r0 *lambda.DeleteFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionInput, ...func(*lambda.Options)) (*lambda.DeleteFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionInput, ...func(*lambda.Options)) *lambda.DeleteFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteFunctionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFunctionCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFunctionCodeSigningConfig(ctx context.Context, params *lambda.DeleteFunctionCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFunctionCodeSigningConfig")
	}

	var r0 *lambda.DeleteFunctionCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.DeleteFunctionCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.DeleteFunctionCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteFunctionCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteFunctionCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFunctionConcurrency provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFunctionConcurrency(ctx context.Context, params *lambda.DeleteFunctionConcurrencyInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionConcurrencyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFunctionConcurrency")
	}

	var r0 *lambda.DeleteFunctionConcurrencyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionConcurrencyInput, ...func(*lambda.Options)) (*lambda.DeleteFunctionConcurrencyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionConcurrencyInput, ...func(*lambda.Options)) *lambda.DeleteFunctionConcurrencyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteFunctionConcurrencyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteFunctionConcurrencyInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFunctionEventInvokeConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFunctionEventInvokeConfig(ctx context.Context, params *lambda.DeleteFunctionEventInvokeConfigInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionEventInvokeConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFunctionEventInvokeConfig")
	}

	var r0 *lambda.DeleteFunctionEventInvokeConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionEventInvokeConfigInput, ...func(*lambda.Options)) (*lambda.DeleteFunctionEventInvokeConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionEventInvokeConfigInput, ...func(*lambda.Options)) *lambda.DeleteFunctionEventInvokeConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteFunctionEventInvokeConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteFunctionEventInvokeConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFunctionUrlConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFunctionUrlConfig(ctx context.Context, params *lambda.DeleteFunctionUrlConfigInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionUrlConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFunctionUrlConfig")
	}

	var r0 *lambda.DeleteFunctionUrlConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionUrlConfigInput, ...func(*lambda.Options)) (*lambda.DeleteFunctionUrlConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteFunctionUrlConfigInput, ...func(*lambda.Options)) *lambda.DeleteFunctionUrlConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteFunctionUrlConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteFunctionUrlConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLayerVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLayerVersion(ctx context.Context, params *lambda.DeleteLayerVersionInput, optFns ...func(*lambda.Options)) (*lambda.DeleteLayerVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLayerVersion")
	}

	var r0 *lambda.DeleteLayerVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteLayerVersionInput, ...func(*lambda.Options)) (*lambda.DeleteLayerVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteLayerVersionInput, ...func(*lambda.Options)) *lambda.DeleteLayerVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteLayerVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteLayerVersionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProvisionedConcurrencyConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProvisionedConcurrencyConfig(ctx context.Context, params *lambda.DeleteProvisionedConcurrencyConfigInput, optFns ...func(*lambda.Options)) (*lambda.DeleteProvisionedConcurrencyConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProvisionedConcurrencyConfig")
	}

	var r0 *lambda.DeleteProvisionedConcurrencyConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) (*lambda.DeleteProvisionedConcurrencyConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.DeleteProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) *lambda.DeleteProvisionedConcurrencyConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.DeleteProvisionedConcurrencyConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.DeleteProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccountSettings(ctx context.Context, params *lambda.GetAccountSettingsInput, optFns ...func(*lambda.Options)) (*lambda.GetAccountSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountSettings")
	}

	var r0 *lambda.GetAccountSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetAccountSettingsInput, ...func(*lambda.Options)) (*lambda.GetAccountSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetAccountSettingsInput, ...func(*lambda.Options)) *lambda.GetAccountSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetAccountSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetAccountSettingsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAlias(ctx context.Context, params *lambda.GetAliasInput, optFns ...func(*lambda.Options)) (*lambda.GetAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAlias")
	}

	var r0 *lambda.GetAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetAliasInput, ...func(*lambda.Options)) (*lambda.GetAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetAliasInput, ...func(*lambda.Options)) *lambda.GetAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetAliasInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCodeSigningConfig(ctx context.Context, params *lambda.GetCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCodeSigningConfig")
	}

	var r0 *lambda.GetCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.GetCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.GetCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventSourceMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventSourceMapping(ctx context.Context, params *lambda.GetEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.GetEventSourceMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventSourceMapping")
	}

	var r0 *lambda.GetEventSourceMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetEventSourceMappingInput, ...func(*lambda.Options)) (*lambda.GetEventSourceMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetEventSourceMappingInput, ...func(*lambda.Options)) *lambda.GetEventSourceMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetEventSourceMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetEventSourceMappingInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunction(ctx context.Context, params *lambda.GetFunctionInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunction")
	}

	var r0 *lambda.GetFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionInput, ...func(*lambda.Options)) (*lambda.GetFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionInput, ...func(*lambda.Options)) *lambda.GetFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionCodeSigningConfig(ctx context.Context, params *lambda.GetFunctionCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionCodeSigningConfig")
	}

	var r0 *lambda.GetFunctionCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.GetFunctionCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.GetFunctionCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionConcurrency provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionConcurrency(ctx context.Context, params *lambda.GetFunctionConcurrencyInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionConcurrencyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionConcurrency")
	}

	var r0 *lambda.GetFunctionConcurrencyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionConcurrencyInput, ...func(*lambda.Options)) (*lambda.GetFunctionConcurrencyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionConcurrencyInput, ...func(*lambda.Options)) *lambda.GetFunctionConcurrencyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionConcurrencyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionConcurrencyInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionConfiguration(ctx context.Context, params *lambda.GetFunctionConfigurationInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionConfiguration")
	}

	var r0 *lambda.GetFunctionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionConfigurationInput, ...func(*lambda.Options)) (*lambda.GetFunctionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionConfigurationInput, ...func(*lambda.Options)) *lambda.GetFunctionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionConfigurationInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionEventInvokeConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionEventInvokeConfig(ctx context.Context, params *lambda.GetFunctionEventInvokeConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionEventInvokeConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionEventInvokeConfig")
	}

	var r0 *lambda.GetFunctionEventInvokeConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionEventInvokeConfigInput, ...func(*lambda.Options)) (*lambda.GetFunctionEventInvokeConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionEventInvokeConfigInput, ...func(*lambda.Options)) *lambda.GetFunctionEventInvokeConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionEventInvokeConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionEventInvokeConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionRecursionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionRecursionConfig(ctx context.Context, params *lambda.GetFunctionRecursionConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionRecursionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionRecursionConfig")
	}

	var r0 *lambda.GetFunctionRecursionConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionRecursionConfigInput, ...func(*lambda.Options)) (*lambda.GetFunctionRecursionConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionRecursionConfigInput, ...func(*lambda.Options)) *lambda.GetFunctionRecursionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionRecursionConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionRecursionConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFunctionUrlConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFunctionUrlConfig(ctx context.Context, params *lambda.GetFunctionUrlConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionUrlConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionUrlConfig")
	}

	var r0 *lambda.GetFunctionUrlConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionUrlConfigInput, ...func(*lambda.Options)) (*lambda.GetFunctionUrlConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetFunctionUrlConfigInput, ...func(*lambda.Options)) *lambda.GetFunctionUrlConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetFunctionUrlConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetFunctionUrlConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLayerVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLayerVersion(ctx context.Context, params *lambda.GetLayerVersionInput, optFns ...func(*lambda.Options)) (*lambda.GetLayerVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLayerVersion")
	}

	var r0 *lambda.GetLayerVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionInput, ...func(*lambda.Options)) (*lambda.GetLayerVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionInput, ...func(*lambda.Options)) *lambda.GetLayerVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetLayerVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetLayerVersionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLayerVersionByArn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLayerVersionByArn(ctx context.Context, params *lambda.GetLayerVersionByArnInput, optFns ...func(*lambda.Options)) (*lambda.GetLayerVersionByArnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLayerVersionByArn")
	}

	var r0 *lambda.GetLayerVersionByArnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionByArnInput, ...func(*lambda.Options)) (*lambda.GetLayerVersionByArnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionByArnInput, ...func(*lambda.Options)) *lambda.GetLayerVersionByArnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetLayerVersionByArnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetLayerVersionByArnInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLayerVersionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLayerVersionPolicy(ctx context.Context, params *lambda.GetLayerVersionPolicyInput, optFns ...func(*lambda.Options)) (*lambda.GetLayerVersionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLayerVersionPolicy")
	}

	var r0 *lambda.GetLayerVersionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionPolicyInput, ...func(*lambda.Options)) (*lambda.GetLayerVersionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetLayerVersionPolicyInput, ...func(*lambda.Options)) *lambda.GetLayerVersionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetLayerVersionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetLayerVersionPolicyInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPolicy(ctx context.Context, params *lambda.GetPolicyInput, optFns ...func(*lambda.Options)) (*lambda.GetPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPolicy")
	}

	var r0 *lambda.GetPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetPolicyInput, ...func(*lambda.Options)) (*lambda.GetPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetPolicyInput, ...func(*lambda.Options)) *lambda.GetPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetPolicyInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProvisionedConcurrencyConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetProvisionedConcurrencyConfig(ctx context.Context, params *lambda.GetProvisionedConcurrencyConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetProvisionedConcurrencyConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProvisionedConcurrencyConfig")
	}

	var r0 *lambda.GetProvisionedConcurrencyConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) (*lambda.GetProvisionedConcurrencyConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) *lambda.GetProvisionedConcurrencyConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetProvisionedConcurrencyConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRuntimeManagementConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRuntimeManagementConfig(ctx context.Context, params *lambda.GetRuntimeManagementConfigInput, optFns ...func(*lambda.Options)) (*lambda.GetRuntimeManagementConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRuntimeManagementConfig")
	}

	var r0 *lambda.GetRuntimeManagementConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetRuntimeManagementConfigInput, ...func(*lambda.Options)) (*lambda.GetRuntimeManagementConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.GetRuntimeManagementConfigInput, ...func(*lambda.Options)) *lambda.GetRuntimeManagementConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.GetRuntimeManagementConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.GetRuntimeManagementConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Invoke provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Invoke(ctx context.Context, params *lambda.InvokeInput, optFns ...func(*lambda.Options)) (*lambda.InvokeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Invoke")
	}

	var r0 *lambda.InvokeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeInput, ...func(*lambda.Options)) (*lambda.InvokeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeInput, ...func(*lambda.Options)) *lambda.InvokeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.InvokeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.InvokeInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvokeAsync provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InvokeAsync(ctx context.Context, params *lambda.InvokeAsyncInput, optFns ...func(*lambda.Options)) (*lambda.InvokeAsyncOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InvokeAsync")
	}

	var r0 *lambda.InvokeAsyncOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeAsyncInput, ...func(*lambda.Options)) (*lambda.InvokeAsyncOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeAsyncInput, ...func(*lambda.Options)) *lambda.InvokeAsyncOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.InvokeAsyncOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.InvokeAsyncInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvokeWithResponseStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InvokeWithResponseStream(ctx context.Context, params *lambda.InvokeWithResponseStreamInput, optFns ...func(*lambda.Options)) (*lambda.InvokeWithResponseStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InvokeWithResponseStream")
	}

	var r0 *lambda.InvokeWithResponseStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeWithResponseStreamInput, ...func(*lambda.Options)) (*lambda.InvokeWithResponseStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.InvokeWithResponseStreamInput, ...func(*lambda.Options)) *lambda.InvokeWithResponseStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.InvokeWithResponseStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.InvokeWithResponseStreamInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAliases(ctx context.Context, params *lambda.ListAliasesInput, optFns ...func(*lambda.Options)) (*lambda.ListAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAliases")
	}

	var r0 *lambda.ListAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListAliasesInput, ...func(*lambda.Options)) (*lambda.ListAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListAliasesInput, ...func(*lambda.Options)) *lambda.ListAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListAliasesInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeSigningConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCodeSigningConfigs(ctx context.Context, params *lambda.ListCodeSigningConfigsInput, optFns ...func(*lambda.Options)) (*lambda.ListCodeSigningConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCodeSigningConfigs")
	}

	var r0 *lambda.ListCodeSigningConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListCodeSigningConfigsInput, ...func(*lambda.Options)) (*lambda.ListCodeSigningConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListCodeSigningConfigsInput, ...func(*lambda.Options)) *lambda.ListCodeSigningConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListCodeSigningConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListCodeSigningConfigsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventSourceMappings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventSourceMappings(ctx context.Context, params *lambda.ListEventSourceMappingsInput, optFns ...func(*lambda.Options)) (*lambda.ListEventSourceMappingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventSourceMappings")
	}

	var r0 *lambda.ListEventSourceMappingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListEventSourceMappingsInput, ...func(*lambda.Options)) (*lambda.ListEventSourceMappingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListEventSourceMappingsInput, ...func(*lambda.Options)) *lambda.ListEventSourceMappingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListEventSourceMappingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListEventSourceMappingsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFunctionEventInvokeConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFunctionEventInvokeConfigs(ctx context.Context, params *lambda.ListFunctionEventInvokeConfigsInput, optFns ...func(*lambda.Options)) (*lambda.ListFunctionEventInvokeConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFunctionEventInvokeConfigs")
	}

	var r0 *lambda.ListFunctionEventInvokeConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionEventInvokeConfigsInput, ...func(*lambda.Options)) (*lambda.ListFunctionEventInvokeConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionEventInvokeConfigsInput, ...func(*lambda.Options)) *lambda.ListFunctionEventInvokeConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListFunctionEventInvokeConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListFunctionEventInvokeConfigsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFunctionUrlConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFunctionUrlConfigs(ctx context.Context, params *lambda.ListFunctionUrlConfigsInput, optFns ...func(*lambda.Options)) (*lambda.ListFunctionUrlConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFunctionUrlConfigs")
	}

	var r0 *lambda.ListFunctionUrlConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionUrlConfigsInput, ...func(*lambda.Options)) (*lambda.ListFunctionUrlConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionUrlConfigsInput, ...func(*lambda.Options)) *lambda.ListFunctionUrlConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListFunctionUrlConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListFunctionUrlConfigsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFunctions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFunctions(ctx context.Context, params *lambda.ListFunctionsInput, optFns ...func(*lambda.Options)) (*lambda.ListFunctionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFunctions")
	}

	var r0 *lambda.ListFunctionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionsInput, ...func(*lambda.Options)) (*lambda.ListFunctionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionsInput, ...func(*lambda.Options)) *lambda.ListFunctionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListFunctionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListFunctionsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFunctionsByCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFunctionsByCodeSigningConfig(ctx context.Context, params *lambda.ListFunctionsByCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.ListFunctionsByCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFunctionsByCodeSigningConfig")
	}

	var r0 *lambda.ListFunctionsByCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionsByCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.ListFunctionsByCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListFunctionsByCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.ListFunctionsByCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListFunctionsByCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListFunctionsByCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLayerVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLayerVersions(ctx context.Context, params *lambda.ListLayerVersionsInput, optFns ...func(*lambda.Options)) (*lambda.ListLayerVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLayerVersions")
	}

	var r0 *lambda.ListLayerVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListLayerVersionsInput, ...func(*lambda.Options)) (*lambda.ListLayerVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListLayerVersionsInput, ...func(*lambda.Options)) *lambda.ListLayerVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListLayerVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListLayerVersionsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLayers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLayers(ctx context.Context, params *lambda.ListLayersInput, optFns ...func(*lambda.Options)) (*lambda.ListLayersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLayers")
	}

	var r0 *lambda.ListLayersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListLayersInput, ...func(*lambda.Options)) (*lambda.ListLayersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListLayersInput, ...func(*lambda.Options)) *lambda.ListLayersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListLayersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListLayersInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProvisionedConcurrencyConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProvisionedConcurrencyConfigs(ctx context.Context, params *lambda.ListProvisionedConcurrencyConfigsInput, optFns ...func(*lambda.Options)) (*lambda.ListProvisionedConcurrencyConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProvisionedConcurrencyConfigs")
	}

	var r0 *lambda.ListProvisionedConcurrencyConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListProvisionedConcurrencyConfigsInput, ...func(*lambda.Options)) (*lambda.ListProvisionedConcurrencyConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListProvisionedConcurrencyConfigsInput, ...func(*lambda.Options)) *lambda.ListProvisionedConcurrencyConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListProvisionedConcurrencyConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListProvisionedConcurrencyConfigsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *lambda.ListTagsInput, optFns ...func(*lambda.Options)) (*lambda.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *lambda.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListTagsInput, ...func(*lambda.Options)) (*lambda.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListTagsInput, ...func(*lambda.Options)) *lambda.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListTagsInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVersionsByFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVersionsByFunction(ctx context.Context, params *lambda.ListVersionsByFunctionInput, optFns ...func(*lambda.Options)) (*lambda.ListVersionsByFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVersionsByFunction")
	}

	var r0 *lambda.ListVersionsByFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListVersionsByFunctionInput, ...func(*lambda.Options)) (*lambda.ListVersionsByFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.ListVersionsByFunctionInput, ...func(*lambda.Options)) *lambda.ListVersionsByFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.ListVersionsByFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.ListVersionsByFunctionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() lambda.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 lambda.Options
	if rf, ok := ret.Get(0).(func() lambda.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(lambda.Options)
	}

	return r0
}

// PublishLayerVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PublishLayerVersion(ctx context.Context, params *lambda.PublishLayerVersionInput, optFns ...func(*lambda.Options)) (*lambda.PublishLayerVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishLayerVersion")
	}

	var r0 *lambda.PublishLayerVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PublishLayerVersionInput, ...func(*lambda.Options)) (*lambda.PublishLayerVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PublishLayerVersionInput, ...func(*lambda.Options)) *lambda.PublishLayerVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PublishLayerVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PublishLayerVersionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublishVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PublishVersion(ctx context.Context, params *lambda.PublishVersionInput, optFns ...func(*lambda.Options)) (*lambda.PublishVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishVersion")
	}

	var r0 *lambda.PublishVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PublishVersionInput, ...func(*lambda.Options)) (*lambda.PublishVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PublishVersionInput, ...func(*lambda.Options)) *lambda.PublishVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PublishVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PublishVersionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutFunctionCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFunctionCodeSigningConfig(ctx context.Context, params *lambda.PutFunctionCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.PutFunctionCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFunctionCodeSigningConfig")
	}

	var r0 *lambda.PutFunctionCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.PutFunctionCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.PutFunctionCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutFunctionCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutFunctionCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutFunctionConcurrency provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFunctionConcurrency(ctx context.Context, params *lambda.PutFunctionConcurrencyInput, optFns ...func(*lambda.Options)) (*lambda.PutFunctionConcurrencyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFunctionConcurrency")
	}

	var r0 *lambda.PutFunctionConcurrencyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionConcurrencyInput, ...func(*lambda.Options)) (*lambda.PutFunctionConcurrencyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionConcurrencyInput, ...func(*lambda.Options)) *lambda.PutFunctionConcurrencyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutFunctionConcurrencyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutFunctionConcurrencyInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutFunctionEventInvokeConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFunctionEventInvokeConfig(ctx context.Context, params *lambda.PutFunctionEventInvokeConfigInput, optFns ...func(*lambda.Options)) (*lambda.PutFunctionEventInvokeConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFunctionEventInvokeConfig")
	}

	var r0 *lambda.PutFunctionEventInvokeConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionEventInvokeConfigInput, ...func(*lambda.Options)) (*lambda.PutFunctionEventInvokeConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionEventInvokeConfigInput, ...func(*lambda.Options)) *lambda.PutFunctionEventInvokeConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutFunctionEventInvokeConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutFunctionEventInvokeConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutFunctionRecursionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFunctionRecursionConfig(ctx context.Context, params *lambda.PutFunctionRecursionConfigInput, optFns ...func(*lambda.Options)) (*lambda.PutFunctionRecursionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFunctionRecursionConfig")
	}

	var r0 *lambda.PutFunctionRecursionConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionRecursionConfigInput, ...func(*lambda.Options)) (*lambda.PutFunctionRecursionConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutFunctionRecursionConfigInput, ...func(*lambda.Options)) *lambda.PutFunctionRecursionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutFunctionRecursionConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutFunctionRecursionConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutProvisionedConcurrencyConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutProvisionedConcurrencyConfig(ctx context.Context, params *lambda.PutProvisionedConcurrencyConfigInput, optFns ...func(*lambda.Options)) (*lambda.PutProvisionedConcurrencyConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutProvisionedConcurrencyConfig")
	}

	var r0 *lambda.PutProvisionedConcurrencyConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) (*lambda.PutProvisionedConcurrencyConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) *lambda.PutProvisionedConcurrencyConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutProvisionedConcurrencyConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutProvisionedConcurrencyConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRuntimeManagementConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRuntimeManagementConfig(ctx context.Context, params *lambda.PutRuntimeManagementConfigInput, optFns ...func(*lambda.Options)) (*lambda.PutRuntimeManagementConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRuntimeManagementConfig")
	}

	var r0 *lambda.PutRuntimeManagementConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutRuntimeManagementConfigInput, ...func(*lambda.Options)) (*lambda.PutRuntimeManagementConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.PutRuntimeManagementConfigInput, ...func(*lambda.Options)) *lambda.PutRuntimeManagementConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.PutRuntimeManagementConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.PutRuntimeManagementConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveLayerVersionPermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveLayerVersionPermission(ctx context.Context, params *lambda.RemoveLayerVersionPermissionInput, optFns ...func(*lambda.Options)) (*lambda.RemoveLayerVersionPermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveLayerVersionPermission")
	}

	var r0 *lambda.RemoveLayerVersionPermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.RemoveLayerVersionPermissionInput, ...func(*lambda.Options)) (*lambda.RemoveLayerVersionPermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.RemoveLayerVersionPermissionInput, ...func(*lambda.Options)) *lambda.RemoveLayerVersionPermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.RemoveLayerVersionPermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.RemoveLayerVersionPermissionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemovePermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemovePermission(ctx context.Context, params *lambda.RemovePermissionInput, optFns ...func(*lambda.Options)) (*lambda.RemovePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePermission")
	}

	var r0 *lambda.RemovePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.RemovePermissionInput, ...func(*lambda.Options)) (*lambda.RemovePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.RemovePermissionInput, ...func(*lambda.Options)) *lambda.RemovePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.RemovePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.RemovePermissionInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *lambda.TagResourceInput, optFns ...func(*lambda.Options)) (*lambda.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *lambda.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.TagResourceInput, ...func(*lambda.Options)) (*lambda.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.TagResourceInput, ...func(*lambda.Options)) *lambda.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.TagResourceInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *lambda.UntagResourceInput, optFns ...func(*lambda.Options)) (*lambda.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *lambda.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UntagResourceInput, ...func(*lambda.Options)) (*lambda.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UntagResourceInput, ...func(*lambda.Options)) *lambda.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UntagResourceInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAlias(ctx context.Context, params *lambda.UpdateAliasInput, optFns ...func(*lambda.Options)) (*lambda.UpdateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAlias")
	}

	var r0 *lambda.UpdateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateAliasInput, ...func(*lambda.Options)) (*lambda.UpdateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateAliasInput, ...func(*lambda.Options)) *lambda.UpdateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateAliasInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCodeSigningConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCodeSigningConfig(ctx context.Context, params *lambda.UpdateCodeSigningConfigInput, optFns ...func(*lambda.Options)) (*lambda.UpdateCodeSigningConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCodeSigningConfig")
	}

	var r0 *lambda.UpdateCodeSigningConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateCodeSigningConfigInput, ...func(*lambda.Options)) (*lambda.UpdateCodeSigningConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateCodeSigningConfigInput, ...func(*lambda.Options)) *lambda.UpdateCodeSigningConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateCodeSigningConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateCodeSigningConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventSourceMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventSourceMapping(ctx context.Context, params *lambda.UpdateEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.UpdateEventSourceMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventSourceMapping")
	}

	var r0 *lambda.UpdateEventSourceMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateEventSourceMappingInput, ...func(*lambda.Options)) (*lambda.UpdateEventSourceMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateEventSourceMappingInput, ...func(*lambda.Options)) *lambda.UpdateEventSourceMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateEventSourceMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateEventSourceMappingInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFunctionCode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFunctionCode(ctx context.Context, params *lambda.UpdateFunctionCodeInput, optFns ...func(*lambda.Options)) (*lambda.UpdateFunctionCodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFunctionCode")
	}

	var r0 *lambda.UpdateFunctionCodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionCodeInput, ...func(*lambda.Options)) (*lambda.UpdateFunctionCodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionCodeInput, ...func(*lambda.Options)) *lambda.UpdateFunctionCodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateFunctionCodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateFunctionCodeInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFunctionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFunctionConfiguration(ctx context.Context, params *lambda.UpdateFunctionConfigurationInput, optFns ...func(*lambda.Options)) (*lambda.UpdateFunctionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFunctionConfiguration")
	}

	var r0 *lambda.UpdateFunctionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionConfigurationInput, ...func(*lambda.Options)) (*lambda.UpdateFunctionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionConfigurationInput, ...func(*lambda.Options)) *lambda.UpdateFunctionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateFunctionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateFunctionConfigurationInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFunctionEventInvokeConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFunctionEventInvokeConfig(ctx context.Context, params *lambda.UpdateFunctionEventInvokeConfigInput, optFns ...func(*lambda.Options)) (*lambda.UpdateFunctionEventInvokeConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFunctionEventInvokeConfig")
	}

	var r0 *lambda.UpdateFunctionEventInvokeConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionEventInvokeConfigInput, ...func(*lambda.Options)) (*lambda.UpdateFunctionEventInvokeConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionEventInvokeConfigInput, ...func(*lambda.Options)) *lambda.UpdateFunctionEventInvokeConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateFunctionEventInvokeConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateFunctionEventInvokeConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFunctionUrlConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFunctionUrlConfig(ctx context.Context, params *lambda.UpdateFunctionUrlConfigInput, optFns ...func(*lambda.Options)) (*lambda.UpdateFunctionUrlConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFunctionUrlConfig")
	}

	var r0 *lambda.UpdateFunctionUrlConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionUrlConfigInput, ...func(*lambda.Options)) (*lambda.UpdateFunctionUrlConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lambda.UpdateFunctionUrlConfigInput, ...func(*lambda.Options)) *lambda.UpdateFunctionUrlConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lambda.UpdateFunctionUrlConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lambda.UpdateFunctionUrlConfigInput, ...func(*lambda.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
