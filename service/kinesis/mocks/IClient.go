// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	kinesis "github.com/aws/aws-sdk-go-v2/service/kinesis"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddTagsToStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTagsToStream(ctx context.Context, params *kinesis.AddTagsToStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.AddTagsToStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToStream")
	}

	var r0 *kinesis.AddTagsToStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) (*kinesis.AddTagsToStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) *kinesis.AddTagsToStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.AddTagsToStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.AddTagsToStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStream(ctx context.Context, params *kinesis.CreateStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStream")
	}

	var r0 *kinesis.CreateStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) *kinesis.CreateStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.CreateStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecreaseStreamRetentionPeriod provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DecreaseStreamRetentionPeriod(ctx context.Context, params *kinesis.DecreaseStreamRetentionPeriodInput, optFns ...func(*kinesis.Options)) (*kinesis.DecreaseStreamRetentionPeriodOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DecreaseStreamRetentionPeriod")
	}

	var r0 *kinesis.DecreaseStreamRetentionPeriodOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) *kinesis.DecreaseStreamRetentionPeriodOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DecreaseStreamRetentionPeriodOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *kinesis.DeleteResourcePolicyInput, optFns ...func(*kinesis.Options)) (*kinesis.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *kinesis.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteResourcePolicyInput, ...func(*kinesis.Options)) (*kinesis.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteResourcePolicyInput, ...func(*kinesis.Options)) *kinesis.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeleteResourcePolicyInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStream(ctx context.Context, params *kinesis.DeleteStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStream")
	}

	var r0 *kinesis.DeleteStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) *kinesis.DeleteStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeleteStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterStreamConsumer(ctx context.Context, params *kinesis.DeregisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DeregisterStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterStreamConsumer")
	}

	var r0 *kinesis.DeregisterStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.DeregisterStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.DeregisterStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeregisterStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLimits(ctx context.Context, params *kinesis.DescribeLimitsInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLimits")
	}

	var r0 *kinesis.DescribeLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) (*kinesis.DescribeLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) *kinesis.DescribeLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeLimitsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStream(ctx context.Context, params *kinesis.DescribeStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStream")
	}

	var r0 *kinesis.DescribeStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStreamConsumer(ctx context.Context, params *kinesis.DescribeStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStreamConsumer")
	}

	var r0 *kinesis.DescribeStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStreamSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStreamSummary(ctx context.Context, params *kinesis.DescribeStreamSummaryInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStreamSummary")
	}

	var r0 *kinesis.DescribeStreamSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamSummaryInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableEnhancedMonitoring provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableEnhancedMonitoring(ctx context.Context, params *kinesis.DisableEnhancedMonitoringInput, optFns ...func(*kinesis.Options)) (*kinesis.DisableEnhancedMonitoringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableEnhancedMonitoring")
	}

	var r0 *kinesis.DisableEnhancedMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) (*kinesis.DisableEnhancedMonitoringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) *kinesis.DisableEnhancedMonitoringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DisableEnhancedMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableEnhancedMonitoring provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableEnhancedMonitoring(ctx context.Context, params *kinesis.EnableEnhancedMonitoringInput, optFns ...func(*kinesis.Options)) (*kinesis.EnableEnhancedMonitoringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableEnhancedMonitoring")
	}

	var r0 *kinesis.EnableEnhancedMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) (*kinesis.EnableEnhancedMonitoringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) *kinesis.EnableEnhancedMonitoringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.EnableEnhancedMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecords(ctx context.Context, params *kinesis.GetRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecords")
	}

	var r0 *kinesis.GetRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) *kinesis.GetRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicy(ctx context.Context, params *kinesis.GetResourcePolicyInput, optFns ...func(*kinesis.Options)) (*kinesis.GetResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicy")
	}

	var r0 *kinesis.GetResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetResourcePolicyInput, ...func(*kinesis.Options)) (*kinesis.GetResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetResourcePolicyInput, ...func(*kinesis.Options)) *kinesis.GetResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetResourcePolicyInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShardIterator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetShardIterator(ctx context.Context, params *kinesis.GetShardIteratorInput, optFns ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetShardIterator")
	}

	var r0 *kinesis.GetShardIteratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) *kinesis.GetShardIteratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetShardIteratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseStreamRetentionPeriod provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) IncreaseStreamRetentionPeriod(ctx context.Context, params *kinesis.IncreaseStreamRetentionPeriodInput, optFns ...func(*kinesis.Options)) (*kinesis.IncreaseStreamRetentionPeriodOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IncreaseStreamRetentionPeriod")
	}

	var r0 *kinesis.IncreaseStreamRetentionPeriodOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) *kinesis.IncreaseStreamRetentionPeriodOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.IncreaseStreamRetentionPeriodOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListShards provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListShards(ctx context.Context, params *kinesis.ListShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListShards")
	}

	var r0 *kinesis.ListShardsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) *kinesis.ListShardsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListShardsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreamConsumers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreamConsumers(ctx context.Context, params *kinesis.ListStreamConsumersInput, optFns ...func(*kinesis.Options)) (*kinesis.ListStreamConsumersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreamConsumers")
	}

	var r0 *kinesis.ListStreamConsumersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) (*kinesis.ListStreamConsumersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) *kinesis.ListStreamConsumersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListStreamConsumersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListStreamConsumersInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreams provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreams(ctx context.Context, params *kinesis.ListStreamsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListStreamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreams")
	}

	var r0 *kinesis.ListStreamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) (*kinesis.ListStreamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) *kinesis.ListStreamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListStreamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListStreamsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForStream(ctx context.Context, params *kinesis.ListTagsForStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.ListTagsForStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForStream")
	}

	var r0 *kinesis.ListTagsForStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) (*kinesis.ListTagsForStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) *kinesis.ListTagsForStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListTagsForStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListTagsForStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeShards provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergeShards(ctx context.Context, params *kinesis.MergeShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.MergeShardsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeShards")
	}

	var r0 *kinesis.MergeShardsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) (*kinesis.MergeShardsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) *kinesis.MergeShardsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.MergeShardsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.MergeShardsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() kinesis.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 kinesis.Options
	if rf, ok := ret.Get(0).(func() kinesis.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kinesis.Options)
	}

	return r0
}

// PutRecord provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRecord(ctx context.Context, params *kinesis.PutRecordInput, optFns ...func(*kinesis.Options)) (*kinesis.PutRecordOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRecord")
	}

	var r0 *kinesis.PutRecordOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) (*kinesis.PutRecordOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) *kinesis.PutRecordOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutRecordOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutRecordInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRecords(ctx context.Context, params *kinesis.PutRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRecords")
	}

	var r0 *kinesis.PutRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) *kinesis.PutRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *kinesis.PutResourcePolicyInput, optFns ...func(*kinesis.Options)) (*kinesis.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *kinesis.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutResourcePolicyInput, ...func(*kinesis.Options)) (*kinesis.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutResourcePolicyInput, ...func(*kinesis.Options)) *kinesis.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutResourcePolicyInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterStreamConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterStreamConsumer(ctx context.Context, params *kinesis.RegisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.RegisterStreamConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterStreamConsumer")
	}

	var r0 *kinesis.RegisterStreamConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) (*kinesis.RegisterStreamConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) *kinesis.RegisterStreamConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.RegisterStreamConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.RegisterStreamConsumerInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTagsFromStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTagsFromStream(ctx context.Context, params *kinesis.RemoveTagsFromStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.RemoveTagsFromStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTagsFromStream")
	}

	var r0 *kinesis.RemoveTagsFromStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) (*kinesis.RemoveTagsFromStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) *kinesis.RemoveTagsFromStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.RemoveTagsFromStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SplitShard provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SplitShard(ctx context.Context, params *kinesis.SplitShardInput, optFns ...func(*kinesis.Options)) (*kinesis.SplitShardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SplitShard")
	}

	var r0 *kinesis.SplitShardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) (*kinesis.SplitShardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) *kinesis.SplitShardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.SplitShardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.SplitShardInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartStreamEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartStreamEncryption(ctx context.Context, params *kinesis.StartStreamEncryptionInput, optFns ...func(*kinesis.Options)) (*kinesis.StartStreamEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartStreamEncryption")
	}

	var r0 *kinesis.StartStreamEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) (*kinesis.StartStreamEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) *kinesis.StartStreamEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.StartStreamEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.StartStreamEncryptionInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopStreamEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopStreamEncryption(ctx context.Context, params *kinesis.StopStreamEncryptionInput, optFns ...func(*kinesis.Options)) (*kinesis.StopStreamEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopStreamEncryption")
	}

	var r0 *kinesis.StopStreamEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) (*kinesis.StopStreamEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) *kinesis.StopStreamEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.StopStreamEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.StopStreamEncryptionInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeToShard provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SubscribeToShard(ctx context.Context, params *kinesis.SubscribeToShardInput, optFns ...func(*kinesis.Options)) (*kinesis.SubscribeToShardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToShard")
	}

	var r0 *kinesis.SubscribeToShardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) (*kinesis.SubscribeToShardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) *kinesis.SubscribeToShardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.SubscribeToShardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.SubscribeToShardInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateShardCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateShardCount(ctx context.Context, params *kinesis.UpdateShardCountInput, optFns ...func(*kinesis.Options)) (*kinesis.UpdateShardCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateShardCount")
	}

	var r0 *kinesis.UpdateShardCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) (*kinesis.UpdateShardCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) *kinesis.UpdateShardCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.UpdateShardCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.UpdateShardCountInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStreamMode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStreamMode(ctx context.Context, params *kinesis.UpdateStreamModeInput, optFns ...func(*kinesis.Options)) (*kinesis.UpdateStreamModeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStreamMode")
	}

	var r0 *kinesis.UpdateStreamModeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) (*kinesis.UpdateStreamModeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) *kinesis.UpdateStreamModeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.UpdateStreamModeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.UpdateStreamModeInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
