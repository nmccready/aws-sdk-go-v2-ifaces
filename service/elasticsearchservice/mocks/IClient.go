// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	elasticsearchservice "github.com/aws/aws-sdk-go-v2/service/elasticsearchservice"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptInboundCrossClusterSearchConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptInboundCrossClusterSearchConnection(ctx context.Context, params *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AcceptInboundCrossClusterSearchConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptInboundCrossClusterSearchConnection")
	}

	var r0 *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AcceptInboundCrossClusterSearchConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.AcceptInboundCrossClusterSearchConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.AcceptInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *elasticsearchservice.AddTagsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *elasticsearchservice.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AddTagsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AddTagsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.AddTagsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociatePackage(ctx context.Context, params *elasticsearchservice.AssociatePackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AssociatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociatePackage")
	}

	var r0 *elasticsearchservice.AssociatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AssociatePackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AssociatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AssociatePackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.AssociatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.AssociatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.AssociatePackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeVpcEndpointAccess(ctx context.Context, params *elasticsearchservice.AuthorizeVpcEndpointAccessInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AuthorizeVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeVpcEndpointAccess")
	}

	var r0 *elasticsearchservice.AuthorizeVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AuthorizeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.AuthorizeVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.AuthorizeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.AuthorizeVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.AuthorizeVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.AuthorizeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDomainConfigChange provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDomainConfigChange(ctx context.Context, params *elasticsearchservice.CancelDomainConfigChangeInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CancelDomainConfigChangeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDomainConfigChange")
	}

	var r0 *elasticsearchservice.CancelDomainConfigChangeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CancelDomainConfigChangeInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CancelDomainConfigChangeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CancelDomainConfigChangeInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CancelDomainConfigChangeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CancelDomainConfigChangeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CancelDomainConfigChangeInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelElasticsearchServiceSoftwareUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelElasticsearchServiceSoftwareUpdate(ctx context.Context, params *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelElasticsearchServiceSoftwareUpdate")
	}

	var r0 *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CancelElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateElasticsearchDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateElasticsearchDomain(ctx context.Context, params *elasticsearchservice.CreateElasticsearchDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateElasticsearchDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateElasticsearchDomain")
	}

	var r0 *elasticsearchservice.CreateElasticsearchDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateElasticsearchDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CreateElasticsearchDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CreateElasticsearchDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CreateElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOutboundCrossClusterSearchConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateOutboundCrossClusterSearchConnection(ctx context.Context, params *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateOutboundCrossClusterSearchConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateOutboundCrossClusterSearchConnection")
	}

	var r0 *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateOutboundCrossClusterSearchConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CreateOutboundCrossClusterSearchConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CreateOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePackage(ctx context.Context, params *elasticsearchservice.CreatePackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackage")
	}

	var r0 *elasticsearchservice.CreatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreatePackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreatePackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CreatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CreatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CreatePackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpoint(ctx context.Context, params *elasticsearchservice.CreateVpcEndpointInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpoint")
	}

	var r0 *elasticsearchservice.CreateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateVpcEndpointInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.CreateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.CreateVpcEndpointInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.CreateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.CreateVpcEndpointInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteElasticsearchDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteElasticsearchDomain(ctx context.Context, params *elasticsearchservice.DeleteElasticsearchDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteElasticsearchDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteElasticsearchDomain")
	}

	var r0 *elasticsearchservice.DeleteElasticsearchDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteElasticsearchDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeleteElasticsearchDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeleteElasticsearchDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeleteElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteElasticsearchServiceRole provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteElasticsearchServiceRole(ctx context.Context, params *elasticsearchservice.DeleteElasticsearchServiceRoleInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteElasticsearchServiceRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteElasticsearchServiceRole")
	}

	var r0 *elasticsearchservice.DeleteElasticsearchServiceRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteElasticsearchServiceRoleInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteElasticsearchServiceRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteElasticsearchServiceRoleInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeleteElasticsearchServiceRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeleteElasticsearchServiceRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeleteElasticsearchServiceRoleInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInboundCrossClusterSearchConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInboundCrossClusterSearchConnection(ctx context.Context, params *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteInboundCrossClusterSearchConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInboundCrossClusterSearchConnection")
	}

	var r0 *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteInboundCrossClusterSearchConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeleteInboundCrossClusterSearchConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeleteInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundCrossClusterSearchConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteOutboundCrossClusterSearchConnection(ctx context.Context, params *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundCrossClusterSearchConnection")
	}

	var r0 *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeleteOutboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePackage(ctx context.Context, params *elasticsearchservice.DeletePackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeletePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 *elasticsearchservice.DeletePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeletePackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeletePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeletePackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeletePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeletePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeletePackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpoint(ctx context.Context, params *elasticsearchservice.DeleteVpcEndpointInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpoint")
	}

	var r0 *elasticsearchservice.DeleteVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteVpcEndpointInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DeleteVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DeleteVpcEndpointInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DeleteVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DeleteVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DeleteVpcEndpointInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainAutoTunes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainAutoTunes(ctx context.Context, params *elasticsearchservice.DescribeDomainAutoTunesInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeDomainAutoTunesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainAutoTunes")
	}

	var r0 *elasticsearchservice.DescribeDomainAutoTunesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeDomainAutoTunesInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeDomainAutoTunesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeDomainAutoTunesInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeDomainAutoTunesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeDomainAutoTunesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeDomainAutoTunesInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainChangeProgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainChangeProgress(ctx context.Context, params *elasticsearchservice.DescribeDomainChangeProgressInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeDomainChangeProgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainChangeProgress")
	}

	var r0 *elasticsearchservice.DescribeDomainChangeProgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeDomainChangeProgressInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeDomainChangeProgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeDomainChangeProgressInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeDomainChangeProgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeDomainChangeProgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeDomainChangeProgressInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticsearchDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeElasticsearchDomain(ctx context.Context, params *elasticsearchservice.DescribeElasticsearchDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticsearchDomain")
	}

	var r0 *elasticsearchservice.DescribeElasticsearchDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeElasticsearchDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeElasticsearchDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticsearchDomainConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeElasticsearchDomainConfig(ctx context.Context, params *elasticsearchservice.DescribeElasticsearchDomainConfigInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticsearchDomainConfig")
	}

	var r0 *elasticsearchservice.DescribeElasticsearchDomainConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeElasticsearchDomainConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeElasticsearchDomainConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticsearchDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeElasticsearchDomains(ctx context.Context, params *elasticsearchservice.DescribeElasticsearchDomainsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticsearchDomains")
	}

	var r0 *elasticsearchservice.DescribeElasticsearchDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeElasticsearchDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeElasticsearchDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeElasticsearchDomainsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticsearchInstanceTypeLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeElasticsearchInstanceTypeLimits(ctx context.Context, params *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticsearchInstanceTypeLimits")
	}

	var r0 *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeElasticsearchInstanceTypeLimitsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInboundCrossClusterSearchConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInboundCrossClusterSearchConnections(ctx context.Context, params *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInboundCrossClusterSearchConnections")
	}

	var r0 *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeInboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutboundCrossClusterSearchConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeOutboundCrossClusterSearchConnections(ctx context.Context, params *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOutboundCrossClusterSearchConnections")
	}

	var r0 *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeOutboundCrossClusterSearchConnectionsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePackages(ctx context.Context, params *elasticsearchservice.DescribePackagesInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribePackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePackages")
	}

	var r0 *elasticsearchservice.DescribePackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribePackagesInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribePackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribePackagesInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribePackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribePackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribePackagesInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedElasticsearchInstanceOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedElasticsearchInstanceOfferings(ctx context.Context, params *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedElasticsearchInstanceOfferings")
	}

	var r0 *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstanceOfferingsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedElasticsearchInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedElasticsearchInstances(ctx context.Context, params *elasticsearchservice.DescribeReservedElasticsearchInstancesInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeReservedElasticsearchInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedElasticsearchInstances")
	}

	var r0 *elasticsearchservice.DescribeReservedElasticsearchInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstancesInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeReservedElasticsearchInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstancesInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeReservedElasticsearchInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeReservedElasticsearchInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeReservedElasticsearchInstancesInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpoints(ctx context.Context, params *elasticsearchservice.DescribeVpcEndpointsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpoints")
	}

	var r0 *elasticsearchservice.DescribeVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeVpcEndpointsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DescribeVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DescribeVpcEndpointsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DescribeVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DescribeVpcEndpointsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DissociatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DissociatePackage(ctx context.Context, params *elasticsearchservice.DissociatePackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DissociatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DissociatePackage")
	}

	var r0 *elasticsearchservice.DissociatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DissociatePackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.DissociatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.DissociatePackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.DissociatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.DissociatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.DissociatePackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompatibleElasticsearchVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCompatibleElasticsearchVersions(ctx context.Context, params *elasticsearchservice.GetCompatibleElasticsearchVersionsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetCompatibleElasticsearchVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCompatibleElasticsearchVersions")
	}

	var r0 *elasticsearchservice.GetCompatibleElasticsearchVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetCompatibleElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetCompatibleElasticsearchVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetCompatibleElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.GetCompatibleElasticsearchVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.GetCompatibleElasticsearchVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.GetCompatibleElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPackageVersionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPackageVersionHistory(ctx context.Context, params *elasticsearchservice.GetPackageVersionHistoryInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetPackageVersionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageVersionHistory")
	}

	var r0 *elasticsearchservice.GetPackageVersionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetPackageVersionHistoryInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetPackageVersionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetPackageVersionHistoryInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.GetPackageVersionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.GetPackageVersionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.GetPackageVersionHistoryInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpgradeHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUpgradeHistory(ctx context.Context, params *elasticsearchservice.GetUpgradeHistoryInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetUpgradeHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUpgradeHistory")
	}

	var r0 *elasticsearchservice.GetUpgradeHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetUpgradeHistoryInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetUpgradeHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetUpgradeHistoryInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.GetUpgradeHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.GetUpgradeHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.GetUpgradeHistoryInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpgradeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUpgradeStatus(ctx context.Context, params *elasticsearchservice.GetUpgradeStatusInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetUpgradeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUpgradeStatus")
	}

	var r0 *elasticsearchservice.GetUpgradeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetUpgradeStatusInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.GetUpgradeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.GetUpgradeStatusInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.GetUpgradeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.GetUpgradeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.GetUpgradeStatusInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomainNames provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomainNames(ctx context.Context, params *elasticsearchservice.ListDomainNamesInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListDomainNamesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomainNames")
	}

	var r0 *elasticsearchservice.ListDomainNamesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListDomainNamesInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListDomainNamesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListDomainNamesInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListDomainNamesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListDomainNamesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListDomainNamesInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomainsForPackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomainsForPackage(ctx context.Context, params *elasticsearchservice.ListDomainsForPackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListDomainsForPackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomainsForPackage")
	}

	var r0 *elasticsearchservice.ListDomainsForPackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListDomainsForPackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListDomainsForPackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListDomainsForPackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListDomainsForPackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListDomainsForPackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListDomainsForPackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListElasticsearchInstanceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListElasticsearchInstanceTypes(ctx context.Context, params *elasticsearchservice.ListElasticsearchInstanceTypesInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListElasticsearchInstanceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListElasticsearchInstanceTypes")
	}

	var r0 *elasticsearchservice.ListElasticsearchInstanceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListElasticsearchInstanceTypesInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListElasticsearchInstanceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListElasticsearchInstanceTypesInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListElasticsearchInstanceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListElasticsearchInstanceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListElasticsearchInstanceTypesInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListElasticsearchVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListElasticsearchVersions(ctx context.Context, params *elasticsearchservice.ListElasticsearchVersionsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListElasticsearchVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListElasticsearchVersions")
	}

	var r0 *elasticsearchservice.ListElasticsearchVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListElasticsearchVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListElasticsearchVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListElasticsearchVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListElasticsearchVersionsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackagesForDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackagesForDomain(ctx context.Context, params *elasticsearchservice.ListPackagesForDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListPackagesForDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackagesForDomain")
	}

	var r0 *elasticsearchservice.ListPackagesForDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListPackagesForDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListPackagesForDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListPackagesForDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListPackagesForDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListPackagesForDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListPackagesForDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *elasticsearchservice.ListTagsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *elasticsearchservice.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListTagsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListTagsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListTagsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpointAccess(ctx context.Context, params *elasticsearchservice.ListVpcEndpointAccessInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpointAccess")
	}

	var r0 *elasticsearchservice.ListVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpoints(ctx context.Context, params *elasticsearchservice.ListVpcEndpointsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpoints")
	}

	var r0 *elasticsearchservice.ListVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListVpcEndpointsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpointsForDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpointsForDomain(ctx context.Context, params *elasticsearchservice.ListVpcEndpointsForDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointsForDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpointsForDomain")
	}

	var r0 *elasticsearchservice.ListVpcEndpointsForDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointsForDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.ListVpcEndpointsForDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.ListVpcEndpointsForDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.ListVpcEndpointsForDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.ListVpcEndpointsForDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.ListVpcEndpointsForDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() elasticsearchservice.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 elasticsearchservice.Options
	if rf, ok := ret.Get(0).(func() elasticsearchservice.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(elasticsearchservice.Options)
	}

	return r0
}

// PurchaseReservedElasticsearchInstanceOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedElasticsearchInstanceOffering(ctx context.Context, params *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedElasticsearchInstanceOffering")
	}

	var r0 *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.PurchaseReservedElasticsearchInstanceOfferingInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectInboundCrossClusterSearchConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectInboundCrossClusterSearchConnection(ctx context.Context, params *elasticsearchservice.RejectInboundCrossClusterSearchConnectionInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RejectInboundCrossClusterSearchConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectInboundCrossClusterSearchConnection")
	}

	var r0 *elasticsearchservice.RejectInboundCrossClusterSearchConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RejectInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RejectInboundCrossClusterSearchConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RejectInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.RejectInboundCrossClusterSearchConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.RejectInboundCrossClusterSearchConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.RejectInboundCrossClusterSearchConnectionInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *elasticsearchservice.RemoveTagsInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *elasticsearchservice.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RemoveTagsInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RemoveTagsInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.RemoveTagsInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeVpcEndpointAccess(ctx context.Context, params *elasticsearchservice.RevokeVpcEndpointAccessInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RevokeVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeVpcEndpointAccess")
	}

	var r0 *elasticsearchservice.RevokeVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RevokeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.RevokeVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.RevokeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.RevokeVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.RevokeVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.RevokeVpcEndpointAccessInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartElasticsearchServiceSoftwareUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartElasticsearchServiceSoftwareUpdate(ctx context.Context, params *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.StartElasticsearchServiceSoftwareUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartElasticsearchServiceSoftwareUpdate")
	}

	var r0 *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.StartElasticsearchServiceSoftwareUpdateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.StartElasticsearchServiceSoftwareUpdateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.StartElasticsearchServiceSoftwareUpdateInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateElasticsearchDomainConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateElasticsearchDomainConfig(ctx context.Context, params *elasticsearchservice.UpdateElasticsearchDomainConfigInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdateElasticsearchDomainConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateElasticsearchDomainConfig")
	}

	var r0 *elasticsearchservice.UpdateElasticsearchDomainConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdateElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdateElasticsearchDomainConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdateElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.UpdateElasticsearchDomainConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.UpdateElasticsearchDomainConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.UpdateElasticsearchDomainConfigInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackage(ctx context.Context, params *elasticsearchservice.UpdatePackageInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackage")
	}

	var r0 *elasticsearchservice.UpdatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdatePackageInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdatePackageInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.UpdatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.UpdatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.UpdatePackageInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVpcEndpoint(ctx context.Context, params *elasticsearchservice.UpdateVpcEndpointInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVpcEndpoint")
	}

	var r0 *elasticsearchservice.UpdateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdateVpcEndpointInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpdateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpdateVpcEndpointInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.UpdateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.UpdateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.UpdateVpcEndpointInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpgradeElasticsearchDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpgradeElasticsearchDomain(ctx context.Context, params *elasticsearchservice.UpgradeElasticsearchDomainInput, optFns ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpgradeElasticsearchDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpgradeElasticsearchDomain")
	}

	var r0 *elasticsearchservice.UpgradeElasticsearchDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpgradeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) (*elasticsearchservice.UpgradeElasticsearchDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticsearchservice.UpgradeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) *elasticsearchservice.UpgradeElasticsearchDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticsearchservice.UpgradeElasticsearchDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticsearchservice.UpgradeElasticsearchDomainInput, ...func(*elasticsearchservice.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
