// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	comprehend "github.com/aws/aws-sdk-go-v2/service/comprehend"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchDetectDominantLanguage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectDominantLanguage(ctx context.Context, params *comprehend.BatchDetectDominantLanguageInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectDominantLanguageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectDominantLanguage")
	}

	var r0 *comprehend.BatchDetectDominantLanguageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectDominantLanguageInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectDominantLanguageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectDominantLanguageInput, ...func(*comprehend.Options)) *comprehend.BatchDetectDominantLanguageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectDominantLanguageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectDominantLanguageInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDetectEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectEntities(ctx context.Context, params *comprehend.BatchDetectEntitiesInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectEntities")
	}

	var r0 *comprehend.BatchDetectEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectEntitiesInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectEntitiesInput, ...func(*comprehend.Options)) *comprehend.BatchDetectEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectEntitiesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDetectKeyPhrases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectKeyPhrases(ctx context.Context, params *comprehend.BatchDetectKeyPhrasesInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectKeyPhrasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectKeyPhrases")
	}

	var r0 *comprehend.BatchDetectKeyPhrasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectKeyPhrasesInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectKeyPhrasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectKeyPhrasesInput, ...func(*comprehend.Options)) *comprehend.BatchDetectKeyPhrasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectKeyPhrasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectKeyPhrasesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDetectSentiment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectSentiment(ctx context.Context, params *comprehend.BatchDetectSentimentInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectSentimentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectSentiment")
	}

	var r0 *comprehend.BatchDetectSentimentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectSentimentInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectSentimentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectSentimentInput, ...func(*comprehend.Options)) *comprehend.BatchDetectSentimentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectSentimentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectSentimentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDetectSyntax provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectSyntax(ctx context.Context, params *comprehend.BatchDetectSyntaxInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectSyntaxOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectSyntax")
	}

	var r0 *comprehend.BatchDetectSyntaxOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectSyntaxInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectSyntaxOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectSyntaxInput, ...func(*comprehend.Options)) *comprehend.BatchDetectSyntaxOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectSyntaxOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectSyntaxInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDetectTargetedSentiment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDetectTargetedSentiment(ctx context.Context, params *comprehend.BatchDetectTargetedSentimentInput, optFns ...func(*comprehend.Options)) (*comprehend.BatchDetectTargetedSentimentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDetectTargetedSentiment")
	}

	var r0 *comprehend.BatchDetectTargetedSentimentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectTargetedSentimentInput, ...func(*comprehend.Options)) (*comprehend.BatchDetectTargetedSentimentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.BatchDetectTargetedSentimentInput, ...func(*comprehend.Options)) *comprehend.BatchDetectTargetedSentimentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.BatchDetectTargetedSentimentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.BatchDetectTargetedSentimentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClassifyDocument provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ClassifyDocument(ctx context.Context, params *comprehend.ClassifyDocumentInput, optFns ...func(*comprehend.Options)) (*comprehend.ClassifyDocumentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClassifyDocument")
	}

	var r0 *comprehend.ClassifyDocumentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ClassifyDocumentInput, ...func(*comprehend.Options)) (*comprehend.ClassifyDocumentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ClassifyDocumentInput, ...func(*comprehend.Options)) *comprehend.ClassifyDocumentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ClassifyDocumentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ClassifyDocumentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContainsPiiEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ContainsPiiEntities(ctx context.Context, params *comprehend.ContainsPiiEntitiesInput, optFns ...func(*comprehend.Options)) (*comprehend.ContainsPiiEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ContainsPiiEntities")
	}

	var r0 *comprehend.ContainsPiiEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ContainsPiiEntitiesInput, ...func(*comprehend.Options)) (*comprehend.ContainsPiiEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ContainsPiiEntitiesInput, ...func(*comprehend.Options)) *comprehend.ContainsPiiEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ContainsPiiEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ContainsPiiEntitiesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataset(ctx context.Context, params *comprehend.CreateDatasetInput, optFns ...func(*comprehend.Options)) (*comprehend.CreateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataset")
	}

	var r0 *comprehend.CreateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateDatasetInput, ...func(*comprehend.Options)) (*comprehend.CreateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateDatasetInput, ...func(*comprehend.Options)) *comprehend.CreateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.CreateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.CreateDatasetInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDocumentClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDocumentClassifier(ctx context.Context, params *comprehend.CreateDocumentClassifierInput, optFns ...func(*comprehend.Options)) (*comprehend.CreateDocumentClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDocumentClassifier")
	}

	var r0 *comprehend.CreateDocumentClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateDocumentClassifierInput, ...func(*comprehend.Options)) (*comprehend.CreateDocumentClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateDocumentClassifierInput, ...func(*comprehend.Options)) *comprehend.CreateDocumentClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.CreateDocumentClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.CreateDocumentClassifierInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEndpoint(ctx context.Context, params *comprehend.CreateEndpointInput, optFns ...func(*comprehend.Options)) (*comprehend.CreateEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEndpoint")
	}

	var r0 *comprehend.CreateEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateEndpointInput, ...func(*comprehend.Options)) (*comprehend.CreateEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateEndpointInput, ...func(*comprehend.Options)) *comprehend.CreateEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.CreateEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.CreateEndpointInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEntityRecognizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEntityRecognizer(ctx context.Context, params *comprehend.CreateEntityRecognizerInput, optFns ...func(*comprehend.Options)) (*comprehend.CreateEntityRecognizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEntityRecognizer")
	}

	var r0 *comprehend.CreateEntityRecognizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateEntityRecognizerInput, ...func(*comprehend.Options)) (*comprehend.CreateEntityRecognizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateEntityRecognizerInput, ...func(*comprehend.Options)) *comprehend.CreateEntityRecognizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.CreateEntityRecognizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.CreateEntityRecognizerInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlywheel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFlywheel(ctx context.Context, params *comprehend.CreateFlywheelInput, optFns ...func(*comprehend.Options)) (*comprehend.CreateFlywheelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlywheel")
	}

	var r0 *comprehend.CreateFlywheelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateFlywheelInput, ...func(*comprehend.Options)) (*comprehend.CreateFlywheelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.CreateFlywheelInput, ...func(*comprehend.Options)) *comprehend.CreateFlywheelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.CreateFlywheelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.CreateFlywheelInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDocumentClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDocumentClassifier(ctx context.Context, params *comprehend.DeleteDocumentClassifierInput, optFns ...func(*comprehend.Options)) (*comprehend.DeleteDocumentClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDocumentClassifier")
	}

	var r0 *comprehend.DeleteDocumentClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteDocumentClassifierInput, ...func(*comprehend.Options)) (*comprehend.DeleteDocumentClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteDocumentClassifierInput, ...func(*comprehend.Options)) *comprehend.DeleteDocumentClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DeleteDocumentClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DeleteDocumentClassifierInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEndpoint(ctx context.Context, params *comprehend.DeleteEndpointInput, optFns ...func(*comprehend.Options)) (*comprehend.DeleteEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEndpoint")
	}

	var r0 *comprehend.DeleteEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteEndpointInput, ...func(*comprehend.Options)) (*comprehend.DeleteEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteEndpointInput, ...func(*comprehend.Options)) *comprehend.DeleteEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DeleteEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DeleteEndpointInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEntityRecognizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEntityRecognizer(ctx context.Context, params *comprehend.DeleteEntityRecognizerInput, optFns ...func(*comprehend.Options)) (*comprehend.DeleteEntityRecognizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEntityRecognizer")
	}

	var r0 *comprehend.DeleteEntityRecognizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteEntityRecognizerInput, ...func(*comprehend.Options)) (*comprehend.DeleteEntityRecognizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteEntityRecognizerInput, ...func(*comprehend.Options)) *comprehend.DeleteEntityRecognizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DeleteEntityRecognizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DeleteEntityRecognizerInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlywheel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFlywheel(ctx context.Context, params *comprehend.DeleteFlywheelInput, optFns ...func(*comprehend.Options)) (*comprehend.DeleteFlywheelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlywheel")
	}

	var r0 *comprehend.DeleteFlywheelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteFlywheelInput, ...func(*comprehend.Options)) (*comprehend.DeleteFlywheelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteFlywheelInput, ...func(*comprehend.Options)) *comprehend.DeleteFlywheelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DeleteFlywheelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DeleteFlywheelInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *comprehend.DeleteResourcePolicyInput, optFns ...func(*comprehend.Options)) (*comprehend.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *comprehend.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteResourcePolicyInput, ...func(*comprehend.Options)) (*comprehend.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DeleteResourcePolicyInput, ...func(*comprehend.Options)) *comprehend.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DeleteResourcePolicyInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataset(ctx context.Context, params *comprehend.DescribeDatasetInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataset")
	}

	var r0 *comprehend.DescribeDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDatasetInput, ...func(*comprehend.Options)) (*comprehend.DescribeDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDatasetInput, ...func(*comprehend.Options)) *comprehend.DescribeDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeDatasetInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDocumentClassificationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDocumentClassificationJob(ctx context.Context, params *comprehend.DescribeDocumentClassificationJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeDocumentClassificationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDocumentClassificationJob")
	}

	var r0 *comprehend.DescribeDocumentClassificationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDocumentClassificationJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeDocumentClassificationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDocumentClassificationJobInput, ...func(*comprehend.Options)) *comprehend.DescribeDocumentClassificationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeDocumentClassificationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeDocumentClassificationJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDocumentClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDocumentClassifier(ctx context.Context, params *comprehend.DescribeDocumentClassifierInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeDocumentClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDocumentClassifier")
	}

	var r0 *comprehend.DescribeDocumentClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDocumentClassifierInput, ...func(*comprehend.Options)) (*comprehend.DescribeDocumentClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDocumentClassifierInput, ...func(*comprehend.Options)) *comprehend.DescribeDocumentClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeDocumentClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeDocumentClassifierInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDominantLanguageDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDominantLanguageDetectionJob(ctx context.Context, params *comprehend.DescribeDominantLanguageDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeDominantLanguageDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDominantLanguageDetectionJob")
	}

	var r0 *comprehend.DescribeDominantLanguageDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeDominantLanguageDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeDominantLanguageDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeDominantLanguageDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEndpoint(ctx context.Context, params *comprehend.DescribeEndpointInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEndpoint")
	}

	var r0 *comprehend.DescribeEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEndpointInput, ...func(*comprehend.Options)) (*comprehend.DescribeEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEndpointInput, ...func(*comprehend.Options)) *comprehend.DescribeEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeEndpointInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEntitiesDetectionJob(ctx context.Context, params *comprehend.DescribeEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEntitiesDetectionJob")
	}

	var r0 *comprehend.DescribeEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEntityRecognizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEntityRecognizer(ctx context.Context, params *comprehend.DescribeEntityRecognizerInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeEntityRecognizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEntityRecognizer")
	}

	var r0 *comprehend.DescribeEntityRecognizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEntityRecognizerInput, ...func(*comprehend.Options)) (*comprehend.DescribeEntityRecognizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEntityRecognizerInput, ...func(*comprehend.Options)) *comprehend.DescribeEntityRecognizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeEntityRecognizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeEntityRecognizerInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEventsDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEventsDetectionJob(ctx context.Context, params *comprehend.DescribeEventsDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeEventsDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEventsDetectionJob")
	}

	var r0 *comprehend.DescribeEventsDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEventsDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeEventsDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeEventsDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeEventsDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeEventsDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeEventsDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlywheel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFlywheel(ctx context.Context, params *comprehend.DescribeFlywheelInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeFlywheelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFlywheel")
	}

	var r0 *comprehend.DescribeFlywheelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeFlywheelInput, ...func(*comprehend.Options)) (*comprehend.DescribeFlywheelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeFlywheelInput, ...func(*comprehend.Options)) *comprehend.DescribeFlywheelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeFlywheelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeFlywheelInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlywheelIteration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFlywheelIteration(ctx context.Context, params *comprehend.DescribeFlywheelIterationInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeFlywheelIterationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFlywheelIteration")
	}

	var r0 *comprehend.DescribeFlywheelIterationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeFlywheelIterationInput, ...func(*comprehend.Options)) (*comprehend.DescribeFlywheelIterationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeFlywheelIterationInput, ...func(*comprehend.Options)) *comprehend.DescribeFlywheelIterationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeFlywheelIterationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeFlywheelIterationInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKeyPhrasesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeKeyPhrasesDetectionJob(ctx context.Context, params *comprehend.DescribeKeyPhrasesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeKeyPhrasesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeKeyPhrasesDetectionJob")
	}

	var r0 *comprehend.DescribeKeyPhrasesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeKeyPhrasesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeKeyPhrasesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeKeyPhrasesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePiiEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePiiEntitiesDetectionJob(ctx context.Context, params *comprehend.DescribePiiEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribePiiEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePiiEntitiesDetectionJob")
	}

	var r0 *comprehend.DescribePiiEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribePiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribePiiEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribePiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribePiiEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribePiiEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribePiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResourcePolicy(ctx context.Context, params *comprehend.DescribeResourcePolicyInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourcePolicy")
	}

	var r0 *comprehend.DescribeResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeResourcePolicyInput, ...func(*comprehend.Options)) (*comprehend.DescribeResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeResourcePolicyInput, ...func(*comprehend.Options)) *comprehend.DescribeResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeResourcePolicyInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSentimentDetectionJob(ctx context.Context, params *comprehend.DescribeSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSentimentDetectionJob")
	}

	var r0 *comprehend.DescribeSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetedSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTargetedSentimentDetectionJob(ctx context.Context, params *comprehend.DescribeTargetedSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeTargetedSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTargetedSentimentDetectionJob")
	}

	var r0 *comprehend.DescribeTargetedSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeTargetedSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeTargetedSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeTargetedSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTopicsDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTopicsDetectionJob(ctx context.Context, params *comprehend.DescribeTopicsDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.DescribeTopicsDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTopicsDetectionJob")
	}

	var r0 *comprehend.DescribeTopicsDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeTopicsDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.DescribeTopicsDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DescribeTopicsDetectionJobInput, ...func(*comprehend.Options)) *comprehend.DescribeTopicsDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DescribeTopicsDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DescribeTopicsDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectDominantLanguage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectDominantLanguage(ctx context.Context, params *comprehend.DetectDominantLanguageInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectDominantLanguageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectDominantLanguage")
	}

	var r0 *comprehend.DetectDominantLanguageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectDominantLanguageInput, ...func(*comprehend.Options)) (*comprehend.DetectDominantLanguageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectDominantLanguageInput, ...func(*comprehend.Options)) *comprehend.DetectDominantLanguageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectDominantLanguageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectDominantLanguageInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectEntities(ctx context.Context, params *comprehend.DetectEntitiesInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectEntities")
	}

	var r0 *comprehend.DetectEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectEntitiesInput, ...func(*comprehend.Options)) (*comprehend.DetectEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectEntitiesInput, ...func(*comprehend.Options)) *comprehend.DetectEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectEntitiesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectKeyPhrases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectKeyPhrases(ctx context.Context, params *comprehend.DetectKeyPhrasesInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectKeyPhrasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectKeyPhrases")
	}

	var r0 *comprehend.DetectKeyPhrasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectKeyPhrasesInput, ...func(*comprehend.Options)) (*comprehend.DetectKeyPhrasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectKeyPhrasesInput, ...func(*comprehend.Options)) *comprehend.DetectKeyPhrasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectKeyPhrasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectKeyPhrasesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectPiiEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectPiiEntities(ctx context.Context, params *comprehend.DetectPiiEntitiesInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectPiiEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectPiiEntities")
	}

	var r0 *comprehend.DetectPiiEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectPiiEntitiesInput, ...func(*comprehend.Options)) (*comprehend.DetectPiiEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectPiiEntitiesInput, ...func(*comprehend.Options)) *comprehend.DetectPiiEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectPiiEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectPiiEntitiesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectSentiment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectSentiment(ctx context.Context, params *comprehend.DetectSentimentInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectSentimentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectSentiment")
	}

	var r0 *comprehend.DetectSentimentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectSentimentInput, ...func(*comprehend.Options)) (*comprehend.DetectSentimentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectSentimentInput, ...func(*comprehend.Options)) *comprehend.DetectSentimentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectSentimentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectSentimentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectSyntax provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectSyntax(ctx context.Context, params *comprehend.DetectSyntaxInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectSyntaxOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectSyntax")
	}

	var r0 *comprehend.DetectSyntaxOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectSyntaxInput, ...func(*comprehend.Options)) (*comprehend.DetectSyntaxOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectSyntaxInput, ...func(*comprehend.Options)) *comprehend.DetectSyntaxOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectSyntaxOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectSyntaxInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectTargetedSentiment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectTargetedSentiment(ctx context.Context, params *comprehend.DetectTargetedSentimentInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectTargetedSentimentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectTargetedSentiment")
	}

	var r0 *comprehend.DetectTargetedSentimentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectTargetedSentimentInput, ...func(*comprehend.Options)) (*comprehend.DetectTargetedSentimentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectTargetedSentimentInput, ...func(*comprehend.Options)) *comprehend.DetectTargetedSentimentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectTargetedSentimentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectTargetedSentimentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectToxicContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectToxicContent(ctx context.Context, params *comprehend.DetectToxicContentInput, optFns ...func(*comprehend.Options)) (*comprehend.DetectToxicContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectToxicContent")
	}

	var r0 *comprehend.DetectToxicContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectToxicContentInput, ...func(*comprehend.Options)) (*comprehend.DetectToxicContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.DetectToxicContentInput, ...func(*comprehend.Options)) *comprehend.DetectToxicContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.DetectToxicContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.DetectToxicContentInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportModel(ctx context.Context, params *comprehend.ImportModelInput, optFns ...func(*comprehend.Options)) (*comprehend.ImportModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportModel")
	}

	var r0 *comprehend.ImportModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ImportModelInput, ...func(*comprehend.Options)) (*comprehend.ImportModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ImportModelInput, ...func(*comprehend.Options)) *comprehend.ImportModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ImportModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ImportModelInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasets(ctx context.Context, params *comprehend.ListDatasetsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListDatasetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasets")
	}

	var r0 *comprehend.ListDatasetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDatasetsInput, ...func(*comprehend.Options)) (*comprehend.ListDatasetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDatasetsInput, ...func(*comprehend.Options)) *comprehend.ListDatasetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListDatasetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListDatasetsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDocumentClassificationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDocumentClassificationJobs(ctx context.Context, params *comprehend.ListDocumentClassificationJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListDocumentClassificationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDocumentClassificationJobs")
	}

	var r0 *comprehend.ListDocumentClassificationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassificationJobsInput, ...func(*comprehend.Options)) (*comprehend.ListDocumentClassificationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassificationJobsInput, ...func(*comprehend.Options)) *comprehend.ListDocumentClassificationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListDocumentClassificationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListDocumentClassificationJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDocumentClassifierSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDocumentClassifierSummaries(ctx context.Context, params *comprehend.ListDocumentClassifierSummariesInput, optFns ...func(*comprehend.Options)) (*comprehend.ListDocumentClassifierSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDocumentClassifierSummaries")
	}

	var r0 *comprehend.ListDocumentClassifierSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassifierSummariesInput, ...func(*comprehend.Options)) (*comprehend.ListDocumentClassifierSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassifierSummariesInput, ...func(*comprehend.Options)) *comprehend.ListDocumentClassifierSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListDocumentClassifierSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListDocumentClassifierSummariesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDocumentClassifiers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDocumentClassifiers(ctx context.Context, params *comprehend.ListDocumentClassifiersInput, optFns ...func(*comprehend.Options)) (*comprehend.ListDocumentClassifiersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDocumentClassifiers")
	}

	var r0 *comprehend.ListDocumentClassifiersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassifiersInput, ...func(*comprehend.Options)) (*comprehend.ListDocumentClassifiersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDocumentClassifiersInput, ...func(*comprehend.Options)) *comprehend.ListDocumentClassifiersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListDocumentClassifiersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListDocumentClassifiersInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDominantLanguageDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDominantLanguageDetectionJobs(ctx context.Context, params *comprehend.ListDominantLanguageDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListDominantLanguageDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDominantLanguageDetectionJobs")
	}

	var r0 *comprehend.ListDominantLanguageDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDominantLanguageDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListDominantLanguageDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListDominantLanguageDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListDominantLanguageDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListDominantLanguageDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListDominantLanguageDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEndpoints(ctx context.Context, params *comprehend.ListEndpointsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEndpoints")
	}

	var r0 *comprehend.ListEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEndpointsInput, ...func(*comprehend.Options)) (*comprehend.ListEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEndpointsInput, ...func(*comprehend.Options)) *comprehend.ListEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListEndpointsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntitiesDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEntitiesDetectionJobs(ctx context.Context, params *comprehend.ListEntitiesDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListEntitiesDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEntitiesDetectionJobs")
	}

	var r0 *comprehend.ListEntitiesDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntitiesDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListEntitiesDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntitiesDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListEntitiesDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListEntitiesDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListEntitiesDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntityRecognizerSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEntityRecognizerSummaries(ctx context.Context, params *comprehend.ListEntityRecognizerSummariesInput, optFns ...func(*comprehend.Options)) (*comprehend.ListEntityRecognizerSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityRecognizerSummaries")
	}

	var r0 *comprehend.ListEntityRecognizerSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntityRecognizerSummariesInput, ...func(*comprehend.Options)) (*comprehend.ListEntityRecognizerSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntityRecognizerSummariesInput, ...func(*comprehend.Options)) *comprehend.ListEntityRecognizerSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListEntityRecognizerSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListEntityRecognizerSummariesInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntityRecognizers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEntityRecognizers(ctx context.Context, params *comprehend.ListEntityRecognizersInput, optFns ...func(*comprehend.Options)) (*comprehend.ListEntityRecognizersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityRecognizers")
	}

	var r0 *comprehend.ListEntityRecognizersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntityRecognizersInput, ...func(*comprehend.Options)) (*comprehend.ListEntityRecognizersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEntityRecognizersInput, ...func(*comprehend.Options)) *comprehend.ListEntityRecognizersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListEntityRecognizersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListEntityRecognizersInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventsDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventsDetectionJobs(ctx context.Context, params *comprehend.ListEventsDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListEventsDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventsDetectionJobs")
	}

	var r0 *comprehend.ListEventsDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEventsDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListEventsDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListEventsDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListEventsDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListEventsDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListEventsDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlywheelIterationHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlywheelIterationHistory(ctx context.Context, params *comprehend.ListFlywheelIterationHistoryInput, optFns ...func(*comprehend.Options)) (*comprehend.ListFlywheelIterationHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlywheelIterationHistory")
	}

	var r0 *comprehend.ListFlywheelIterationHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListFlywheelIterationHistoryInput, ...func(*comprehend.Options)) (*comprehend.ListFlywheelIterationHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListFlywheelIterationHistoryInput, ...func(*comprehend.Options)) *comprehend.ListFlywheelIterationHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListFlywheelIterationHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListFlywheelIterationHistoryInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlywheels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlywheels(ctx context.Context, params *comprehend.ListFlywheelsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListFlywheelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlywheels")
	}

	var r0 *comprehend.ListFlywheelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListFlywheelsInput, ...func(*comprehend.Options)) (*comprehend.ListFlywheelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListFlywheelsInput, ...func(*comprehend.Options)) *comprehend.ListFlywheelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListFlywheelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListFlywheelsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeyPhrasesDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeyPhrasesDetectionJobs(ctx context.Context, params *comprehend.ListKeyPhrasesDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListKeyPhrasesDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeyPhrasesDetectionJobs")
	}

	var r0 *comprehend.ListKeyPhrasesDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListKeyPhrasesDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListKeyPhrasesDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListKeyPhrasesDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListKeyPhrasesDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListKeyPhrasesDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListKeyPhrasesDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPiiEntitiesDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPiiEntitiesDetectionJobs(ctx context.Context, params *comprehend.ListPiiEntitiesDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListPiiEntitiesDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPiiEntitiesDetectionJobs")
	}

	var r0 *comprehend.ListPiiEntitiesDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListPiiEntitiesDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListPiiEntitiesDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListPiiEntitiesDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListPiiEntitiesDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListPiiEntitiesDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListPiiEntitiesDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSentimentDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSentimentDetectionJobs(ctx context.Context, params *comprehend.ListSentimentDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListSentimentDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSentimentDetectionJobs")
	}

	var r0 *comprehend.ListSentimentDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListSentimentDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListSentimentDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListSentimentDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListSentimentDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListSentimentDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListSentimentDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *comprehend.ListTagsForResourceInput, optFns ...func(*comprehend.Options)) (*comprehend.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *comprehend.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTagsForResourceInput, ...func(*comprehend.Options)) (*comprehend.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTagsForResourceInput, ...func(*comprehend.Options)) *comprehend.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListTagsForResourceInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTargetedSentimentDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTargetedSentimentDetectionJobs(ctx context.Context, params *comprehend.ListTargetedSentimentDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListTargetedSentimentDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTargetedSentimentDetectionJobs")
	}

	var r0 *comprehend.ListTargetedSentimentDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTargetedSentimentDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListTargetedSentimentDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTargetedSentimentDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListTargetedSentimentDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListTargetedSentimentDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListTargetedSentimentDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTopicsDetectionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTopicsDetectionJobs(ctx context.Context, params *comprehend.ListTopicsDetectionJobsInput, optFns ...func(*comprehend.Options)) (*comprehend.ListTopicsDetectionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTopicsDetectionJobs")
	}

	var r0 *comprehend.ListTopicsDetectionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTopicsDetectionJobsInput, ...func(*comprehend.Options)) (*comprehend.ListTopicsDetectionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.ListTopicsDetectionJobsInput, ...func(*comprehend.Options)) *comprehend.ListTopicsDetectionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.ListTopicsDetectionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.ListTopicsDetectionJobsInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() comprehend.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 comprehend.Options
	if rf, ok := ret.Get(0).(func() comprehend.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(comprehend.Options)
	}

	return r0
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *comprehend.PutResourcePolicyInput, optFns ...func(*comprehend.Options)) (*comprehend.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *comprehend.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.PutResourcePolicyInput, ...func(*comprehend.Options)) (*comprehend.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.PutResourcePolicyInput, ...func(*comprehend.Options)) *comprehend.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.PutResourcePolicyInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDocumentClassificationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDocumentClassificationJob(ctx context.Context, params *comprehend.StartDocumentClassificationJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartDocumentClassificationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDocumentClassificationJob")
	}

	var r0 *comprehend.StartDocumentClassificationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartDocumentClassificationJobInput, ...func(*comprehend.Options)) (*comprehend.StartDocumentClassificationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartDocumentClassificationJobInput, ...func(*comprehend.Options)) *comprehend.StartDocumentClassificationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartDocumentClassificationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartDocumentClassificationJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDominantLanguageDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDominantLanguageDetectionJob(ctx context.Context, params *comprehend.StartDominantLanguageDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartDominantLanguageDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDominantLanguageDetectionJob")
	}

	var r0 *comprehend.StartDominantLanguageDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartDominantLanguageDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartDominantLanguageDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartDominantLanguageDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartEntitiesDetectionJob(ctx context.Context, params *comprehend.StartEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartEntitiesDetectionJob")
	}

	var r0 *comprehend.StartEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartEventsDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartEventsDetectionJob(ctx context.Context, params *comprehend.StartEventsDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartEventsDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartEventsDetectionJob")
	}

	var r0 *comprehend.StartEventsDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartEventsDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartEventsDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartEventsDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartEventsDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartEventsDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartEventsDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFlywheelIteration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFlywheelIteration(ctx context.Context, params *comprehend.StartFlywheelIterationInput, optFns ...func(*comprehend.Options)) (*comprehend.StartFlywheelIterationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFlywheelIteration")
	}

	var r0 *comprehend.StartFlywheelIterationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartFlywheelIterationInput, ...func(*comprehend.Options)) (*comprehend.StartFlywheelIterationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartFlywheelIterationInput, ...func(*comprehend.Options)) *comprehend.StartFlywheelIterationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartFlywheelIterationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartFlywheelIterationInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartKeyPhrasesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartKeyPhrasesDetectionJob(ctx context.Context, params *comprehend.StartKeyPhrasesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartKeyPhrasesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartKeyPhrasesDetectionJob")
	}

	var r0 *comprehend.StartKeyPhrasesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartKeyPhrasesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartKeyPhrasesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartKeyPhrasesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartPiiEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartPiiEntitiesDetectionJob(ctx context.Context, params *comprehend.StartPiiEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartPiiEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartPiiEntitiesDetectionJob")
	}

	var r0 *comprehend.StartPiiEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartPiiEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartPiiEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartPiiEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartSentimentDetectionJob(ctx context.Context, params *comprehend.StartSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartSentimentDetectionJob")
	}

	var r0 *comprehend.StartSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTargetedSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTargetedSentimentDetectionJob(ctx context.Context, params *comprehend.StartTargetedSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartTargetedSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTargetedSentimentDetectionJob")
	}

	var r0 *comprehend.StartTargetedSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartTargetedSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartTargetedSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartTargetedSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTopicsDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTopicsDetectionJob(ctx context.Context, params *comprehend.StartTopicsDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StartTopicsDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTopicsDetectionJob")
	}

	var r0 *comprehend.StartTopicsDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartTopicsDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StartTopicsDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StartTopicsDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StartTopicsDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StartTopicsDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StartTopicsDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopDominantLanguageDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopDominantLanguageDetectionJob(ctx context.Context, params *comprehend.StopDominantLanguageDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopDominantLanguageDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopDominantLanguageDetectionJob")
	}

	var r0 *comprehend.StopDominantLanguageDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopDominantLanguageDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopDominantLanguageDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopDominantLanguageDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopDominantLanguageDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopEntitiesDetectionJob(ctx context.Context, params *comprehend.StopEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopEntitiesDetectionJob")
	}

	var r0 *comprehend.StopEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopEventsDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopEventsDetectionJob(ctx context.Context, params *comprehend.StopEventsDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopEventsDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopEventsDetectionJob")
	}

	var r0 *comprehend.StopEventsDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopEventsDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopEventsDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopEventsDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopEventsDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopEventsDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopEventsDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopKeyPhrasesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopKeyPhrasesDetectionJob(ctx context.Context, params *comprehend.StopKeyPhrasesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopKeyPhrasesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopKeyPhrasesDetectionJob")
	}

	var r0 *comprehend.StopKeyPhrasesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopKeyPhrasesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopKeyPhrasesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopKeyPhrasesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopKeyPhrasesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopPiiEntitiesDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopPiiEntitiesDetectionJob(ctx context.Context, params *comprehend.StopPiiEntitiesDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopPiiEntitiesDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopPiiEntitiesDetectionJob")
	}

	var r0 *comprehend.StopPiiEntitiesDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopPiiEntitiesDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopPiiEntitiesDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopPiiEntitiesDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopPiiEntitiesDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopSentimentDetectionJob(ctx context.Context, params *comprehend.StopSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopSentimentDetectionJob")
	}

	var r0 *comprehend.StopSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTargetedSentimentDetectionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopTargetedSentimentDetectionJob(ctx context.Context, params *comprehend.StopTargetedSentimentDetectionJobInput, optFns ...func(*comprehend.Options)) (*comprehend.StopTargetedSentimentDetectionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTargetedSentimentDetectionJob")
	}

	var r0 *comprehend.StopTargetedSentimentDetectionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) (*comprehend.StopTargetedSentimentDetectionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) *comprehend.StopTargetedSentimentDetectionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopTargetedSentimentDetectionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopTargetedSentimentDetectionJobInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTrainingDocumentClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopTrainingDocumentClassifier(ctx context.Context, params *comprehend.StopTrainingDocumentClassifierInput, optFns ...func(*comprehend.Options)) (*comprehend.StopTrainingDocumentClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTrainingDocumentClassifier")
	}

	var r0 *comprehend.StopTrainingDocumentClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTrainingDocumentClassifierInput, ...func(*comprehend.Options)) (*comprehend.StopTrainingDocumentClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTrainingDocumentClassifierInput, ...func(*comprehend.Options)) *comprehend.StopTrainingDocumentClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopTrainingDocumentClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopTrainingDocumentClassifierInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTrainingEntityRecognizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopTrainingEntityRecognizer(ctx context.Context, params *comprehend.StopTrainingEntityRecognizerInput, optFns ...func(*comprehend.Options)) (*comprehend.StopTrainingEntityRecognizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTrainingEntityRecognizer")
	}

	var r0 *comprehend.StopTrainingEntityRecognizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTrainingEntityRecognizerInput, ...func(*comprehend.Options)) (*comprehend.StopTrainingEntityRecognizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.StopTrainingEntityRecognizerInput, ...func(*comprehend.Options)) *comprehend.StopTrainingEntityRecognizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.StopTrainingEntityRecognizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.StopTrainingEntityRecognizerInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *comprehend.TagResourceInput, optFns ...func(*comprehend.Options)) (*comprehend.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *comprehend.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.TagResourceInput, ...func(*comprehend.Options)) (*comprehend.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.TagResourceInput, ...func(*comprehend.Options)) *comprehend.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.TagResourceInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *comprehend.UntagResourceInput, optFns ...func(*comprehend.Options)) (*comprehend.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *comprehend.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UntagResourceInput, ...func(*comprehend.Options)) (*comprehend.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UntagResourceInput, ...func(*comprehend.Options)) *comprehend.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.UntagResourceInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEndpoint(ctx context.Context, params *comprehend.UpdateEndpointInput, optFns ...func(*comprehend.Options)) (*comprehend.UpdateEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEndpoint")
	}

	var r0 *comprehend.UpdateEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UpdateEndpointInput, ...func(*comprehend.Options)) (*comprehend.UpdateEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UpdateEndpointInput, ...func(*comprehend.Options)) *comprehend.UpdateEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.UpdateEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.UpdateEndpointInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFlywheel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFlywheel(ctx context.Context, params *comprehend.UpdateFlywheelInput, optFns ...func(*comprehend.Options)) (*comprehend.UpdateFlywheelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFlywheel")
	}

	var r0 *comprehend.UpdateFlywheelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UpdateFlywheelInput, ...func(*comprehend.Options)) (*comprehend.UpdateFlywheelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *comprehend.UpdateFlywheelInput, ...func(*comprehend.Options)) *comprehend.UpdateFlywheelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*comprehend.UpdateFlywheelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *comprehend.UpdateFlywheelInput, ...func(*comprehend.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
