// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	elasticache "github.com/aws/aws-sdk-go-v2/service/elasticache"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddTagsToResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTagsToResource(ctx context.Context, params *elasticache.AddTagsToResourceInput, optFns ...func(*elasticache.Options)) (*elasticache.AddTagsToResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToResource")
	}

	var r0 *elasticache.AddTagsToResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.AddTagsToResourceInput, ...func(*elasticache.Options)) (*elasticache.AddTagsToResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.AddTagsToResourceInput, ...func(*elasticache.Options)) *elasticache.AddTagsToResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.AddTagsToResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.AddTagsToResourceInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeCacheSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeCacheSecurityGroupIngress(ctx context.Context, params *elasticache.AuthorizeCacheSecurityGroupIngressInput, optFns ...func(*elasticache.Options)) (*elasticache.AuthorizeCacheSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeCacheSecurityGroupIngress")
	}

	var r0 *elasticache.AuthorizeCacheSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.AuthorizeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) (*elasticache.AuthorizeCacheSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.AuthorizeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) *elasticache.AuthorizeCacheSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.AuthorizeCacheSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.AuthorizeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchApplyUpdateAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchApplyUpdateAction(ctx context.Context, params *elasticache.BatchApplyUpdateActionInput, optFns ...func(*elasticache.Options)) (*elasticache.BatchApplyUpdateActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchApplyUpdateAction")
	}

	var r0 *elasticache.BatchApplyUpdateActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.BatchApplyUpdateActionInput, ...func(*elasticache.Options)) (*elasticache.BatchApplyUpdateActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.BatchApplyUpdateActionInput, ...func(*elasticache.Options)) *elasticache.BatchApplyUpdateActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.BatchApplyUpdateActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.BatchApplyUpdateActionInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchStopUpdateAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchStopUpdateAction(ctx context.Context, params *elasticache.BatchStopUpdateActionInput, optFns ...func(*elasticache.Options)) (*elasticache.BatchStopUpdateActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchStopUpdateAction")
	}

	var r0 *elasticache.BatchStopUpdateActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.BatchStopUpdateActionInput, ...func(*elasticache.Options)) (*elasticache.BatchStopUpdateActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.BatchStopUpdateActionInput, ...func(*elasticache.Options)) *elasticache.BatchStopUpdateActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.BatchStopUpdateActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.BatchStopUpdateActionInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteMigration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompleteMigration(ctx context.Context, params *elasticache.CompleteMigrationInput, optFns ...func(*elasticache.Options)) (*elasticache.CompleteMigrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompleteMigration")
	}

	var r0 *elasticache.CompleteMigrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CompleteMigrationInput, ...func(*elasticache.Options)) (*elasticache.CompleteMigrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CompleteMigrationInput, ...func(*elasticache.Options)) *elasticache.CompleteMigrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CompleteMigrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CompleteMigrationInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyServerlessCacheSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyServerlessCacheSnapshot(ctx context.Context, params *elasticache.CopyServerlessCacheSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.CopyServerlessCacheSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyServerlessCacheSnapshot")
	}

	var r0 *elasticache.CopyServerlessCacheSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CopyServerlessCacheSnapshotInput, ...func(*elasticache.Options)) (*elasticache.CopyServerlessCacheSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CopyServerlessCacheSnapshotInput, ...func(*elasticache.Options)) *elasticache.CopyServerlessCacheSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CopyServerlessCacheSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CopyServerlessCacheSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopySnapshot(ctx context.Context, params *elasticache.CopySnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.CopySnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopySnapshot")
	}

	var r0 *elasticache.CopySnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CopySnapshotInput, ...func(*elasticache.Options)) (*elasticache.CopySnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CopySnapshotInput, ...func(*elasticache.Options)) *elasticache.CopySnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CopySnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CopySnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCacheCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCacheCluster(ctx context.Context, params *elasticache.CreateCacheClusterInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateCacheClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCacheCluster")
	}

	var r0 *elasticache.CreateCacheClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheClusterInput, ...func(*elasticache.Options)) (*elasticache.CreateCacheClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheClusterInput, ...func(*elasticache.Options)) *elasticache.CreateCacheClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateCacheClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateCacheClusterInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCacheParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCacheParameterGroup(ctx context.Context, params *elasticache.CreateCacheParameterGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateCacheParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCacheParameterGroup")
	}

	var r0 *elasticache.CreateCacheParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheParameterGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateCacheParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheParameterGroupInput, ...func(*elasticache.Options)) *elasticache.CreateCacheParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateCacheParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateCacheParameterGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCacheSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCacheSecurityGroup(ctx context.Context, params *elasticache.CreateCacheSecurityGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateCacheSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCacheSecurityGroup")
	}

	var r0 *elasticache.CreateCacheSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheSecurityGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateCacheSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheSecurityGroupInput, ...func(*elasticache.Options)) *elasticache.CreateCacheSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateCacheSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateCacheSecurityGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCacheSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCacheSubnetGroup(ctx context.Context, params *elasticache.CreateCacheSubnetGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateCacheSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCacheSubnetGroup")
	}

	var r0 *elasticache.CreateCacheSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheSubnetGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateCacheSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateCacheSubnetGroupInput, ...func(*elasticache.Options)) *elasticache.CreateCacheSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateCacheSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateCacheSubnetGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGlobalReplicationGroup(ctx context.Context, params *elasticache.CreateGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGlobalReplicationGroup")
	}

	var r0 *elasticache.CreateGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.CreateGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReplicationGroup(ctx context.Context, params *elasticache.CreateReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReplicationGroup")
	}

	var r0 *elasticache.CreateReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.CreateReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateServerlessCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateServerlessCache(ctx context.Context, params *elasticache.CreateServerlessCacheInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateServerlessCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateServerlessCache")
	}

	var r0 *elasticache.CreateServerlessCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateServerlessCacheInput, ...func(*elasticache.Options)) (*elasticache.CreateServerlessCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateServerlessCacheInput, ...func(*elasticache.Options)) *elasticache.CreateServerlessCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateServerlessCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateServerlessCacheInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateServerlessCacheSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateServerlessCacheSnapshot(ctx context.Context, params *elasticache.CreateServerlessCacheSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateServerlessCacheSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateServerlessCacheSnapshot")
	}

	var r0 *elasticache.CreateServerlessCacheSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateServerlessCacheSnapshotInput, ...func(*elasticache.Options)) (*elasticache.CreateServerlessCacheSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateServerlessCacheSnapshotInput, ...func(*elasticache.Options)) *elasticache.CreateServerlessCacheSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateServerlessCacheSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateServerlessCacheSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshot(ctx context.Context, params *elasticache.CreateSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *elasticache.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateSnapshotInput, ...func(*elasticache.Options)) (*elasticache.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateSnapshotInput, ...func(*elasticache.Options)) *elasticache.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUser(ctx context.Context, params *elasticache.CreateUserInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *elasticache.CreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateUserInput, ...func(*elasticache.Options)) (*elasticache.CreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateUserInput, ...func(*elasticache.Options)) *elasticache.CreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateUserInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUserGroup(ctx context.Context, params *elasticache.CreateUserGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.CreateUserGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserGroup")
	}

	var r0 *elasticache.CreateUserGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateUserGroupInput, ...func(*elasticache.Options)) (*elasticache.CreateUserGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.CreateUserGroupInput, ...func(*elasticache.Options)) *elasticache.CreateUserGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.CreateUserGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.CreateUserGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecreaseNodeGroupsInGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DecreaseNodeGroupsInGlobalReplicationGroup(ctx context.Context, params *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DecreaseNodeGroupsInGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DecreaseNodeGroupsInGlobalReplicationGroup")
	}

	var r0 *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.DecreaseNodeGroupsInGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DecreaseNodeGroupsInGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DecreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecreaseReplicaCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DecreaseReplicaCount(ctx context.Context, params *elasticache.DecreaseReplicaCountInput, optFns ...func(*elasticache.Options)) (*elasticache.DecreaseReplicaCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DecreaseReplicaCount")
	}

	var r0 *elasticache.DecreaseReplicaCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DecreaseReplicaCountInput, ...func(*elasticache.Options)) (*elasticache.DecreaseReplicaCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DecreaseReplicaCountInput, ...func(*elasticache.Options)) *elasticache.DecreaseReplicaCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DecreaseReplicaCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DecreaseReplicaCountInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCacheCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCacheCluster(ctx context.Context, params *elasticache.DeleteCacheClusterInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteCacheClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCacheCluster")
	}

	var r0 *elasticache.DeleteCacheClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheClusterInput, ...func(*elasticache.Options)) (*elasticache.DeleteCacheClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheClusterInput, ...func(*elasticache.Options)) *elasticache.DeleteCacheClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteCacheClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteCacheClusterInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCacheParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCacheParameterGroup(ctx context.Context, params *elasticache.DeleteCacheParameterGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteCacheParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCacheParameterGroup")
	}

	var r0 *elasticache.DeleteCacheParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheParameterGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteCacheParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheParameterGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteCacheParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteCacheParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteCacheParameterGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCacheSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCacheSecurityGroup(ctx context.Context, params *elasticache.DeleteCacheSecurityGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteCacheSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCacheSecurityGroup")
	}

	var r0 *elasticache.DeleteCacheSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheSecurityGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteCacheSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheSecurityGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteCacheSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteCacheSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteCacheSecurityGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCacheSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCacheSubnetGroup(ctx context.Context, params *elasticache.DeleteCacheSubnetGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteCacheSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCacheSubnetGroup")
	}

	var r0 *elasticache.DeleteCacheSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheSubnetGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteCacheSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteCacheSubnetGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteCacheSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteCacheSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteCacheSubnetGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGlobalReplicationGroup(ctx context.Context, params *elasticache.DeleteGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGlobalReplicationGroup")
	}

	var r0 *elasticache.DeleteGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReplicationGroup(ctx context.Context, params *elasticache.DeleteReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReplicationGroup")
	}

	var r0 *elasticache.DeleteReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteServerlessCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteServerlessCache(ctx context.Context, params *elasticache.DeleteServerlessCacheInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteServerlessCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteServerlessCache")
	}

	var r0 *elasticache.DeleteServerlessCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteServerlessCacheInput, ...func(*elasticache.Options)) (*elasticache.DeleteServerlessCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteServerlessCacheInput, ...func(*elasticache.Options)) *elasticache.DeleteServerlessCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteServerlessCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteServerlessCacheInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteServerlessCacheSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteServerlessCacheSnapshot(ctx context.Context, params *elasticache.DeleteServerlessCacheSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteServerlessCacheSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteServerlessCacheSnapshot")
	}

	var r0 *elasticache.DeleteServerlessCacheSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteServerlessCacheSnapshotInput, ...func(*elasticache.Options)) (*elasticache.DeleteServerlessCacheSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteServerlessCacheSnapshotInput, ...func(*elasticache.Options)) *elasticache.DeleteServerlessCacheSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteServerlessCacheSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteServerlessCacheSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshot(ctx context.Context, params *elasticache.DeleteSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshot")
	}

	var r0 *elasticache.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteSnapshotInput, ...func(*elasticache.Options)) (*elasticache.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteSnapshotInput, ...func(*elasticache.Options)) *elasticache.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUser(ctx context.Context, params *elasticache.DeleteUserInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *elasticache.DeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteUserInput, ...func(*elasticache.Options)) (*elasticache.DeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteUserInput, ...func(*elasticache.Options)) *elasticache.DeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteUserInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUserGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUserGroup(ctx context.Context, params *elasticache.DeleteUserGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DeleteUserGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserGroup")
	}

	var r0 *elasticache.DeleteUserGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteUserGroupInput, ...func(*elasticache.Options)) (*elasticache.DeleteUserGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DeleteUserGroupInput, ...func(*elasticache.Options)) *elasticache.DeleteUserGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DeleteUserGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DeleteUserGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheClusters(ctx context.Context, params *elasticache.DescribeCacheClustersInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheClusters")
	}

	var r0 *elasticache.DescribeCacheClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheClustersInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheClustersInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheClustersInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheEngineVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheEngineVersions(ctx context.Context, params *elasticache.DescribeCacheEngineVersionsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheEngineVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheEngineVersions")
	}

	var r0 *elasticache.DescribeCacheEngineVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheEngineVersionsInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheEngineVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheEngineVersionsInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheEngineVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheEngineVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheEngineVersionsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheParameterGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheParameterGroups(ctx context.Context, params *elasticache.DescribeCacheParameterGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheParameterGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheParameterGroups")
	}

	var r0 *elasticache.DescribeCacheParameterGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheParameterGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheParameterGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheParameterGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheParameterGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheParameterGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheParameterGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheParameters(ctx context.Context, params *elasticache.DescribeCacheParametersInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheParameters")
	}

	var r0 *elasticache.DescribeCacheParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheParametersInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheParametersInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheParametersInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheSecurityGroups(ctx context.Context, params *elasticache.DescribeCacheSecurityGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheSecurityGroups")
	}

	var r0 *elasticache.DescribeCacheSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheSecurityGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheSecurityGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheSecurityGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCacheSubnetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCacheSubnetGroups(ctx context.Context, params *elasticache.DescribeCacheSubnetGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeCacheSubnetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCacheSubnetGroups")
	}

	var r0 *elasticache.DescribeCacheSubnetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheSubnetGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeCacheSubnetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeCacheSubnetGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeCacheSubnetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeCacheSubnetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeCacheSubnetGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEngineDefaultParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEngineDefaultParameters(ctx context.Context, params *elasticache.DescribeEngineDefaultParametersInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeEngineDefaultParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEngineDefaultParameters")
	}

	var r0 *elasticache.DescribeEngineDefaultParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeEngineDefaultParametersInput, ...func(*elasticache.Options)) (*elasticache.DescribeEngineDefaultParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeEngineDefaultParametersInput, ...func(*elasticache.Options)) *elasticache.DescribeEngineDefaultParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeEngineDefaultParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeEngineDefaultParametersInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEvents(ctx context.Context, params *elasticache.DescribeEventsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEvents")
	}

	var r0 *elasticache.DescribeEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeEventsInput, ...func(*elasticache.Options)) (*elasticache.DescribeEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeEventsInput, ...func(*elasticache.Options)) *elasticache.DescribeEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeEventsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGlobalReplicationGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGlobalReplicationGroups(ctx context.Context, params *elasticache.DescribeGlobalReplicationGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeGlobalReplicationGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGlobalReplicationGroups")
	}

	var r0 *elasticache.DescribeGlobalReplicationGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeGlobalReplicationGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeGlobalReplicationGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeGlobalReplicationGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeGlobalReplicationGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeGlobalReplicationGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeGlobalReplicationGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReplicationGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReplicationGroups(ctx context.Context, params *elasticache.DescribeReplicationGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeReplicationGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReplicationGroups")
	}

	var r0 *elasticache.DescribeReplicationGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReplicationGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeReplicationGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReplicationGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeReplicationGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeReplicationGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeReplicationGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedCacheNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedCacheNodes(ctx context.Context, params *elasticache.DescribeReservedCacheNodesInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeReservedCacheNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedCacheNodes")
	}

	var r0 *elasticache.DescribeReservedCacheNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReservedCacheNodesInput, ...func(*elasticache.Options)) (*elasticache.DescribeReservedCacheNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReservedCacheNodesInput, ...func(*elasticache.Options)) *elasticache.DescribeReservedCacheNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeReservedCacheNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeReservedCacheNodesInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedCacheNodesOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedCacheNodesOfferings(ctx context.Context, params *elasticache.DescribeReservedCacheNodesOfferingsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeReservedCacheNodesOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedCacheNodesOfferings")
	}

	var r0 *elasticache.DescribeReservedCacheNodesOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReservedCacheNodesOfferingsInput, ...func(*elasticache.Options)) (*elasticache.DescribeReservedCacheNodesOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeReservedCacheNodesOfferingsInput, ...func(*elasticache.Options)) *elasticache.DescribeReservedCacheNodesOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeReservedCacheNodesOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeReservedCacheNodesOfferingsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServerlessCacheSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeServerlessCacheSnapshots(ctx context.Context, params *elasticache.DescribeServerlessCacheSnapshotsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeServerlessCacheSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServerlessCacheSnapshots")
	}

	var r0 *elasticache.DescribeServerlessCacheSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServerlessCacheSnapshotsInput, ...func(*elasticache.Options)) (*elasticache.DescribeServerlessCacheSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServerlessCacheSnapshotsInput, ...func(*elasticache.Options)) *elasticache.DescribeServerlessCacheSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeServerlessCacheSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeServerlessCacheSnapshotsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServerlessCaches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeServerlessCaches(ctx context.Context, params *elasticache.DescribeServerlessCachesInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeServerlessCachesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServerlessCaches")
	}

	var r0 *elasticache.DescribeServerlessCachesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServerlessCachesInput, ...func(*elasticache.Options)) (*elasticache.DescribeServerlessCachesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServerlessCachesInput, ...func(*elasticache.Options)) *elasticache.DescribeServerlessCachesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeServerlessCachesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeServerlessCachesInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServiceUpdates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeServiceUpdates(ctx context.Context, params *elasticache.DescribeServiceUpdatesInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeServiceUpdatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServiceUpdates")
	}

	var r0 *elasticache.DescribeServiceUpdatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServiceUpdatesInput, ...func(*elasticache.Options)) (*elasticache.DescribeServiceUpdatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeServiceUpdatesInput, ...func(*elasticache.Options)) *elasticache.DescribeServiceUpdatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeServiceUpdatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeServiceUpdatesInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshots(ctx context.Context, params *elasticache.DescribeSnapshotsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshots")
	}

	var r0 *elasticache.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeSnapshotsInput, ...func(*elasticache.Options)) (*elasticache.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeSnapshotsInput, ...func(*elasticache.Options)) *elasticache.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeSnapshotsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUpdateActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUpdateActions(ctx context.Context, params *elasticache.DescribeUpdateActionsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeUpdateActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUpdateActions")
	}

	var r0 *elasticache.DescribeUpdateActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUpdateActionsInput, ...func(*elasticache.Options)) (*elasticache.DescribeUpdateActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUpdateActionsInput, ...func(*elasticache.Options)) *elasticache.DescribeUpdateActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeUpdateActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeUpdateActionsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUserGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUserGroups(ctx context.Context, params *elasticache.DescribeUserGroupsInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeUserGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUserGroups")
	}

	var r0 *elasticache.DescribeUserGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUserGroupsInput, ...func(*elasticache.Options)) (*elasticache.DescribeUserGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUserGroupsInput, ...func(*elasticache.Options)) *elasticache.DescribeUserGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeUserGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeUserGroupsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUsers(ctx context.Context, params *elasticache.DescribeUsersInput, optFns ...func(*elasticache.Options)) (*elasticache.DescribeUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUsers")
	}

	var r0 *elasticache.DescribeUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUsersInput, ...func(*elasticache.Options)) (*elasticache.DescribeUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DescribeUsersInput, ...func(*elasticache.Options)) *elasticache.DescribeUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DescribeUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DescribeUsersInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateGlobalReplicationGroup(ctx context.Context, params *elasticache.DisassociateGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.DisassociateGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateGlobalReplicationGroup")
	}

	var r0 *elasticache.DisassociateGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DisassociateGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.DisassociateGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.DisassociateGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.DisassociateGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.DisassociateGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.DisassociateGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportServerlessCacheSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportServerlessCacheSnapshot(ctx context.Context, params *elasticache.ExportServerlessCacheSnapshotInput, optFns ...func(*elasticache.Options)) (*elasticache.ExportServerlessCacheSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportServerlessCacheSnapshot")
	}

	var r0 *elasticache.ExportServerlessCacheSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ExportServerlessCacheSnapshotInput, ...func(*elasticache.Options)) (*elasticache.ExportServerlessCacheSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ExportServerlessCacheSnapshotInput, ...func(*elasticache.Options)) *elasticache.ExportServerlessCacheSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ExportServerlessCacheSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ExportServerlessCacheSnapshotInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FailoverGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) FailoverGlobalReplicationGroup(ctx context.Context, params *elasticache.FailoverGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.FailoverGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FailoverGlobalReplicationGroup")
	}

	var r0 *elasticache.FailoverGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.FailoverGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.FailoverGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.FailoverGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.FailoverGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.FailoverGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.FailoverGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseNodeGroupsInGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) IncreaseNodeGroupsInGlobalReplicationGroup(ctx context.Context, params *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.IncreaseNodeGroupsInGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IncreaseNodeGroupsInGlobalReplicationGroup")
	}

	var r0 *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.IncreaseNodeGroupsInGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.IncreaseNodeGroupsInGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.IncreaseNodeGroupsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseReplicaCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) IncreaseReplicaCount(ctx context.Context, params *elasticache.IncreaseReplicaCountInput, optFns ...func(*elasticache.Options)) (*elasticache.IncreaseReplicaCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IncreaseReplicaCount")
	}

	var r0 *elasticache.IncreaseReplicaCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.IncreaseReplicaCountInput, ...func(*elasticache.Options)) (*elasticache.IncreaseReplicaCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.IncreaseReplicaCountInput, ...func(*elasticache.Options)) *elasticache.IncreaseReplicaCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.IncreaseReplicaCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.IncreaseReplicaCountInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAllowedNodeTypeModifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAllowedNodeTypeModifications(ctx context.Context, params *elasticache.ListAllowedNodeTypeModificationsInput, optFns ...func(*elasticache.Options)) (*elasticache.ListAllowedNodeTypeModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllowedNodeTypeModifications")
	}

	var r0 *elasticache.ListAllowedNodeTypeModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ListAllowedNodeTypeModificationsInput, ...func(*elasticache.Options)) (*elasticache.ListAllowedNodeTypeModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ListAllowedNodeTypeModificationsInput, ...func(*elasticache.Options)) *elasticache.ListAllowedNodeTypeModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ListAllowedNodeTypeModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ListAllowedNodeTypeModificationsInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *elasticache.ListTagsForResourceInput, optFns ...func(*elasticache.Options)) (*elasticache.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *elasticache.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ListTagsForResourceInput, ...func(*elasticache.Options)) (*elasticache.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ListTagsForResourceInput, ...func(*elasticache.Options)) *elasticache.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ListTagsForResourceInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCacheCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCacheCluster(ctx context.Context, params *elasticache.ModifyCacheClusterInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyCacheClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCacheCluster")
	}

	var r0 *elasticache.ModifyCacheClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheClusterInput, ...func(*elasticache.Options)) (*elasticache.ModifyCacheClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheClusterInput, ...func(*elasticache.Options)) *elasticache.ModifyCacheClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyCacheClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyCacheClusterInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCacheParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCacheParameterGroup(ctx context.Context, params *elasticache.ModifyCacheParameterGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyCacheParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCacheParameterGroup")
	}

	var r0 *elasticache.ModifyCacheParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheParameterGroupInput, ...func(*elasticache.Options)) (*elasticache.ModifyCacheParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheParameterGroupInput, ...func(*elasticache.Options)) *elasticache.ModifyCacheParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyCacheParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyCacheParameterGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCacheSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCacheSubnetGroup(ctx context.Context, params *elasticache.ModifyCacheSubnetGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyCacheSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCacheSubnetGroup")
	}

	var r0 *elasticache.ModifyCacheSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheSubnetGroupInput, ...func(*elasticache.Options)) (*elasticache.ModifyCacheSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyCacheSubnetGroupInput, ...func(*elasticache.Options)) *elasticache.ModifyCacheSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyCacheSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyCacheSubnetGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyGlobalReplicationGroup(ctx context.Context, params *elasticache.ModifyGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyGlobalReplicationGroup")
	}

	var r0 *elasticache.ModifyGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.ModifyGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.ModifyGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyReplicationGroup(ctx context.Context, params *elasticache.ModifyReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyReplicationGroup")
	}

	var r0 *elasticache.ModifyReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.ModifyReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.ModifyReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyReplicationGroupShardConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyReplicationGroupShardConfiguration(ctx context.Context, params *elasticache.ModifyReplicationGroupShardConfigurationInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyReplicationGroupShardConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyReplicationGroupShardConfiguration")
	}

	var r0 *elasticache.ModifyReplicationGroupShardConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyReplicationGroupShardConfigurationInput, ...func(*elasticache.Options)) (*elasticache.ModifyReplicationGroupShardConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyReplicationGroupShardConfigurationInput, ...func(*elasticache.Options)) *elasticache.ModifyReplicationGroupShardConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyReplicationGroupShardConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyReplicationGroupShardConfigurationInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyServerlessCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyServerlessCache(ctx context.Context, params *elasticache.ModifyServerlessCacheInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyServerlessCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyServerlessCache")
	}

	var r0 *elasticache.ModifyServerlessCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyServerlessCacheInput, ...func(*elasticache.Options)) (*elasticache.ModifyServerlessCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyServerlessCacheInput, ...func(*elasticache.Options)) *elasticache.ModifyServerlessCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyServerlessCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyServerlessCacheInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyUser(ctx context.Context, params *elasticache.ModifyUserInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyUser")
	}

	var r0 *elasticache.ModifyUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyUserInput, ...func(*elasticache.Options)) (*elasticache.ModifyUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyUserInput, ...func(*elasticache.Options)) *elasticache.ModifyUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyUserInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyUserGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyUserGroup(ctx context.Context, params *elasticache.ModifyUserGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ModifyUserGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyUserGroup")
	}

	var r0 *elasticache.ModifyUserGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyUserGroupInput, ...func(*elasticache.Options)) (*elasticache.ModifyUserGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ModifyUserGroupInput, ...func(*elasticache.Options)) *elasticache.ModifyUserGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ModifyUserGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ModifyUserGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() elasticache.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 elasticache.Options
	if rf, ok := ret.Get(0).(func() elasticache.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(elasticache.Options)
	}

	return r0
}

// PurchaseReservedCacheNodesOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedCacheNodesOffering(ctx context.Context, params *elasticache.PurchaseReservedCacheNodesOfferingInput, optFns ...func(*elasticache.Options)) (*elasticache.PurchaseReservedCacheNodesOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedCacheNodesOffering")
	}

	var r0 *elasticache.PurchaseReservedCacheNodesOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.PurchaseReservedCacheNodesOfferingInput, ...func(*elasticache.Options)) (*elasticache.PurchaseReservedCacheNodesOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.PurchaseReservedCacheNodesOfferingInput, ...func(*elasticache.Options)) *elasticache.PurchaseReservedCacheNodesOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.PurchaseReservedCacheNodesOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.PurchaseReservedCacheNodesOfferingInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebalanceSlotsInGlobalReplicationGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebalanceSlotsInGlobalReplicationGroup(ctx context.Context, params *elasticache.RebalanceSlotsInGlobalReplicationGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.RebalanceSlotsInGlobalReplicationGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebalanceSlotsInGlobalReplicationGroup")
	}

	var r0 *elasticache.RebalanceSlotsInGlobalReplicationGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RebalanceSlotsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) (*elasticache.RebalanceSlotsInGlobalReplicationGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RebalanceSlotsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) *elasticache.RebalanceSlotsInGlobalReplicationGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.RebalanceSlotsInGlobalReplicationGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.RebalanceSlotsInGlobalReplicationGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootCacheCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootCacheCluster(ctx context.Context, params *elasticache.RebootCacheClusterInput, optFns ...func(*elasticache.Options)) (*elasticache.RebootCacheClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootCacheCluster")
	}

	var r0 *elasticache.RebootCacheClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RebootCacheClusterInput, ...func(*elasticache.Options)) (*elasticache.RebootCacheClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RebootCacheClusterInput, ...func(*elasticache.Options)) *elasticache.RebootCacheClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.RebootCacheClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.RebootCacheClusterInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTagsFromResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTagsFromResource(ctx context.Context, params *elasticache.RemoveTagsFromResourceInput, optFns ...func(*elasticache.Options)) (*elasticache.RemoveTagsFromResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTagsFromResource")
	}

	var r0 *elasticache.RemoveTagsFromResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RemoveTagsFromResourceInput, ...func(*elasticache.Options)) (*elasticache.RemoveTagsFromResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RemoveTagsFromResourceInput, ...func(*elasticache.Options)) *elasticache.RemoveTagsFromResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.RemoveTagsFromResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.RemoveTagsFromResourceInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetCacheParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetCacheParameterGroup(ctx context.Context, params *elasticache.ResetCacheParameterGroupInput, optFns ...func(*elasticache.Options)) (*elasticache.ResetCacheParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetCacheParameterGroup")
	}

	var r0 *elasticache.ResetCacheParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ResetCacheParameterGroupInput, ...func(*elasticache.Options)) (*elasticache.ResetCacheParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.ResetCacheParameterGroupInput, ...func(*elasticache.Options)) *elasticache.ResetCacheParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.ResetCacheParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.ResetCacheParameterGroupInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeCacheSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeCacheSecurityGroupIngress(ctx context.Context, params *elasticache.RevokeCacheSecurityGroupIngressInput, optFns ...func(*elasticache.Options)) (*elasticache.RevokeCacheSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeCacheSecurityGroupIngress")
	}

	var r0 *elasticache.RevokeCacheSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RevokeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) (*elasticache.RevokeCacheSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.RevokeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) *elasticache.RevokeCacheSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.RevokeCacheSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.RevokeCacheSecurityGroupIngressInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMigration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMigration(ctx context.Context, params *elasticache.StartMigrationInput, optFns ...func(*elasticache.Options)) (*elasticache.StartMigrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMigration")
	}

	var r0 *elasticache.StartMigrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.StartMigrationInput, ...func(*elasticache.Options)) (*elasticache.StartMigrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.StartMigrationInput, ...func(*elasticache.Options)) *elasticache.StartMigrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.StartMigrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.StartMigrationInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestFailover provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestFailover(ctx context.Context, params *elasticache.TestFailoverInput, optFns ...func(*elasticache.Options)) (*elasticache.TestFailoverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestFailover")
	}

	var r0 *elasticache.TestFailoverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.TestFailoverInput, ...func(*elasticache.Options)) (*elasticache.TestFailoverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.TestFailoverInput, ...func(*elasticache.Options)) *elasticache.TestFailoverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.TestFailoverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.TestFailoverInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestMigration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestMigration(ctx context.Context, params *elasticache.TestMigrationInput, optFns ...func(*elasticache.Options)) (*elasticache.TestMigrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestMigration")
	}

	var r0 *elasticache.TestMigrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.TestMigrationInput, ...func(*elasticache.Options)) (*elasticache.TestMigrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticache.TestMigrationInput, ...func(*elasticache.Options)) *elasticache.TestMigrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticache.TestMigrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticache.TestMigrationInput, ...func(*elasticache.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
