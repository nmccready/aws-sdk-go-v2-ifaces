// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	memorydb "github.com/aws/aws-sdk-go-v2/service/memorydb"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchUpdateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdateCluster(ctx context.Context, params *memorydb.BatchUpdateClusterInput, optFns ...func(*memorydb.Options)) (*memorydb.BatchUpdateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateCluster")
	}

	var r0 *memorydb.BatchUpdateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.BatchUpdateClusterInput, ...func(*memorydb.Options)) (*memorydb.BatchUpdateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.BatchUpdateClusterInput, ...func(*memorydb.Options)) *memorydb.BatchUpdateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.BatchUpdateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.BatchUpdateClusterInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopySnapshot(ctx context.Context, params *memorydb.CopySnapshotInput, optFns ...func(*memorydb.Options)) (*memorydb.CopySnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopySnapshot")
	}

	var r0 *memorydb.CopySnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CopySnapshotInput, ...func(*memorydb.Options)) (*memorydb.CopySnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CopySnapshotInput, ...func(*memorydb.Options)) *memorydb.CopySnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CopySnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CopySnapshotInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateACL(ctx context.Context, params *memorydb.CreateACLInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateACL")
	}

	var r0 *memorydb.CreateACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateACLInput, ...func(*memorydb.Options)) (*memorydb.CreateACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateACLInput, ...func(*memorydb.Options)) *memorydb.CreateACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateACLInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCluster(ctx context.Context, params *memorydb.CreateClusterInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *memorydb.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateClusterInput, ...func(*memorydb.Options)) (*memorydb.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateClusterInput, ...func(*memorydb.Options)) *memorydb.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateClusterInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateParameterGroup(ctx context.Context, params *memorydb.CreateParameterGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterGroup")
	}

	var r0 *memorydb.CreateParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateParameterGroupInput, ...func(*memorydb.Options)) (*memorydb.CreateParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateParameterGroupInput, ...func(*memorydb.Options)) *memorydb.CreateParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateParameterGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshot(ctx context.Context, params *memorydb.CreateSnapshotInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *memorydb.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateSnapshotInput, ...func(*memorydb.Options)) (*memorydb.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateSnapshotInput, ...func(*memorydb.Options)) *memorydb.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateSnapshotInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubnetGroup(ctx context.Context, params *memorydb.CreateSubnetGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnetGroup")
	}

	var r0 *memorydb.CreateSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateSubnetGroupInput, ...func(*memorydb.Options)) (*memorydb.CreateSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateSubnetGroupInput, ...func(*memorydb.Options)) *memorydb.CreateSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateSubnetGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUser(ctx context.Context, params *memorydb.CreateUserInput, optFns ...func(*memorydb.Options)) (*memorydb.CreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *memorydb.CreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateUserInput, ...func(*memorydb.Options)) (*memorydb.CreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.CreateUserInput, ...func(*memorydb.Options)) *memorydb.CreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.CreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.CreateUserInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteACL(ctx context.Context, params *memorydb.DeleteACLInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteACL")
	}

	var r0 *memorydb.DeleteACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteACLInput, ...func(*memorydb.Options)) (*memorydb.DeleteACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteACLInput, ...func(*memorydb.Options)) *memorydb.DeleteACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteACLInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCluster(ctx context.Context, params *memorydb.DeleteClusterInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 *memorydb.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteClusterInput, ...func(*memorydb.Options)) (*memorydb.DeleteClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteClusterInput, ...func(*memorydb.Options)) *memorydb.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteClusterInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteParameterGroup(ctx context.Context, params *memorydb.DeleteParameterGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteParameterGroup")
	}

	var r0 *memorydb.DeleteParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteParameterGroupInput, ...func(*memorydb.Options)) (*memorydb.DeleteParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteParameterGroupInput, ...func(*memorydb.Options)) *memorydb.DeleteParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteParameterGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshot(ctx context.Context, params *memorydb.DeleteSnapshotInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshot")
	}

	var r0 *memorydb.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteSnapshotInput, ...func(*memorydb.Options)) (*memorydb.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteSnapshotInput, ...func(*memorydb.Options)) *memorydb.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteSnapshotInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubnetGroup(ctx context.Context, params *memorydb.DeleteSubnetGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnetGroup")
	}

	var r0 *memorydb.DeleteSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteSubnetGroupInput, ...func(*memorydb.Options)) (*memorydb.DeleteSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteSubnetGroupInput, ...func(*memorydb.Options)) *memorydb.DeleteSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteSubnetGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUser(ctx context.Context, params *memorydb.DeleteUserInput, optFns ...func(*memorydb.Options)) (*memorydb.DeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *memorydb.DeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteUserInput, ...func(*memorydb.Options)) (*memorydb.DeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DeleteUserInput, ...func(*memorydb.Options)) *memorydb.DeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DeleteUserInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeACLs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeACLs(ctx context.Context, params *memorydb.DescribeACLsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeACLsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeACLs")
	}

	var r0 *memorydb.DescribeACLsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeACLsInput, ...func(*memorydb.Options)) (*memorydb.DescribeACLsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeACLsInput, ...func(*memorydb.Options)) *memorydb.DescribeACLsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeACLsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeACLsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusters(ctx context.Context, params *memorydb.DescribeClustersInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusters")
	}

	var r0 *memorydb.DescribeClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeClustersInput, ...func(*memorydb.Options)) (*memorydb.DescribeClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeClustersInput, ...func(*memorydb.Options)) *memorydb.DescribeClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeClustersInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEngineVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEngineVersions(ctx context.Context, params *memorydb.DescribeEngineVersionsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeEngineVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEngineVersions")
	}

	var r0 *memorydb.DescribeEngineVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeEngineVersionsInput, ...func(*memorydb.Options)) (*memorydb.DescribeEngineVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeEngineVersionsInput, ...func(*memorydb.Options)) *memorydb.DescribeEngineVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeEngineVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeEngineVersionsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEvents(ctx context.Context, params *memorydb.DescribeEventsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEvents")
	}

	var r0 *memorydb.DescribeEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeEventsInput, ...func(*memorydb.Options)) (*memorydb.DescribeEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeEventsInput, ...func(*memorydb.Options)) *memorydb.DescribeEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeEventsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeParameterGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeParameterGroups(ctx context.Context, params *memorydb.DescribeParameterGroupsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeParameterGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeParameterGroups")
	}

	var r0 *memorydb.DescribeParameterGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeParameterGroupsInput, ...func(*memorydb.Options)) (*memorydb.DescribeParameterGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeParameterGroupsInput, ...func(*memorydb.Options)) *memorydb.DescribeParameterGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeParameterGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeParameterGroupsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeParameters(ctx context.Context, params *memorydb.DescribeParametersInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeParameters")
	}

	var r0 *memorydb.DescribeParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeParametersInput, ...func(*memorydb.Options)) (*memorydb.DescribeParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeParametersInput, ...func(*memorydb.Options)) *memorydb.DescribeParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeParametersInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedNodes(ctx context.Context, params *memorydb.DescribeReservedNodesInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeReservedNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedNodes")
	}

	var r0 *memorydb.DescribeReservedNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeReservedNodesInput, ...func(*memorydb.Options)) (*memorydb.DescribeReservedNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeReservedNodesInput, ...func(*memorydb.Options)) *memorydb.DescribeReservedNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeReservedNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeReservedNodesInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedNodesOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedNodesOfferings(ctx context.Context, params *memorydb.DescribeReservedNodesOfferingsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeReservedNodesOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedNodesOfferings")
	}

	var r0 *memorydb.DescribeReservedNodesOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeReservedNodesOfferingsInput, ...func(*memorydb.Options)) (*memorydb.DescribeReservedNodesOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeReservedNodesOfferingsInput, ...func(*memorydb.Options)) *memorydb.DescribeReservedNodesOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeReservedNodesOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeReservedNodesOfferingsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServiceUpdates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeServiceUpdates(ctx context.Context, params *memorydb.DescribeServiceUpdatesInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeServiceUpdatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServiceUpdates")
	}

	var r0 *memorydb.DescribeServiceUpdatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeServiceUpdatesInput, ...func(*memorydb.Options)) (*memorydb.DescribeServiceUpdatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeServiceUpdatesInput, ...func(*memorydb.Options)) *memorydb.DescribeServiceUpdatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeServiceUpdatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeServiceUpdatesInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshots(ctx context.Context, params *memorydb.DescribeSnapshotsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshots")
	}

	var r0 *memorydb.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeSnapshotsInput, ...func(*memorydb.Options)) (*memorydb.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeSnapshotsInput, ...func(*memorydb.Options)) *memorydb.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeSnapshotsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSubnetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSubnetGroups(ctx context.Context, params *memorydb.DescribeSubnetGroupsInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeSubnetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSubnetGroups")
	}

	var r0 *memorydb.DescribeSubnetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeSubnetGroupsInput, ...func(*memorydb.Options)) (*memorydb.DescribeSubnetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeSubnetGroupsInput, ...func(*memorydb.Options)) *memorydb.DescribeSubnetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeSubnetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeSubnetGroupsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUsers(ctx context.Context, params *memorydb.DescribeUsersInput, optFns ...func(*memorydb.Options)) (*memorydb.DescribeUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUsers")
	}

	var r0 *memorydb.DescribeUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeUsersInput, ...func(*memorydb.Options)) (*memorydb.DescribeUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.DescribeUsersInput, ...func(*memorydb.Options)) *memorydb.DescribeUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.DescribeUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.DescribeUsersInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FailoverShard provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) FailoverShard(ctx context.Context, params *memorydb.FailoverShardInput, optFns ...func(*memorydb.Options)) (*memorydb.FailoverShardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FailoverShard")
	}

	var r0 *memorydb.FailoverShardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.FailoverShardInput, ...func(*memorydb.Options)) (*memorydb.FailoverShardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.FailoverShardInput, ...func(*memorydb.Options)) *memorydb.FailoverShardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.FailoverShardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.FailoverShardInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAllowedNodeTypeUpdates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAllowedNodeTypeUpdates(ctx context.Context, params *memorydb.ListAllowedNodeTypeUpdatesInput, optFns ...func(*memorydb.Options)) (*memorydb.ListAllowedNodeTypeUpdatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllowedNodeTypeUpdates")
	}

	var r0 *memorydb.ListAllowedNodeTypeUpdatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ListAllowedNodeTypeUpdatesInput, ...func(*memorydb.Options)) (*memorydb.ListAllowedNodeTypeUpdatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ListAllowedNodeTypeUpdatesInput, ...func(*memorydb.Options)) *memorydb.ListAllowedNodeTypeUpdatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.ListAllowedNodeTypeUpdatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.ListAllowedNodeTypeUpdatesInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *memorydb.ListTagsInput, optFns ...func(*memorydb.Options)) (*memorydb.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *memorydb.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ListTagsInput, ...func(*memorydb.Options)) (*memorydb.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ListTagsInput, ...func(*memorydb.Options)) *memorydb.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.ListTagsInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() memorydb.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 memorydb.Options
	if rf, ok := ret.Get(0).(func() memorydb.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(memorydb.Options)
	}

	return r0
}

// PurchaseReservedNodesOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedNodesOffering(ctx context.Context, params *memorydb.PurchaseReservedNodesOfferingInput, optFns ...func(*memorydb.Options)) (*memorydb.PurchaseReservedNodesOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedNodesOffering")
	}

	var r0 *memorydb.PurchaseReservedNodesOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.PurchaseReservedNodesOfferingInput, ...func(*memorydb.Options)) (*memorydb.PurchaseReservedNodesOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.PurchaseReservedNodesOfferingInput, ...func(*memorydb.Options)) *memorydb.PurchaseReservedNodesOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.PurchaseReservedNodesOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.PurchaseReservedNodesOfferingInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetParameterGroup(ctx context.Context, params *memorydb.ResetParameterGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.ResetParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetParameterGroup")
	}

	var r0 *memorydb.ResetParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ResetParameterGroupInput, ...func(*memorydb.Options)) (*memorydb.ResetParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.ResetParameterGroupInput, ...func(*memorydb.Options)) *memorydb.ResetParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.ResetParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.ResetParameterGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *memorydb.TagResourceInput, optFns ...func(*memorydb.Options)) (*memorydb.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *memorydb.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.TagResourceInput, ...func(*memorydb.Options)) (*memorydb.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.TagResourceInput, ...func(*memorydb.Options)) *memorydb.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.TagResourceInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *memorydb.UntagResourceInput, optFns ...func(*memorydb.Options)) (*memorydb.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *memorydb.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UntagResourceInput, ...func(*memorydb.Options)) (*memorydb.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UntagResourceInput, ...func(*memorydb.Options)) *memorydb.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UntagResourceInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateACL(ctx context.Context, params *memorydb.UpdateACLInput, optFns ...func(*memorydb.Options)) (*memorydb.UpdateACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateACL")
	}

	var r0 *memorydb.UpdateACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateACLInput, ...func(*memorydb.Options)) (*memorydb.UpdateACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateACLInput, ...func(*memorydb.Options)) *memorydb.UpdateACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UpdateACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UpdateACLInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCluster(ctx context.Context, params *memorydb.UpdateClusterInput, optFns ...func(*memorydb.Options)) (*memorydb.UpdateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCluster")
	}

	var r0 *memorydb.UpdateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateClusterInput, ...func(*memorydb.Options)) (*memorydb.UpdateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateClusterInput, ...func(*memorydb.Options)) *memorydb.UpdateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UpdateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UpdateClusterInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateParameterGroup(ctx context.Context, params *memorydb.UpdateParameterGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.UpdateParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParameterGroup")
	}

	var r0 *memorydb.UpdateParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateParameterGroupInput, ...func(*memorydb.Options)) (*memorydb.UpdateParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateParameterGroupInput, ...func(*memorydb.Options)) *memorydb.UpdateParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UpdateParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UpdateParameterGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSubnetGroup(ctx context.Context, params *memorydb.UpdateSubnetGroupInput, optFns ...func(*memorydb.Options)) (*memorydb.UpdateSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubnetGroup")
	}

	var r0 *memorydb.UpdateSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateSubnetGroupInput, ...func(*memorydb.Options)) (*memorydb.UpdateSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateSubnetGroupInput, ...func(*memorydb.Options)) *memorydb.UpdateSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UpdateSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UpdateSubnetGroupInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateUser(ctx context.Context, params *memorydb.UpdateUserInput, optFns ...func(*memorydb.Options)) (*memorydb.UpdateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *memorydb.UpdateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateUserInput, ...func(*memorydb.Options)) (*memorydb.UpdateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *memorydb.UpdateUserInput, ...func(*memorydb.Options)) *memorydb.UpdateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*memorydb.UpdateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *memorydb.UpdateUserInput, ...func(*memorydb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
