// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	codebuild "github.com/aws/aws-sdk-go-v2/service/codebuild"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchDeleteBuilds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteBuilds(ctx context.Context, params *codebuild.BatchDeleteBuildsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchDeleteBuildsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteBuilds")
	}

	var r0 *codebuild.BatchDeleteBuildsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchDeleteBuildsInput, ...func(*codebuild.Options)) (*codebuild.BatchDeleteBuildsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchDeleteBuildsInput, ...func(*codebuild.Options)) *codebuild.BatchDeleteBuildsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchDeleteBuildsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchDeleteBuildsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetBuildBatches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetBuildBatches(ctx context.Context, params *codebuild.BatchGetBuildBatchesInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetBuildBatchesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetBuildBatches")
	}

	var r0 *codebuild.BatchGetBuildBatchesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetBuildBatchesInput, ...func(*codebuild.Options)) (*codebuild.BatchGetBuildBatchesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetBuildBatchesInput, ...func(*codebuild.Options)) *codebuild.BatchGetBuildBatchesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetBuildBatchesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetBuildBatchesInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetBuilds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetBuilds(ctx context.Context, params *codebuild.BatchGetBuildsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetBuildsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetBuilds")
	}

	var r0 *codebuild.BatchGetBuildsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetBuildsInput, ...func(*codebuild.Options)) (*codebuild.BatchGetBuildsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetBuildsInput, ...func(*codebuild.Options)) *codebuild.BatchGetBuildsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetBuildsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetBuildsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetFleets(ctx context.Context, params *codebuild.BatchGetFleetsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetFleets")
	}

	var r0 *codebuild.BatchGetFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetFleetsInput, ...func(*codebuild.Options)) (*codebuild.BatchGetFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetFleetsInput, ...func(*codebuild.Options)) *codebuild.BatchGetFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetFleetsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetProjects(ctx context.Context, params *codebuild.BatchGetProjectsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetProjects")
	}

	var r0 *codebuild.BatchGetProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetProjectsInput, ...func(*codebuild.Options)) (*codebuild.BatchGetProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetProjectsInput, ...func(*codebuild.Options)) *codebuild.BatchGetProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetProjectsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetReportGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetReportGroups(ctx context.Context, params *codebuild.BatchGetReportGroupsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetReportGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetReportGroups")
	}

	var r0 *codebuild.BatchGetReportGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetReportGroupsInput, ...func(*codebuild.Options)) (*codebuild.BatchGetReportGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetReportGroupsInput, ...func(*codebuild.Options)) *codebuild.BatchGetReportGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetReportGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetReportGroupsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetReports(ctx context.Context, params *codebuild.BatchGetReportsInput, optFns ...func(*codebuild.Options)) (*codebuild.BatchGetReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetReports")
	}

	var r0 *codebuild.BatchGetReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetReportsInput, ...func(*codebuild.Options)) (*codebuild.BatchGetReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetReportsInput, ...func(*codebuild.Options)) *codebuild.BatchGetReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetReportsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFleet(ctx context.Context, params *codebuild.CreateFleetInput, optFns ...func(*codebuild.Options)) (*codebuild.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleet")
	}

	var r0 *codebuild.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateFleetInput, ...func(*codebuild.Options)) (*codebuild.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateFleetInput, ...func(*codebuild.Options)) *codebuild.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateFleetInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProject(ctx context.Context, params *codebuild.CreateProjectInput, optFns ...func(*codebuild.Options)) (*codebuild.CreateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *codebuild.CreateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateProjectInput, ...func(*codebuild.Options)) (*codebuild.CreateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateProjectInput, ...func(*codebuild.Options)) *codebuild.CreateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateProjectInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReportGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReportGroup(ctx context.Context, params *codebuild.CreateReportGroupInput, optFns ...func(*codebuild.Options)) (*codebuild.CreateReportGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReportGroup")
	}

	var r0 *codebuild.CreateReportGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateReportGroupInput, ...func(*codebuild.Options)) (*codebuild.CreateReportGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateReportGroupInput, ...func(*codebuild.Options)) *codebuild.CreateReportGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateReportGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateReportGroupInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebhook provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebhook(ctx context.Context, params *codebuild.CreateWebhookInput, optFns ...func(*codebuild.Options)) (*codebuild.CreateWebhookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebhook")
	}

	var r0 *codebuild.CreateWebhookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateWebhookInput, ...func(*codebuild.Options)) (*codebuild.CreateWebhookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateWebhookInput, ...func(*codebuild.Options)) *codebuild.CreateWebhookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateWebhookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateWebhookInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBuildBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBuildBatch(ctx context.Context, params *codebuild.DeleteBuildBatchInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteBuildBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBuildBatch")
	}

	var r0 *codebuild.DeleteBuildBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteBuildBatchInput, ...func(*codebuild.Options)) (*codebuild.DeleteBuildBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteBuildBatchInput, ...func(*codebuild.Options)) *codebuild.DeleteBuildBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteBuildBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteBuildBatchInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFleet(ctx context.Context, params *codebuild.DeleteFleetInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleet")
	}

	var r0 *codebuild.DeleteFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteFleetInput, ...func(*codebuild.Options)) (*codebuild.DeleteFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteFleetInput, ...func(*codebuild.Options)) *codebuild.DeleteFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteFleetInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProject(ctx context.Context, params *codebuild.DeleteProjectInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *codebuild.DeleteProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteProjectInput, ...func(*codebuild.Options)) (*codebuild.DeleteProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteProjectInput, ...func(*codebuild.Options)) *codebuild.DeleteProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteProjectInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReport(ctx context.Context, params *codebuild.DeleteReportInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReport")
	}

	var r0 *codebuild.DeleteReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteReportInput, ...func(*codebuild.Options)) (*codebuild.DeleteReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteReportInput, ...func(*codebuild.Options)) *codebuild.DeleteReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteReportInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReportGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReportGroup(ctx context.Context, params *codebuild.DeleteReportGroupInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteReportGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReportGroup")
	}

	var r0 *codebuild.DeleteReportGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteReportGroupInput, ...func(*codebuild.Options)) (*codebuild.DeleteReportGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteReportGroupInput, ...func(*codebuild.Options)) *codebuild.DeleteReportGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteReportGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteReportGroupInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *codebuild.DeleteResourcePolicyInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *codebuild.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteResourcePolicyInput, ...func(*codebuild.Options)) (*codebuild.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteResourcePolicyInput, ...func(*codebuild.Options)) *codebuild.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteResourcePolicyInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSourceCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSourceCredentials(ctx context.Context, params *codebuild.DeleteSourceCredentialsInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSourceCredentials")
	}

	var r0 *codebuild.DeleteSourceCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteSourceCredentialsInput, ...func(*codebuild.Options)) (*codebuild.DeleteSourceCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteSourceCredentialsInput, ...func(*codebuild.Options)) *codebuild.DeleteSourceCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteSourceCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteSourceCredentialsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebhook provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWebhook(ctx context.Context, params *codebuild.DeleteWebhookInput, optFns ...func(*codebuild.Options)) (*codebuild.DeleteWebhookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWebhook")
	}

	var r0 *codebuild.DeleteWebhookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteWebhookInput, ...func(*codebuild.Options)) (*codebuild.DeleteWebhookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteWebhookInput, ...func(*codebuild.Options)) *codebuild.DeleteWebhookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteWebhookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteWebhookInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCodeCoverages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCodeCoverages(ctx context.Context, params *codebuild.DescribeCodeCoveragesInput, optFns ...func(*codebuild.Options)) (*codebuild.DescribeCodeCoveragesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCodeCoverages")
	}

	var r0 *codebuild.DescribeCodeCoveragesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DescribeCodeCoveragesInput, ...func(*codebuild.Options)) (*codebuild.DescribeCodeCoveragesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DescribeCodeCoveragesInput, ...func(*codebuild.Options)) *codebuild.DescribeCodeCoveragesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DescribeCodeCoveragesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DescribeCodeCoveragesInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTestCases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTestCases(ctx context.Context, params *codebuild.DescribeTestCasesInput, optFns ...func(*codebuild.Options)) (*codebuild.DescribeTestCasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTestCases")
	}

	var r0 *codebuild.DescribeTestCasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DescribeTestCasesInput, ...func(*codebuild.Options)) (*codebuild.DescribeTestCasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DescribeTestCasesInput, ...func(*codebuild.Options)) *codebuild.DescribeTestCasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DescribeTestCasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DescribeTestCasesInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReportGroupTrend provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReportGroupTrend(ctx context.Context, params *codebuild.GetReportGroupTrendInput, optFns ...func(*codebuild.Options)) (*codebuild.GetReportGroupTrendOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReportGroupTrend")
	}

	var r0 *codebuild.GetReportGroupTrendOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.GetReportGroupTrendInput, ...func(*codebuild.Options)) (*codebuild.GetReportGroupTrendOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.GetReportGroupTrendInput, ...func(*codebuild.Options)) *codebuild.GetReportGroupTrendOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.GetReportGroupTrendOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.GetReportGroupTrendInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicy(ctx context.Context, params *codebuild.GetResourcePolicyInput, optFns ...func(*codebuild.Options)) (*codebuild.GetResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicy")
	}

	var r0 *codebuild.GetResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.GetResourcePolicyInput, ...func(*codebuild.Options)) (*codebuild.GetResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.GetResourcePolicyInput, ...func(*codebuild.Options)) *codebuild.GetResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.GetResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.GetResourcePolicyInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSourceCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportSourceCredentials(ctx context.Context, params *codebuild.ImportSourceCredentialsInput, optFns ...func(*codebuild.Options)) (*codebuild.ImportSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportSourceCredentials")
	}

	var r0 *codebuild.ImportSourceCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ImportSourceCredentialsInput, ...func(*codebuild.Options)) (*codebuild.ImportSourceCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ImportSourceCredentialsInput, ...func(*codebuild.Options)) *codebuild.ImportSourceCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ImportSourceCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ImportSourceCredentialsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvalidateProjectCache provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InvalidateProjectCache(ctx context.Context, params *codebuild.InvalidateProjectCacheInput, optFns ...func(*codebuild.Options)) (*codebuild.InvalidateProjectCacheOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InvalidateProjectCache")
	}

	var r0 *codebuild.InvalidateProjectCacheOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.InvalidateProjectCacheInput, ...func(*codebuild.Options)) (*codebuild.InvalidateProjectCacheOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.InvalidateProjectCacheInput, ...func(*codebuild.Options)) *codebuild.InvalidateProjectCacheOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.InvalidateProjectCacheOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.InvalidateProjectCacheInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildBatches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuildBatches(ctx context.Context, params *codebuild.ListBuildBatchesInput, optFns ...func(*codebuild.Options)) (*codebuild.ListBuildBatchesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildBatches")
	}

	var r0 *codebuild.ListBuildBatchesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildBatchesInput, ...func(*codebuild.Options)) (*codebuild.ListBuildBatchesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildBatchesInput, ...func(*codebuild.Options)) *codebuild.ListBuildBatchesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildBatchesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildBatchesInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildBatchesForProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuildBatchesForProject(ctx context.Context, params *codebuild.ListBuildBatchesForProjectInput, optFns ...func(*codebuild.Options)) (*codebuild.ListBuildBatchesForProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildBatchesForProject")
	}

	var r0 *codebuild.ListBuildBatchesForProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildBatchesForProjectInput, ...func(*codebuild.Options)) (*codebuild.ListBuildBatchesForProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildBatchesForProjectInput, ...func(*codebuild.Options)) *codebuild.ListBuildBatchesForProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildBatchesForProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildBatchesForProjectInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuilds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuilds(ctx context.Context, params *codebuild.ListBuildsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListBuildsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuilds")
	}

	var r0 *codebuild.ListBuildsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsInput, ...func(*codebuild.Options)) (*codebuild.ListBuildsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsInput, ...func(*codebuild.Options)) *codebuild.ListBuildsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildsForProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuildsForProject(ctx context.Context, params *codebuild.ListBuildsForProjectInput, optFns ...func(*codebuild.Options)) (*codebuild.ListBuildsForProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsForProject")
	}

	var r0 *codebuild.ListBuildsForProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsForProjectInput, ...func(*codebuild.Options)) (*codebuild.ListBuildsForProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsForProjectInput, ...func(*codebuild.Options)) *codebuild.ListBuildsForProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsForProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildsForProjectInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCuratedEnvironmentImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCuratedEnvironmentImages(ctx context.Context, params *codebuild.ListCuratedEnvironmentImagesInput, optFns ...func(*codebuild.Options)) (*codebuild.ListCuratedEnvironmentImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCuratedEnvironmentImages")
	}

	var r0 *codebuild.ListCuratedEnvironmentImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListCuratedEnvironmentImagesInput, ...func(*codebuild.Options)) (*codebuild.ListCuratedEnvironmentImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListCuratedEnvironmentImagesInput, ...func(*codebuild.Options)) *codebuild.ListCuratedEnvironmentImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListCuratedEnvironmentImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListCuratedEnvironmentImagesInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFleets(ctx context.Context, params *codebuild.ListFleetsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFleets")
	}

	var r0 *codebuild.ListFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListFleetsInput, ...func(*codebuild.Options)) (*codebuild.ListFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListFleetsInput, ...func(*codebuild.Options)) *codebuild.ListFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListFleetsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProjects(ctx context.Context, params *codebuild.ListProjectsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 *codebuild.ListProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListProjectsInput, ...func(*codebuild.Options)) (*codebuild.ListProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListProjectsInput, ...func(*codebuild.Options)) *codebuild.ListProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListProjectsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReportGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReportGroups(ctx context.Context, params *codebuild.ListReportGroupsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListReportGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportGroups")
	}

	var r0 *codebuild.ListReportGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportGroupsInput, ...func(*codebuild.Options)) (*codebuild.ListReportGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportGroupsInput, ...func(*codebuild.Options)) *codebuild.ListReportGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListReportGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListReportGroupsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReports(ctx context.Context, params *codebuild.ListReportsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReports")
	}

	var r0 *codebuild.ListReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportsInput, ...func(*codebuild.Options)) (*codebuild.ListReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportsInput, ...func(*codebuild.Options)) *codebuild.ListReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListReportsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReportsForReportGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReportsForReportGroup(ctx context.Context, params *codebuild.ListReportsForReportGroupInput, optFns ...func(*codebuild.Options)) (*codebuild.ListReportsForReportGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportsForReportGroup")
	}

	var r0 *codebuild.ListReportsForReportGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportsForReportGroupInput, ...func(*codebuild.Options)) (*codebuild.ListReportsForReportGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListReportsForReportGroupInput, ...func(*codebuild.Options)) *codebuild.ListReportsForReportGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListReportsForReportGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListReportsForReportGroupInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSharedProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSharedProjects(ctx context.Context, params *codebuild.ListSharedProjectsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListSharedProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSharedProjects")
	}

	var r0 *codebuild.ListSharedProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSharedProjectsInput, ...func(*codebuild.Options)) (*codebuild.ListSharedProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSharedProjectsInput, ...func(*codebuild.Options)) *codebuild.ListSharedProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListSharedProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListSharedProjectsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSharedReportGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSharedReportGroups(ctx context.Context, params *codebuild.ListSharedReportGroupsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListSharedReportGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSharedReportGroups")
	}

	var r0 *codebuild.ListSharedReportGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSharedReportGroupsInput, ...func(*codebuild.Options)) (*codebuild.ListSharedReportGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSharedReportGroupsInput, ...func(*codebuild.Options)) *codebuild.ListSharedReportGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListSharedReportGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListSharedReportGroupsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSourceCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSourceCredentials(ctx context.Context, params *codebuild.ListSourceCredentialsInput, optFns ...func(*codebuild.Options)) (*codebuild.ListSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSourceCredentials")
	}

	var r0 *codebuild.ListSourceCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSourceCredentialsInput, ...func(*codebuild.Options)) (*codebuild.ListSourceCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSourceCredentialsInput, ...func(*codebuild.Options)) *codebuild.ListSourceCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListSourceCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListSourceCredentialsInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() codebuild.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 codebuild.Options
	if rf, ok := ret.Get(0).(func() codebuild.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(codebuild.Options)
	}

	return r0
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *codebuild.PutResourcePolicyInput, optFns ...func(*codebuild.Options)) (*codebuild.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *codebuild.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.PutResourcePolicyInput, ...func(*codebuild.Options)) (*codebuild.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.PutResourcePolicyInput, ...func(*codebuild.Options)) *codebuild.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.PutResourcePolicyInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetryBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetryBuild(ctx context.Context, params *codebuild.RetryBuildInput, optFns ...func(*codebuild.Options)) (*codebuild.RetryBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryBuild")
	}

	var r0 *codebuild.RetryBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.RetryBuildInput, ...func(*codebuild.Options)) (*codebuild.RetryBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.RetryBuildInput, ...func(*codebuild.Options)) *codebuild.RetryBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.RetryBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.RetryBuildInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetryBuildBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetryBuildBatch(ctx context.Context, params *codebuild.RetryBuildBatchInput, optFns ...func(*codebuild.Options)) (*codebuild.RetryBuildBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryBuildBatch")
	}

	var r0 *codebuild.RetryBuildBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.RetryBuildBatchInput, ...func(*codebuild.Options)) (*codebuild.RetryBuildBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.RetryBuildBatchInput, ...func(*codebuild.Options)) *codebuild.RetryBuildBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.RetryBuildBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.RetryBuildBatchInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBuild(ctx context.Context, params *codebuild.StartBuildInput, optFns ...func(*codebuild.Options)) (*codebuild.StartBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBuild")
	}

	var r0 *codebuild.StartBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StartBuildInput, ...func(*codebuild.Options)) (*codebuild.StartBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StartBuildInput, ...func(*codebuild.Options)) *codebuild.StartBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StartBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StartBuildInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBuildBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBuildBatch(ctx context.Context, params *codebuild.StartBuildBatchInput, optFns ...func(*codebuild.Options)) (*codebuild.StartBuildBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBuildBatch")
	}

	var r0 *codebuild.StartBuildBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StartBuildBatchInput, ...func(*codebuild.Options)) (*codebuild.StartBuildBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StartBuildBatchInput, ...func(*codebuild.Options)) *codebuild.StartBuildBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StartBuildBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StartBuildBatchInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopBuild(ctx context.Context, params *codebuild.StopBuildInput, optFns ...func(*codebuild.Options)) (*codebuild.StopBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopBuild")
	}

	var r0 *codebuild.StopBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StopBuildInput, ...func(*codebuild.Options)) (*codebuild.StopBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StopBuildInput, ...func(*codebuild.Options)) *codebuild.StopBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StopBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StopBuildInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBuildBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopBuildBatch(ctx context.Context, params *codebuild.StopBuildBatchInput, optFns ...func(*codebuild.Options)) (*codebuild.StopBuildBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopBuildBatch")
	}

	var r0 *codebuild.StopBuildBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StopBuildBatchInput, ...func(*codebuild.Options)) (*codebuild.StopBuildBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StopBuildBatchInput, ...func(*codebuild.Options)) *codebuild.StopBuildBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StopBuildBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StopBuildBatchInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFleet(ctx context.Context, params *codebuild.UpdateFleetInput, optFns ...func(*codebuild.Options)) (*codebuild.UpdateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFleet")
	}

	var r0 *codebuild.UpdateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateFleetInput, ...func(*codebuild.Options)) (*codebuild.UpdateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateFleetInput, ...func(*codebuild.Options)) *codebuild.UpdateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateFleetInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProject(ctx context.Context, params *codebuild.UpdateProjectInput, optFns ...func(*codebuild.Options)) (*codebuild.UpdateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 *codebuild.UpdateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateProjectInput, ...func(*codebuild.Options)) (*codebuild.UpdateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateProjectInput, ...func(*codebuild.Options)) *codebuild.UpdateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateProjectInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProjectVisibility provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProjectVisibility(ctx context.Context, params *codebuild.UpdateProjectVisibilityInput, optFns ...func(*codebuild.Options)) (*codebuild.UpdateProjectVisibilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProjectVisibility")
	}

	var r0 *codebuild.UpdateProjectVisibilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateProjectVisibilityInput, ...func(*codebuild.Options)) (*codebuild.UpdateProjectVisibilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateProjectVisibilityInput, ...func(*codebuild.Options)) *codebuild.UpdateProjectVisibilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateProjectVisibilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateProjectVisibilityInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateReportGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateReportGroup(ctx context.Context, params *codebuild.UpdateReportGroupInput, optFns ...func(*codebuild.Options)) (*codebuild.UpdateReportGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateReportGroup")
	}

	var r0 *codebuild.UpdateReportGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateReportGroupInput, ...func(*codebuild.Options)) (*codebuild.UpdateReportGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateReportGroupInput, ...func(*codebuild.Options)) *codebuild.UpdateReportGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateReportGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateReportGroupInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebhook provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWebhook(ctx context.Context, params *codebuild.UpdateWebhookInput, optFns ...func(*codebuild.Options)) (*codebuild.UpdateWebhookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWebhook")
	}

	var r0 *codebuild.UpdateWebhookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateWebhookInput, ...func(*codebuild.Options)) (*codebuild.UpdateWebhookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateWebhookInput, ...func(*codebuild.Options)) *codebuild.UpdateWebhookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateWebhookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateWebhookInput, ...func(*codebuild.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
