// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	forecast "github.com/aws/aws-sdk-go-v2/service/forecast"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAutoPredictor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAutoPredictor(ctx context.Context, params *forecast.CreateAutoPredictorInput, optFns ...func(*forecast.Options)) (*forecast.CreateAutoPredictorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAutoPredictor")
	}

	var r0 *forecast.CreateAutoPredictorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateAutoPredictorInput, ...func(*forecast.Options)) (*forecast.CreateAutoPredictorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateAutoPredictorInput, ...func(*forecast.Options)) *forecast.CreateAutoPredictorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateAutoPredictorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateAutoPredictorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataset(ctx context.Context, params *forecast.CreateDatasetInput, optFns ...func(*forecast.Options)) (*forecast.CreateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataset")
	}

	var r0 *forecast.CreateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetInput, ...func(*forecast.Options)) (*forecast.CreateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetInput, ...func(*forecast.Options)) *forecast.CreateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateDatasetInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDatasetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDatasetGroup(ctx context.Context, params *forecast.CreateDatasetGroupInput, optFns ...func(*forecast.Options)) (*forecast.CreateDatasetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatasetGroup")
	}

	var r0 *forecast.CreateDatasetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetGroupInput, ...func(*forecast.Options)) (*forecast.CreateDatasetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetGroupInput, ...func(*forecast.Options)) *forecast.CreateDatasetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateDatasetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateDatasetGroupInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDatasetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDatasetImportJob(ctx context.Context, params *forecast.CreateDatasetImportJobInput, optFns ...func(*forecast.Options)) (*forecast.CreateDatasetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatasetImportJob")
	}

	var r0 *forecast.CreateDatasetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetImportJobInput, ...func(*forecast.Options)) (*forecast.CreateDatasetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateDatasetImportJobInput, ...func(*forecast.Options)) *forecast.CreateDatasetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateDatasetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateDatasetImportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateExplainability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateExplainability(ctx context.Context, params *forecast.CreateExplainabilityInput, optFns ...func(*forecast.Options)) (*forecast.CreateExplainabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExplainability")
	}

	var r0 *forecast.CreateExplainabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateExplainabilityInput, ...func(*forecast.Options)) (*forecast.CreateExplainabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateExplainabilityInput, ...func(*forecast.Options)) *forecast.CreateExplainabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateExplainabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateExplainabilityInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateExplainabilityExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateExplainabilityExport(ctx context.Context, params *forecast.CreateExplainabilityExportInput, optFns ...func(*forecast.Options)) (*forecast.CreateExplainabilityExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExplainabilityExport")
	}

	var r0 *forecast.CreateExplainabilityExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateExplainabilityExportInput, ...func(*forecast.Options)) (*forecast.CreateExplainabilityExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateExplainabilityExportInput, ...func(*forecast.Options)) *forecast.CreateExplainabilityExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateExplainabilityExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateExplainabilityExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateForecast(ctx context.Context, params *forecast.CreateForecastInput, optFns ...func(*forecast.Options)) (*forecast.CreateForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateForecast")
	}

	var r0 *forecast.CreateForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateForecastInput, ...func(*forecast.Options)) (*forecast.CreateForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateForecastInput, ...func(*forecast.Options)) *forecast.CreateForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateForecastExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateForecastExportJob(ctx context.Context, params *forecast.CreateForecastExportJobInput, optFns ...func(*forecast.Options)) (*forecast.CreateForecastExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateForecastExportJob")
	}

	var r0 *forecast.CreateForecastExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateForecastExportJobInput, ...func(*forecast.Options)) (*forecast.CreateForecastExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateForecastExportJobInput, ...func(*forecast.Options)) *forecast.CreateForecastExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateForecastExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateForecastExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMonitor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMonitor(ctx context.Context, params *forecast.CreateMonitorInput, optFns ...func(*forecast.Options)) (*forecast.CreateMonitorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMonitor")
	}

	var r0 *forecast.CreateMonitorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateMonitorInput, ...func(*forecast.Options)) (*forecast.CreateMonitorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateMonitorInput, ...func(*forecast.Options)) *forecast.CreateMonitorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateMonitorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateMonitorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePredictor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePredictor(ctx context.Context, params *forecast.CreatePredictorInput, optFns ...func(*forecast.Options)) (*forecast.CreatePredictorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePredictor")
	}

	var r0 *forecast.CreatePredictorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreatePredictorInput, ...func(*forecast.Options)) (*forecast.CreatePredictorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreatePredictorInput, ...func(*forecast.Options)) *forecast.CreatePredictorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreatePredictorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreatePredictorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePredictorBacktestExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePredictorBacktestExportJob(ctx context.Context, params *forecast.CreatePredictorBacktestExportJobInput, optFns ...func(*forecast.Options)) (*forecast.CreatePredictorBacktestExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePredictorBacktestExportJob")
	}

	var r0 *forecast.CreatePredictorBacktestExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreatePredictorBacktestExportJobInput, ...func(*forecast.Options)) (*forecast.CreatePredictorBacktestExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreatePredictorBacktestExportJobInput, ...func(*forecast.Options)) *forecast.CreatePredictorBacktestExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreatePredictorBacktestExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreatePredictorBacktestExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWhatIfAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWhatIfAnalysis(ctx context.Context, params *forecast.CreateWhatIfAnalysisInput, optFns ...func(*forecast.Options)) (*forecast.CreateWhatIfAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWhatIfAnalysis")
	}

	var r0 *forecast.CreateWhatIfAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfAnalysisInput, ...func(*forecast.Options)) (*forecast.CreateWhatIfAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfAnalysisInput, ...func(*forecast.Options)) *forecast.CreateWhatIfAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateWhatIfAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateWhatIfAnalysisInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWhatIfForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWhatIfForecast(ctx context.Context, params *forecast.CreateWhatIfForecastInput, optFns ...func(*forecast.Options)) (*forecast.CreateWhatIfForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWhatIfForecast")
	}

	var r0 *forecast.CreateWhatIfForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfForecastInput, ...func(*forecast.Options)) (*forecast.CreateWhatIfForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfForecastInput, ...func(*forecast.Options)) *forecast.CreateWhatIfForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateWhatIfForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateWhatIfForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWhatIfForecastExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWhatIfForecastExport(ctx context.Context, params *forecast.CreateWhatIfForecastExportInput, optFns ...func(*forecast.Options)) (*forecast.CreateWhatIfForecastExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWhatIfForecastExport")
	}

	var r0 *forecast.CreateWhatIfForecastExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfForecastExportInput, ...func(*forecast.Options)) (*forecast.CreateWhatIfForecastExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.CreateWhatIfForecastExportInput, ...func(*forecast.Options)) *forecast.CreateWhatIfForecastExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.CreateWhatIfForecastExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.CreateWhatIfForecastExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataset(ctx context.Context, params *forecast.DeleteDatasetInput, optFns ...func(*forecast.Options)) (*forecast.DeleteDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataset")
	}

	var r0 *forecast.DeleteDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetInput, ...func(*forecast.Options)) (*forecast.DeleteDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetInput, ...func(*forecast.Options)) *forecast.DeleteDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteDatasetInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDatasetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDatasetGroup(ctx context.Context, params *forecast.DeleteDatasetGroupInput, optFns ...func(*forecast.Options)) (*forecast.DeleteDatasetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatasetGroup")
	}

	var r0 *forecast.DeleteDatasetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetGroupInput, ...func(*forecast.Options)) (*forecast.DeleteDatasetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetGroupInput, ...func(*forecast.Options)) *forecast.DeleteDatasetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteDatasetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteDatasetGroupInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDatasetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDatasetImportJob(ctx context.Context, params *forecast.DeleteDatasetImportJobInput, optFns ...func(*forecast.Options)) (*forecast.DeleteDatasetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatasetImportJob")
	}

	var r0 *forecast.DeleteDatasetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetImportJobInput, ...func(*forecast.Options)) (*forecast.DeleteDatasetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteDatasetImportJobInput, ...func(*forecast.Options)) *forecast.DeleteDatasetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteDatasetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteDatasetImportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExplainability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteExplainability(ctx context.Context, params *forecast.DeleteExplainabilityInput, optFns ...func(*forecast.Options)) (*forecast.DeleteExplainabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExplainability")
	}

	var r0 *forecast.DeleteExplainabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteExplainabilityInput, ...func(*forecast.Options)) (*forecast.DeleteExplainabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteExplainabilityInput, ...func(*forecast.Options)) *forecast.DeleteExplainabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteExplainabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteExplainabilityInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExplainabilityExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteExplainabilityExport(ctx context.Context, params *forecast.DeleteExplainabilityExportInput, optFns ...func(*forecast.Options)) (*forecast.DeleteExplainabilityExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExplainabilityExport")
	}

	var r0 *forecast.DeleteExplainabilityExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteExplainabilityExportInput, ...func(*forecast.Options)) (*forecast.DeleteExplainabilityExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteExplainabilityExportInput, ...func(*forecast.Options)) *forecast.DeleteExplainabilityExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteExplainabilityExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteExplainabilityExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteForecast(ctx context.Context, params *forecast.DeleteForecastInput, optFns ...func(*forecast.Options)) (*forecast.DeleteForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteForecast")
	}

	var r0 *forecast.DeleteForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteForecastInput, ...func(*forecast.Options)) (*forecast.DeleteForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteForecastInput, ...func(*forecast.Options)) *forecast.DeleteForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteForecastExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteForecastExportJob(ctx context.Context, params *forecast.DeleteForecastExportJobInput, optFns ...func(*forecast.Options)) (*forecast.DeleteForecastExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteForecastExportJob")
	}

	var r0 *forecast.DeleteForecastExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteForecastExportJobInput, ...func(*forecast.Options)) (*forecast.DeleteForecastExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteForecastExportJobInput, ...func(*forecast.Options)) *forecast.DeleteForecastExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteForecastExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteForecastExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMonitor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMonitor(ctx context.Context, params *forecast.DeleteMonitorInput, optFns ...func(*forecast.Options)) (*forecast.DeleteMonitorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMonitor")
	}

	var r0 *forecast.DeleteMonitorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteMonitorInput, ...func(*forecast.Options)) (*forecast.DeleteMonitorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteMonitorInput, ...func(*forecast.Options)) *forecast.DeleteMonitorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteMonitorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteMonitorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePredictor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePredictor(ctx context.Context, params *forecast.DeletePredictorInput, optFns ...func(*forecast.Options)) (*forecast.DeletePredictorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePredictor")
	}

	var r0 *forecast.DeletePredictorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeletePredictorInput, ...func(*forecast.Options)) (*forecast.DeletePredictorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeletePredictorInput, ...func(*forecast.Options)) *forecast.DeletePredictorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeletePredictorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeletePredictorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePredictorBacktestExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePredictorBacktestExportJob(ctx context.Context, params *forecast.DeletePredictorBacktestExportJobInput, optFns ...func(*forecast.Options)) (*forecast.DeletePredictorBacktestExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePredictorBacktestExportJob")
	}

	var r0 *forecast.DeletePredictorBacktestExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeletePredictorBacktestExportJobInput, ...func(*forecast.Options)) (*forecast.DeletePredictorBacktestExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeletePredictorBacktestExportJobInput, ...func(*forecast.Options)) *forecast.DeletePredictorBacktestExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeletePredictorBacktestExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeletePredictorBacktestExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourceTree provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourceTree(ctx context.Context, params *forecast.DeleteResourceTreeInput, optFns ...func(*forecast.Options)) (*forecast.DeleteResourceTreeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourceTree")
	}

	var r0 *forecast.DeleteResourceTreeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteResourceTreeInput, ...func(*forecast.Options)) (*forecast.DeleteResourceTreeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteResourceTreeInput, ...func(*forecast.Options)) *forecast.DeleteResourceTreeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteResourceTreeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteResourceTreeInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWhatIfAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWhatIfAnalysis(ctx context.Context, params *forecast.DeleteWhatIfAnalysisInput, optFns ...func(*forecast.Options)) (*forecast.DeleteWhatIfAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWhatIfAnalysis")
	}

	var r0 *forecast.DeleteWhatIfAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfAnalysisInput, ...func(*forecast.Options)) (*forecast.DeleteWhatIfAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfAnalysisInput, ...func(*forecast.Options)) *forecast.DeleteWhatIfAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteWhatIfAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteWhatIfAnalysisInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWhatIfForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWhatIfForecast(ctx context.Context, params *forecast.DeleteWhatIfForecastInput, optFns ...func(*forecast.Options)) (*forecast.DeleteWhatIfForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWhatIfForecast")
	}

	var r0 *forecast.DeleteWhatIfForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfForecastInput, ...func(*forecast.Options)) (*forecast.DeleteWhatIfForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfForecastInput, ...func(*forecast.Options)) *forecast.DeleteWhatIfForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteWhatIfForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteWhatIfForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWhatIfForecastExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWhatIfForecastExport(ctx context.Context, params *forecast.DeleteWhatIfForecastExportInput, optFns ...func(*forecast.Options)) (*forecast.DeleteWhatIfForecastExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWhatIfForecastExport")
	}

	var r0 *forecast.DeleteWhatIfForecastExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfForecastExportInput, ...func(*forecast.Options)) (*forecast.DeleteWhatIfForecastExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DeleteWhatIfForecastExportInput, ...func(*forecast.Options)) *forecast.DeleteWhatIfForecastExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DeleteWhatIfForecastExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DeleteWhatIfForecastExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAutoPredictor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAutoPredictor(ctx context.Context, params *forecast.DescribeAutoPredictorInput, optFns ...func(*forecast.Options)) (*forecast.DescribeAutoPredictorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAutoPredictor")
	}

	var r0 *forecast.DescribeAutoPredictorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeAutoPredictorInput, ...func(*forecast.Options)) (*forecast.DescribeAutoPredictorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeAutoPredictorInput, ...func(*forecast.Options)) *forecast.DescribeAutoPredictorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeAutoPredictorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeAutoPredictorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataset(ctx context.Context, params *forecast.DescribeDatasetInput, optFns ...func(*forecast.Options)) (*forecast.DescribeDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataset")
	}

	var r0 *forecast.DescribeDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetInput, ...func(*forecast.Options)) (*forecast.DescribeDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetInput, ...func(*forecast.Options)) *forecast.DescribeDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeDatasetInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDatasetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDatasetGroup(ctx context.Context, params *forecast.DescribeDatasetGroupInput, optFns ...func(*forecast.Options)) (*forecast.DescribeDatasetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDatasetGroup")
	}

	var r0 *forecast.DescribeDatasetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetGroupInput, ...func(*forecast.Options)) (*forecast.DescribeDatasetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetGroupInput, ...func(*forecast.Options)) *forecast.DescribeDatasetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeDatasetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeDatasetGroupInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDatasetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDatasetImportJob(ctx context.Context, params *forecast.DescribeDatasetImportJobInput, optFns ...func(*forecast.Options)) (*forecast.DescribeDatasetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDatasetImportJob")
	}

	var r0 *forecast.DescribeDatasetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetImportJobInput, ...func(*forecast.Options)) (*forecast.DescribeDatasetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeDatasetImportJobInput, ...func(*forecast.Options)) *forecast.DescribeDatasetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeDatasetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeDatasetImportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExplainability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExplainability(ctx context.Context, params *forecast.DescribeExplainabilityInput, optFns ...func(*forecast.Options)) (*forecast.DescribeExplainabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExplainability")
	}

	var r0 *forecast.DescribeExplainabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeExplainabilityInput, ...func(*forecast.Options)) (*forecast.DescribeExplainabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeExplainabilityInput, ...func(*forecast.Options)) *forecast.DescribeExplainabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeExplainabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeExplainabilityInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExplainabilityExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExplainabilityExport(ctx context.Context, params *forecast.DescribeExplainabilityExportInput, optFns ...func(*forecast.Options)) (*forecast.DescribeExplainabilityExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExplainabilityExport")
	}

	var r0 *forecast.DescribeExplainabilityExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeExplainabilityExportInput, ...func(*forecast.Options)) (*forecast.DescribeExplainabilityExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeExplainabilityExportInput, ...func(*forecast.Options)) *forecast.DescribeExplainabilityExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeExplainabilityExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeExplainabilityExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeForecast(ctx context.Context, params *forecast.DescribeForecastInput, optFns ...func(*forecast.Options)) (*forecast.DescribeForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeForecast")
	}

	var r0 *forecast.DescribeForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeForecastInput, ...func(*forecast.Options)) (*forecast.DescribeForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeForecastInput, ...func(*forecast.Options)) *forecast.DescribeForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeForecastExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeForecastExportJob(ctx context.Context, params *forecast.DescribeForecastExportJobInput, optFns ...func(*forecast.Options)) (*forecast.DescribeForecastExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeForecastExportJob")
	}

	var r0 *forecast.DescribeForecastExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeForecastExportJobInput, ...func(*forecast.Options)) (*forecast.DescribeForecastExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeForecastExportJobInput, ...func(*forecast.Options)) *forecast.DescribeForecastExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeForecastExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeForecastExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMonitor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMonitor(ctx context.Context, params *forecast.DescribeMonitorInput, optFns ...func(*forecast.Options)) (*forecast.DescribeMonitorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMonitor")
	}

	var r0 *forecast.DescribeMonitorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeMonitorInput, ...func(*forecast.Options)) (*forecast.DescribeMonitorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeMonitorInput, ...func(*forecast.Options)) *forecast.DescribeMonitorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeMonitorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeMonitorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePredictor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePredictor(ctx context.Context, params *forecast.DescribePredictorInput, optFns ...func(*forecast.Options)) (*forecast.DescribePredictorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePredictor")
	}

	var r0 *forecast.DescribePredictorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribePredictorInput, ...func(*forecast.Options)) (*forecast.DescribePredictorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribePredictorInput, ...func(*forecast.Options)) *forecast.DescribePredictorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribePredictorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribePredictorInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePredictorBacktestExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePredictorBacktestExportJob(ctx context.Context, params *forecast.DescribePredictorBacktestExportJobInput, optFns ...func(*forecast.Options)) (*forecast.DescribePredictorBacktestExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePredictorBacktestExportJob")
	}

	var r0 *forecast.DescribePredictorBacktestExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribePredictorBacktestExportJobInput, ...func(*forecast.Options)) (*forecast.DescribePredictorBacktestExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribePredictorBacktestExportJobInput, ...func(*forecast.Options)) *forecast.DescribePredictorBacktestExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribePredictorBacktestExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribePredictorBacktestExportJobInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWhatIfAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWhatIfAnalysis(ctx context.Context, params *forecast.DescribeWhatIfAnalysisInput, optFns ...func(*forecast.Options)) (*forecast.DescribeWhatIfAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWhatIfAnalysis")
	}

	var r0 *forecast.DescribeWhatIfAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfAnalysisInput, ...func(*forecast.Options)) (*forecast.DescribeWhatIfAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfAnalysisInput, ...func(*forecast.Options)) *forecast.DescribeWhatIfAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeWhatIfAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeWhatIfAnalysisInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWhatIfForecast provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWhatIfForecast(ctx context.Context, params *forecast.DescribeWhatIfForecastInput, optFns ...func(*forecast.Options)) (*forecast.DescribeWhatIfForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWhatIfForecast")
	}

	var r0 *forecast.DescribeWhatIfForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfForecastInput, ...func(*forecast.Options)) (*forecast.DescribeWhatIfForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfForecastInput, ...func(*forecast.Options)) *forecast.DescribeWhatIfForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeWhatIfForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeWhatIfForecastInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWhatIfForecastExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWhatIfForecastExport(ctx context.Context, params *forecast.DescribeWhatIfForecastExportInput, optFns ...func(*forecast.Options)) (*forecast.DescribeWhatIfForecastExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWhatIfForecastExport")
	}

	var r0 *forecast.DescribeWhatIfForecastExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfForecastExportInput, ...func(*forecast.Options)) (*forecast.DescribeWhatIfForecastExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.DescribeWhatIfForecastExportInput, ...func(*forecast.Options)) *forecast.DescribeWhatIfForecastExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.DescribeWhatIfForecastExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.DescribeWhatIfForecastExportInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccuracyMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccuracyMetrics(ctx context.Context, params *forecast.GetAccuracyMetricsInput, optFns ...func(*forecast.Options)) (*forecast.GetAccuracyMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccuracyMetrics")
	}

	var r0 *forecast.GetAccuracyMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.GetAccuracyMetricsInput, ...func(*forecast.Options)) (*forecast.GetAccuracyMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.GetAccuracyMetricsInput, ...func(*forecast.Options)) *forecast.GetAccuracyMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.GetAccuracyMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.GetAccuracyMetricsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasetGroups(ctx context.Context, params *forecast.ListDatasetGroupsInput, optFns ...func(*forecast.Options)) (*forecast.ListDatasetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasetGroups")
	}

	var r0 *forecast.ListDatasetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetGroupsInput, ...func(*forecast.Options)) (*forecast.ListDatasetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetGroupsInput, ...func(*forecast.Options)) *forecast.ListDatasetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListDatasetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListDatasetGroupsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasetImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasetImportJobs(ctx context.Context, params *forecast.ListDatasetImportJobsInput, optFns ...func(*forecast.Options)) (*forecast.ListDatasetImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasetImportJobs")
	}

	var r0 *forecast.ListDatasetImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetImportJobsInput, ...func(*forecast.Options)) (*forecast.ListDatasetImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetImportJobsInput, ...func(*forecast.Options)) *forecast.ListDatasetImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListDatasetImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListDatasetImportJobsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasets(ctx context.Context, params *forecast.ListDatasetsInput, optFns ...func(*forecast.Options)) (*forecast.ListDatasetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasets")
	}

	var r0 *forecast.ListDatasetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetsInput, ...func(*forecast.Options)) (*forecast.ListDatasetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListDatasetsInput, ...func(*forecast.Options)) *forecast.ListDatasetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListDatasetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListDatasetsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExplainabilities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExplainabilities(ctx context.Context, params *forecast.ListExplainabilitiesInput, optFns ...func(*forecast.Options)) (*forecast.ListExplainabilitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExplainabilities")
	}

	var r0 *forecast.ListExplainabilitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListExplainabilitiesInput, ...func(*forecast.Options)) (*forecast.ListExplainabilitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListExplainabilitiesInput, ...func(*forecast.Options)) *forecast.ListExplainabilitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListExplainabilitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListExplainabilitiesInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExplainabilityExports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExplainabilityExports(ctx context.Context, params *forecast.ListExplainabilityExportsInput, optFns ...func(*forecast.Options)) (*forecast.ListExplainabilityExportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExplainabilityExports")
	}

	var r0 *forecast.ListExplainabilityExportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListExplainabilityExportsInput, ...func(*forecast.Options)) (*forecast.ListExplainabilityExportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListExplainabilityExportsInput, ...func(*forecast.Options)) *forecast.ListExplainabilityExportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListExplainabilityExportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListExplainabilityExportsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListForecastExportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListForecastExportJobs(ctx context.Context, params *forecast.ListForecastExportJobsInput, optFns ...func(*forecast.Options)) (*forecast.ListForecastExportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListForecastExportJobs")
	}

	var r0 *forecast.ListForecastExportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListForecastExportJobsInput, ...func(*forecast.Options)) (*forecast.ListForecastExportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListForecastExportJobsInput, ...func(*forecast.Options)) *forecast.ListForecastExportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListForecastExportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListForecastExportJobsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListForecasts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListForecasts(ctx context.Context, params *forecast.ListForecastsInput, optFns ...func(*forecast.Options)) (*forecast.ListForecastsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListForecasts")
	}

	var r0 *forecast.ListForecastsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListForecastsInput, ...func(*forecast.Options)) (*forecast.ListForecastsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListForecastsInput, ...func(*forecast.Options)) *forecast.ListForecastsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListForecastsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListForecastsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMonitorEvaluations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMonitorEvaluations(ctx context.Context, params *forecast.ListMonitorEvaluationsInput, optFns ...func(*forecast.Options)) (*forecast.ListMonitorEvaluationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMonitorEvaluations")
	}

	var r0 *forecast.ListMonitorEvaluationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListMonitorEvaluationsInput, ...func(*forecast.Options)) (*forecast.ListMonitorEvaluationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListMonitorEvaluationsInput, ...func(*forecast.Options)) *forecast.ListMonitorEvaluationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListMonitorEvaluationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListMonitorEvaluationsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMonitors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMonitors(ctx context.Context, params *forecast.ListMonitorsInput, optFns ...func(*forecast.Options)) (*forecast.ListMonitorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMonitors")
	}

	var r0 *forecast.ListMonitorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListMonitorsInput, ...func(*forecast.Options)) (*forecast.ListMonitorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListMonitorsInput, ...func(*forecast.Options)) *forecast.ListMonitorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListMonitorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListMonitorsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPredictorBacktestExportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPredictorBacktestExportJobs(ctx context.Context, params *forecast.ListPredictorBacktestExportJobsInput, optFns ...func(*forecast.Options)) (*forecast.ListPredictorBacktestExportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPredictorBacktestExportJobs")
	}

	var r0 *forecast.ListPredictorBacktestExportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListPredictorBacktestExportJobsInput, ...func(*forecast.Options)) (*forecast.ListPredictorBacktestExportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListPredictorBacktestExportJobsInput, ...func(*forecast.Options)) *forecast.ListPredictorBacktestExportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListPredictorBacktestExportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListPredictorBacktestExportJobsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPredictors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPredictors(ctx context.Context, params *forecast.ListPredictorsInput, optFns ...func(*forecast.Options)) (*forecast.ListPredictorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPredictors")
	}

	var r0 *forecast.ListPredictorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListPredictorsInput, ...func(*forecast.Options)) (*forecast.ListPredictorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListPredictorsInput, ...func(*forecast.Options)) *forecast.ListPredictorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListPredictorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListPredictorsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *forecast.ListTagsForResourceInput, optFns ...func(*forecast.Options)) (*forecast.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *forecast.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListTagsForResourceInput, ...func(*forecast.Options)) (*forecast.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListTagsForResourceInput, ...func(*forecast.Options)) *forecast.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListTagsForResourceInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWhatIfAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWhatIfAnalyses(ctx context.Context, params *forecast.ListWhatIfAnalysesInput, optFns ...func(*forecast.Options)) (*forecast.ListWhatIfAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWhatIfAnalyses")
	}

	var r0 *forecast.ListWhatIfAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfAnalysesInput, ...func(*forecast.Options)) (*forecast.ListWhatIfAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfAnalysesInput, ...func(*forecast.Options)) *forecast.ListWhatIfAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListWhatIfAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListWhatIfAnalysesInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWhatIfForecastExports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWhatIfForecastExports(ctx context.Context, params *forecast.ListWhatIfForecastExportsInput, optFns ...func(*forecast.Options)) (*forecast.ListWhatIfForecastExportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWhatIfForecastExports")
	}

	var r0 *forecast.ListWhatIfForecastExportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfForecastExportsInput, ...func(*forecast.Options)) (*forecast.ListWhatIfForecastExportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfForecastExportsInput, ...func(*forecast.Options)) *forecast.ListWhatIfForecastExportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListWhatIfForecastExportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListWhatIfForecastExportsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWhatIfForecasts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWhatIfForecasts(ctx context.Context, params *forecast.ListWhatIfForecastsInput, optFns ...func(*forecast.Options)) (*forecast.ListWhatIfForecastsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWhatIfForecasts")
	}

	var r0 *forecast.ListWhatIfForecastsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfForecastsInput, ...func(*forecast.Options)) (*forecast.ListWhatIfForecastsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ListWhatIfForecastsInput, ...func(*forecast.Options)) *forecast.ListWhatIfForecastsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ListWhatIfForecastsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ListWhatIfForecastsInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() forecast.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 forecast.Options
	if rf, ok := ret.Get(0).(func() forecast.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(forecast.Options)
	}

	return r0
}

// ResumeResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResumeResource(ctx context.Context, params *forecast.ResumeResourceInput, optFns ...func(*forecast.Options)) (*forecast.ResumeResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeResource")
	}

	var r0 *forecast.ResumeResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ResumeResourceInput, ...func(*forecast.Options)) (*forecast.ResumeResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.ResumeResourceInput, ...func(*forecast.Options)) *forecast.ResumeResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.ResumeResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.ResumeResourceInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopResource(ctx context.Context, params *forecast.StopResourceInput, optFns ...func(*forecast.Options)) (*forecast.StopResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopResource")
	}

	var r0 *forecast.StopResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.StopResourceInput, ...func(*forecast.Options)) (*forecast.StopResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.StopResourceInput, ...func(*forecast.Options)) *forecast.StopResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.StopResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.StopResourceInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *forecast.TagResourceInput, optFns ...func(*forecast.Options)) (*forecast.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *forecast.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.TagResourceInput, ...func(*forecast.Options)) (*forecast.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.TagResourceInput, ...func(*forecast.Options)) *forecast.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.TagResourceInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *forecast.UntagResourceInput, optFns ...func(*forecast.Options)) (*forecast.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *forecast.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.UntagResourceInput, ...func(*forecast.Options)) (*forecast.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.UntagResourceInput, ...func(*forecast.Options)) *forecast.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.UntagResourceInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDatasetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDatasetGroup(ctx context.Context, params *forecast.UpdateDatasetGroupInput, optFns ...func(*forecast.Options)) (*forecast.UpdateDatasetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatasetGroup")
	}

	var r0 *forecast.UpdateDatasetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.UpdateDatasetGroupInput, ...func(*forecast.Options)) (*forecast.UpdateDatasetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *forecast.UpdateDatasetGroupInput, ...func(*forecast.Options)) *forecast.UpdateDatasetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*forecast.UpdateDatasetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *forecast.UpdateDatasetGroupInput, ...func(*forecast.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
