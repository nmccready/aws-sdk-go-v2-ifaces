// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	sfn "github.com/aws/aws-sdk-go-v2/service/sfn"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateActivity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateActivity(ctx context.Context, params *sfn.CreateActivityInput, optFns ...func(*sfn.Options)) (*sfn.CreateActivityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateActivity")
	}

	var r0 *sfn.CreateActivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateActivityInput, ...func(*sfn.Options)) (*sfn.CreateActivityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateActivityInput, ...func(*sfn.Options)) *sfn.CreateActivityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.CreateActivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.CreateActivityInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStateMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStateMachine(ctx context.Context, params *sfn.CreateStateMachineInput, optFns ...func(*sfn.Options)) (*sfn.CreateStateMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStateMachine")
	}

	var r0 *sfn.CreateStateMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateStateMachineInput, ...func(*sfn.Options)) (*sfn.CreateStateMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateStateMachineInput, ...func(*sfn.Options)) *sfn.CreateStateMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.CreateStateMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.CreateStateMachineInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStateMachineAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStateMachineAlias(ctx context.Context, params *sfn.CreateStateMachineAliasInput, optFns ...func(*sfn.Options)) (*sfn.CreateStateMachineAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStateMachineAlias")
	}

	var r0 *sfn.CreateStateMachineAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateStateMachineAliasInput, ...func(*sfn.Options)) (*sfn.CreateStateMachineAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.CreateStateMachineAliasInput, ...func(*sfn.Options)) *sfn.CreateStateMachineAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.CreateStateMachineAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.CreateStateMachineAliasInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteActivity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteActivity(ctx context.Context, params *sfn.DeleteActivityInput, optFns ...func(*sfn.Options)) (*sfn.DeleteActivityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteActivity")
	}

	var r0 *sfn.DeleteActivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteActivityInput, ...func(*sfn.Options)) (*sfn.DeleteActivityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteActivityInput, ...func(*sfn.Options)) *sfn.DeleteActivityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DeleteActivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DeleteActivityInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStateMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStateMachine(ctx context.Context, params *sfn.DeleteStateMachineInput, optFns ...func(*sfn.Options)) (*sfn.DeleteStateMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStateMachine")
	}

	var r0 *sfn.DeleteStateMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineInput, ...func(*sfn.Options)) (*sfn.DeleteStateMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineInput, ...func(*sfn.Options)) *sfn.DeleteStateMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DeleteStateMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DeleteStateMachineInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStateMachineAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStateMachineAlias(ctx context.Context, params *sfn.DeleteStateMachineAliasInput, optFns ...func(*sfn.Options)) (*sfn.DeleteStateMachineAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStateMachineAlias")
	}

	var r0 *sfn.DeleteStateMachineAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineAliasInput, ...func(*sfn.Options)) (*sfn.DeleteStateMachineAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineAliasInput, ...func(*sfn.Options)) *sfn.DeleteStateMachineAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DeleteStateMachineAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DeleteStateMachineAliasInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStateMachineVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStateMachineVersion(ctx context.Context, params *sfn.DeleteStateMachineVersionInput, optFns ...func(*sfn.Options)) (*sfn.DeleteStateMachineVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStateMachineVersion")
	}

	var r0 *sfn.DeleteStateMachineVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineVersionInput, ...func(*sfn.Options)) (*sfn.DeleteStateMachineVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DeleteStateMachineVersionInput, ...func(*sfn.Options)) *sfn.DeleteStateMachineVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DeleteStateMachineVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DeleteStateMachineVersionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeActivity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeActivity(ctx context.Context, params *sfn.DescribeActivityInput, optFns ...func(*sfn.Options)) (*sfn.DescribeActivityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeActivity")
	}

	var r0 *sfn.DescribeActivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeActivityInput, ...func(*sfn.Options)) (*sfn.DescribeActivityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeActivityInput, ...func(*sfn.Options)) *sfn.DescribeActivityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeActivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeActivityInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExecution(ctx context.Context, params *sfn.DescribeExecutionInput, optFns ...func(*sfn.Options)) (*sfn.DescribeExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExecution")
	}

	var r0 *sfn.DescribeExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeExecutionInput, ...func(*sfn.Options)) (*sfn.DescribeExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeExecutionInput, ...func(*sfn.Options)) *sfn.DescribeExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMapRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMapRun(ctx context.Context, params *sfn.DescribeMapRunInput, optFns ...func(*sfn.Options)) (*sfn.DescribeMapRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMapRun")
	}

	var r0 *sfn.DescribeMapRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeMapRunInput, ...func(*sfn.Options)) (*sfn.DescribeMapRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeMapRunInput, ...func(*sfn.Options)) *sfn.DescribeMapRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeMapRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeMapRunInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStateMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStateMachine(ctx context.Context, params *sfn.DescribeStateMachineInput, optFns ...func(*sfn.Options)) (*sfn.DescribeStateMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStateMachine")
	}

	var r0 *sfn.DescribeStateMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineInput, ...func(*sfn.Options)) (*sfn.DescribeStateMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineInput, ...func(*sfn.Options)) *sfn.DescribeStateMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeStateMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeStateMachineInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStateMachineAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStateMachineAlias(ctx context.Context, params *sfn.DescribeStateMachineAliasInput, optFns ...func(*sfn.Options)) (*sfn.DescribeStateMachineAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStateMachineAlias")
	}

	var r0 *sfn.DescribeStateMachineAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineAliasInput, ...func(*sfn.Options)) (*sfn.DescribeStateMachineAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineAliasInput, ...func(*sfn.Options)) *sfn.DescribeStateMachineAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeStateMachineAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeStateMachineAliasInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStateMachineForExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStateMachineForExecution(ctx context.Context, params *sfn.DescribeStateMachineForExecutionInput, optFns ...func(*sfn.Options)) (*sfn.DescribeStateMachineForExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStateMachineForExecution")
	}

	var r0 *sfn.DescribeStateMachineForExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineForExecutionInput, ...func(*sfn.Options)) (*sfn.DescribeStateMachineForExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.DescribeStateMachineForExecutionInput, ...func(*sfn.Options)) *sfn.DescribeStateMachineForExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.DescribeStateMachineForExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.DescribeStateMachineForExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActivityTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetActivityTask(ctx context.Context, params *sfn.GetActivityTaskInput, optFns ...func(*sfn.Options)) (*sfn.GetActivityTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetActivityTask")
	}

	var r0 *sfn.GetActivityTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.GetActivityTaskInput, ...func(*sfn.Options)) (*sfn.GetActivityTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.GetActivityTaskInput, ...func(*sfn.Options)) *sfn.GetActivityTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.GetActivityTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.GetActivityTaskInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExecutionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetExecutionHistory(ctx context.Context, params *sfn.GetExecutionHistoryInput, optFns ...func(*sfn.Options)) (*sfn.GetExecutionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionHistory")
	}

	var r0 *sfn.GetExecutionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.GetExecutionHistoryInput, ...func(*sfn.Options)) (*sfn.GetExecutionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.GetExecutionHistoryInput, ...func(*sfn.Options)) *sfn.GetExecutionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.GetExecutionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.GetExecutionHistoryInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActivities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActivities(ctx context.Context, params *sfn.ListActivitiesInput, optFns ...func(*sfn.Options)) (*sfn.ListActivitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActivities")
	}

	var r0 *sfn.ListActivitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListActivitiesInput, ...func(*sfn.Options)) (*sfn.ListActivitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListActivitiesInput, ...func(*sfn.Options)) *sfn.ListActivitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListActivitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListActivitiesInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExecutions(ctx context.Context, params *sfn.ListExecutionsInput, optFns ...func(*sfn.Options)) (*sfn.ListExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExecutions")
	}

	var r0 *sfn.ListExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListExecutionsInput, ...func(*sfn.Options)) (*sfn.ListExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListExecutionsInput, ...func(*sfn.Options)) *sfn.ListExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListExecutionsInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMapRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMapRuns(ctx context.Context, params *sfn.ListMapRunsInput, optFns ...func(*sfn.Options)) (*sfn.ListMapRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMapRuns")
	}

	var r0 *sfn.ListMapRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListMapRunsInput, ...func(*sfn.Options)) (*sfn.ListMapRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListMapRunsInput, ...func(*sfn.Options)) *sfn.ListMapRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListMapRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListMapRunsInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStateMachineAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStateMachineAliases(ctx context.Context, params *sfn.ListStateMachineAliasesInput, optFns ...func(*sfn.Options)) (*sfn.ListStateMachineAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStateMachineAliases")
	}

	var r0 *sfn.ListStateMachineAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachineAliasesInput, ...func(*sfn.Options)) (*sfn.ListStateMachineAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachineAliasesInput, ...func(*sfn.Options)) *sfn.ListStateMachineAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListStateMachineAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListStateMachineAliasesInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStateMachineVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStateMachineVersions(ctx context.Context, params *sfn.ListStateMachineVersionsInput, optFns ...func(*sfn.Options)) (*sfn.ListStateMachineVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStateMachineVersions")
	}

	var r0 *sfn.ListStateMachineVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachineVersionsInput, ...func(*sfn.Options)) (*sfn.ListStateMachineVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachineVersionsInput, ...func(*sfn.Options)) *sfn.ListStateMachineVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListStateMachineVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListStateMachineVersionsInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStateMachines provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStateMachines(ctx context.Context, params *sfn.ListStateMachinesInput, optFns ...func(*sfn.Options)) (*sfn.ListStateMachinesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStateMachines")
	}

	var r0 *sfn.ListStateMachinesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachinesInput, ...func(*sfn.Options)) (*sfn.ListStateMachinesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListStateMachinesInput, ...func(*sfn.Options)) *sfn.ListStateMachinesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListStateMachinesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListStateMachinesInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *sfn.ListTagsForResourceInput, optFns ...func(*sfn.Options)) (*sfn.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *sfn.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListTagsForResourceInput, ...func(*sfn.Options)) (*sfn.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ListTagsForResourceInput, ...func(*sfn.Options)) *sfn.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ListTagsForResourceInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() sfn.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 sfn.Options
	if rf, ok := ret.Get(0).(func() sfn.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(sfn.Options)
	}

	return r0
}

// PublishStateMachineVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PublishStateMachineVersion(ctx context.Context, params *sfn.PublishStateMachineVersionInput, optFns ...func(*sfn.Options)) (*sfn.PublishStateMachineVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishStateMachineVersion")
	}

	var r0 *sfn.PublishStateMachineVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.PublishStateMachineVersionInput, ...func(*sfn.Options)) (*sfn.PublishStateMachineVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.PublishStateMachineVersionInput, ...func(*sfn.Options)) *sfn.PublishStateMachineVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.PublishStateMachineVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.PublishStateMachineVersionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RedriveExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RedriveExecution(ctx context.Context, params *sfn.RedriveExecutionInput, optFns ...func(*sfn.Options)) (*sfn.RedriveExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RedriveExecution")
	}

	var r0 *sfn.RedriveExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.RedriveExecutionInput, ...func(*sfn.Options)) (*sfn.RedriveExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.RedriveExecutionInput, ...func(*sfn.Options)) *sfn.RedriveExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.RedriveExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.RedriveExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTaskFailure provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendTaskFailure(ctx context.Context, params *sfn.SendTaskFailureInput, optFns ...func(*sfn.Options)) (*sfn.SendTaskFailureOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTaskFailure")
	}

	var r0 *sfn.SendTaskFailureOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskFailureInput, ...func(*sfn.Options)) (*sfn.SendTaskFailureOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskFailureInput, ...func(*sfn.Options)) *sfn.SendTaskFailureOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.SendTaskFailureOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.SendTaskFailureInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTaskHeartbeat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendTaskHeartbeat(ctx context.Context, params *sfn.SendTaskHeartbeatInput, optFns ...func(*sfn.Options)) (*sfn.SendTaskHeartbeatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTaskHeartbeat")
	}

	var r0 *sfn.SendTaskHeartbeatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskHeartbeatInput, ...func(*sfn.Options)) (*sfn.SendTaskHeartbeatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskHeartbeatInput, ...func(*sfn.Options)) *sfn.SendTaskHeartbeatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.SendTaskHeartbeatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.SendTaskHeartbeatInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTaskSuccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendTaskSuccess(ctx context.Context, params *sfn.SendTaskSuccessInput, optFns ...func(*sfn.Options)) (*sfn.SendTaskSuccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTaskSuccess")
	}

	var r0 *sfn.SendTaskSuccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskSuccessInput, ...func(*sfn.Options)) (*sfn.SendTaskSuccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.SendTaskSuccessInput, ...func(*sfn.Options)) *sfn.SendTaskSuccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.SendTaskSuccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.SendTaskSuccessInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartExecution(ctx context.Context, params *sfn.StartExecutionInput, optFns ...func(*sfn.Options)) (*sfn.StartExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartExecution")
	}

	var r0 *sfn.StartExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StartExecutionInput, ...func(*sfn.Options)) (*sfn.StartExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StartExecutionInput, ...func(*sfn.Options)) *sfn.StartExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.StartExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.StartExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartSyncExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartSyncExecution(ctx context.Context, params *sfn.StartSyncExecutionInput, optFns ...func(*sfn.Options)) (*sfn.StartSyncExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartSyncExecution")
	}

	var r0 *sfn.StartSyncExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StartSyncExecutionInput, ...func(*sfn.Options)) (*sfn.StartSyncExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StartSyncExecutionInput, ...func(*sfn.Options)) *sfn.StartSyncExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.StartSyncExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.StartSyncExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopExecution(ctx context.Context, params *sfn.StopExecutionInput, optFns ...func(*sfn.Options)) (*sfn.StopExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopExecution")
	}

	var r0 *sfn.StopExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StopExecutionInput, ...func(*sfn.Options)) (*sfn.StopExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.StopExecutionInput, ...func(*sfn.Options)) *sfn.StopExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.StopExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.StopExecutionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *sfn.TagResourceInput, optFns ...func(*sfn.Options)) (*sfn.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *sfn.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.TagResourceInput, ...func(*sfn.Options)) (*sfn.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.TagResourceInput, ...func(*sfn.Options)) *sfn.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.TagResourceInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestState(ctx context.Context, params *sfn.TestStateInput, optFns ...func(*sfn.Options)) (*sfn.TestStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestState")
	}

	var r0 *sfn.TestStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.TestStateInput, ...func(*sfn.Options)) (*sfn.TestStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.TestStateInput, ...func(*sfn.Options)) *sfn.TestStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.TestStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.TestStateInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *sfn.UntagResourceInput, optFns ...func(*sfn.Options)) (*sfn.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *sfn.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UntagResourceInput, ...func(*sfn.Options)) (*sfn.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UntagResourceInput, ...func(*sfn.Options)) *sfn.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.UntagResourceInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMapRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMapRun(ctx context.Context, params *sfn.UpdateMapRunInput, optFns ...func(*sfn.Options)) (*sfn.UpdateMapRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMapRun")
	}

	var r0 *sfn.UpdateMapRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateMapRunInput, ...func(*sfn.Options)) (*sfn.UpdateMapRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateMapRunInput, ...func(*sfn.Options)) *sfn.UpdateMapRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.UpdateMapRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.UpdateMapRunInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStateMachine provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStateMachine(ctx context.Context, params *sfn.UpdateStateMachineInput, optFns ...func(*sfn.Options)) (*sfn.UpdateStateMachineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStateMachine")
	}

	var r0 *sfn.UpdateStateMachineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateStateMachineInput, ...func(*sfn.Options)) (*sfn.UpdateStateMachineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateStateMachineInput, ...func(*sfn.Options)) *sfn.UpdateStateMachineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.UpdateStateMachineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.UpdateStateMachineInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStateMachineAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStateMachineAlias(ctx context.Context, params *sfn.UpdateStateMachineAliasInput, optFns ...func(*sfn.Options)) (*sfn.UpdateStateMachineAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStateMachineAlias")
	}

	var r0 *sfn.UpdateStateMachineAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateStateMachineAliasInput, ...func(*sfn.Options)) (*sfn.UpdateStateMachineAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.UpdateStateMachineAliasInput, ...func(*sfn.Options)) *sfn.UpdateStateMachineAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.UpdateStateMachineAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.UpdateStateMachineAliasInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateStateMachineDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidateStateMachineDefinition(ctx context.Context, params *sfn.ValidateStateMachineDefinitionInput, optFns ...func(*sfn.Options)) (*sfn.ValidateStateMachineDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateStateMachineDefinition")
	}

	var r0 *sfn.ValidateStateMachineDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ValidateStateMachineDefinitionInput, ...func(*sfn.Options)) (*sfn.ValidateStateMachineDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *sfn.ValidateStateMachineDefinitionInput, ...func(*sfn.Options)) *sfn.ValidateStateMachineDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sfn.ValidateStateMachineDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *sfn.ValidateStateMachineDefinitionInput, ...func(*sfn.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
