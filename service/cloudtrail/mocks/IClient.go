// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	cloudtrail "github.com/aws/aws-sdk-go-v2/service/cloudtrail"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *cloudtrail.AddTagsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *cloudtrail.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.AddTagsInput, ...func(*cloudtrail.Options)) (*cloudtrail.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.AddTagsInput, ...func(*cloudtrail.Options)) *cloudtrail.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.AddTagsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelQuery(ctx context.Context, params *cloudtrail.CancelQueryInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.CancelQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelQuery")
	}

	var r0 *cloudtrail.CancelQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CancelQueryInput, ...func(*cloudtrail.Options)) (*cloudtrail.CancelQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CancelQueryInput, ...func(*cloudtrail.Options)) *cloudtrail.CancelQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.CancelQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.CancelQueryInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateChannel(ctx context.Context, params *cloudtrail.CreateChannelInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.CreateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateChannel")
	}

	var r0 *cloudtrail.CreateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateChannelInput, ...func(*cloudtrail.Options)) (*cloudtrail.CreateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateChannelInput, ...func(*cloudtrail.Options)) *cloudtrail.CreateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.CreateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.CreateChannelInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventDataStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventDataStore(ctx context.Context, params *cloudtrail.CreateEventDataStoreInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.CreateEventDataStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventDataStore")
	}

	var r0 *cloudtrail.CreateEventDataStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateEventDataStoreInput, ...func(*cloudtrail.Options)) (*cloudtrail.CreateEventDataStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateEventDataStoreInput, ...func(*cloudtrail.Options)) *cloudtrail.CreateEventDataStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.CreateEventDataStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.CreateEventDataStoreInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrail(ctx context.Context, params *cloudtrail.CreateTrailInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.CreateTrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrail")
	}

	var r0 *cloudtrail.CreateTrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateTrailInput, ...func(*cloudtrail.Options)) (*cloudtrail.CreateTrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.CreateTrailInput, ...func(*cloudtrail.Options)) *cloudtrail.CreateTrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.CreateTrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.CreateTrailInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteChannel(ctx context.Context, params *cloudtrail.DeleteChannelInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DeleteChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteChannel")
	}

	var r0 *cloudtrail.DeleteChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteChannelInput, ...func(*cloudtrail.Options)) (*cloudtrail.DeleteChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteChannelInput, ...func(*cloudtrail.Options)) *cloudtrail.DeleteChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DeleteChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DeleteChannelInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventDataStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventDataStore(ctx context.Context, params *cloudtrail.DeleteEventDataStoreInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DeleteEventDataStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventDataStore")
	}

	var r0 *cloudtrail.DeleteEventDataStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteEventDataStoreInput, ...func(*cloudtrail.Options)) (*cloudtrail.DeleteEventDataStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteEventDataStoreInput, ...func(*cloudtrail.Options)) *cloudtrail.DeleteEventDataStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DeleteEventDataStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DeleteEventDataStoreInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *cloudtrail.DeleteResourcePolicyInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *cloudtrail.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteResourcePolicyInput, ...func(*cloudtrail.Options)) (*cloudtrail.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteResourcePolicyInput, ...func(*cloudtrail.Options)) *cloudtrail.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DeleteResourcePolicyInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrail(ctx context.Context, params *cloudtrail.DeleteTrailInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DeleteTrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrail")
	}

	var r0 *cloudtrail.DeleteTrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteTrailInput, ...func(*cloudtrail.Options)) (*cloudtrail.DeleteTrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeleteTrailInput, ...func(*cloudtrail.Options)) *cloudtrail.DeleteTrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DeleteTrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DeleteTrailInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterOrganizationDelegatedAdmin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterOrganizationDelegatedAdmin(ctx context.Context, params *cloudtrail.DeregisterOrganizationDelegatedAdminInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DeregisterOrganizationDelegatedAdminOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterOrganizationDelegatedAdmin")
	}

	var r0 *cloudtrail.DeregisterOrganizationDelegatedAdminOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeregisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) (*cloudtrail.DeregisterOrganizationDelegatedAdminOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DeregisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) *cloudtrail.DeregisterOrganizationDelegatedAdminOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DeregisterOrganizationDelegatedAdminOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DeregisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeQuery(ctx context.Context, params *cloudtrail.DescribeQueryInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DescribeQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeQuery")
	}

	var r0 *cloudtrail.DescribeQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DescribeQueryInput, ...func(*cloudtrail.Options)) (*cloudtrail.DescribeQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DescribeQueryInput, ...func(*cloudtrail.Options)) *cloudtrail.DescribeQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DescribeQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DescribeQueryInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrails(ctx context.Context, params *cloudtrail.DescribeTrailsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DescribeTrailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrails")
	}

	var r0 *cloudtrail.DescribeTrailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DescribeTrailsInput, ...func(*cloudtrail.Options)) (*cloudtrail.DescribeTrailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DescribeTrailsInput, ...func(*cloudtrail.Options)) *cloudtrail.DescribeTrailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DescribeTrailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DescribeTrailsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFederation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableFederation(ctx context.Context, params *cloudtrail.DisableFederationInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.DisableFederationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableFederation")
	}

	var r0 *cloudtrail.DisableFederationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DisableFederationInput, ...func(*cloudtrail.Options)) (*cloudtrail.DisableFederationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.DisableFederationInput, ...func(*cloudtrail.Options)) *cloudtrail.DisableFederationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.DisableFederationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.DisableFederationInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFederation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableFederation(ctx context.Context, params *cloudtrail.EnableFederationInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.EnableFederationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableFederation")
	}

	var r0 *cloudtrail.EnableFederationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.EnableFederationInput, ...func(*cloudtrail.Options)) (*cloudtrail.EnableFederationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.EnableFederationInput, ...func(*cloudtrail.Options)) *cloudtrail.EnableFederationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.EnableFederationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.EnableFederationInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChannel(ctx context.Context, params *cloudtrail.GetChannelInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChannel")
	}

	var r0 *cloudtrail.GetChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetChannelInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetChannelInput, ...func(*cloudtrail.Options)) *cloudtrail.GetChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetChannelInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventDataStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventDataStore(ctx context.Context, params *cloudtrail.GetEventDataStoreInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetEventDataStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventDataStore")
	}

	var r0 *cloudtrail.GetEventDataStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetEventDataStoreInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetEventDataStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetEventDataStoreInput, ...func(*cloudtrail.Options)) *cloudtrail.GetEventDataStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetEventDataStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetEventDataStoreInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventSelectors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventSelectors(ctx context.Context, params *cloudtrail.GetEventSelectorsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetEventSelectorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventSelectors")
	}

	var r0 *cloudtrail.GetEventSelectorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetEventSelectorsInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetEventSelectorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetEventSelectorsInput, ...func(*cloudtrail.Options)) *cloudtrail.GetEventSelectorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetEventSelectorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetEventSelectorsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImport(ctx context.Context, params *cloudtrail.GetImportInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImport")
	}

	var r0 *cloudtrail.GetImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetImportInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetImportInput, ...func(*cloudtrail.Options)) *cloudtrail.GetImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetImportInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsightSelectors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsightSelectors(ctx context.Context, params *cloudtrail.GetInsightSelectorsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetInsightSelectorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsightSelectors")
	}

	var r0 *cloudtrail.GetInsightSelectorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetInsightSelectorsInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetInsightSelectorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetInsightSelectorsInput, ...func(*cloudtrail.Options)) *cloudtrail.GetInsightSelectorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetInsightSelectorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetInsightSelectorsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQueryResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQueryResults(ctx context.Context, params *cloudtrail.GetQueryResultsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetQueryResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQueryResults")
	}

	var r0 *cloudtrail.GetQueryResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetQueryResultsInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetQueryResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetQueryResultsInput, ...func(*cloudtrail.Options)) *cloudtrail.GetQueryResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetQueryResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetQueryResultsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicy(ctx context.Context, params *cloudtrail.GetResourcePolicyInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicy")
	}

	var r0 *cloudtrail.GetResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetResourcePolicyInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetResourcePolicyInput, ...func(*cloudtrail.Options)) *cloudtrail.GetResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetResourcePolicyInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTrail(ctx context.Context, params *cloudtrail.GetTrailInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetTrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTrail")
	}

	var r0 *cloudtrail.GetTrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetTrailInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetTrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetTrailInput, ...func(*cloudtrail.Options)) *cloudtrail.GetTrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetTrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetTrailInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrailStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTrailStatus(ctx context.Context, params *cloudtrail.GetTrailStatusInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.GetTrailStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTrailStatus")
	}

	var r0 *cloudtrail.GetTrailStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetTrailStatusInput, ...func(*cloudtrail.Options)) (*cloudtrail.GetTrailStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.GetTrailStatusInput, ...func(*cloudtrail.Options)) *cloudtrail.GetTrailStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.GetTrailStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.GetTrailStatusInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChannels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListChannels(ctx context.Context, params *cloudtrail.ListChannelsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListChannelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 *cloudtrail.ListChannelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListChannelsInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListChannelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListChannelsInput, ...func(*cloudtrail.Options)) *cloudtrail.ListChannelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListChannelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListChannelsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventDataStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventDataStores(ctx context.Context, params *cloudtrail.ListEventDataStoresInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListEventDataStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventDataStores")
	}

	var r0 *cloudtrail.ListEventDataStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListEventDataStoresInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListEventDataStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListEventDataStoresInput, ...func(*cloudtrail.Options)) *cloudtrail.ListEventDataStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListEventDataStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListEventDataStoresInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImportFailures provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImportFailures(ctx context.Context, params *cloudtrail.ListImportFailuresInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListImportFailuresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImportFailures")
	}

	var r0 *cloudtrail.ListImportFailuresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListImportFailuresInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListImportFailuresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListImportFailuresInput, ...func(*cloudtrail.Options)) *cloudtrail.ListImportFailuresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListImportFailuresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListImportFailuresInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImports(ctx context.Context, params *cloudtrail.ListImportsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListImportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImports")
	}

	var r0 *cloudtrail.ListImportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListImportsInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListImportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListImportsInput, ...func(*cloudtrail.Options)) *cloudtrail.ListImportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListImportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListImportsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInsightsMetricData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInsightsMetricData(ctx context.Context, params *cloudtrail.ListInsightsMetricDataInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListInsightsMetricDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInsightsMetricData")
	}

	var r0 *cloudtrail.ListInsightsMetricDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListInsightsMetricDataInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListInsightsMetricDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListInsightsMetricDataInput, ...func(*cloudtrail.Options)) *cloudtrail.ListInsightsMetricDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListInsightsMetricDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListInsightsMetricDataInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPublicKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPublicKeys(ctx context.Context, params *cloudtrail.ListPublicKeysInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListPublicKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPublicKeys")
	}

	var r0 *cloudtrail.ListPublicKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListPublicKeysInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListPublicKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListPublicKeysInput, ...func(*cloudtrail.Options)) *cloudtrail.ListPublicKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListPublicKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListPublicKeysInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQueries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQueries(ctx context.Context, params *cloudtrail.ListQueriesInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListQueriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQueries")
	}

	var r0 *cloudtrail.ListQueriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListQueriesInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListQueriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListQueriesInput, ...func(*cloudtrail.Options)) *cloudtrail.ListQueriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListQueriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListQueriesInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *cloudtrail.ListTagsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *cloudtrail.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListTagsInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListTagsInput, ...func(*cloudtrail.Options)) *cloudtrail.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListTagsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTrails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTrails(ctx context.Context, params *cloudtrail.ListTrailsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.ListTrailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTrails")
	}

	var r0 *cloudtrail.ListTrailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListTrailsInput, ...func(*cloudtrail.Options)) (*cloudtrail.ListTrailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.ListTrailsInput, ...func(*cloudtrail.Options)) *cloudtrail.ListTrailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.ListTrailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.ListTrailsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LookupEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) LookupEvents(ctx context.Context, params *cloudtrail.LookupEventsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.LookupEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LookupEvents")
	}

	var r0 *cloudtrail.LookupEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.LookupEventsInput, ...func(*cloudtrail.Options)) (*cloudtrail.LookupEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.LookupEventsInput, ...func(*cloudtrail.Options)) *cloudtrail.LookupEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.LookupEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.LookupEventsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() cloudtrail.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 cloudtrail.Options
	if rf, ok := ret.Get(0).(func() cloudtrail.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(cloudtrail.Options)
	}

	return r0
}

// PutEventSelectors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutEventSelectors(ctx context.Context, params *cloudtrail.PutEventSelectorsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.PutEventSelectorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEventSelectors")
	}

	var r0 *cloudtrail.PutEventSelectorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutEventSelectorsInput, ...func(*cloudtrail.Options)) (*cloudtrail.PutEventSelectorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutEventSelectorsInput, ...func(*cloudtrail.Options)) *cloudtrail.PutEventSelectorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.PutEventSelectorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.PutEventSelectorsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutInsightSelectors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutInsightSelectors(ctx context.Context, params *cloudtrail.PutInsightSelectorsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.PutInsightSelectorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutInsightSelectors")
	}

	var r0 *cloudtrail.PutInsightSelectorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutInsightSelectorsInput, ...func(*cloudtrail.Options)) (*cloudtrail.PutInsightSelectorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutInsightSelectorsInput, ...func(*cloudtrail.Options)) *cloudtrail.PutInsightSelectorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.PutInsightSelectorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.PutInsightSelectorsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *cloudtrail.PutResourcePolicyInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *cloudtrail.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutResourcePolicyInput, ...func(*cloudtrail.Options)) (*cloudtrail.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.PutResourcePolicyInput, ...func(*cloudtrail.Options)) *cloudtrail.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.PutResourcePolicyInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterOrganizationDelegatedAdmin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterOrganizationDelegatedAdmin(ctx context.Context, params *cloudtrail.RegisterOrganizationDelegatedAdminInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.RegisterOrganizationDelegatedAdminOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterOrganizationDelegatedAdmin")
	}

	var r0 *cloudtrail.RegisterOrganizationDelegatedAdminOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RegisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) (*cloudtrail.RegisterOrganizationDelegatedAdminOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RegisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) *cloudtrail.RegisterOrganizationDelegatedAdminOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.RegisterOrganizationDelegatedAdminOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.RegisterOrganizationDelegatedAdminInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *cloudtrail.RemoveTagsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *cloudtrail.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RemoveTagsInput, ...func(*cloudtrail.Options)) (*cloudtrail.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RemoveTagsInput, ...func(*cloudtrail.Options)) *cloudtrail.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.RemoveTagsInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreEventDataStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreEventDataStore(ctx context.Context, params *cloudtrail.RestoreEventDataStoreInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.RestoreEventDataStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreEventDataStore")
	}

	var r0 *cloudtrail.RestoreEventDataStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RestoreEventDataStoreInput, ...func(*cloudtrail.Options)) (*cloudtrail.RestoreEventDataStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.RestoreEventDataStoreInput, ...func(*cloudtrail.Options)) *cloudtrail.RestoreEventDataStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.RestoreEventDataStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.RestoreEventDataStoreInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartEventDataStoreIngestion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartEventDataStoreIngestion(ctx context.Context, params *cloudtrail.StartEventDataStoreIngestionInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StartEventDataStoreIngestionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartEventDataStoreIngestion")
	}

	var r0 *cloudtrail.StartEventDataStoreIngestionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) (*cloudtrail.StartEventDataStoreIngestionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) *cloudtrail.StartEventDataStoreIngestionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StartEventDataStoreIngestionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StartEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImport(ctx context.Context, params *cloudtrail.StartImportInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StartImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImport")
	}

	var r0 *cloudtrail.StartImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartImportInput, ...func(*cloudtrail.Options)) (*cloudtrail.StartImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartImportInput, ...func(*cloudtrail.Options)) *cloudtrail.StartImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StartImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StartImportInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartLogging provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartLogging(ctx context.Context, params *cloudtrail.StartLoggingInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StartLoggingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartLogging")
	}

	var r0 *cloudtrail.StartLoggingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartLoggingInput, ...func(*cloudtrail.Options)) (*cloudtrail.StartLoggingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartLoggingInput, ...func(*cloudtrail.Options)) *cloudtrail.StartLoggingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StartLoggingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StartLoggingInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartQuery(ctx context.Context, params *cloudtrail.StartQueryInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StartQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartQuery")
	}

	var r0 *cloudtrail.StartQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartQueryInput, ...func(*cloudtrail.Options)) (*cloudtrail.StartQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StartQueryInput, ...func(*cloudtrail.Options)) *cloudtrail.StartQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StartQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StartQueryInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopEventDataStoreIngestion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopEventDataStoreIngestion(ctx context.Context, params *cloudtrail.StopEventDataStoreIngestionInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StopEventDataStoreIngestionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopEventDataStoreIngestion")
	}

	var r0 *cloudtrail.StopEventDataStoreIngestionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) (*cloudtrail.StopEventDataStoreIngestionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) *cloudtrail.StopEventDataStoreIngestionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StopEventDataStoreIngestionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StopEventDataStoreIngestionInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopImport(ctx context.Context, params *cloudtrail.StopImportInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StopImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopImport")
	}

	var r0 *cloudtrail.StopImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopImportInput, ...func(*cloudtrail.Options)) (*cloudtrail.StopImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopImportInput, ...func(*cloudtrail.Options)) *cloudtrail.StopImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StopImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StopImportInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopLogging provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopLogging(ctx context.Context, params *cloudtrail.StopLoggingInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.StopLoggingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopLogging")
	}

	var r0 *cloudtrail.StopLoggingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopLoggingInput, ...func(*cloudtrail.Options)) (*cloudtrail.StopLoggingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.StopLoggingInput, ...func(*cloudtrail.Options)) *cloudtrail.StopLoggingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.StopLoggingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.StopLoggingInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateChannel(ctx context.Context, params *cloudtrail.UpdateChannelInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.UpdateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannel")
	}

	var r0 *cloudtrail.UpdateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateChannelInput, ...func(*cloudtrail.Options)) (*cloudtrail.UpdateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateChannelInput, ...func(*cloudtrail.Options)) *cloudtrail.UpdateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.UpdateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.UpdateChannelInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventDataStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventDataStore(ctx context.Context, params *cloudtrail.UpdateEventDataStoreInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.UpdateEventDataStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventDataStore")
	}

	var r0 *cloudtrail.UpdateEventDataStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateEventDataStoreInput, ...func(*cloudtrail.Options)) (*cloudtrail.UpdateEventDataStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateEventDataStoreInput, ...func(*cloudtrail.Options)) *cloudtrail.UpdateEventDataStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.UpdateEventDataStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.UpdateEventDataStoreInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTrail(ctx context.Context, params *cloudtrail.UpdateTrailInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.UpdateTrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTrail")
	}

	var r0 *cloudtrail.UpdateTrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateTrailInput, ...func(*cloudtrail.Options)) (*cloudtrail.UpdateTrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cloudtrail.UpdateTrailInput, ...func(*cloudtrail.Options)) *cloudtrail.UpdateTrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cloudtrail.UpdateTrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cloudtrail.UpdateTrailInput, ...func(*cloudtrail.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
