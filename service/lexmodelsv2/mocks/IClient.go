// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	lexmodelsv2 "github.com/aws/aws-sdk-go-v2/service/lexmodelsv2"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchCreateCustomVocabularyItem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreateCustomVocabularyItem(ctx context.Context, params *lexmodelsv2.BatchCreateCustomVocabularyItemInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchCreateCustomVocabularyItemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreateCustomVocabularyItem")
	}

	var r0 *lexmodelsv2.BatchCreateCustomVocabularyItemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchCreateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchCreateCustomVocabularyItemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchCreateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.BatchCreateCustomVocabularyItemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.BatchCreateCustomVocabularyItemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.BatchCreateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteCustomVocabularyItem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteCustomVocabularyItem(ctx context.Context, params *lexmodelsv2.BatchDeleteCustomVocabularyItemInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchDeleteCustomVocabularyItemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteCustomVocabularyItem")
	}

	var r0 *lexmodelsv2.BatchDeleteCustomVocabularyItemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchDeleteCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchDeleteCustomVocabularyItemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchDeleteCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.BatchDeleteCustomVocabularyItemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.BatchDeleteCustomVocabularyItemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.BatchDeleteCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchUpdateCustomVocabularyItem provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdateCustomVocabularyItem(ctx context.Context, params *lexmodelsv2.BatchUpdateCustomVocabularyItemInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchUpdateCustomVocabularyItemOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateCustomVocabularyItem")
	}

	var r0 *lexmodelsv2.BatchUpdateCustomVocabularyItemOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchUpdateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BatchUpdateCustomVocabularyItemOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BatchUpdateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.BatchUpdateCustomVocabularyItemOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.BatchUpdateCustomVocabularyItemOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.BatchUpdateCustomVocabularyItemInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildBotLocale provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BuildBotLocale(ctx context.Context, params *lexmodelsv2.BuildBotLocaleInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BuildBotLocaleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BuildBotLocale")
	}

	var r0 *lexmodelsv2.BuildBotLocaleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BuildBotLocaleInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.BuildBotLocaleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.BuildBotLocaleInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.BuildBotLocaleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.BuildBotLocaleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.BuildBotLocaleInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBot(ctx context.Context, params *lexmodelsv2.CreateBotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBot")
	}

	var r0 *lexmodelsv2.CreateBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateBotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBotAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBotAlias(ctx context.Context, params *lexmodelsv2.CreateBotAliasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBotAlias")
	}

	var r0 *lexmodelsv2.CreateBotAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotAliasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotAliasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateBotAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateBotAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateBotAliasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBotLocale provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBotLocale(ctx context.Context, params *lexmodelsv2.CreateBotLocaleInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotLocaleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBotLocale")
	}

	var r0 *lexmodelsv2.CreateBotLocaleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotLocaleInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotLocaleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotLocaleInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateBotLocaleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateBotLocaleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateBotLocaleInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBotReplica provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBotReplica(ctx context.Context, params *lexmodelsv2.CreateBotReplicaInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotReplicaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBotReplica")
	}

	var r0 *lexmodelsv2.CreateBotReplicaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotReplicaInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotReplicaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotReplicaInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateBotReplicaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateBotReplicaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateBotReplicaInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBotVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBotVersion(ctx context.Context, params *lexmodelsv2.CreateBotVersionInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBotVersion")
	}

	var r0 *lexmodelsv2.CreateBotVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotVersionInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateBotVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateBotVersionInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateBotVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateBotVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateBotVersionInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateExport(ctx context.Context, params *lexmodelsv2.CreateExportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExport")
	}

	var r0 *lexmodelsv2.CreateExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateExportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateExportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateExportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIntent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIntent(ctx context.Context, params *lexmodelsv2.CreateIntentInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateIntentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIntent")
	}

	var r0 *lexmodelsv2.CreateIntentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateIntentInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateIntentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateIntentInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateIntentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateIntentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateIntentInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResourcePolicy(ctx context.Context, params *lexmodelsv2.CreateResourcePolicyInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResourcePolicy")
	}

	var r0 *lexmodelsv2.CreateResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateResourcePolicyInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateResourcePolicyInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateResourcePolicyInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResourcePolicyStatement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResourcePolicyStatement(ctx context.Context, params *lexmodelsv2.CreateResourcePolicyStatementInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateResourcePolicyStatementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResourcePolicyStatement")
	}

	var r0 *lexmodelsv2.CreateResourcePolicyStatementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateResourcePolicyStatementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateResourcePolicyStatementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateResourcePolicyStatementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSlot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSlot(ctx context.Context, params *lexmodelsv2.CreateSlotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateSlotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSlot")
	}

	var r0 *lexmodelsv2.CreateSlotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateSlotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateSlotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateSlotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateSlotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateSlotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateSlotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSlotType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSlotType(ctx context.Context, params *lexmodelsv2.CreateSlotTypeInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateSlotTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSlotType")
	}

	var r0 *lexmodelsv2.CreateSlotTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateSlotTypeInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateSlotTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateSlotTypeInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateSlotTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateSlotTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateSlotTypeInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTestSetDiscrepancyReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTestSetDiscrepancyReport(ctx context.Context, params *lexmodelsv2.CreateTestSetDiscrepancyReportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateTestSetDiscrepancyReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTestSetDiscrepancyReport")
	}

	var r0 *lexmodelsv2.CreateTestSetDiscrepancyReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateTestSetDiscrepancyReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateTestSetDiscrepancyReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateTestSetDiscrepancyReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUploadUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUploadUrl(ctx context.Context, params *lexmodelsv2.CreateUploadUrlInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateUploadUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUploadUrl")
	}

	var r0 *lexmodelsv2.CreateUploadUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateUploadUrlInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.CreateUploadUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.CreateUploadUrlInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.CreateUploadUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.CreateUploadUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.CreateUploadUrlInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBot(ctx context.Context, params *lexmodelsv2.DeleteBotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBot")
	}

	var r0 *lexmodelsv2.DeleteBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteBotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBotAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBotAlias(ctx context.Context, params *lexmodelsv2.DeleteBotAliasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBotAlias")
	}

	var r0 *lexmodelsv2.DeleteBotAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotAliasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotAliasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteBotAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteBotAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteBotAliasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBotLocale provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBotLocale(ctx context.Context, params *lexmodelsv2.DeleteBotLocaleInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotLocaleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBotLocale")
	}

	var r0 *lexmodelsv2.DeleteBotLocaleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotLocaleInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotLocaleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotLocaleInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteBotLocaleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteBotLocaleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteBotLocaleInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBotReplica provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBotReplica(ctx context.Context, params *lexmodelsv2.DeleteBotReplicaInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotReplicaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBotReplica")
	}

	var r0 *lexmodelsv2.DeleteBotReplicaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotReplicaInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotReplicaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotReplicaInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteBotReplicaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteBotReplicaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteBotReplicaInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBotVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBotVersion(ctx context.Context, params *lexmodelsv2.DeleteBotVersionInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBotVersion")
	}

	var r0 *lexmodelsv2.DeleteBotVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotVersionInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteBotVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteBotVersionInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteBotVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteBotVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteBotVersionInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomVocabulary(ctx context.Context, params *lexmodelsv2.DeleteCustomVocabularyInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteCustomVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomVocabulary")
	}

	var r0 *lexmodelsv2.DeleteCustomVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteCustomVocabularyInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteCustomVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteCustomVocabularyInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteCustomVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteCustomVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteCustomVocabularyInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteExport(ctx context.Context, params *lexmodelsv2.DeleteExportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExport")
	}

	var r0 *lexmodelsv2.DeleteExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteExportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteExportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteExportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImport(ctx context.Context, params *lexmodelsv2.DeleteImportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImport")
	}

	var r0 *lexmodelsv2.DeleteImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteImportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteImportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteImportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIntent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIntent(ctx context.Context, params *lexmodelsv2.DeleteIntentInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteIntentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIntent")
	}

	var r0 *lexmodelsv2.DeleteIntentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteIntentInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteIntentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteIntentInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteIntentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteIntentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteIntentInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *lexmodelsv2.DeleteResourcePolicyInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *lexmodelsv2.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicyStatement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicyStatement(ctx context.Context, params *lexmodelsv2.DeleteResourcePolicyStatementInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteResourcePolicyStatementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicyStatement")
	}

	var r0 *lexmodelsv2.DeleteResourcePolicyStatementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteResourcePolicyStatementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteResourcePolicyStatementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteResourcePolicyStatementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteResourcePolicyStatementInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSlot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSlot(ctx context.Context, params *lexmodelsv2.DeleteSlotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteSlotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSlot")
	}

	var r0 *lexmodelsv2.DeleteSlotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteSlotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteSlotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteSlotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteSlotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteSlotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteSlotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSlotType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSlotType(ctx context.Context, params *lexmodelsv2.DeleteSlotTypeInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteSlotTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSlotType")
	}

	var r0 *lexmodelsv2.DeleteSlotTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteSlotTypeInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteSlotTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteSlotTypeInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteSlotTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteSlotTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteSlotTypeInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTestSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTestSet(ctx context.Context, params *lexmodelsv2.DeleteTestSetInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteTestSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTestSet")
	}

	var r0 *lexmodelsv2.DeleteTestSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteTestSetInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteTestSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteTestSetInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteTestSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteTestSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteTestSetInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUtterances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUtterances(ctx context.Context, params *lexmodelsv2.DeleteUtterancesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteUtterancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUtterances")
	}

	var r0 *lexmodelsv2.DeleteUtterancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteUtterancesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DeleteUtterancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DeleteUtterancesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DeleteUtterancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DeleteUtterancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DeleteUtterancesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBot(ctx context.Context, params *lexmodelsv2.DescribeBotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBot")
	}

	var r0 *lexmodelsv2.DescribeBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotAlias(ctx context.Context, params *lexmodelsv2.DescribeBotAliasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotAlias")
	}

	var r0 *lexmodelsv2.DescribeBotAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotAliasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotAliasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotAliasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotLocale provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotLocale(ctx context.Context, params *lexmodelsv2.DescribeBotLocaleInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotLocaleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotLocale")
	}

	var r0 *lexmodelsv2.DescribeBotLocaleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotLocaleInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotLocaleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotLocaleInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotLocaleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotLocaleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotLocaleInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotRecommendation(ctx context.Context, params *lexmodelsv2.DescribeBotRecommendationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotRecommendation")
	}

	var r0 *lexmodelsv2.DescribeBotRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotRecommendationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotRecommendationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotRecommendationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotReplica provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotReplica(ctx context.Context, params *lexmodelsv2.DescribeBotReplicaInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotReplicaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotReplica")
	}

	var r0 *lexmodelsv2.DescribeBotReplicaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotReplicaInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotReplicaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotReplicaInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotReplicaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotReplicaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotReplicaInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotResourceGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotResourceGeneration(ctx context.Context, params *lexmodelsv2.DescribeBotResourceGenerationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotResourceGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotResourceGeneration")
	}

	var r0 *lexmodelsv2.DescribeBotResourceGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotResourceGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotResourceGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotResourceGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBotVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBotVersion(ctx context.Context, params *lexmodelsv2.DescribeBotVersionInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBotVersion")
	}

	var r0 *lexmodelsv2.DescribeBotVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotVersionInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeBotVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeBotVersionInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeBotVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeBotVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeBotVersionInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomVocabularyMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomVocabularyMetadata(ctx context.Context, params *lexmodelsv2.DescribeCustomVocabularyMetadataInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeCustomVocabularyMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomVocabularyMetadata")
	}

	var r0 *lexmodelsv2.DescribeCustomVocabularyMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeCustomVocabularyMetadataInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeCustomVocabularyMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeCustomVocabularyMetadataInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeCustomVocabularyMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeCustomVocabularyMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeCustomVocabularyMetadataInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExport(ctx context.Context, params *lexmodelsv2.DescribeExportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExport")
	}

	var r0 *lexmodelsv2.DescribeExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeExportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeExportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeExportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImport(ctx context.Context, params *lexmodelsv2.DescribeImportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImport")
	}

	var r0 *lexmodelsv2.DescribeImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeImportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeImportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeImportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIntent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIntent(ctx context.Context, params *lexmodelsv2.DescribeIntentInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeIntentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIntent")
	}

	var r0 *lexmodelsv2.DescribeIntentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeIntentInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeIntentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeIntentInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeIntentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeIntentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeIntentInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResourcePolicy(ctx context.Context, params *lexmodelsv2.DescribeResourcePolicyInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourcePolicy")
	}

	var r0 *lexmodelsv2.DescribeResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeResourcePolicyInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeResourcePolicyInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeResourcePolicyInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSlot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSlot(ctx context.Context, params *lexmodelsv2.DescribeSlotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeSlotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSlot")
	}

	var r0 *lexmodelsv2.DescribeSlotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeSlotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeSlotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeSlotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeSlotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeSlotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeSlotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSlotType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSlotType(ctx context.Context, params *lexmodelsv2.DescribeSlotTypeInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeSlotTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSlotType")
	}

	var r0 *lexmodelsv2.DescribeSlotTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeSlotTypeInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeSlotTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeSlotTypeInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeSlotTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeSlotTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeSlotTypeInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTestExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTestExecution(ctx context.Context, params *lexmodelsv2.DescribeTestExecutionInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTestExecution")
	}

	var r0 *lexmodelsv2.DescribeTestExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestExecutionInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestExecutionInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeTestExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeTestExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeTestExecutionInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTestSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTestSet(ctx context.Context, params *lexmodelsv2.DescribeTestSetInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTestSet")
	}

	var r0 *lexmodelsv2.DescribeTestSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeTestSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeTestSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeTestSetInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTestSetDiscrepancyReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTestSetDiscrepancyReport(ctx context.Context, params *lexmodelsv2.DescribeTestSetDiscrepancyReportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetDiscrepancyReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTestSetDiscrepancyReport")
	}

	var r0 *lexmodelsv2.DescribeTestSetDiscrepancyReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetDiscrepancyReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeTestSetDiscrepancyReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeTestSetDiscrepancyReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeTestSetDiscrepancyReportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTestSetGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTestSetGeneration(ctx context.Context, params *lexmodelsv2.DescribeTestSetGenerationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTestSetGeneration")
	}

	var r0 *lexmodelsv2.DescribeTestSetGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetGenerationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.DescribeTestSetGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.DescribeTestSetGenerationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.DescribeTestSetGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.DescribeTestSetGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.DescribeTestSetGenerationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateBotElement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateBotElement(ctx context.Context, params *lexmodelsv2.GenerateBotElementInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.GenerateBotElementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateBotElement")
	}

	var r0 *lexmodelsv2.GenerateBotElementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.GenerateBotElementInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.GenerateBotElementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.GenerateBotElementInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.GenerateBotElementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.GenerateBotElementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.GenerateBotElementInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTestExecutionArtifactsUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTestExecutionArtifactsUrl(ctx context.Context, params *lexmodelsv2.GetTestExecutionArtifactsUrlInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.GetTestExecutionArtifactsUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestExecutionArtifactsUrl")
	}

	var r0 *lexmodelsv2.GetTestExecutionArtifactsUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.GetTestExecutionArtifactsUrlInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.GetTestExecutionArtifactsUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.GetTestExecutionArtifactsUrlInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.GetTestExecutionArtifactsUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.GetTestExecutionArtifactsUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.GetTestExecutionArtifactsUrlInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAggregatedUtterances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAggregatedUtterances(ctx context.Context, params *lexmodelsv2.ListAggregatedUtterancesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListAggregatedUtterancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAggregatedUtterances")
	}

	var r0 *lexmodelsv2.ListAggregatedUtterancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListAggregatedUtterancesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListAggregatedUtterancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListAggregatedUtterancesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListAggregatedUtterancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListAggregatedUtterancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListAggregatedUtterancesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotAliasReplicas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotAliasReplicas(ctx context.Context, params *lexmodelsv2.ListBotAliasReplicasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotAliasReplicasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotAliasReplicas")
	}

	var r0 *lexmodelsv2.ListBotAliasReplicasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotAliasReplicasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotAliasReplicasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotAliasReplicasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotAliasReplicasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotAliasReplicasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotAliasReplicasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotAliases(ctx context.Context, params *lexmodelsv2.ListBotAliasesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotAliases")
	}

	var r0 *lexmodelsv2.ListBotAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotAliasesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotAliasesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotAliasesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotLocales provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotLocales(ctx context.Context, params *lexmodelsv2.ListBotLocalesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotLocalesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotLocales")
	}

	var r0 *lexmodelsv2.ListBotLocalesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotLocalesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotLocalesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotLocalesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotLocalesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotLocalesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotLocalesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotRecommendations(ctx context.Context, params *lexmodelsv2.ListBotRecommendationsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotRecommendations")
	}

	var r0 *lexmodelsv2.ListBotRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotRecommendationsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotRecommendationsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotRecommendationsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotReplicas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotReplicas(ctx context.Context, params *lexmodelsv2.ListBotReplicasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotReplicasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotReplicas")
	}

	var r0 *lexmodelsv2.ListBotReplicasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotReplicasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotReplicasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotReplicasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotReplicasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotReplicasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotReplicasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotResourceGenerations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotResourceGenerations(ctx context.Context, params *lexmodelsv2.ListBotResourceGenerationsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotResourceGenerationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotResourceGenerations")
	}

	var r0 *lexmodelsv2.ListBotResourceGenerationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotResourceGenerationsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotResourceGenerationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotResourceGenerationsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotResourceGenerationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotResourceGenerationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotResourceGenerationsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotVersionReplicas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotVersionReplicas(ctx context.Context, params *lexmodelsv2.ListBotVersionReplicasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotVersionReplicasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotVersionReplicas")
	}

	var r0 *lexmodelsv2.ListBotVersionReplicasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotVersionReplicasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotVersionReplicasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotVersionReplicasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotVersionReplicasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotVersionReplicasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotVersionReplicasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBotVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBotVersions(ctx context.Context, params *lexmodelsv2.ListBotVersionsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBotVersions")
	}

	var r0 *lexmodelsv2.ListBotVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotVersionsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotVersionsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotVersionsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBots(ctx context.Context, params *lexmodelsv2.ListBotsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBots")
	}

	var r0 *lexmodelsv2.ListBotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBotsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBotsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuiltInIntents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuiltInIntents(ctx context.Context, params *lexmodelsv2.ListBuiltInIntentsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBuiltInIntentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuiltInIntents")
	}

	var r0 *lexmodelsv2.ListBuiltInIntentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBuiltInIntentsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBuiltInIntentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBuiltInIntentsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBuiltInIntentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBuiltInIntentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBuiltInIntentsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuiltInSlotTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuiltInSlotTypes(ctx context.Context, params *lexmodelsv2.ListBuiltInSlotTypesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBuiltInSlotTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuiltInSlotTypes")
	}

	var r0 *lexmodelsv2.ListBuiltInSlotTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBuiltInSlotTypesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListBuiltInSlotTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListBuiltInSlotTypesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListBuiltInSlotTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListBuiltInSlotTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListBuiltInSlotTypesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomVocabularyItems provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomVocabularyItems(ctx context.Context, params *lexmodelsv2.ListCustomVocabularyItemsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListCustomVocabularyItemsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomVocabularyItems")
	}

	var r0 *lexmodelsv2.ListCustomVocabularyItemsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListCustomVocabularyItemsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListCustomVocabularyItemsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListCustomVocabularyItemsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListCustomVocabularyItemsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListCustomVocabularyItemsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListCustomVocabularyItemsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExports(ctx context.Context, params *lexmodelsv2.ListExportsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListExportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExports")
	}

	var r0 *lexmodelsv2.ListExportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListExportsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListExportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListExportsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListExportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListExportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListExportsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImports(ctx context.Context, params *lexmodelsv2.ListImportsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListImportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImports")
	}

	var r0 *lexmodelsv2.ListImportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListImportsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListImportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListImportsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListImportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListImportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListImportsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIntentMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIntentMetrics(ctx context.Context, params *lexmodelsv2.ListIntentMetricsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIntentMetrics")
	}

	var r0 *lexmodelsv2.ListIntentMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentMetricsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentMetricsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListIntentMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListIntentMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListIntentMetricsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIntentPaths provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIntentPaths(ctx context.Context, params *lexmodelsv2.ListIntentPathsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentPathsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIntentPaths")
	}

	var r0 *lexmodelsv2.ListIntentPathsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentPathsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentPathsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentPathsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListIntentPathsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListIntentPathsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListIntentPathsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIntentStageMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIntentStageMetrics(ctx context.Context, params *lexmodelsv2.ListIntentStageMetricsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentStageMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIntentStageMetrics")
	}

	var r0 *lexmodelsv2.ListIntentStageMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentStageMetricsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentStageMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentStageMetricsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListIntentStageMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListIntentStageMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListIntentStageMetricsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIntents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIntents(ctx context.Context, params *lexmodelsv2.ListIntentsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIntents")
	}

	var r0 *lexmodelsv2.ListIntentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListIntentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListIntentsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListIntentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListIntentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListIntentsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRecommendedIntents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRecommendedIntents(ctx context.Context, params *lexmodelsv2.ListRecommendedIntentsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListRecommendedIntentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRecommendedIntents")
	}

	var r0 *lexmodelsv2.ListRecommendedIntentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListRecommendedIntentsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListRecommendedIntentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListRecommendedIntentsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListRecommendedIntentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListRecommendedIntentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListRecommendedIntentsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSessionAnalyticsData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSessionAnalyticsData(ctx context.Context, params *lexmodelsv2.ListSessionAnalyticsDataInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSessionAnalyticsDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSessionAnalyticsData")
	}

	var r0 *lexmodelsv2.ListSessionAnalyticsDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSessionAnalyticsDataInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSessionAnalyticsDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSessionAnalyticsDataInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListSessionAnalyticsDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListSessionAnalyticsDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListSessionAnalyticsDataInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSessionMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSessionMetrics(ctx context.Context, params *lexmodelsv2.ListSessionMetricsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSessionMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSessionMetrics")
	}

	var r0 *lexmodelsv2.ListSessionMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSessionMetricsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSessionMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSessionMetricsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListSessionMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListSessionMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListSessionMetricsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSlotTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSlotTypes(ctx context.Context, params *lexmodelsv2.ListSlotTypesInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSlotTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSlotTypes")
	}

	var r0 *lexmodelsv2.ListSlotTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSlotTypesInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSlotTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSlotTypesInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListSlotTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListSlotTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListSlotTypesInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSlots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSlots(ctx context.Context, params *lexmodelsv2.ListSlotsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSlotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSlots")
	}

	var r0 *lexmodelsv2.ListSlotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSlotsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListSlotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListSlotsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListSlotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListSlotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListSlotsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *lexmodelsv2.ListTagsForResourceInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *lexmodelsv2.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTagsForResourceInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTagsForResourceInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListTagsForResourceInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTestExecutionResultItems provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTestExecutionResultItems(ctx context.Context, params *lexmodelsv2.ListTestExecutionResultItemsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestExecutionResultItemsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestExecutionResultItems")
	}

	var r0 *lexmodelsv2.ListTestExecutionResultItemsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestExecutionResultItemsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestExecutionResultItemsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestExecutionResultItemsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListTestExecutionResultItemsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListTestExecutionResultItemsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListTestExecutionResultItemsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTestExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTestExecutions(ctx context.Context, params *lexmodelsv2.ListTestExecutionsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestExecutions")
	}

	var r0 *lexmodelsv2.ListTestExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestExecutionsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestExecutionsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListTestExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListTestExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListTestExecutionsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTestSetRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTestSetRecords(ctx context.Context, params *lexmodelsv2.ListTestSetRecordsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestSetRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSetRecords")
	}

	var r0 *lexmodelsv2.ListTestSetRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestSetRecordsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestSetRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestSetRecordsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListTestSetRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListTestSetRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListTestSetRecordsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTestSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTestSets(ctx context.Context, params *lexmodelsv2.ListTestSetsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSets")
	}

	var r0 *lexmodelsv2.ListTestSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestSetsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListTestSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListTestSetsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListTestSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListTestSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListTestSetsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUtteranceAnalyticsData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUtteranceAnalyticsData(ctx context.Context, params *lexmodelsv2.ListUtteranceAnalyticsDataInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListUtteranceAnalyticsDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUtteranceAnalyticsData")
	}

	var r0 *lexmodelsv2.ListUtteranceAnalyticsDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListUtteranceAnalyticsDataInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListUtteranceAnalyticsDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListUtteranceAnalyticsDataInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListUtteranceAnalyticsDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListUtteranceAnalyticsDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListUtteranceAnalyticsDataInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUtteranceMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUtteranceMetrics(ctx context.Context, params *lexmodelsv2.ListUtteranceMetricsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListUtteranceMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUtteranceMetrics")
	}

	var r0 *lexmodelsv2.ListUtteranceMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListUtteranceMetricsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.ListUtteranceMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.ListUtteranceMetricsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.ListUtteranceMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.ListUtteranceMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.ListUtteranceMetricsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() lexmodelsv2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 lexmodelsv2.Options
	if rf, ok := ret.Get(0).(func() lexmodelsv2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(lexmodelsv2.Options)
	}

	return r0
}

// SearchAssociatedTranscripts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchAssociatedTranscripts(ctx context.Context, params *lexmodelsv2.SearchAssociatedTranscriptsInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.SearchAssociatedTranscriptsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchAssociatedTranscripts")
	}

	var r0 *lexmodelsv2.SearchAssociatedTranscriptsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.SearchAssociatedTranscriptsInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.SearchAssociatedTranscriptsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.SearchAssociatedTranscriptsInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.SearchAssociatedTranscriptsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.SearchAssociatedTranscriptsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.SearchAssociatedTranscriptsInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBotRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBotRecommendation(ctx context.Context, params *lexmodelsv2.StartBotRecommendationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartBotRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBotRecommendation")
	}

	var r0 *lexmodelsv2.StartBotRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartBotRecommendationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartBotRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartBotRecommendationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StartBotRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StartBotRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StartBotRecommendationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBotResourceGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBotResourceGeneration(ctx context.Context, params *lexmodelsv2.StartBotResourceGenerationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartBotResourceGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBotResourceGeneration")
	}

	var r0 *lexmodelsv2.StartBotResourceGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartBotResourceGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StartBotResourceGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StartBotResourceGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StartBotResourceGenerationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImport(ctx context.Context, params *lexmodelsv2.StartImportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImport")
	}

	var r0 *lexmodelsv2.StartImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartImportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartImportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StartImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StartImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StartImportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTestExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTestExecution(ctx context.Context, params *lexmodelsv2.StartTestExecutionInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartTestExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTestExecution")
	}

	var r0 *lexmodelsv2.StartTestExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartTestExecutionInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartTestExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartTestExecutionInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StartTestExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StartTestExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StartTestExecutionInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTestSetGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTestSetGeneration(ctx context.Context, params *lexmodelsv2.StartTestSetGenerationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartTestSetGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTestSetGeneration")
	}

	var r0 *lexmodelsv2.StartTestSetGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartTestSetGenerationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StartTestSetGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StartTestSetGenerationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StartTestSetGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StartTestSetGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StartTestSetGenerationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBotRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopBotRecommendation(ctx context.Context, params *lexmodelsv2.StopBotRecommendationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StopBotRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopBotRecommendation")
	}

	var r0 *lexmodelsv2.StopBotRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StopBotRecommendationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.StopBotRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.StopBotRecommendationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.StopBotRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.StopBotRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.StopBotRecommendationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *lexmodelsv2.TagResourceInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *lexmodelsv2.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.TagResourceInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.TagResourceInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.TagResourceInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *lexmodelsv2.UntagResourceInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *lexmodelsv2.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UntagResourceInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UntagResourceInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UntagResourceInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBot(ctx context.Context, params *lexmodelsv2.UpdateBotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBot")
	}

	var r0 *lexmodelsv2.UpdateBotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateBotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateBotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateBotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBotAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBotAlias(ctx context.Context, params *lexmodelsv2.UpdateBotAliasInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBotAlias")
	}

	var r0 *lexmodelsv2.UpdateBotAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotAliasInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotAliasInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateBotAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateBotAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateBotAliasInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBotLocale provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBotLocale(ctx context.Context, params *lexmodelsv2.UpdateBotLocaleInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotLocaleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBotLocale")
	}

	var r0 *lexmodelsv2.UpdateBotLocaleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotLocaleInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotLocaleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotLocaleInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateBotLocaleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateBotLocaleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateBotLocaleInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBotRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBotRecommendation(ctx context.Context, params *lexmodelsv2.UpdateBotRecommendationInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBotRecommendation")
	}

	var r0 *lexmodelsv2.UpdateBotRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotRecommendationInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateBotRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateBotRecommendationInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateBotRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateBotRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateBotRecommendationInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateExport(ctx context.Context, params *lexmodelsv2.UpdateExportInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExport")
	}

	var r0 *lexmodelsv2.UpdateExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateExportInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateExportInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateExportInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIntent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIntent(ctx context.Context, params *lexmodelsv2.UpdateIntentInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateIntentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIntent")
	}

	var r0 *lexmodelsv2.UpdateIntentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateIntentInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateIntentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateIntentInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateIntentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateIntentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateIntentInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResourcePolicy(ctx context.Context, params *lexmodelsv2.UpdateResourcePolicyInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResourcePolicy")
	}

	var r0 *lexmodelsv2.UpdateResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateResourcePolicyInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateResourcePolicyInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateResourcePolicyInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSlot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSlot(ctx context.Context, params *lexmodelsv2.UpdateSlotInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateSlotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSlot")
	}

	var r0 *lexmodelsv2.UpdateSlotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateSlotInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateSlotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateSlotInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateSlotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateSlotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateSlotInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSlotType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSlotType(ctx context.Context, params *lexmodelsv2.UpdateSlotTypeInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateSlotTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSlotType")
	}

	var r0 *lexmodelsv2.UpdateSlotTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateSlotTypeInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateSlotTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateSlotTypeInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateSlotTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateSlotTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateSlotTypeInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTestSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTestSet(ctx context.Context, params *lexmodelsv2.UpdateTestSetInput, optFns ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateTestSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTestSet")
	}

	var r0 *lexmodelsv2.UpdateTestSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateTestSetInput, ...func(*lexmodelsv2.Options)) (*lexmodelsv2.UpdateTestSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lexmodelsv2.UpdateTestSetInput, ...func(*lexmodelsv2.Options)) *lexmodelsv2.UpdateTestSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lexmodelsv2.UpdateTestSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lexmodelsv2.UpdateTestSetInput, ...func(*lexmodelsv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
