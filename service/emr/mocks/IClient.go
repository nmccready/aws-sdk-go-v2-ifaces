// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	emr "github.com/aws/aws-sdk-go-v2/service/emr"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddInstanceFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddInstanceFleet(ctx context.Context, params *emr.AddInstanceFleetInput, optFns ...func(*emr.Options)) (*emr.AddInstanceFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddInstanceFleet")
	}

	var r0 *emr.AddInstanceFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddInstanceFleetInput, ...func(*emr.Options)) (*emr.AddInstanceFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddInstanceFleetInput, ...func(*emr.Options)) *emr.AddInstanceFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.AddInstanceFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.AddInstanceFleetInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddInstanceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddInstanceGroups(ctx context.Context, params *emr.AddInstanceGroupsInput, optFns ...func(*emr.Options)) (*emr.AddInstanceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddInstanceGroups")
	}

	var r0 *emr.AddInstanceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddInstanceGroupsInput, ...func(*emr.Options)) (*emr.AddInstanceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddInstanceGroupsInput, ...func(*emr.Options)) *emr.AddInstanceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.AddInstanceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.AddInstanceGroupsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddJobFlowSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddJobFlowSteps(ctx context.Context, params *emr.AddJobFlowStepsInput, optFns ...func(*emr.Options)) (*emr.AddJobFlowStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddJobFlowSteps")
	}

	var r0 *emr.AddJobFlowStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddJobFlowStepsInput, ...func(*emr.Options)) (*emr.AddJobFlowStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddJobFlowStepsInput, ...func(*emr.Options)) *emr.AddJobFlowStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.AddJobFlowStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.AddJobFlowStepsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *emr.AddTagsInput, optFns ...func(*emr.Options)) (*emr.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *emr.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddTagsInput, ...func(*emr.Options)) (*emr.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.AddTagsInput, ...func(*emr.Options)) *emr.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.AddTagsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSteps(ctx context.Context, params *emr.CancelStepsInput, optFns ...func(*emr.Options)) (*emr.CancelStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSteps")
	}

	var r0 *emr.CancelStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CancelStepsInput, ...func(*emr.Options)) (*emr.CancelStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CancelStepsInput, ...func(*emr.Options)) *emr.CancelStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.CancelStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.CancelStepsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSecurityConfiguration(ctx context.Context, params *emr.CreateSecurityConfigurationInput, optFns ...func(*emr.Options)) (*emr.CreateSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityConfiguration")
	}

	var r0 *emr.CreateSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateSecurityConfigurationInput, ...func(*emr.Options)) (*emr.CreateSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateSecurityConfigurationInput, ...func(*emr.Options)) *emr.CreateSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.CreateSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.CreateSecurityConfigurationInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStudio provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStudio(ctx context.Context, params *emr.CreateStudioInput, optFns ...func(*emr.Options)) (*emr.CreateStudioOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStudio")
	}

	var r0 *emr.CreateStudioOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateStudioInput, ...func(*emr.Options)) (*emr.CreateStudioOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateStudioInput, ...func(*emr.Options)) *emr.CreateStudioOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.CreateStudioOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.CreateStudioInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStudioSessionMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStudioSessionMapping(ctx context.Context, params *emr.CreateStudioSessionMappingInput, optFns ...func(*emr.Options)) (*emr.CreateStudioSessionMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStudioSessionMapping")
	}

	var r0 *emr.CreateStudioSessionMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateStudioSessionMappingInput, ...func(*emr.Options)) (*emr.CreateStudioSessionMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.CreateStudioSessionMappingInput, ...func(*emr.Options)) *emr.CreateStudioSessionMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.CreateStudioSessionMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.CreateStudioSessionMappingInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSecurityConfiguration(ctx context.Context, params *emr.DeleteSecurityConfigurationInput, optFns ...func(*emr.Options)) (*emr.DeleteSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityConfiguration")
	}

	var r0 *emr.DeleteSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteSecurityConfigurationInput, ...func(*emr.Options)) (*emr.DeleteSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteSecurityConfigurationInput, ...func(*emr.Options)) *emr.DeleteSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DeleteSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DeleteSecurityConfigurationInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStudio provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStudio(ctx context.Context, params *emr.DeleteStudioInput, optFns ...func(*emr.Options)) (*emr.DeleteStudioOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStudio")
	}

	var r0 *emr.DeleteStudioOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteStudioInput, ...func(*emr.Options)) (*emr.DeleteStudioOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteStudioInput, ...func(*emr.Options)) *emr.DeleteStudioOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DeleteStudioOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DeleteStudioInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStudioSessionMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStudioSessionMapping(ctx context.Context, params *emr.DeleteStudioSessionMappingInput, optFns ...func(*emr.Options)) (*emr.DeleteStudioSessionMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStudioSessionMapping")
	}

	var r0 *emr.DeleteStudioSessionMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteStudioSessionMappingInput, ...func(*emr.Options)) (*emr.DeleteStudioSessionMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DeleteStudioSessionMappingInput, ...func(*emr.Options)) *emr.DeleteStudioSessionMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DeleteStudioSessionMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DeleteStudioSessionMappingInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCluster(ctx context.Context, params *emr.DescribeClusterInput, optFns ...func(*emr.Options)) (*emr.DescribeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCluster")
	}

	var r0 *emr.DescribeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeClusterInput, ...func(*emr.Options)) (*emr.DescribeClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeClusterInput, ...func(*emr.Options)) *emr.DescribeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeClusterInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJobFlows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJobFlows(ctx context.Context, params *emr.DescribeJobFlowsInput, optFns ...func(*emr.Options)) (*emr.DescribeJobFlowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJobFlows")
	}

	var r0 *emr.DescribeJobFlowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeJobFlowsInput, ...func(*emr.Options)) (*emr.DescribeJobFlowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeJobFlowsInput, ...func(*emr.Options)) *emr.DescribeJobFlowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeJobFlowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeJobFlowsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNotebookExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNotebookExecution(ctx context.Context, params *emr.DescribeNotebookExecutionInput, optFns ...func(*emr.Options)) (*emr.DescribeNotebookExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNotebookExecution")
	}

	var r0 *emr.DescribeNotebookExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeNotebookExecutionInput, ...func(*emr.Options)) (*emr.DescribeNotebookExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeNotebookExecutionInput, ...func(*emr.Options)) *emr.DescribeNotebookExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeNotebookExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeNotebookExecutionInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReleaseLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReleaseLabel(ctx context.Context, params *emr.DescribeReleaseLabelInput, optFns ...func(*emr.Options)) (*emr.DescribeReleaseLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReleaseLabel")
	}

	var r0 *emr.DescribeReleaseLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeReleaseLabelInput, ...func(*emr.Options)) (*emr.DescribeReleaseLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeReleaseLabelInput, ...func(*emr.Options)) *emr.DescribeReleaseLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeReleaseLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeReleaseLabelInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSecurityConfiguration(ctx context.Context, params *emr.DescribeSecurityConfigurationInput, optFns ...func(*emr.Options)) (*emr.DescribeSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityConfiguration")
	}

	var r0 *emr.DescribeSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeSecurityConfigurationInput, ...func(*emr.Options)) (*emr.DescribeSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeSecurityConfigurationInput, ...func(*emr.Options)) *emr.DescribeSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeSecurityConfigurationInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStep(ctx context.Context, params *emr.DescribeStepInput, optFns ...func(*emr.Options)) (*emr.DescribeStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStep")
	}

	var r0 *emr.DescribeStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeStepInput, ...func(*emr.Options)) (*emr.DescribeStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeStepInput, ...func(*emr.Options)) *emr.DescribeStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeStepInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStudio provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStudio(ctx context.Context, params *emr.DescribeStudioInput, optFns ...func(*emr.Options)) (*emr.DescribeStudioOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStudio")
	}

	var r0 *emr.DescribeStudioOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeStudioInput, ...func(*emr.Options)) (*emr.DescribeStudioOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.DescribeStudioInput, ...func(*emr.Options)) *emr.DescribeStudioOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.DescribeStudioOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.DescribeStudioInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAutoTerminationPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAutoTerminationPolicy(ctx context.Context, params *emr.GetAutoTerminationPolicyInput, optFns ...func(*emr.Options)) (*emr.GetAutoTerminationPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAutoTerminationPolicy")
	}

	var r0 *emr.GetAutoTerminationPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetAutoTerminationPolicyInput, ...func(*emr.Options)) (*emr.GetAutoTerminationPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetAutoTerminationPolicyInput, ...func(*emr.Options)) *emr.GetAutoTerminationPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.GetAutoTerminationPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.GetAutoTerminationPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockPublicAccessConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlockPublicAccessConfiguration(ctx context.Context, params *emr.GetBlockPublicAccessConfigurationInput, optFns ...func(*emr.Options)) (*emr.GetBlockPublicAccessConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockPublicAccessConfiguration")
	}

	var r0 *emr.GetBlockPublicAccessConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetBlockPublicAccessConfigurationInput, ...func(*emr.Options)) (*emr.GetBlockPublicAccessConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetBlockPublicAccessConfigurationInput, ...func(*emr.Options)) *emr.GetBlockPublicAccessConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.GetBlockPublicAccessConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.GetBlockPublicAccessConfigurationInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterSessionCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClusterSessionCredentials(ctx context.Context, params *emr.GetClusterSessionCredentialsInput, optFns ...func(*emr.Options)) (*emr.GetClusterSessionCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterSessionCredentials")
	}

	var r0 *emr.GetClusterSessionCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetClusterSessionCredentialsInput, ...func(*emr.Options)) (*emr.GetClusterSessionCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetClusterSessionCredentialsInput, ...func(*emr.Options)) *emr.GetClusterSessionCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.GetClusterSessionCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.GetClusterSessionCredentialsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetManagedScalingPolicy(ctx context.Context, params *emr.GetManagedScalingPolicyInput, optFns ...func(*emr.Options)) (*emr.GetManagedScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedScalingPolicy")
	}

	var r0 *emr.GetManagedScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetManagedScalingPolicyInput, ...func(*emr.Options)) (*emr.GetManagedScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetManagedScalingPolicyInput, ...func(*emr.Options)) *emr.GetManagedScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.GetManagedScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.GetManagedScalingPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStudioSessionMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStudioSessionMapping(ctx context.Context, params *emr.GetStudioSessionMappingInput, optFns ...func(*emr.Options)) (*emr.GetStudioSessionMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStudioSessionMapping")
	}

	var r0 *emr.GetStudioSessionMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetStudioSessionMappingInput, ...func(*emr.Options)) (*emr.GetStudioSessionMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.GetStudioSessionMappingInput, ...func(*emr.Options)) *emr.GetStudioSessionMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.GetStudioSessionMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.GetStudioSessionMappingInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBootstrapActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBootstrapActions(ctx context.Context, params *emr.ListBootstrapActionsInput, optFns ...func(*emr.Options)) (*emr.ListBootstrapActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBootstrapActions")
	}

	var r0 *emr.ListBootstrapActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListBootstrapActionsInput, ...func(*emr.Options)) (*emr.ListBootstrapActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListBootstrapActionsInput, ...func(*emr.Options)) *emr.ListBootstrapActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListBootstrapActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListBootstrapActionsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClusters(ctx context.Context, params *emr.ListClustersInput, optFns ...func(*emr.Options)) (*emr.ListClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusters")
	}

	var r0 *emr.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListClustersInput, ...func(*emr.Options)) (*emr.ListClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListClustersInput, ...func(*emr.Options)) *emr.ListClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListClustersInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInstanceFleets(ctx context.Context, params *emr.ListInstanceFleetsInput, optFns ...func(*emr.Options)) (*emr.ListInstanceFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInstanceFleets")
	}

	var r0 *emr.ListInstanceFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstanceFleetsInput, ...func(*emr.Options)) (*emr.ListInstanceFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstanceFleetsInput, ...func(*emr.Options)) *emr.ListInstanceFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListInstanceFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListInstanceFleetsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInstanceGroups(ctx context.Context, params *emr.ListInstanceGroupsInput, optFns ...func(*emr.Options)) (*emr.ListInstanceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInstanceGroups")
	}

	var r0 *emr.ListInstanceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstanceGroupsInput, ...func(*emr.Options)) (*emr.ListInstanceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstanceGroupsInput, ...func(*emr.Options)) *emr.ListInstanceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListInstanceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListInstanceGroupsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInstances(ctx context.Context, params *emr.ListInstancesInput, optFns ...func(*emr.Options)) (*emr.ListInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInstances")
	}

	var r0 *emr.ListInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstancesInput, ...func(*emr.Options)) (*emr.ListInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListInstancesInput, ...func(*emr.Options)) *emr.ListInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListInstancesInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNotebookExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNotebookExecutions(ctx context.Context, params *emr.ListNotebookExecutionsInput, optFns ...func(*emr.Options)) (*emr.ListNotebookExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNotebookExecutions")
	}

	var r0 *emr.ListNotebookExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListNotebookExecutionsInput, ...func(*emr.Options)) (*emr.ListNotebookExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListNotebookExecutionsInput, ...func(*emr.Options)) *emr.ListNotebookExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListNotebookExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListNotebookExecutionsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReleaseLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReleaseLabels(ctx context.Context, params *emr.ListReleaseLabelsInput, optFns ...func(*emr.Options)) (*emr.ListReleaseLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReleaseLabels")
	}

	var r0 *emr.ListReleaseLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListReleaseLabelsInput, ...func(*emr.Options)) (*emr.ListReleaseLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListReleaseLabelsInput, ...func(*emr.Options)) *emr.ListReleaseLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListReleaseLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListReleaseLabelsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSecurityConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSecurityConfigurations(ctx context.Context, params *emr.ListSecurityConfigurationsInput, optFns ...func(*emr.Options)) (*emr.ListSecurityConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSecurityConfigurations")
	}

	var r0 *emr.ListSecurityConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListSecurityConfigurationsInput, ...func(*emr.Options)) (*emr.ListSecurityConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListSecurityConfigurationsInput, ...func(*emr.Options)) *emr.ListSecurityConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListSecurityConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListSecurityConfigurationsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSteps(ctx context.Context, params *emr.ListStepsInput, optFns ...func(*emr.Options)) (*emr.ListStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSteps")
	}

	var r0 *emr.ListStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStepsInput, ...func(*emr.Options)) (*emr.ListStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStepsInput, ...func(*emr.Options)) *emr.ListStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListStepsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStudioSessionMappings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStudioSessionMappings(ctx context.Context, params *emr.ListStudioSessionMappingsInput, optFns ...func(*emr.Options)) (*emr.ListStudioSessionMappingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStudioSessionMappings")
	}

	var r0 *emr.ListStudioSessionMappingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStudioSessionMappingsInput, ...func(*emr.Options)) (*emr.ListStudioSessionMappingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStudioSessionMappingsInput, ...func(*emr.Options)) *emr.ListStudioSessionMappingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListStudioSessionMappingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListStudioSessionMappingsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStudios provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStudios(ctx context.Context, params *emr.ListStudiosInput, optFns ...func(*emr.Options)) (*emr.ListStudiosOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStudios")
	}

	var r0 *emr.ListStudiosOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStudiosInput, ...func(*emr.Options)) (*emr.ListStudiosOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListStudiosInput, ...func(*emr.Options)) *emr.ListStudiosOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListStudiosOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListStudiosInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSupportedInstanceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSupportedInstanceTypes(ctx context.Context, params *emr.ListSupportedInstanceTypesInput, optFns ...func(*emr.Options)) (*emr.ListSupportedInstanceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSupportedInstanceTypes")
	}

	var r0 *emr.ListSupportedInstanceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListSupportedInstanceTypesInput, ...func(*emr.Options)) (*emr.ListSupportedInstanceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ListSupportedInstanceTypesInput, ...func(*emr.Options)) *emr.ListSupportedInstanceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ListSupportedInstanceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ListSupportedInstanceTypesInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCluster(ctx context.Context, params *emr.ModifyClusterInput, optFns ...func(*emr.Options)) (*emr.ModifyClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCluster")
	}

	var r0 *emr.ModifyClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyClusterInput, ...func(*emr.Options)) (*emr.ModifyClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyClusterInput, ...func(*emr.Options)) *emr.ModifyClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ModifyClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ModifyClusterInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceFleet(ctx context.Context, params *emr.ModifyInstanceFleetInput, optFns ...func(*emr.Options)) (*emr.ModifyInstanceFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceFleet")
	}

	var r0 *emr.ModifyInstanceFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyInstanceFleetInput, ...func(*emr.Options)) (*emr.ModifyInstanceFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyInstanceFleetInput, ...func(*emr.Options)) *emr.ModifyInstanceFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ModifyInstanceFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ModifyInstanceFleetInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceGroups(ctx context.Context, params *emr.ModifyInstanceGroupsInput, optFns ...func(*emr.Options)) (*emr.ModifyInstanceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceGroups")
	}

	var r0 *emr.ModifyInstanceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyInstanceGroupsInput, ...func(*emr.Options)) (*emr.ModifyInstanceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.ModifyInstanceGroupsInput, ...func(*emr.Options)) *emr.ModifyInstanceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.ModifyInstanceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.ModifyInstanceGroupsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() emr.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 emr.Options
	if rf, ok := ret.Get(0).(func() emr.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(emr.Options)
	}

	return r0
}

// PutAutoScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutAutoScalingPolicy(ctx context.Context, params *emr.PutAutoScalingPolicyInput, optFns ...func(*emr.Options)) (*emr.PutAutoScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutAutoScalingPolicy")
	}

	var r0 *emr.PutAutoScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutAutoScalingPolicyInput, ...func(*emr.Options)) (*emr.PutAutoScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutAutoScalingPolicyInput, ...func(*emr.Options)) *emr.PutAutoScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.PutAutoScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.PutAutoScalingPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutAutoTerminationPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutAutoTerminationPolicy(ctx context.Context, params *emr.PutAutoTerminationPolicyInput, optFns ...func(*emr.Options)) (*emr.PutAutoTerminationPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutAutoTerminationPolicy")
	}

	var r0 *emr.PutAutoTerminationPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutAutoTerminationPolicyInput, ...func(*emr.Options)) (*emr.PutAutoTerminationPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutAutoTerminationPolicyInput, ...func(*emr.Options)) *emr.PutAutoTerminationPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.PutAutoTerminationPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.PutAutoTerminationPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutBlockPublicAccessConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutBlockPublicAccessConfiguration(ctx context.Context, params *emr.PutBlockPublicAccessConfigurationInput, optFns ...func(*emr.Options)) (*emr.PutBlockPublicAccessConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutBlockPublicAccessConfiguration")
	}

	var r0 *emr.PutBlockPublicAccessConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutBlockPublicAccessConfigurationInput, ...func(*emr.Options)) (*emr.PutBlockPublicAccessConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutBlockPublicAccessConfigurationInput, ...func(*emr.Options)) *emr.PutBlockPublicAccessConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.PutBlockPublicAccessConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.PutBlockPublicAccessConfigurationInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutManagedScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutManagedScalingPolicy(ctx context.Context, params *emr.PutManagedScalingPolicyInput, optFns ...func(*emr.Options)) (*emr.PutManagedScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutManagedScalingPolicy")
	}

	var r0 *emr.PutManagedScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutManagedScalingPolicyInput, ...func(*emr.Options)) (*emr.PutManagedScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.PutManagedScalingPolicyInput, ...func(*emr.Options)) *emr.PutManagedScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.PutManagedScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.PutManagedScalingPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveAutoScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveAutoScalingPolicy(ctx context.Context, params *emr.RemoveAutoScalingPolicyInput, optFns ...func(*emr.Options)) (*emr.RemoveAutoScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAutoScalingPolicy")
	}

	var r0 *emr.RemoveAutoScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveAutoScalingPolicyInput, ...func(*emr.Options)) (*emr.RemoveAutoScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveAutoScalingPolicyInput, ...func(*emr.Options)) *emr.RemoveAutoScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.RemoveAutoScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.RemoveAutoScalingPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveAutoTerminationPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveAutoTerminationPolicy(ctx context.Context, params *emr.RemoveAutoTerminationPolicyInput, optFns ...func(*emr.Options)) (*emr.RemoveAutoTerminationPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAutoTerminationPolicy")
	}

	var r0 *emr.RemoveAutoTerminationPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveAutoTerminationPolicyInput, ...func(*emr.Options)) (*emr.RemoveAutoTerminationPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveAutoTerminationPolicyInput, ...func(*emr.Options)) *emr.RemoveAutoTerminationPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.RemoveAutoTerminationPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.RemoveAutoTerminationPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveManagedScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveManagedScalingPolicy(ctx context.Context, params *emr.RemoveManagedScalingPolicyInput, optFns ...func(*emr.Options)) (*emr.RemoveManagedScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveManagedScalingPolicy")
	}

	var r0 *emr.RemoveManagedScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveManagedScalingPolicyInput, ...func(*emr.Options)) (*emr.RemoveManagedScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveManagedScalingPolicyInput, ...func(*emr.Options)) *emr.RemoveManagedScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.RemoveManagedScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.RemoveManagedScalingPolicyInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *emr.RemoveTagsInput, optFns ...func(*emr.Options)) (*emr.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *emr.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveTagsInput, ...func(*emr.Options)) (*emr.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RemoveTagsInput, ...func(*emr.Options)) *emr.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.RemoveTagsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunJobFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RunJobFlow(ctx context.Context, params *emr.RunJobFlowInput, optFns ...func(*emr.Options)) (*emr.RunJobFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunJobFlow")
	}

	var r0 *emr.RunJobFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RunJobFlowInput, ...func(*emr.Options)) (*emr.RunJobFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.RunJobFlowInput, ...func(*emr.Options)) *emr.RunJobFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.RunJobFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.RunJobFlowInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetKeepJobFlowAliveWhenNoSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetKeepJobFlowAliveWhenNoSteps(ctx context.Context, params *emr.SetKeepJobFlowAliveWhenNoStepsInput, optFns ...func(*emr.Options)) (*emr.SetKeepJobFlowAliveWhenNoStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetKeepJobFlowAliveWhenNoSteps")
	}

	var r0 *emr.SetKeepJobFlowAliveWhenNoStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetKeepJobFlowAliveWhenNoStepsInput, ...func(*emr.Options)) (*emr.SetKeepJobFlowAliveWhenNoStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetKeepJobFlowAliveWhenNoStepsInput, ...func(*emr.Options)) *emr.SetKeepJobFlowAliveWhenNoStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.SetKeepJobFlowAliveWhenNoStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.SetKeepJobFlowAliveWhenNoStepsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTerminationProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetTerminationProtection(ctx context.Context, params *emr.SetTerminationProtectionInput, optFns ...func(*emr.Options)) (*emr.SetTerminationProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTerminationProtection")
	}

	var r0 *emr.SetTerminationProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetTerminationProtectionInput, ...func(*emr.Options)) (*emr.SetTerminationProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetTerminationProtectionInput, ...func(*emr.Options)) *emr.SetTerminationProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.SetTerminationProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.SetTerminationProtectionInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetUnhealthyNodeReplacement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetUnhealthyNodeReplacement(ctx context.Context, params *emr.SetUnhealthyNodeReplacementInput, optFns ...func(*emr.Options)) (*emr.SetUnhealthyNodeReplacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetUnhealthyNodeReplacement")
	}

	var r0 *emr.SetUnhealthyNodeReplacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetUnhealthyNodeReplacementInput, ...func(*emr.Options)) (*emr.SetUnhealthyNodeReplacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetUnhealthyNodeReplacementInput, ...func(*emr.Options)) *emr.SetUnhealthyNodeReplacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.SetUnhealthyNodeReplacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.SetUnhealthyNodeReplacementInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetVisibleToAllUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetVisibleToAllUsers(ctx context.Context, params *emr.SetVisibleToAllUsersInput, optFns ...func(*emr.Options)) (*emr.SetVisibleToAllUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetVisibleToAllUsers")
	}

	var r0 *emr.SetVisibleToAllUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetVisibleToAllUsersInput, ...func(*emr.Options)) (*emr.SetVisibleToAllUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.SetVisibleToAllUsersInput, ...func(*emr.Options)) *emr.SetVisibleToAllUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.SetVisibleToAllUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.SetVisibleToAllUsersInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartNotebookExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartNotebookExecution(ctx context.Context, params *emr.StartNotebookExecutionInput, optFns ...func(*emr.Options)) (*emr.StartNotebookExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartNotebookExecution")
	}

	var r0 *emr.StartNotebookExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.StartNotebookExecutionInput, ...func(*emr.Options)) (*emr.StartNotebookExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.StartNotebookExecutionInput, ...func(*emr.Options)) *emr.StartNotebookExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.StartNotebookExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.StartNotebookExecutionInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopNotebookExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopNotebookExecution(ctx context.Context, params *emr.StopNotebookExecutionInput, optFns ...func(*emr.Options)) (*emr.StopNotebookExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopNotebookExecution")
	}

	var r0 *emr.StopNotebookExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.StopNotebookExecutionInput, ...func(*emr.Options)) (*emr.StopNotebookExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.StopNotebookExecutionInput, ...func(*emr.Options)) *emr.StopNotebookExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.StopNotebookExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.StopNotebookExecutionInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateJobFlows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateJobFlows(ctx context.Context, params *emr.TerminateJobFlowsInput, optFns ...func(*emr.Options)) (*emr.TerminateJobFlowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateJobFlows")
	}

	var r0 *emr.TerminateJobFlowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.TerminateJobFlowsInput, ...func(*emr.Options)) (*emr.TerminateJobFlowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.TerminateJobFlowsInput, ...func(*emr.Options)) *emr.TerminateJobFlowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.TerminateJobFlowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.TerminateJobFlowsInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStudio provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStudio(ctx context.Context, params *emr.UpdateStudioInput, optFns ...func(*emr.Options)) (*emr.UpdateStudioOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStudio")
	}

	var r0 *emr.UpdateStudioOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.UpdateStudioInput, ...func(*emr.Options)) (*emr.UpdateStudioOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.UpdateStudioInput, ...func(*emr.Options)) *emr.UpdateStudioOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.UpdateStudioOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.UpdateStudioInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStudioSessionMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStudioSessionMapping(ctx context.Context, params *emr.UpdateStudioSessionMappingInput, optFns ...func(*emr.Options)) (*emr.UpdateStudioSessionMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStudioSessionMapping")
	}

	var r0 *emr.UpdateStudioSessionMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *emr.UpdateStudioSessionMappingInput, ...func(*emr.Options)) (*emr.UpdateStudioSessionMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *emr.UpdateStudioSessionMappingInput, ...func(*emr.Options)) *emr.UpdateStudioSessionMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emr.UpdateStudioSessionMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *emr.UpdateStudioSessionMappingInput, ...func(*emr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
