// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	qldb "github.com/aws/aws-sdk-go-v2/service/qldb"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CancelJournalKinesisStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelJournalKinesisStream(ctx context.Context, params *qldb.CancelJournalKinesisStreamInput, optFns ...func(*qldb.Options)) (*qldb.CancelJournalKinesisStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelJournalKinesisStream")
	}

	var r0 *qldb.CancelJournalKinesisStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.CancelJournalKinesisStreamInput, ...func(*qldb.Options)) (*qldb.CancelJournalKinesisStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.CancelJournalKinesisStreamInput, ...func(*qldb.Options)) *qldb.CancelJournalKinesisStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.CancelJournalKinesisStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.CancelJournalKinesisStreamInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLedger(ctx context.Context, params *qldb.CreateLedgerInput, optFns ...func(*qldb.Options)) (*qldb.CreateLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLedger")
	}

	var r0 *qldb.CreateLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.CreateLedgerInput, ...func(*qldb.Options)) (*qldb.CreateLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.CreateLedgerInput, ...func(*qldb.Options)) *qldb.CreateLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.CreateLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.CreateLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLedger(ctx context.Context, params *qldb.DeleteLedgerInput, optFns ...func(*qldb.Options)) (*qldb.DeleteLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLedger")
	}

	var r0 *qldb.DeleteLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DeleteLedgerInput, ...func(*qldb.Options)) (*qldb.DeleteLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DeleteLedgerInput, ...func(*qldb.Options)) *qldb.DeleteLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.DeleteLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.DeleteLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJournalKinesisStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJournalKinesisStream(ctx context.Context, params *qldb.DescribeJournalKinesisStreamInput, optFns ...func(*qldb.Options)) (*qldb.DescribeJournalKinesisStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJournalKinesisStream")
	}

	var r0 *qldb.DescribeJournalKinesisStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeJournalKinesisStreamInput, ...func(*qldb.Options)) (*qldb.DescribeJournalKinesisStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeJournalKinesisStreamInput, ...func(*qldb.Options)) *qldb.DescribeJournalKinesisStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.DescribeJournalKinesisStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.DescribeJournalKinesisStreamInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJournalS3Export provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJournalS3Export(ctx context.Context, params *qldb.DescribeJournalS3ExportInput, optFns ...func(*qldb.Options)) (*qldb.DescribeJournalS3ExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJournalS3Export")
	}

	var r0 *qldb.DescribeJournalS3ExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeJournalS3ExportInput, ...func(*qldb.Options)) (*qldb.DescribeJournalS3ExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeJournalS3ExportInput, ...func(*qldb.Options)) *qldb.DescribeJournalS3ExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.DescribeJournalS3ExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.DescribeJournalS3ExportInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLedger(ctx context.Context, params *qldb.DescribeLedgerInput, optFns ...func(*qldb.Options)) (*qldb.DescribeLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLedger")
	}

	var r0 *qldb.DescribeLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeLedgerInput, ...func(*qldb.Options)) (*qldb.DescribeLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.DescribeLedgerInput, ...func(*qldb.Options)) *qldb.DescribeLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.DescribeLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.DescribeLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportJournalToS3 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportJournalToS3(ctx context.Context, params *qldb.ExportJournalToS3Input, optFns ...func(*qldb.Options)) (*qldb.ExportJournalToS3Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportJournalToS3")
	}

	var r0 *qldb.ExportJournalToS3Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ExportJournalToS3Input, ...func(*qldb.Options)) (*qldb.ExportJournalToS3Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ExportJournalToS3Input, ...func(*qldb.Options)) *qldb.ExportJournalToS3Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ExportJournalToS3Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ExportJournalToS3Input, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlock(ctx context.Context, params *qldb.GetBlockInput, optFns ...func(*qldb.Options)) (*qldb.GetBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlock")
	}

	var r0 *qldb.GetBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetBlockInput, ...func(*qldb.Options)) (*qldb.GetBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetBlockInput, ...func(*qldb.Options)) *qldb.GetBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.GetBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.GetBlockInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDigest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDigest(ctx context.Context, params *qldb.GetDigestInput, optFns ...func(*qldb.Options)) (*qldb.GetDigestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDigest")
	}

	var r0 *qldb.GetDigestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetDigestInput, ...func(*qldb.Options)) (*qldb.GetDigestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetDigestInput, ...func(*qldb.Options)) *qldb.GetDigestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.GetDigestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.GetDigestInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRevision provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRevision(ctx context.Context, params *qldb.GetRevisionInput, optFns ...func(*qldb.Options)) (*qldb.GetRevisionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRevision")
	}

	var r0 *qldb.GetRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetRevisionInput, ...func(*qldb.Options)) (*qldb.GetRevisionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.GetRevisionInput, ...func(*qldb.Options)) *qldb.GetRevisionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.GetRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.GetRevisionInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJournalKinesisStreamsForLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJournalKinesisStreamsForLedger(ctx context.Context, params *qldb.ListJournalKinesisStreamsForLedgerInput, optFns ...func(*qldb.Options)) (*qldb.ListJournalKinesisStreamsForLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJournalKinesisStreamsForLedger")
	}

	var r0 *qldb.ListJournalKinesisStreamsForLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalKinesisStreamsForLedgerInput, ...func(*qldb.Options)) (*qldb.ListJournalKinesisStreamsForLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalKinesisStreamsForLedgerInput, ...func(*qldb.Options)) *qldb.ListJournalKinesisStreamsForLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ListJournalKinesisStreamsForLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ListJournalKinesisStreamsForLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJournalS3Exports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJournalS3Exports(ctx context.Context, params *qldb.ListJournalS3ExportsInput, optFns ...func(*qldb.Options)) (*qldb.ListJournalS3ExportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJournalS3Exports")
	}

	var r0 *qldb.ListJournalS3ExportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalS3ExportsInput, ...func(*qldb.Options)) (*qldb.ListJournalS3ExportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalS3ExportsInput, ...func(*qldb.Options)) *qldb.ListJournalS3ExportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ListJournalS3ExportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ListJournalS3ExportsInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJournalS3ExportsForLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJournalS3ExportsForLedger(ctx context.Context, params *qldb.ListJournalS3ExportsForLedgerInput, optFns ...func(*qldb.Options)) (*qldb.ListJournalS3ExportsForLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJournalS3ExportsForLedger")
	}

	var r0 *qldb.ListJournalS3ExportsForLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalS3ExportsForLedgerInput, ...func(*qldb.Options)) (*qldb.ListJournalS3ExportsForLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListJournalS3ExportsForLedgerInput, ...func(*qldb.Options)) *qldb.ListJournalS3ExportsForLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ListJournalS3ExportsForLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ListJournalS3ExportsForLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLedgers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLedgers(ctx context.Context, params *qldb.ListLedgersInput, optFns ...func(*qldb.Options)) (*qldb.ListLedgersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLedgers")
	}

	var r0 *qldb.ListLedgersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListLedgersInput, ...func(*qldb.Options)) (*qldb.ListLedgersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListLedgersInput, ...func(*qldb.Options)) *qldb.ListLedgersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ListLedgersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ListLedgersInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *qldb.ListTagsForResourceInput, optFns ...func(*qldb.Options)) (*qldb.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *qldb.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListTagsForResourceInput, ...func(*qldb.Options)) (*qldb.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.ListTagsForResourceInput, ...func(*qldb.Options)) *qldb.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.ListTagsForResourceInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() qldb.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 qldb.Options
	if rf, ok := ret.Get(0).(func() qldb.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(qldb.Options)
	}

	return r0
}

// StreamJournalToKinesis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StreamJournalToKinesis(ctx context.Context, params *qldb.StreamJournalToKinesisInput, optFns ...func(*qldb.Options)) (*qldb.StreamJournalToKinesisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamJournalToKinesis")
	}

	var r0 *qldb.StreamJournalToKinesisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.StreamJournalToKinesisInput, ...func(*qldb.Options)) (*qldb.StreamJournalToKinesisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.StreamJournalToKinesisInput, ...func(*qldb.Options)) *qldb.StreamJournalToKinesisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.StreamJournalToKinesisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.StreamJournalToKinesisInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *qldb.TagResourceInput, optFns ...func(*qldb.Options)) (*qldb.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *qldb.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.TagResourceInput, ...func(*qldb.Options)) (*qldb.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.TagResourceInput, ...func(*qldb.Options)) *qldb.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.TagResourceInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *qldb.UntagResourceInput, optFns ...func(*qldb.Options)) (*qldb.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *qldb.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UntagResourceInput, ...func(*qldb.Options)) (*qldb.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UntagResourceInput, ...func(*qldb.Options)) *qldb.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.UntagResourceInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLedger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLedger(ctx context.Context, params *qldb.UpdateLedgerInput, optFns ...func(*qldb.Options)) (*qldb.UpdateLedgerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLedger")
	}

	var r0 *qldb.UpdateLedgerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UpdateLedgerInput, ...func(*qldb.Options)) (*qldb.UpdateLedgerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UpdateLedgerInput, ...func(*qldb.Options)) *qldb.UpdateLedgerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.UpdateLedgerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.UpdateLedgerInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLedgerPermissionsMode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLedgerPermissionsMode(ctx context.Context, params *qldb.UpdateLedgerPermissionsModeInput, optFns ...func(*qldb.Options)) (*qldb.UpdateLedgerPermissionsModeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLedgerPermissionsMode")
	}

	var r0 *qldb.UpdateLedgerPermissionsModeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UpdateLedgerPermissionsModeInput, ...func(*qldb.Options)) (*qldb.UpdateLedgerPermissionsModeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qldb.UpdateLedgerPermissionsModeInput, ...func(*qldb.Options)) *qldb.UpdateLedgerPermissionsModeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qldb.UpdateLedgerPermissionsModeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qldb.UpdateLedgerPermissionsModeInput, ...func(*qldb.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
