// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	bedrockagentcore "github.com/aws/aws-sdk-go-v2/service/bedrockagentcore"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEvent(ctx context.Context, params *bedrockagentcore.CreateEventInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.CreateEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEvent")
	}

	var r0 *bedrockagentcore.CreateEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.CreateEventInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.CreateEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.CreateEventInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.CreateEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.CreateEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.CreateEventInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEvent(ctx context.Context, params *bedrockagentcore.DeleteEventInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.DeleteEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 *bedrockagentcore.DeleteEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.DeleteEventInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.DeleteEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.DeleteEventInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.DeleteEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.DeleteEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.DeleteEventInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMemoryRecord provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMemoryRecord(ctx context.Context, params *bedrockagentcore.DeleteMemoryRecordInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.DeleteMemoryRecordOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMemoryRecord")
	}

	var r0 *bedrockagentcore.DeleteMemoryRecordOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.DeleteMemoryRecordInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.DeleteMemoryRecordOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.DeleteMemoryRecordInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.DeleteMemoryRecordOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.DeleteMemoryRecordOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.DeleteMemoryRecordInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBrowserSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBrowserSession(ctx context.Context, params *bedrockagentcore.GetBrowserSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetBrowserSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBrowserSession")
	}

	var r0 *bedrockagentcore.GetBrowserSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetBrowserSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetBrowserSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetBrowserSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetBrowserSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetBrowserSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetBrowserSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCodeInterpreterSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCodeInterpreterSession(ctx context.Context, params *bedrockagentcore.GetCodeInterpreterSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetCodeInterpreterSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCodeInterpreterSession")
	}

	var r0 *bedrockagentcore.GetCodeInterpreterSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetCodeInterpreterSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetCodeInterpreterSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetCodeInterpreterSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvent(ctx context.Context, params *bedrockagentcore.GetEventInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvent")
	}

	var r0 *bedrockagentcore.GetEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetEventInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetEventInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetEventInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemoryRecord provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMemoryRecord(ctx context.Context, params *bedrockagentcore.GetMemoryRecordInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetMemoryRecordOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMemoryRecord")
	}

	var r0 *bedrockagentcore.GetMemoryRecordOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetMemoryRecordInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetMemoryRecordOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetMemoryRecordInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetMemoryRecordOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetMemoryRecordOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetMemoryRecordInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourceApiKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourceApiKey(ctx context.Context, params *bedrockagentcore.GetResourceApiKeyInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetResourceApiKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourceApiKey")
	}

	var r0 *bedrockagentcore.GetResourceApiKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetResourceApiKeyInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetResourceApiKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetResourceApiKeyInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetResourceApiKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetResourceApiKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetResourceApiKeyInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourceOauth2Token provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourceOauth2Token(ctx context.Context, params *bedrockagentcore.GetResourceOauth2TokenInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetResourceOauth2TokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourceOauth2Token")
	}

	var r0 *bedrockagentcore.GetResourceOauth2TokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetResourceOauth2TokenInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetResourceOauth2TokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetResourceOauth2TokenInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetResourceOauth2TokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetResourceOauth2TokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetResourceOauth2TokenInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkloadAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkloadAccessToken(ctx context.Context, params *bedrockagentcore.GetWorkloadAccessTokenInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkloadAccessToken")
	}

	var r0 *bedrockagentcore.GetWorkloadAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetWorkloadAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetWorkloadAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkloadAccessTokenForJWT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkloadAccessTokenForJWT(ctx context.Context, params *bedrockagentcore.GetWorkloadAccessTokenForJWTInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenForJWTOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkloadAccessTokenForJWT")
	}

	var r0 *bedrockagentcore.GetWorkloadAccessTokenForJWTOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForJWTInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenForJWTOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForJWTInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetWorkloadAccessTokenForJWTOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetWorkloadAccessTokenForJWTOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForJWTInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkloadAccessTokenForUserId provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkloadAccessTokenForUserId(ctx context.Context, params *bedrockagentcore.GetWorkloadAccessTokenForUserIdInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenForUserIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkloadAccessTokenForUserId")
	}

	var r0 *bedrockagentcore.GetWorkloadAccessTokenForUserIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForUserIdInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.GetWorkloadAccessTokenForUserIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForUserIdInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.GetWorkloadAccessTokenForUserIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.GetWorkloadAccessTokenForUserIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.GetWorkloadAccessTokenForUserIdInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvokeAgentRuntime provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InvokeAgentRuntime(ctx context.Context, params *bedrockagentcore.InvokeAgentRuntimeInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.InvokeAgentRuntimeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InvokeAgentRuntime")
	}

	var r0 *bedrockagentcore.InvokeAgentRuntimeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.InvokeAgentRuntimeInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.InvokeAgentRuntimeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.InvokeAgentRuntimeInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.InvokeAgentRuntimeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.InvokeAgentRuntimeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.InvokeAgentRuntimeInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvokeCodeInterpreter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InvokeCodeInterpreter(ctx context.Context, params *bedrockagentcore.InvokeCodeInterpreterInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.InvokeCodeInterpreterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InvokeCodeInterpreter")
	}

	var r0 *bedrockagentcore.InvokeCodeInterpreterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.InvokeCodeInterpreterInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.InvokeCodeInterpreterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.InvokeCodeInterpreterInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.InvokeCodeInterpreterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.InvokeCodeInterpreterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.InvokeCodeInterpreterInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActors(ctx context.Context, params *bedrockagentcore.ListActorsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListActorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActors")
	}

	var r0 *bedrockagentcore.ListActorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListActorsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListActorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListActorsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListActorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListActorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListActorsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBrowserSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBrowserSessions(ctx context.Context, params *bedrockagentcore.ListBrowserSessionsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListBrowserSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBrowserSessions")
	}

	var r0 *bedrockagentcore.ListBrowserSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListBrowserSessionsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListBrowserSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListBrowserSessionsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListBrowserSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListBrowserSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListBrowserSessionsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeInterpreterSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCodeInterpreterSessions(ctx context.Context, params *bedrockagentcore.ListCodeInterpreterSessionsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListCodeInterpreterSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCodeInterpreterSessions")
	}

	var r0 *bedrockagentcore.ListCodeInterpreterSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListCodeInterpreterSessionsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListCodeInterpreterSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListCodeInterpreterSessionsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListCodeInterpreterSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListCodeInterpreterSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListCodeInterpreterSessionsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEvents(ctx context.Context, params *bedrockagentcore.ListEventsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEvents")
	}

	var r0 *bedrockagentcore.ListEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListEventsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListEventsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListEventsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMemoryRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMemoryRecords(ctx context.Context, params *bedrockagentcore.ListMemoryRecordsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListMemoryRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMemoryRecords")
	}

	var r0 *bedrockagentcore.ListMemoryRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListMemoryRecordsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListMemoryRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListMemoryRecordsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListMemoryRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListMemoryRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListMemoryRecordsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSessions(ctx context.Context, params *bedrockagentcore.ListSessionsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSessions")
	}

	var r0 *bedrockagentcore.ListSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListSessionsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.ListSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.ListSessionsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.ListSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.ListSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.ListSessionsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() bedrockagentcore.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 bedrockagentcore.Options
	if rf, ok := ret.Get(0).(func() bedrockagentcore.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bedrockagentcore.Options)
	}

	return r0
}

// RetrieveMemoryRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetrieveMemoryRecords(ctx context.Context, params *bedrockagentcore.RetrieveMemoryRecordsInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.RetrieveMemoryRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveMemoryRecords")
	}

	var r0 *bedrockagentcore.RetrieveMemoryRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.RetrieveMemoryRecordsInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.RetrieveMemoryRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.RetrieveMemoryRecordsInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.RetrieveMemoryRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.RetrieveMemoryRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.RetrieveMemoryRecordsInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBrowserSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBrowserSession(ctx context.Context, params *bedrockagentcore.StartBrowserSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StartBrowserSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBrowserSession")
	}

	var r0 *bedrockagentcore.StartBrowserSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StartBrowserSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StartBrowserSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StartBrowserSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.StartBrowserSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.StartBrowserSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.StartBrowserSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartCodeInterpreterSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCodeInterpreterSession(ctx context.Context, params *bedrockagentcore.StartCodeInterpreterSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StartCodeInterpreterSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCodeInterpreterSession")
	}

	var r0 *bedrockagentcore.StartCodeInterpreterSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StartCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StartCodeInterpreterSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StartCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.StartCodeInterpreterSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.StartCodeInterpreterSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.StartCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBrowserSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopBrowserSession(ctx context.Context, params *bedrockagentcore.StopBrowserSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StopBrowserSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopBrowserSession")
	}

	var r0 *bedrockagentcore.StopBrowserSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StopBrowserSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StopBrowserSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StopBrowserSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.StopBrowserSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.StopBrowserSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.StopBrowserSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopCodeInterpreterSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopCodeInterpreterSession(ctx context.Context, params *bedrockagentcore.StopCodeInterpreterSessionInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StopCodeInterpreterSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopCodeInterpreterSession")
	}

	var r0 *bedrockagentcore.StopCodeInterpreterSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StopCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.StopCodeInterpreterSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.StopCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.StopCodeInterpreterSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.StopCodeInterpreterSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.StopCodeInterpreterSessionInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrowserStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBrowserStream(ctx context.Context, params *bedrockagentcore.UpdateBrowserStreamInput, optFns ...func(*bedrockagentcore.Options)) (*bedrockagentcore.UpdateBrowserStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBrowserStream")
	}

	var r0 *bedrockagentcore.UpdateBrowserStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.UpdateBrowserStreamInput, ...func(*bedrockagentcore.Options)) (*bedrockagentcore.UpdateBrowserStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagentcore.UpdateBrowserStreamInput, ...func(*bedrockagentcore.Options)) *bedrockagentcore.UpdateBrowserStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagentcore.UpdateBrowserStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagentcore.UpdateBrowserStreamInput, ...func(*bedrockagentcore.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
