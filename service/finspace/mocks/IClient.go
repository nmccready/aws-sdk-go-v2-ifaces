// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	finspace "github.com/aws/aws-sdk-go-v2/service/finspace"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEnvironment(ctx context.Context, params *finspace.CreateEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.CreateEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEnvironment")
	}

	var r0 *finspace.CreateEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateEnvironmentInput, ...func(*finspace.Options)) (*finspace.CreateEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateEnvironmentInput, ...func(*finspace.Options)) *finspace.CreateEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxChangeset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxChangeset(ctx context.Context, params *finspace.CreateKxChangesetInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxChangesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxChangeset")
	}

	var r0 *finspace.CreateKxChangesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxChangesetInput, ...func(*finspace.Options)) (*finspace.CreateKxChangesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxChangesetInput, ...func(*finspace.Options)) *finspace.CreateKxChangesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxChangesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxChangesetInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxCluster(ctx context.Context, params *finspace.CreateKxClusterInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxCluster")
	}

	var r0 *finspace.CreateKxClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxClusterInput, ...func(*finspace.Options)) (*finspace.CreateKxClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxClusterInput, ...func(*finspace.Options)) *finspace.CreateKxClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxClusterInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxDatabase(ctx context.Context, params *finspace.CreateKxDatabaseInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxDatabase")
	}

	var r0 *finspace.CreateKxDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxDatabaseInput, ...func(*finspace.Options)) (*finspace.CreateKxDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxDatabaseInput, ...func(*finspace.Options)) *finspace.CreateKxDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxDatabaseInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxDataview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxDataview(ctx context.Context, params *finspace.CreateKxDataviewInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxDataviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxDataview")
	}

	var r0 *finspace.CreateKxDataviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxDataviewInput, ...func(*finspace.Options)) (*finspace.CreateKxDataviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxDataviewInput, ...func(*finspace.Options)) *finspace.CreateKxDataviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxDataviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxDataviewInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxEnvironment(ctx context.Context, params *finspace.CreateKxEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxEnvironment")
	}

	var r0 *finspace.CreateKxEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxEnvironmentInput, ...func(*finspace.Options)) (*finspace.CreateKxEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxEnvironmentInput, ...func(*finspace.Options)) *finspace.CreateKxEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxScalingGroup(ctx context.Context, params *finspace.CreateKxScalingGroupInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxScalingGroup")
	}

	var r0 *finspace.CreateKxScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxScalingGroupInput, ...func(*finspace.Options)) (*finspace.CreateKxScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxScalingGroupInput, ...func(*finspace.Options)) *finspace.CreateKxScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxScalingGroupInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxUser(ctx context.Context, params *finspace.CreateKxUserInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxUser")
	}

	var r0 *finspace.CreateKxUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxUserInput, ...func(*finspace.Options)) (*finspace.CreateKxUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxUserInput, ...func(*finspace.Options)) *finspace.CreateKxUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxUserInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKxVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKxVolume(ctx context.Context, params *finspace.CreateKxVolumeInput, optFns ...func(*finspace.Options)) (*finspace.CreateKxVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKxVolume")
	}

	var r0 *finspace.CreateKxVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxVolumeInput, ...func(*finspace.Options)) (*finspace.CreateKxVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.CreateKxVolumeInput, ...func(*finspace.Options)) *finspace.CreateKxVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.CreateKxVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.CreateKxVolumeInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEnvironment(ctx context.Context, params *finspace.DeleteEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.DeleteEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEnvironment")
	}

	var r0 *finspace.DeleteEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteEnvironmentInput, ...func(*finspace.Options)) (*finspace.DeleteEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteEnvironmentInput, ...func(*finspace.Options)) *finspace.DeleteEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxCluster(ctx context.Context, params *finspace.DeleteKxClusterInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxCluster")
	}

	var r0 *finspace.DeleteKxClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxClusterInput, ...func(*finspace.Options)) (*finspace.DeleteKxClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxClusterInput, ...func(*finspace.Options)) *finspace.DeleteKxClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxClusterInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxClusterNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxClusterNode(ctx context.Context, params *finspace.DeleteKxClusterNodeInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxClusterNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxClusterNode")
	}

	var r0 *finspace.DeleteKxClusterNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxClusterNodeInput, ...func(*finspace.Options)) (*finspace.DeleteKxClusterNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxClusterNodeInput, ...func(*finspace.Options)) *finspace.DeleteKxClusterNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxClusterNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxClusterNodeInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxDatabase(ctx context.Context, params *finspace.DeleteKxDatabaseInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxDatabase")
	}

	var r0 *finspace.DeleteKxDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxDatabaseInput, ...func(*finspace.Options)) (*finspace.DeleteKxDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxDatabaseInput, ...func(*finspace.Options)) *finspace.DeleteKxDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxDatabaseInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxDataview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxDataview(ctx context.Context, params *finspace.DeleteKxDataviewInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxDataviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxDataview")
	}

	var r0 *finspace.DeleteKxDataviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxDataviewInput, ...func(*finspace.Options)) (*finspace.DeleteKxDataviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxDataviewInput, ...func(*finspace.Options)) *finspace.DeleteKxDataviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxDataviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxDataviewInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxEnvironment(ctx context.Context, params *finspace.DeleteKxEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxEnvironment")
	}

	var r0 *finspace.DeleteKxEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxEnvironmentInput, ...func(*finspace.Options)) (*finspace.DeleteKxEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxEnvironmentInput, ...func(*finspace.Options)) *finspace.DeleteKxEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxScalingGroup(ctx context.Context, params *finspace.DeleteKxScalingGroupInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxScalingGroup")
	}

	var r0 *finspace.DeleteKxScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxScalingGroupInput, ...func(*finspace.Options)) (*finspace.DeleteKxScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxScalingGroupInput, ...func(*finspace.Options)) *finspace.DeleteKxScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxScalingGroupInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxUser(ctx context.Context, params *finspace.DeleteKxUserInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxUser")
	}

	var r0 *finspace.DeleteKxUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxUserInput, ...func(*finspace.Options)) (*finspace.DeleteKxUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxUserInput, ...func(*finspace.Options)) *finspace.DeleteKxUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxUserInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKxVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKxVolume(ctx context.Context, params *finspace.DeleteKxVolumeInput, optFns ...func(*finspace.Options)) (*finspace.DeleteKxVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKxVolume")
	}

	var r0 *finspace.DeleteKxVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxVolumeInput, ...func(*finspace.Options)) (*finspace.DeleteKxVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.DeleteKxVolumeInput, ...func(*finspace.Options)) *finspace.DeleteKxVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.DeleteKxVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.DeleteKxVolumeInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEnvironment(ctx context.Context, params *finspace.GetEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.GetEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEnvironment")
	}

	var r0 *finspace.GetEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetEnvironmentInput, ...func(*finspace.Options)) (*finspace.GetEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetEnvironmentInput, ...func(*finspace.Options)) *finspace.GetEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxChangeset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxChangeset(ctx context.Context, params *finspace.GetKxChangesetInput, optFns ...func(*finspace.Options)) (*finspace.GetKxChangesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxChangeset")
	}

	var r0 *finspace.GetKxChangesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxChangesetInput, ...func(*finspace.Options)) (*finspace.GetKxChangesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxChangesetInput, ...func(*finspace.Options)) *finspace.GetKxChangesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxChangesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxChangesetInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxCluster(ctx context.Context, params *finspace.GetKxClusterInput, optFns ...func(*finspace.Options)) (*finspace.GetKxClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxCluster")
	}

	var r0 *finspace.GetKxClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxClusterInput, ...func(*finspace.Options)) (*finspace.GetKxClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxClusterInput, ...func(*finspace.Options)) *finspace.GetKxClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxClusterInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxConnectionString provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxConnectionString(ctx context.Context, params *finspace.GetKxConnectionStringInput, optFns ...func(*finspace.Options)) (*finspace.GetKxConnectionStringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxConnectionString")
	}

	var r0 *finspace.GetKxConnectionStringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxConnectionStringInput, ...func(*finspace.Options)) (*finspace.GetKxConnectionStringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxConnectionStringInput, ...func(*finspace.Options)) *finspace.GetKxConnectionStringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxConnectionStringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxConnectionStringInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxDatabase(ctx context.Context, params *finspace.GetKxDatabaseInput, optFns ...func(*finspace.Options)) (*finspace.GetKxDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxDatabase")
	}

	var r0 *finspace.GetKxDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxDatabaseInput, ...func(*finspace.Options)) (*finspace.GetKxDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxDatabaseInput, ...func(*finspace.Options)) *finspace.GetKxDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxDatabaseInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxDataview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxDataview(ctx context.Context, params *finspace.GetKxDataviewInput, optFns ...func(*finspace.Options)) (*finspace.GetKxDataviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxDataview")
	}

	var r0 *finspace.GetKxDataviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxDataviewInput, ...func(*finspace.Options)) (*finspace.GetKxDataviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxDataviewInput, ...func(*finspace.Options)) *finspace.GetKxDataviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxDataviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxDataviewInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxEnvironment(ctx context.Context, params *finspace.GetKxEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.GetKxEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxEnvironment")
	}

	var r0 *finspace.GetKxEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxEnvironmentInput, ...func(*finspace.Options)) (*finspace.GetKxEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxEnvironmentInput, ...func(*finspace.Options)) *finspace.GetKxEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxScalingGroup(ctx context.Context, params *finspace.GetKxScalingGroupInput, optFns ...func(*finspace.Options)) (*finspace.GetKxScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxScalingGroup")
	}

	var r0 *finspace.GetKxScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxScalingGroupInput, ...func(*finspace.Options)) (*finspace.GetKxScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxScalingGroupInput, ...func(*finspace.Options)) *finspace.GetKxScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxScalingGroupInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxUser(ctx context.Context, params *finspace.GetKxUserInput, optFns ...func(*finspace.Options)) (*finspace.GetKxUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxUser")
	}

	var r0 *finspace.GetKxUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxUserInput, ...func(*finspace.Options)) (*finspace.GetKxUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxUserInput, ...func(*finspace.Options)) *finspace.GetKxUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxUserInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKxVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKxVolume(ctx context.Context, params *finspace.GetKxVolumeInput, optFns ...func(*finspace.Options)) (*finspace.GetKxVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKxVolume")
	}

	var r0 *finspace.GetKxVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxVolumeInput, ...func(*finspace.Options)) (*finspace.GetKxVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.GetKxVolumeInput, ...func(*finspace.Options)) *finspace.GetKxVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.GetKxVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.GetKxVolumeInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEnvironments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEnvironments(ctx context.Context, params *finspace.ListEnvironmentsInput, optFns ...func(*finspace.Options)) (*finspace.ListEnvironmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEnvironments")
	}

	var r0 *finspace.ListEnvironmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListEnvironmentsInput, ...func(*finspace.Options)) (*finspace.ListEnvironmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListEnvironmentsInput, ...func(*finspace.Options)) *finspace.ListEnvironmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListEnvironmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListEnvironmentsInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxChangesets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxChangesets(ctx context.Context, params *finspace.ListKxChangesetsInput, optFns ...func(*finspace.Options)) (*finspace.ListKxChangesetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxChangesets")
	}

	var r0 *finspace.ListKxChangesetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxChangesetsInput, ...func(*finspace.Options)) (*finspace.ListKxChangesetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxChangesetsInput, ...func(*finspace.Options)) *finspace.ListKxChangesetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxChangesetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxChangesetsInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxClusterNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxClusterNodes(ctx context.Context, params *finspace.ListKxClusterNodesInput, optFns ...func(*finspace.Options)) (*finspace.ListKxClusterNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxClusterNodes")
	}

	var r0 *finspace.ListKxClusterNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxClusterNodesInput, ...func(*finspace.Options)) (*finspace.ListKxClusterNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxClusterNodesInput, ...func(*finspace.Options)) *finspace.ListKxClusterNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxClusterNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxClusterNodesInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxClusters(ctx context.Context, params *finspace.ListKxClustersInput, optFns ...func(*finspace.Options)) (*finspace.ListKxClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxClusters")
	}

	var r0 *finspace.ListKxClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxClustersInput, ...func(*finspace.Options)) (*finspace.ListKxClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxClustersInput, ...func(*finspace.Options)) *finspace.ListKxClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxClustersInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxDatabases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxDatabases(ctx context.Context, params *finspace.ListKxDatabasesInput, optFns ...func(*finspace.Options)) (*finspace.ListKxDatabasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxDatabases")
	}

	var r0 *finspace.ListKxDatabasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxDatabasesInput, ...func(*finspace.Options)) (*finspace.ListKxDatabasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxDatabasesInput, ...func(*finspace.Options)) *finspace.ListKxDatabasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxDatabasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxDatabasesInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxDataviews provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxDataviews(ctx context.Context, params *finspace.ListKxDataviewsInput, optFns ...func(*finspace.Options)) (*finspace.ListKxDataviewsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxDataviews")
	}

	var r0 *finspace.ListKxDataviewsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxDataviewsInput, ...func(*finspace.Options)) (*finspace.ListKxDataviewsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxDataviewsInput, ...func(*finspace.Options)) *finspace.ListKxDataviewsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxDataviewsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxDataviewsInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxEnvironments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxEnvironments(ctx context.Context, params *finspace.ListKxEnvironmentsInput, optFns ...func(*finspace.Options)) (*finspace.ListKxEnvironmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxEnvironments")
	}

	var r0 *finspace.ListKxEnvironmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxEnvironmentsInput, ...func(*finspace.Options)) (*finspace.ListKxEnvironmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxEnvironmentsInput, ...func(*finspace.Options)) *finspace.ListKxEnvironmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxEnvironmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxEnvironmentsInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxScalingGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxScalingGroups(ctx context.Context, params *finspace.ListKxScalingGroupsInput, optFns ...func(*finspace.Options)) (*finspace.ListKxScalingGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxScalingGroups")
	}

	var r0 *finspace.ListKxScalingGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxScalingGroupsInput, ...func(*finspace.Options)) (*finspace.ListKxScalingGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxScalingGroupsInput, ...func(*finspace.Options)) *finspace.ListKxScalingGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxScalingGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxScalingGroupsInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxUsers(ctx context.Context, params *finspace.ListKxUsersInput, optFns ...func(*finspace.Options)) (*finspace.ListKxUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxUsers")
	}

	var r0 *finspace.ListKxUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxUsersInput, ...func(*finspace.Options)) (*finspace.ListKxUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxUsersInput, ...func(*finspace.Options)) *finspace.ListKxUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxUsersInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKxVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKxVolumes(ctx context.Context, params *finspace.ListKxVolumesInput, optFns ...func(*finspace.Options)) (*finspace.ListKxVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKxVolumes")
	}

	var r0 *finspace.ListKxVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxVolumesInput, ...func(*finspace.Options)) (*finspace.ListKxVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListKxVolumesInput, ...func(*finspace.Options)) *finspace.ListKxVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListKxVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListKxVolumesInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *finspace.ListTagsForResourceInput, optFns ...func(*finspace.Options)) (*finspace.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *finspace.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListTagsForResourceInput, ...func(*finspace.Options)) (*finspace.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.ListTagsForResourceInput, ...func(*finspace.Options)) *finspace.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.ListTagsForResourceInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() finspace.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 finspace.Options
	if rf, ok := ret.Get(0).(func() finspace.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(finspace.Options)
	}

	return r0
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *finspace.TagResourceInput, optFns ...func(*finspace.Options)) (*finspace.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *finspace.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.TagResourceInput, ...func(*finspace.Options)) (*finspace.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.TagResourceInput, ...func(*finspace.Options)) *finspace.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.TagResourceInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *finspace.UntagResourceInput, optFns ...func(*finspace.Options)) (*finspace.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *finspace.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UntagResourceInput, ...func(*finspace.Options)) (*finspace.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UntagResourceInput, ...func(*finspace.Options)) *finspace.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UntagResourceInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEnvironment(ctx context.Context, params *finspace.UpdateEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.UpdateEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEnvironment")
	}

	var r0 *finspace.UpdateEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateEnvironmentInput, ...func(*finspace.Options)) (*finspace.UpdateEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateEnvironmentInput, ...func(*finspace.Options)) *finspace.UpdateEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxClusterCodeConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxClusterCodeConfiguration(ctx context.Context, params *finspace.UpdateKxClusterCodeConfigurationInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxClusterCodeConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxClusterCodeConfiguration")
	}

	var r0 *finspace.UpdateKxClusterCodeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxClusterCodeConfigurationInput, ...func(*finspace.Options)) (*finspace.UpdateKxClusterCodeConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxClusterCodeConfigurationInput, ...func(*finspace.Options)) *finspace.UpdateKxClusterCodeConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxClusterCodeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxClusterCodeConfigurationInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxClusterDatabases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxClusterDatabases(ctx context.Context, params *finspace.UpdateKxClusterDatabasesInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxClusterDatabasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxClusterDatabases")
	}

	var r0 *finspace.UpdateKxClusterDatabasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxClusterDatabasesInput, ...func(*finspace.Options)) (*finspace.UpdateKxClusterDatabasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxClusterDatabasesInput, ...func(*finspace.Options)) *finspace.UpdateKxClusterDatabasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxClusterDatabasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxClusterDatabasesInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxDatabase(ctx context.Context, params *finspace.UpdateKxDatabaseInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxDatabase")
	}

	var r0 *finspace.UpdateKxDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxDatabaseInput, ...func(*finspace.Options)) (*finspace.UpdateKxDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxDatabaseInput, ...func(*finspace.Options)) *finspace.UpdateKxDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxDatabaseInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxDataview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxDataview(ctx context.Context, params *finspace.UpdateKxDataviewInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxDataviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxDataview")
	}

	var r0 *finspace.UpdateKxDataviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxDataviewInput, ...func(*finspace.Options)) (*finspace.UpdateKxDataviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxDataviewInput, ...func(*finspace.Options)) *finspace.UpdateKxDataviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxDataviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxDataviewInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxEnvironment(ctx context.Context, params *finspace.UpdateKxEnvironmentInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxEnvironment")
	}

	var r0 *finspace.UpdateKxEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxEnvironmentInput, ...func(*finspace.Options)) (*finspace.UpdateKxEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxEnvironmentInput, ...func(*finspace.Options)) *finspace.UpdateKxEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxEnvironmentInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxEnvironmentNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxEnvironmentNetwork(ctx context.Context, params *finspace.UpdateKxEnvironmentNetworkInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxEnvironmentNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxEnvironmentNetwork")
	}

	var r0 *finspace.UpdateKxEnvironmentNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxEnvironmentNetworkInput, ...func(*finspace.Options)) (*finspace.UpdateKxEnvironmentNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxEnvironmentNetworkInput, ...func(*finspace.Options)) *finspace.UpdateKxEnvironmentNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxEnvironmentNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxEnvironmentNetworkInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxUser(ctx context.Context, params *finspace.UpdateKxUserInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxUser")
	}

	var r0 *finspace.UpdateKxUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxUserInput, ...func(*finspace.Options)) (*finspace.UpdateKxUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxUserInput, ...func(*finspace.Options)) *finspace.UpdateKxUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxUserInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKxVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKxVolume(ctx context.Context, params *finspace.UpdateKxVolumeInput, optFns ...func(*finspace.Options)) (*finspace.UpdateKxVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKxVolume")
	}

	var r0 *finspace.UpdateKxVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxVolumeInput, ...func(*finspace.Options)) (*finspace.UpdateKxVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *finspace.UpdateKxVolumeInput, ...func(*finspace.Options)) *finspace.UpdateKxVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*finspace.UpdateKxVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *finspace.UpdateKxVolumeInput, ...func(*finspace.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
