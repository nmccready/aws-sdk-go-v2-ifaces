// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptAddressTransfer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptAddressTransfer(ctx context.Context, params *ec2.AcceptAddressTransferInput, optFns ...func(*ec2.Options)) (*ec2.AcceptAddressTransferOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptAddressTransfer")
	}

	var r0 *ec2.AcceptAddressTransferOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptAddressTransferInput, ...func(*ec2.Options)) (*ec2.AcceptAddressTransferOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptAddressTransferInput, ...func(*ec2.Options)) *ec2.AcceptAddressTransferOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptAddressTransferOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptAddressTransferInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptCapacityReservationBillingOwnership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptCapacityReservationBillingOwnership(ctx context.Context, params *ec2.AcceptCapacityReservationBillingOwnershipInput, optFns ...func(*ec2.Options)) (*ec2.AcceptCapacityReservationBillingOwnershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptCapacityReservationBillingOwnership")
	}

	var r0 *ec2.AcceptCapacityReservationBillingOwnershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) (*ec2.AcceptCapacityReservationBillingOwnershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) *ec2.AcceptCapacityReservationBillingOwnershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptCapacityReservationBillingOwnershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptReservedInstancesExchangeQuote(ctx context.Context, params *ec2.AcceptReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptReservedInstancesExchangeQuote")
	}

	var r0 *ec2.AcceptReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.AcceptReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptTransitGatewayVpcAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayVpcAttachment")
	}

	var r0 *ec2.AcceptTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptVpcEndpointConnections(ctx context.Context, params *ec2.AcceptVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptVpcEndpointConnections")
	}

	var r0 *ec2.AcceptVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.AcceptVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptVpcPeeringConnection(ctx context.Context, params *ec2.AcceptVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptVpcPeeringConnection")
	}

	var r0 *ec2.AcceptVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.AcceptVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AdvertiseByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AdvertiseByoipCidr(ctx context.Context, params *ec2.AdvertiseByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AdvertiseByoipCidr")
	}

	var r0 *ec2.AdvertiseByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) *ec2.AdvertiseByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AdvertiseByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AllocateAddress(ctx context.Context, params *ec2.AllocateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateAddress")
	}

	var r0 *ec2.AllocateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) *ec2.AllocateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateHosts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AllocateHosts(ctx context.Context, params *ec2.AllocateHostsInput, optFns ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateHosts")
	}

	var r0 *ec2.AllocateHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) *ec2.AllocateHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AllocateIpamPoolCidr(ctx context.Context, params *ec2.AllocateIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateIpamPoolCidr")
	}

	var r0 *ec2.AllocateIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.AllocateIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplySecurityGroupsToClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ApplySecurityGroupsToClientVpnTargetNetwork(ctx context.Context, params *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplySecurityGroupsToClientVpnTargetNetwork")
	}

	var r0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssignIpv6Addresses(ctx context.Context, params *ec2.AssignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignIpv6Addresses")
	}

	var r0 *ec2.AssignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.AssignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssignPrivateIpAddresses(ctx context.Context, params *ec2.AssignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignPrivateIpAddresses")
	}

	var r0 *ec2.AssignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.AssignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignPrivateNatGatewayAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssignPrivateNatGatewayAddress(ctx context.Context, params *ec2.AssignPrivateNatGatewayAddressInput, optFns ...func(*ec2.Options)) (*ec2.AssignPrivateNatGatewayAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignPrivateNatGatewayAddress")
	}

	var r0 *ec2.AssignPrivateNatGatewayAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) (*ec2.AssignPrivateNatGatewayAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) *ec2.AssignPrivateNatGatewayAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignPrivateNatGatewayAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateAddress(ctx context.Context, params *ec2.AssociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAddress")
	}

	var r0 *ec2.AssociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) *ec2.AssociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateCapacityReservationBillingOwner provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateCapacityReservationBillingOwner(ctx context.Context, params *ec2.AssociateCapacityReservationBillingOwnerInput, optFns ...func(*ec2.Options)) (*ec2.AssociateCapacityReservationBillingOwnerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateCapacityReservationBillingOwner")
	}

	var r0 *ec2.AssociateCapacityReservationBillingOwnerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) (*ec2.AssociateCapacityReservationBillingOwnerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) *ec2.AssociateCapacityReservationBillingOwnerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateCapacityReservationBillingOwnerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateClientVpnTargetNetwork(ctx context.Context, params *ec2.AssociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateClientVpnTargetNetwork")
	}

	var r0 *ec2.AssociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.AssociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateDhcpOptions(ctx context.Context, params *ec2.AssociateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateDhcpOptions")
	}

	var r0 *ec2.AssociateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.AssociateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.AssociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateEnclaveCertificateIamRole")
	}

	var r0 *ec2.AssociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.AssociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateIamInstanceProfile(ctx context.Context, params *ec2.AssociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateIamInstanceProfile")
	}

	var r0 *ec2.AssociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.AssociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateInstanceEventWindow(ctx context.Context, params *ec2.AssociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateInstanceEventWindow")
	}

	var r0 *ec2.AssociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.AssociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIpamByoasn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateIpamByoasn(ctx context.Context, params *ec2.AssociateIpamByoasnInput, optFns ...func(*ec2.Options)) (*ec2.AssociateIpamByoasnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateIpamByoasn")
	}

	var r0 *ec2.AssociateIpamByoasnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIpamByoasnInput, ...func(*ec2.Options)) (*ec2.AssociateIpamByoasnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIpamByoasnInput, ...func(*ec2.Options)) *ec2.AssociateIpamByoasnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIpamByoasnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateIpamByoasnInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIpamResourceDiscovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateIpamResourceDiscovery(ctx context.Context, params *ec2.AssociateIpamResourceDiscoveryInput, optFns ...func(*ec2.Options)) (*ec2.AssociateIpamResourceDiscoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateIpamResourceDiscovery")
	}

	var r0 *ec2.AssociateIpamResourceDiscoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) (*ec2.AssociateIpamResourceDiscoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) *ec2.AssociateIpamResourceDiscoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIpamResourceDiscoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateNatGatewayAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateNatGatewayAddress(ctx context.Context, params *ec2.AssociateNatGatewayAddressInput, optFns ...func(*ec2.Options)) (*ec2.AssociateNatGatewayAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateNatGatewayAddress")
	}

	var r0 *ec2.AssociateNatGatewayAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateNatGatewayAddressInput, ...func(*ec2.Options)) (*ec2.AssociateNatGatewayAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateNatGatewayAddressInput, ...func(*ec2.Options)) *ec2.AssociateNatGatewayAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateNatGatewayAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateNatGatewayAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateRouteServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateRouteServer(ctx context.Context, params *ec2.AssociateRouteServerInput, optFns ...func(*ec2.Options)) (*ec2.AssociateRouteServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateRouteServer")
	}

	var r0 *ec2.AssociateRouteServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteServerInput, ...func(*ec2.Options)) (*ec2.AssociateRouteServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteServerInput, ...func(*ec2.Options)) *ec2.AssociateRouteServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateRouteServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateRouteServerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateRouteTable(ctx context.Context, params *ec2.AssociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateRouteTable")
	}

	var r0 *ec2.AssociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateSecurityGroupVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateSecurityGroupVpc(ctx context.Context, params *ec2.AssociateSecurityGroupVpcInput, optFns ...func(*ec2.Options)) (*ec2.AssociateSecurityGroupVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateSecurityGroupVpc")
	}

	var r0 *ec2.AssociateSecurityGroupVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSecurityGroupVpcInput, ...func(*ec2.Options)) (*ec2.AssociateSecurityGroupVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSecurityGroupVpcInput, ...func(*ec2.Options)) *ec2.AssociateSecurityGroupVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateSecurityGroupVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateSecurityGroupVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateSubnetCidrBlock(ctx context.Context, params *ec2.AssociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateSubnetCidrBlock")
	}

	var r0 *ec2.AssociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.AssociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.AssociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayPolicyTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateTransitGatewayPolicyTable(ctx context.Context, params *ec2.AssociateTransitGatewayPolicyTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayPolicyTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTransitGatewayPolicyTable")
	}

	var r0 *ec2.AssociateTransitGatewayPolicyTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayPolicyTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayPolicyTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayPolicyTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateTransitGatewayRouteTable(ctx context.Context, params *ec2.AssociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTransitGatewayRouteTable")
	}

	var r0 *ec2.AssociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateTrunkInterface(ctx context.Context, params *ec2.AssociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTrunkInterface")
	}

	var r0 *ec2.AssociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.AssociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateVpcCidrBlock(ctx context.Context, params *ec2.AssociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateVpcCidrBlock")
	}

	var r0 *ec2.AssociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachClassicLinkVpc(ctx context.Context, params *ec2.AttachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachClassicLinkVpc")
	}

	var r0 *ec2.AttachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.AttachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachInternetGateway(ctx context.Context, params *ec2.AttachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachInternetGateway")
	}

	var r0 *ec2.AttachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) *ec2.AttachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachNetworkInterface(ctx context.Context, params *ec2.AttachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachNetworkInterface")
	}

	var r0 *ec2.AttachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.AttachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVerifiedAccessTrustProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachVerifiedAccessTrustProvider(ctx context.Context, params *ec2.AttachVerifiedAccessTrustProviderInput, optFns ...func(*ec2.Options)) (*ec2.AttachVerifiedAccessTrustProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachVerifiedAccessTrustProvider")
	}

	var r0 *ec2.AttachVerifiedAccessTrustProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) (*ec2.AttachVerifiedAccessTrustProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) *ec2.AttachVerifiedAccessTrustProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVerifiedAccessTrustProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachVolume(ctx context.Context, params *ec2.AttachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachVolume")
	}

	var r0 *ec2.AttachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) *ec2.AttachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AttachVpnGateway(ctx context.Context, params *ec2.AttachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachVpnGateway")
	}

	var r0 *ec2.AttachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) *ec2.AttachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeClientVpnIngress(ctx context.Context, params *ec2.AuthorizeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeClientVpnIngress")
	}

	var r0 *ec2.AuthorizeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeSecurityGroupEgress(ctx context.Context, params *ec2.AuthorizeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSecurityGroupEgress")
	}

	var r0 *ec2.AuthorizeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeSecurityGroupIngress(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSecurityGroupIngress")
	}

	var r0 *ec2.AuthorizeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BundleInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BundleInstance(ctx context.Context, params *ec2.BundleInstanceInput, optFns ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BundleInstance")
	}

	var r0 *ec2.BundleInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) *ec2.BundleInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.BundleInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBundleTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelBundleTask(ctx context.Context, params *ec2.CancelBundleTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBundleTask")
	}

	var r0 *ec2.CancelBundleTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) *ec2.CancelBundleTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelBundleTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelCapacityReservation(ctx context.Context, params *ec2.CancelCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelCapacityReservation")
	}

	var r0 *ec2.CancelCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelCapacityReservationFleets(ctx context.Context, params *ec2.CancelCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelCapacityReservationFleets")
	}

	var r0 *ec2.CancelCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelConversionTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelConversionTask(ctx context.Context, params *ec2.CancelConversionTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelConversionTask")
	}

	var r0 *ec2.CancelConversionTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) *ec2.CancelConversionTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelConversionTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDeclarativePoliciesReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDeclarativePoliciesReport(ctx context.Context, params *ec2.CancelDeclarativePoliciesReportInput, optFns ...func(*ec2.Options)) (*ec2.CancelDeclarativePoliciesReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDeclarativePoliciesReport")
	}

	var r0 *ec2.CancelDeclarativePoliciesReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelDeclarativePoliciesReportInput, ...func(*ec2.Options)) (*ec2.CancelDeclarativePoliciesReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelDeclarativePoliciesReportInput, ...func(*ec2.Options)) *ec2.CancelDeclarativePoliciesReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelDeclarativePoliciesReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelDeclarativePoliciesReportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelExportTask(ctx context.Context, params *ec2.CancelExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelExportTask")
	}

	var r0 *ec2.CancelExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) *ec2.CancelExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelImageLaunchPermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelImageLaunchPermission(ctx context.Context, params *ec2.CancelImageLaunchPermissionInput, optFns ...func(*ec2.Options)) (*ec2.CancelImageLaunchPermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelImageLaunchPermission")
	}

	var r0 *ec2.CancelImageLaunchPermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImageLaunchPermissionInput, ...func(*ec2.Options)) (*ec2.CancelImageLaunchPermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImageLaunchPermissionInput, ...func(*ec2.Options)) *ec2.CancelImageLaunchPermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelImageLaunchPermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelImageLaunchPermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelImportTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelImportTask(ctx context.Context, params *ec2.CancelImportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelImportTask")
	}

	var r0 *ec2.CancelImportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) *ec2.CancelImportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelImportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelReservedInstancesListing(ctx context.Context, params *ec2.CancelReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelReservedInstancesListing")
	}

	var r0 *ec2.CancelReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CancelReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSpotFleetRequests(ctx context.Context, params *ec2.CancelSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSpotFleetRequests")
	}

	var r0 *ec2.CancelSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSpotInstanceRequests(ctx context.Context, params *ec2.CancelSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSpotInstanceRequests")
	}

	var r0 *ec2.CancelSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmProductInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ConfirmProductInstance(ctx context.Context, params *ec2.ConfirmProductInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmProductInstance")
	}

	var r0 *ec2.ConfirmProductInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) *ec2.ConfirmProductInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ConfirmProductInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyFpgaImage(ctx context.Context, params *ec2.CopyFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyFpgaImage")
	}

	var r0 *ec2.CopyFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) *ec2.CopyFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyImage(ctx context.Context, params *ec2.CopyImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyImage")
	}

	var r0 *ec2.CopyImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) (*ec2.CopyImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) *ec2.CopyImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopySnapshot(ctx context.Context, params *ec2.CopySnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopySnapshot")
	}

	var r0 *ec2.CopySnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) *ec2.CopySnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopySnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyVolumes(ctx context.Context, params *ec2.CopyVolumesInput, optFns ...func(*ec2.Options)) (*ec2.CopyVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyVolumes")
	}

	var r0 *ec2.CopyVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyVolumesInput, ...func(*ec2.Options)) (*ec2.CopyVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyVolumesInput, ...func(*ec2.Options)) *ec2.CopyVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyVolumesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityManagerDataExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCapacityManagerDataExport(ctx context.Context, params *ec2.CreateCapacityManagerDataExportInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityManagerDataExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityManagerDataExport")
	}

	var r0 *ec2.CreateCapacityManagerDataExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityManagerDataExportInput, ...func(*ec2.Options)) (*ec2.CreateCapacityManagerDataExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityManagerDataExportInput, ...func(*ec2.Options)) *ec2.CreateCapacityManagerDataExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityManagerDataExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityManagerDataExportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCapacityReservation(ctx context.Context, params *ec2.CreateCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityReservation")
	}

	var r0 *ec2.CreateCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservationBySplitting provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCapacityReservationBySplitting(ctx context.Context, params *ec2.CreateCapacityReservationBySplittingInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationBySplittingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityReservationBySplitting")
	}

	var r0 *ec2.CreateCapacityReservationBySplittingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationBySplittingInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationBySplittingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationBySplittingInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationBySplittingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationBySplittingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationBySplittingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCapacityReservationFleet(ctx context.Context, params *ec2.CreateCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityReservationFleet")
	}

	var r0 *ec2.CreateCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCarrierGateway(ctx context.Context, params *ec2.CreateCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCarrierGateway")
	}

	var r0 *ec2.CreateCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) *ec2.CreateCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClientVpnEndpoint(ctx context.Context, params *ec2.CreateClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientVpnEndpoint")
	}

	var r0 *ec2.CreateClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.CreateClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClientVpnRoute(ctx context.Context, params *ec2.CreateClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientVpnRoute")
	}

	var r0 *ec2.CreateClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) *ec2.CreateClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCoipCidr(ctx context.Context, params *ec2.CreateCoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.CreateCoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCoipCidr")
	}

	var r0 *ec2.CreateCoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCoipCidrInput, ...func(*ec2.Options)) (*ec2.CreateCoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCoipCidrInput, ...func(*ec2.Options)) *ec2.CreateCoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCoipPool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCoipPool(ctx context.Context, params *ec2.CreateCoipPoolInput, optFns ...func(*ec2.Options)) (*ec2.CreateCoipPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCoipPool")
	}

	var r0 *ec2.CreateCoipPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCoipPoolInput, ...func(*ec2.Options)) (*ec2.CreateCoipPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCoipPoolInput, ...func(*ec2.Options)) *ec2.CreateCoipPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCoipPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCoipPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomerGateway(ctx context.Context, params *ec2.CreateCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomerGateway")
	}

	var r0 *ec2.CreateCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) *ec2.CreateCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDefaultSubnet(ctx context.Context, params *ec2.CreateDefaultSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDefaultSubnet")
	}

	var r0 *ec2.CreateDefaultSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) *ec2.CreateDefaultSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDefaultVpc(ctx context.Context, params *ec2.CreateDefaultVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDefaultVpc")
	}

	var r0 *ec2.CreateDefaultVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) *ec2.CreateDefaultVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDelegateMacVolumeOwnershipTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDelegateMacVolumeOwnershipTask(ctx context.Context, params *ec2.CreateDelegateMacVolumeOwnershipTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateDelegateMacVolumeOwnershipTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDelegateMacVolumeOwnershipTask")
	}

	var r0 *ec2.CreateDelegateMacVolumeOwnershipTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDelegateMacVolumeOwnershipTaskInput, ...func(*ec2.Options)) (*ec2.CreateDelegateMacVolumeOwnershipTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDelegateMacVolumeOwnershipTaskInput, ...func(*ec2.Options)) *ec2.CreateDelegateMacVolumeOwnershipTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDelegateMacVolumeOwnershipTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDelegateMacVolumeOwnershipTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDhcpOptions(ctx context.Context, params *ec2.CreateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDhcpOptions")
	}

	var r0 *ec2.CreateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.CreateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEgressOnlyInternetGateway(ctx context.Context, params *ec2.CreateEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEgressOnlyInternetGateway")
	}

	var r0 *ec2.CreateEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFleet(ctx context.Context, params *ec2.CreateFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleet")
	}

	var r0 *ec2.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) *ec2.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFlowLogs(ctx context.Context, params *ec2.CreateFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlowLogs")
	}

	var r0 *ec2.CreateFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) *ec2.CreateFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFpgaImage(ctx context.Context, params *ec2.CreateFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFpgaImage")
	}

	var r0 *ec2.CreateFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) *ec2.CreateFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateImage(ctx context.Context, params *ec2.CreateImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateImage")
	}

	var r0 *ec2.CreateImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) (*ec2.CreateImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) *ec2.CreateImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateImageUsageReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateImageUsageReport(ctx context.Context, params *ec2.CreateImageUsageReportInput, optFns ...func(*ec2.Options)) (*ec2.CreateImageUsageReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateImageUsageReport")
	}

	var r0 *ec2.CreateImageUsageReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageUsageReportInput, ...func(*ec2.Options)) (*ec2.CreateImageUsageReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageUsageReportInput, ...func(*ec2.Options)) *ec2.CreateImageUsageReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateImageUsageReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateImageUsageReportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceConnectEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInstanceConnectEndpoint(ctx context.Context, params *ec2.CreateInstanceConnectEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceConnectEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstanceConnectEndpoint")
	}

	var r0 *ec2.CreateInstanceConnectEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceConnectEndpointInput, ...func(*ec2.Options)) (*ec2.CreateInstanceConnectEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceConnectEndpointInput, ...func(*ec2.Options)) *ec2.CreateInstanceConnectEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceConnectEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceConnectEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInstanceEventWindow(ctx context.Context, params *ec2.CreateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstanceEventWindow")
	}

	var r0 *ec2.CreateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.CreateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInstanceExportTask(ctx context.Context, params *ec2.CreateInstanceExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstanceExportTask")
	}

	var r0 *ec2.CreateInstanceExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) *ec2.CreateInstanceExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInternetGateway(ctx context.Context, params *ec2.CreateInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInternetGateway")
	}

	var r0 *ec2.CreateInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInterruptibleCapacityReservationAllocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInterruptibleCapacityReservationAllocation(ctx context.Context, params *ec2.CreateInterruptibleCapacityReservationAllocationInput, optFns ...func(*ec2.Options)) (*ec2.CreateInterruptibleCapacityReservationAllocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInterruptibleCapacityReservationAllocation")
	}

	var r0 *ec2.CreateInterruptibleCapacityReservationAllocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) (*ec2.CreateInterruptibleCapacityReservationAllocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) *ec2.CreateInterruptibleCapacityReservationAllocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInterruptibleCapacityReservationAllocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpam provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpam(ctx context.Context, params *ec2.CreateIpamInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpam")
	}

	var r0 *ec2.CreateIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) *ec2.CreateIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamExternalResourceVerificationToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamExternalResourceVerificationToken(ctx context.Context, params *ec2.CreateIpamExternalResourceVerificationTokenInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamExternalResourceVerificationTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamExternalResourceVerificationToken")
	}

	var r0 *ec2.CreateIpamExternalResourceVerificationTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) (*ec2.CreateIpamExternalResourceVerificationTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) *ec2.CreateIpamExternalResourceVerificationTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamExternalResourceVerificationTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamPolicy(ctx context.Context, params *ec2.CreateIpamPolicyInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamPolicy")
	}

	var r0 *ec2.CreateIpamPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPolicyInput, ...func(*ec2.Options)) (*ec2.CreateIpamPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPolicyInput, ...func(*ec2.Options)) *ec2.CreateIpamPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamPool(ctx context.Context, params *ec2.CreateIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamPool")
	}

	var r0 *ec2.CreateIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) *ec2.CreateIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamPrefixListResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamPrefixListResolver(ctx context.Context, params *ec2.CreateIpamPrefixListResolverInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPrefixListResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamPrefixListResolver")
	}

	var r0 *ec2.CreateIpamPrefixListResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPrefixListResolverInput, ...func(*ec2.Options)) (*ec2.CreateIpamPrefixListResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPrefixListResolverInput, ...func(*ec2.Options)) *ec2.CreateIpamPrefixListResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPrefixListResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPrefixListResolverInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamPrefixListResolverTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamPrefixListResolverTarget(ctx context.Context, params *ec2.CreateIpamPrefixListResolverTargetInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPrefixListResolverTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamPrefixListResolverTarget")
	}

	var r0 *ec2.CreateIpamPrefixListResolverTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) (*ec2.CreateIpamPrefixListResolverTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) *ec2.CreateIpamPrefixListResolverTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPrefixListResolverTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamResourceDiscovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamResourceDiscovery(ctx context.Context, params *ec2.CreateIpamResourceDiscoveryInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamResourceDiscoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamResourceDiscovery")
	}

	var r0 *ec2.CreateIpamResourceDiscoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamResourceDiscoveryInput, ...func(*ec2.Options)) (*ec2.CreateIpamResourceDiscoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamResourceDiscoveryInput, ...func(*ec2.Options)) *ec2.CreateIpamResourceDiscoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamResourceDiscoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamResourceDiscoveryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIpamScope(ctx context.Context, params *ec2.CreateIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamScope")
	}

	var r0 *ec2.CreateIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) *ec2.CreateIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKeyPair(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKeyPair")
	}

	var r0 *ec2.CreateKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) *ec2.CreateKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLaunchTemplate(ctx context.Context, params *ec2.CreateLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLaunchTemplate")
	}

	var r0 *ec2.CreateLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplateVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLaunchTemplateVersion(ctx context.Context, params *ec2.CreateLaunchTemplateVersionInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLaunchTemplateVersion")
	}

	var r0 *ec2.CreateLaunchTemplateVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayRoute(ctx context.Context, params *ec2.CreateLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRoute")
	}

	var r0 *ec2.CreateLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayRouteTable(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRouteTable")
	}

	var r0 *ec2.CreateLocalGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation")
	}

	var r0 *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRouteTableVpcAssociation")
	}

	var r0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayVirtualInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayVirtualInterface(ctx context.Context, params *ec2.CreateLocalGatewayVirtualInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayVirtualInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayVirtualInterface")
	}

	var r0 *ec2.CreateLocalGatewayVirtualInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayVirtualInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayVirtualInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayVirtualInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayVirtualInterfaceGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocalGatewayVirtualInterfaceGroup(ctx context.Context, params *ec2.CreateLocalGatewayVirtualInterfaceGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayVirtualInterfaceGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayVirtualInterfaceGroup")
	}

	var r0 *ec2.CreateLocalGatewayVirtualInterfaceGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayVirtualInterfaceGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayVirtualInterfaceGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayVirtualInterfaceGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMacSystemIntegrityProtectionModificationTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMacSystemIntegrityProtectionModificationTask(ctx context.Context, params *ec2.CreateMacSystemIntegrityProtectionModificationTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateMacSystemIntegrityProtectionModificationTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMacSystemIntegrityProtectionModificationTask")
	}

	var r0 *ec2.CreateMacSystemIntegrityProtectionModificationTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateMacSystemIntegrityProtectionModificationTaskInput, ...func(*ec2.Options)) (*ec2.CreateMacSystemIntegrityProtectionModificationTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateMacSystemIntegrityProtectionModificationTaskInput, ...func(*ec2.Options)) *ec2.CreateMacSystemIntegrityProtectionModificationTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateMacSystemIntegrityProtectionModificationTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateMacSystemIntegrityProtectionModificationTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateManagedPrefixList(ctx context.Context, params *ec2.CreateManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateManagedPrefixList")
	}

	var r0 *ec2.CreateManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) *ec2.CreateManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNatGateway(ctx context.Context, params *ec2.CreateNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNatGateway")
	}

	var r0 *ec2.CreateNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) *ec2.CreateNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkAcl(ctx context.Context, params *ec2.CreateNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkAcl")
	}

	var r0 *ec2.CreateNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkAclEntry(ctx context.Context, params *ec2.CreateNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkAclEntry")
	}

	var r0 *ec2.CreateNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkInsightsAccessScope(ctx context.Context, params *ec2.CreateNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInsightsAccessScope")
	}

	var r0 *ec2.CreateNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkInsightsPath(ctx context.Context, params *ec2.CreateNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInsightsPath")
	}

	var r0 *ec2.CreateNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkInterface(ctx context.Context, params *ec2.CreateNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInterface")
	}

	var r0 *ec2.CreateNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetworkInterfacePermission(ctx context.Context, params *ec2.CreateNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInterfacePermission")
	}

	var r0 *ec2.CreateNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePlacementGroup(ctx context.Context, params *ec2.CreatePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlacementGroup")
	}

	var r0 *ec2.CreatePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) *ec2.CreatePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePublicIpv4Pool(ctx context.Context, params *ec2.CreatePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePublicIpv4Pool")
	}

	var r0 *ec2.CreatePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.CreatePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReplaceRootVolumeTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReplaceRootVolumeTask(ctx context.Context, params *ec2.CreateReplaceRootVolumeTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReplaceRootVolumeTask")
	}

	var r0 *ec2.CreateReplaceRootVolumeTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) *ec2.CreateReplaceRootVolumeTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReplaceRootVolumeTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReservedInstancesListing(ctx context.Context, params *ec2.CreateReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReservedInstancesListing")
	}

	var r0 *ec2.CreateReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CreateReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRestoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRestoreImageTask(ctx context.Context, params *ec2.CreateRestoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRestoreImageTask")
	}

	var r0 *ec2.CreateRestoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateRestoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRestoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRoute(ctx context.Context, params *ec2.CreateRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRoute")
	}

	var r0 *ec2.CreateRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) *ec2.CreateRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRouteServer(ctx context.Context, params *ec2.CreateRouteServerInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteServer")
	}

	var r0 *ec2.CreateRouteServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerInput, ...func(*ec2.Options)) (*ec2.CreateRouteServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerInput, ...func(*ec2.Options)) *ec2.CreateRouteServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteServerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteServerEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRouteServerEndpoint(ctx context.Context, params *ec2.CreateRouteServerEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteServerEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteServerEndpoint")
	}

	var r0 *ec2.CreateRouteServerEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerEndpointInput, ...func(*ec2.Options)) (*ec2.CreateRouteServerEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerEndpointInput, ...func(*ec2.Options)) *ec2.CreateRouteServerEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteServerEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteServerEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteServerPeer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRouteServerPeer(ctx context.Context, params *ec2.CreateRouteServerPeerInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteServerPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteServerPeer")
	}

	var r0 *ec2.CreateRouteServerPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerPeerInput, ...func(*ec2.Options)) (*ec2.CreateRouteServerPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteServerPeerInput, ...func(*ec2.Options)) *ec2.CreateRouteServerPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteServerPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteServerPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRouteTable(ctx context.Context, params *ec2.CreateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteTable")
	}

	var r0 *ec2.CreateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) *ec2.CreateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSecurityGroup(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityGroup")
	}

	var r0 *ec2.CreateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) *ec2.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshot(ctx context.Context, params *ec2.CreateSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *ec2.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) *ec2.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshots(ctx context.Context, params *ec2.CreateSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshots")
	}

	var r0 *ec2.CreateSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) *ec2.CreateSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSpotDatafeedSubscription(ctx context.Context, params *ec2.CreateSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSpotDatafeedSubscription")
	}

	var r0 *ec2.CreateSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.CreateSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStoreImageTask(ctx context.Context, params *ec2.CreateStoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStoreImageTask")
	}

	var r0 *ec2.CreateStoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateStoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateStoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubnet(ctx context.Context, params *ec2.CreateSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnet")
	}

	var r0 *ec2.CreateSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) *ec2.CreateSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubnetCidrReservation(ctx context.Context, params *ec2.CreateSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnetCidrReservation")
	}

	var r0 *ec2.CreateSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.CreateSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTags")
	}

	var r0 *ec2.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) *ec2.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrafficMirrorFilter(ctx context.Context, params *ec2.CreateTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorFilter")
	}

	var r0 *ec2.CreateTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrafficMirrorFilterRule(ctx context.Context, params *ec2.CreateTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorFilterRule")
	}

	var r0 *ec2.CreateTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrafficMirrorSession(ctx context.Context, params *ec2.CreateTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorSession")
	}

	var r0 *ec2.CreateTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrafficMirrorTarget(ctx context.Context, params *ec2.CreateTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorTarget")
	}

	var r0 *ec2.CreateTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGateway(ctx context.Context, params *ec2.CreateTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGateway")
	}

	var r0 *ec2.CreateTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayConnect(ctx context.Context, params *ec2.CreateTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayConnect")
	}

	var r0 *ec2.CreateTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayConnectPeer(ctx context.Context, params *ec2.CreateTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayConnectPeer")
	}

	var r0 *ec2.CreateTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayMeteringPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayMeteringPolicy(ctx context.Context, params *ec2.CreateTransitGatewayMeteringPolicyInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMeteringPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayMeteringPolicy")
	}

	var r0 *ec2.CreateTransitGatewayMeteringPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMeteringPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayMeteringPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMeteringPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayMeteringPolicyEntry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayMeteringPolicyEntry(ctx context.Context, params *ec2.CreateTransitGatewayMeteringPolicyEntryInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMeteringPolicyEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayMeteringPolicyEntry")
	}

	var r0 *ec2.CreateTransitGatewayMeteringPolicyEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMeteringPolicyEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayMeteringPolicyEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMeteringPolicyEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.CreateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.CreateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.CreateTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.CreateTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPolicyTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayPolicyTable(ctx context.Context, params *ec2.CreateTransitGatewayPolicyTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPolicyTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayPolicyTable")
	}

	var r0 *ec2.CreateTransitGatewayPolicyTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPolicyTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPolicyTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPolicyTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayPrefixListReference(ctx context.Context, params *ec2.CreateTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayPrefixListReference")
	}

	var r0 *ec2.CreateTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayRoute(ctx context.Context, params *ec2.CreateTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayRoute")
	}

	var r0 *ec2.CreateTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayRouteTable(ctx context.Context, params *ec2.CreateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayRouteTable")
	}

	var r0 *ec2.CreateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRouteTableAnnouncement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayRouteTableAnnouncement(ctx context.Context, params *ec2.CreateTransitGatewayRouteTableAnnouncementInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableAnnouncementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayRouteTableAnnouncement")
	}

	var r0 *ec2.CreateTransitGatewayRouteTableAnnouncementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableAnnouncementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteTableAnnouncementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteTableAnnouncementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTransitGatewayVpcAttachment(ctx context.Context, params *ec2.CreateTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayVpcAttachment")
	}

	var r0 *ec2.CreateTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVerifiedAccessEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVerifiedAccessEndpoint(ctx context.Context, params *ec2.CreateVerifiedAccessEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVerifiedAccessEndpoint")
	}

	var r0 *ec2.CreateVerifiedAccessEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessEndpointInput, ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessEndpointInput, ...func(*ec2.Options)) *ec2.CreateVerifiedAccessEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVerifiedAccessEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVerifiedAccessEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVerifiedAccessGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVerifiedAccessGroup(ctx context.Context, params *ec2.CreateVerifiedAccessGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVerifiedAccessGroup")
	}

	var r0 *ec2.CreateVerifiedAccessGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessGroupInput, ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessGroupInput, ...func(*ec2.Options)) *ec2.CreateVerifiedAccessGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVerifiedAccessGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVerifiedAccessGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVerifiedAccessInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVerifiedAccessInstance(ctx context.Context, params *ec2.CreateVerifiedAccessInstanceInput, optFns ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVerifiedAccessInstance")
	}

	var r0 *ec2.CreateVerifiedAccessInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessInstanceInput, ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessInstanceInput, ...func(*ec2.Options)) *ec2.CreateVerifiedAccessInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVerifiedAccessInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVerifiedAccessInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVerifiedAccessTrustProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVerifiedAccessTrustProvider(ctx context.Context, params *ec2.CreateVerifiedAccessTrustProviderInput, optFns ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessTrustProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVerifiedAccessTrustProvider")
	}

	var r0 *ec2.CreateVerifiedAccessTrustProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) (*ec2.CreateVerifiedAccessTrustProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) *ec2.CreateVerifiedAccessTrustProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVerifiedAccessTrustProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVolume(ctx context.Context, params *ec2.CreateVolumeInput, optFns ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVolume")
	}

	var r0 *ec2.CreateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) *ec2.CreateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpc(ctx context.Context, params *ec2.CreateVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpc")
	}

	var r0 *ec2.CreateVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) *ec2.CreateVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcBlockPublicAccessExclusion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcBlockPublicAccessExclusion(ctx context.Context, params *ec2.CreateVpcBlockPublicAccessExclusionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcBlockPublicAccessExclusionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcBlockPublicAccessExclusion")
	}

	var r0 *ec2.CreateVpcBlockPublicAccessExclusionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) (*ec2.CreateVpcBlockPublicAccessExclusionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) *ec2.CreateVpcBlockPublicAccessExclusionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcBlockPublicAccessExclusionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEncryptionControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEncryptionControl(ctx context.Context, params *ec2.CreateVpcEncryptionControlInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEncryptionControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEncryptionControl")
	}

	var r0 *ec2.CreateVpcEncryptionControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEncryptionControlInput, ...func(*ec2.Options)) (*ec2.CreateVpcEncryptionControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEncryptionControlInput, ...func(*ec2.Options)) *ec2.CreateVpcEncryptionControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEncryptionControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEncryptionControlInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpoint(ctx context.Context, params *ec2.CreateVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpoint")
	}

	var r0 *ec2.CreateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpointConnectionNotification(ctx context.Context, params *ec2.CreateVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpointConnectionNotification")
	}

	var r0 *ec2.CreateVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.CreateVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpointServiceConfiguration")
	}

	var r0 *ec2.CreateVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcPeeringConnection(ctx context.Context, params *ec2.CreateVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcPeeringConnection")
	}

	var r0 *ec2.CreateVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConcentrator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpnConcentrator(ctx context.Context, params *ec2.CreateVpnConcentratorInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConcentratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnConcentrator")
	}

	var r0 *ec2.CreateVpnConcentratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConcentratorInput, ...func(*ec2.Options)) (*ec2.CreateVpnConcentratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConcentratorInput, ...func(*ec2.Options)) *ec2.CreateVpnConcentratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConcentratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConcentratorInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpnConnection(ctx context.Context, params *ec2.CreateVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnConnection")
	}

	var r0 *ec2.CreateVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpnConnectionRoute(ctx context.Context, params *ec2.CreateVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnConnectionRoute")
	}

	var r0 *ec2.CreateVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpnGateway(ctx context.Context, params *ec2.CreateVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnGateway")
	}

	var r0 *ec2.CreateVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) *ec2.CreateVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCapacityManagerDataExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCapacityManagerDataExport(ctx context.Context, params *ec2.DeleteCapacityManagerDataExportInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCapacityManagerDataExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCapacityManagerDataExport")
	}

	var r0 *ec2.DeleteCapacityManagerDataExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCapacityManagerDataExportInput, ...func(*ec2.Options)) (*ec2.DeleteCapacityManagerDataExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCapacityManagerDataExportInput, ...func(*ec2.Options)) *ec2.DeleteCapacityManagerDataExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCapacityManagerDataExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCapacityManagerDataExportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCarrierGateway(ctx context.Context, params *ec2.DeleteCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCarrierGateway")
	}

	var r0 *ec2.DeleteCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClientVpnEndpoint(ctx context.Context, params *ec2.DeleteClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClientVpnEndpoint")
	}

	var r0 *ec2.DeleteClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClientVpnRoute(ctx context.Context, params *ec2.DeleteClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClientVpnRoute")
	}

	var r0 *ec2.DeleteClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCoipCidr(ctx context.Context, params *ec2.DeleteCoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCoipCidr")
	}

	var r0 *ec2.DeleteCoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCoipCidrInput, ...func(*ec2.Options)) (*ec2.DeleteCoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCoipCidrInput, ...func(*ec2.Options)) *ec2.DeleteCoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCoipPool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCoipPool(ctx context.Context, params *ec2.DeleteCoipPoolInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCoipPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCoipPool")
	}

	var r0 *ec2.DeleteCoipPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCoipPoolInput, ...func(*ec2.Options)) (*ec2.DeleteCoipPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCoipPoolInput, ...func(*ec2.Options)) *ec2.DeleteCoipPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCoipPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCoipPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomerGateway(ctx context.Context, params *ec2.DeleteCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomerGateway")
	}

	var r0 *ec2.DeleteCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDhcpOptions(ctx context.Context, params *ec2.DeleteDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDhcpOptions")
	}

	var r0 *ec2.DeleteDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DeleteDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEgressOnlyInternetGateway(ctx context.Context, params *ec2.DeleteEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEgressOnlyInternetGateway")
	}

	var r0 *ec2.DeleteEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFleets(ctx context.Context, params *ec2.DeleteFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleets")
	}

	var r0 *ec2.DeleteFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) *ec2.DeleteFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFlowLogs(ctx context.Context, params *ec2.DeleteFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlowLogs")
	}

	var r0 *ec2.DeleteFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) *ec2.DeleteFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFpgaImage(ctx context.Context, params *ec2.DeleteFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFpgaImage")
	}

	var r0 *ec2.DeleteFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) *ec2.DeleteFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImageUsageReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImageUsageReport(ctx context.Context, params *ec2.DeleteImageUsageReportInput, optFns ...func(*ec2.Options)) (*ec2.DeleteImageUsageReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImageUsageReport")
	}

	var r0 *ec2.DeleteImageUsageReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteImageUsageReportInput, ...func(*ec2.Options)) (*ec2.DeleteImageUsageReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteImageUsageReportInput, ...func(*ec2.Options)) *ec2.DeleteImageUsageReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteImageUsageReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteImageUsageReportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInstanceConnectEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInstanceConnectEndpoint(ctx context.Context, params *ec2.DeleteInstanceConnectEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInstanceConnectEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInstanceConnectEndpoint")
	}

	var r0 *ec2.DeleteInstanceConnectEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceConnectEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteInstanceConnectEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceConnectEndpointInput, ...func(*ec2.Options)) *ec2.DeleteInstanceConnectEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInstanceConnectEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInstanceConnectEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInstanceEventWindow(ctx context.Context, params *ec2.DeleteInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInstanceEventWindow")
	}

	var r0 *ec2.DeleteInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DeleteInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInternetGateway(ctx context.Context, params *ec2.DeleteInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInternetGateway")
	}

	var r0 *ec2.DeleteInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpam provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpam(ctx context.Context, params *ec2.DeleteIpamInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpam")
	}

	var r0 *ec2.DeleteIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) *ec2.DeleteIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamExternalResourceVerificationToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamExternalResourceVerificationToken(ctx context.Context, params *ec2.DeleteIpamExternalResourceVerificationTokenInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamExternalResourceVerificationTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamExternalResourceVerificationToken")
	}

	var r0 *ec2.DeleteIpamExternalResourceVerificationTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) (*ec2.DeleteIpamExternalResourceVerificationTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) *ec2.DeleteIpamExternalResourceVerificationTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamExternalResourceVerificationTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamExternalResourceVerificationTokenInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamPolicy(ctx context.Context, params *ec2.DeleteIpamPolicyInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamPolicy")
	}

	var r0 *ec2.DeleteIpamPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPolicyInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPolicyInput, ...func(*ec2.Options)) *ec2.DeleteIpamPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamPool(ctx context.Context, params *ec2.DeleteIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamPool")
	}

	var r0 *ec2.DeleteIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) *ec2.DeleteIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamPrefixListResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamPrefixListResolver(ctx context.Context, params *ec2.DeleteIpamPrefixListResolverInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPrefixListResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamPrefixListResolver")
	}

	var r0 *ec2.DeleteIpamPrefixListResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPrefixListResolverInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPrefixListResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPrefixListResolverInput, ...func(*ec2.Options)) *ec2.DeleteIpamPrefixListResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPrefixListResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPrefixListResolverInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamPrefixListResolverTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamPrefixListResolverTarget(ctx context.Context, params *ec2.DeleteIpamPrefixListResolverTargetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPrefixListResolverTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamPrefixListResolverTarget")
	}

	var r0 *ec2.DeleteIpamPrefixListResolverTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPrefixListResolverTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) *ec2.DeleteIpamPrefixListResolverTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPrefixListResolverTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamResourceDiscovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamResourceDiscovery(ctx context.Context, params *ec2.DeleteIpamResourceDiscoveryInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamResourceDiscoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamResourceDiscovery")
	}

	var r0 *ec2.DeleteIpamResourceDiscoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamResourceDiscoveryInput, ...func(*ec2.Options)) (*ec2.DeleteIpamResourceDiscoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamResourceDiscoveryInput, ...func(*ec2.Options)) *ec2.DeleteIpamResourceDiscoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamResourceDiscoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamResourceDiscoveryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIpamScope(ctx context.Context, params *ec2.DeleteIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamScope")
	}

	var r0 *ec2.DeleteIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) *ec2.DeleteIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKeyPair(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKeyPair")
	}

	var r0 *ec2.DeleteKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) *ec2.DeleteKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLaunchTemplate(ctx context.Context, params *ec2.DeleteLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLaunchTemplate")
	}

	var r0 *ec2.DeleteLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLaunchTemplateVersions(ctx context.Context, params *ec2.DeleteLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLaunchTemplateVersions")
	}

	var r0 *ec2.DeleteLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayRoute(ctx context.Context, params *ec2.DeleteLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRoute")
	}

	var r0 *ec2.DeleteLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayRouteTable(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRouteTable")
	}

	var r0 *ec2.DeleteLocalGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation")
	}

	var r0 *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRouteTableVpcAssociation")
	}

	var r0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayVirtualInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayVirtualInterface(ctx context.Context, params *ec2.DeleteLocalGatewayVirtualInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayVirtualInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayVirtualInterface")
	}

	var r0 *ec2.DeleteLocalGatewayVirtualInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayVirtualInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayVirtualInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayVirtualInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayVirtualInterfaceGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocalGatewayVirtualInterfaceGroup(ctx context.Context, params *ec2.DeleteLocalGatewayVirtualInterfaceGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayVirtualInterfaceGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayVirtualInterfaceGroup")
	}

	var r0 *ec2.DeleteLocalGatewayVirtualInterfaceGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayVirtualInterfaceGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayVirtualInterfaceGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayVirtualInterfaceGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayVirtualInterfaceGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteManagedPrefixList(ctx context.Context, params *ec2.DeleteManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteManagedPrefixList")
	}

	var r0 *ec2.DeleteManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) *ec2.DeleteManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNatGateway(ctx context.Context, params *ec2.DeleteNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNatGateway")
	}

	var r0 *ec2.DeleteNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) *ec2.DeleteNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkAcl(ctx context.Context, params *ec2.DeleteNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkAcl")
	}

	var r0 *ec2.DeleteNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkAclEntry(ctx context.Context, params *ec2.DeleteNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkAclEntry")
	}

	var r0 *ec2.DeleteNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInsightsAccessScope(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAccessScope")
	}

	var r0 *ec2.DeleteNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAccessScopeAnalysis")
	}

	var r0 *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInsightsAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAnalysis")
	}

	var r0 *ec2.DeleteNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInsightsPath(ctx context.Context, params *ec2.DeleteNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsPath")
	}

	var r0 *ec2.DeleteNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInterface(ctx context.Context, params *ec2.DeleteNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInterface")
	}

	var r0 *ec2.DeleteNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkInterfacePermission(ctx context.Context, params *ec2.DeleteNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInterfacePermission")
	}

	var r0 *ec2.DeleteNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePlacementGroup(ctx context.Context, params *ec2.DeletePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePlacementGroup")
	}

	var r0 *ec2.DeletePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) *ec2.DeletePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePublicIpv4Pool(ctx context.Context, params *ec2.DeletePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicIpv4Pool")
	}

	var r0 *ec2.DeletePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.DeletePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQueuedReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQueuedReservedInstances(ctx context.Context, params *ec2.DeleteQueuedReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQueuedReservedInstances")
	}

	var r0 *ec2.DeleteQueuedReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) *ec2.DeleteQueuedReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteQueuedReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRoute(ctx context.Context, params *ec2.DeleteRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoute")
	}

	var r0 *ec2.DeleteRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) *ec2.DeleteRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRouteServer(ctx context.Context, params *ec2.DeleteRouteServerInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteServer")
	}

	var r0 *ec2.DeleteRouteServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerInput, ...func(*ec2.Options)) (*ec2.DeleteRouteServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerInput, ...func(*ec2.Options)) *ec2.DeleteRouteServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteServerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteServerEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRouteServerEndpoint(ctx context.Context, params *ec2.DeleteRouteServerEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteServerEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteServerEndpoint")
	}

	var r0 *ec2.DeleteRouteServerEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteRouteServerEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerEndpointInput, ...func(*ec2.Options)) *ec2.DeleteRouteServerEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteServerEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteServerEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteServerPeer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRouteServerPeer(ctx context.Context, params *ec2.DeleteRouteServerPeerInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteServerPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteServerPeer")
	}

	var r0 *ec2.DeleteRouteServerPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerPeerInput, ...func(*ec2.Options)) (*ec2.DeleteRouteServerPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteServerPeerInput, ...func(*ec2.Options)) *ec2.DeleteRouteServerPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteServerPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteServerPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRouteTable(ctx context.Context, params *ec2.DeleteRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteTable")
	}

	var r0 *ec2.DeleteRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSecurityGroup(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityGroup")
	}

	var r0 *ec2.DeleteSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) *ec2.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshot(ctx context.Context, params *ec2.DeleteSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshot")
	}

	var r0 *ec2.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) *ec2.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSpotDatafeedSubscription(ctx context.Context, params *ec2.DeleteSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSpotDatafeedSubscription")
	}

	var r0 *ec2.DeleteSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DeleteSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubnet(ctx context.Context, params *ec2.DeleteSubnetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnet")
	}

	var r0 *ec2.DeleteSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) *ec2.DeleteSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubnetCidrReservation(ctx context.Context, params *ec2.DeleteSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnetCidrReservation")
	}

	var r0 *ec2.DeleteSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.DeleteSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTags(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTags")
	}

	var r0 *ec2.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) *ec2.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrafficMirrorFilter(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorFilter")
	}

	var r0 *ec2.DeleteTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrafficMirrorFilterRule(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorFilterRule")
	}

	var r0 *ec2.DeleteTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrafficMirrorSession(ctx context.Context, params *ec2.DeleteTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorSession")
	}

	var r0 *ec2.DeleteTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrafficMirrorTarget(ctx context.Context, params *ec2.DeleteTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorTarget")
	}

	var r0 *ec2.DeleteTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGateway(ctx context.Context, params *ec2.DeleteTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGateway")
	}

	var r0 *ec2.DeleteTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayConnect(ctx context.Context, params *ec2.DeleteTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayConnect")
	}

	var r0 *ec2.DeleteTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayConnectPeer(ctx context.Context, params *ec2.DeleteTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayConnectPeer")
	}

	var r0 *ec2.DeleteTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayMeteringPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayMeteringPolicy(ctx context.Context, params *ec2.DeleteTransitGatewayMeteringPolicyInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMeteringPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayMeteringPolicy")
	}

	var r0 *ec2.DeleteTransitGatewayMeteringPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMeteringPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayMeteringPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMeteringPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayMeteringPolicyEntry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayMeteringPolicyEntry(ctx context.Context, params *ec2.DeleteTransitGatewayMeteringPolicyEntryInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMeteringPolicyEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayMeteringPolicyEntry")
	}

	var r0 *ec2.DeleteTransitGatewayMeteringPolicyEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMeteringPolicyEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayMeteringPolicyEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMeteringPolicyEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayMeteringPolicyEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DeleteTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayMulticastDomain")
	}

	var r0 *ec2.DeleteTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPolicyTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayPolicyTable(ctx context.Context, params *ec2.DeleteTransitGatewayPolicyTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPolicyTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayPolicyTable")
	}

	var r0 *ec2.DeleteTransitGatewayPolicyTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPolicyTableInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPolicyTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPolicyTableInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPolicyTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPolicyTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPolicyTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayPrefixListReference(ctx context.Context, params *ec2.DeleteTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayPrefixListReference")
	}

	var r0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayRoute(ctx context.Context, params *ec2.DeleteTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayRoute")
	}

	var r0 *ec2.DeleteTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayRouteTable(ctx context.Context, params *ec2.DeleteTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayRouteTable")
	}

	var r0 *ec2.DeleteTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRouteTableAnnouncement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayRouteTableAnnouncement(ctx context.Context, params *ec2.DeleteTransitGatewayRouteTableAnnouncementInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableAnnouncementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayRouteTableAnnouncement")
	}

	var r0 *ec2.DeleteTransitGatewayRouteTableAnnouncementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableAnnouncementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteTableAnnouncementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteTableAnnouncementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableAnnouncementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTransitGatewayVpcAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayVpcAttachment")
	}

	var r0 *ec2.DeleteTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVerifiedAccessEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVerifiedAccessEndpoint(ctx context.Context, params *ec2.DeleteVerifiedAccessEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerifiedAccessEndpoint")
	}

	var r0 *ec2.DeleteVerifiedAccessEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessEndpointInput, ...func(*ec2.Options)) *ec2.DeleteVerifiedAccessEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVerifiedAccessEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVerifiedAccessEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVerifiedAccessGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVerifiedAccessGroup(ctx context.Context, params *ec2.DeleteVerifiedAccessGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerifiedAccessGroup")
	}

	var r0 *ec2.DeleteVerifiedAccessGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessGroupInput, ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessGroupInput, ...func(*ec2.Options)) *ec2.DeleteVerifiedAccessGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVerifiedAccessGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVerifiedAccessGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVerifiedAccessInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVerifiedAccessInstance(ctx context.Context, params *ec2.DeleteVerifiedAccessInstanceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerifiedAccessInstance")
	}

	var r0 *ec2.DeleteVerifiedAccessInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessInstanceInput, ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessInstanceInput, ...func(*ec2.Options)) *ec2.DeleteVerifiedAccessInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVerifiedAccessInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVerifiedAccessInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVerifiedAccessTrustProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVerifiedAccessTrustProvider(ctx context.Context, params *ec2.DeleteVerifiedAccessTrustProviderInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessTrustProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerifiedAccessTrustProvider")
	}

	var r0 *ec2.DeleteVerifiedAccessTrustProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) (*ec2.DeleteVerifiedAccessTrustProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) *ec2.DeleteVerifiedAccessTrustProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVerifiedAccessTrustProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVolume(ctx context.Context, params *ec2.DeleteVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVolume")
	}

	var r0 *ec2.DeleteVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) *ec2.DeleteVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpc(ctx context.Context, params *ec2.DeleteVpcInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpc")
	}

	var r0 *ec2.DeleteVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) *ec2.DeleteVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcBlockPublicAccessExclusion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcBlockPublicAccessExclusion(ctx context.Context, params *ec2.DeleteVpcBlockPublicAccessExclusionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcBlockPublicAccessExclusionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcBlockPublicAccessExclusion")
	}

	var r0 *ec2.DeleteVpcBlockPublicAccessExclusionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) (*ec2.DeleteVpcBlockPublicAccessExclusionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) *ec2.DeleteVpcBlockPublicAccessExclusionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcBlockPublicAccessExclusionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEncryptionControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEncryptionControl(ctx context.Context, params *ec2.DeleteVpcEncryptionControlInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEncryptionControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEncryptionControl")
	}

	var r0 *ec2.DeleteVpcEncryptionControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEncryptionControlInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEncryptionControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEncryptionControlInput, ...func(*ec2.Options)) *ec2.DeleteVpcEncryptionControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEncryptionControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEncryptionControlInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DeleteVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpointConnectionNotifications")
	}

	var r0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DeleteVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpointServiceConfigurations")
	}

	var r0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpoints(ctx context.Context, params *ec2.DeleteVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpoints")
	}

	var r0 *ec2.DeleteVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcPeeringConnection(ctx context.Context, params *ec2.DeleteVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcPeeringConnection")
	}

	var r0 *ec2.DeleteVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConcentrator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpnConcentrator(ctx context.Context, params *ec2.DeleteVpnConcentratorInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConcentratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnConcentrator")
	}

	var r0 *ec2.DeleteVpnConcentratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConcentratorInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConcentratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConcentratorInput, ...func(*ec2.Options)) *ec2.DeleteVpnConcentratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConcentratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConcentratorInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpnConnection(ctx context.Context, params *ec2.DeleteVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnConnection")
	}

	var r0 *ec2.DeleteVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpnConnectionRoute(ctx context.Context, params *ec2.DeleteVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnConnectionRoute")
	}

	var r0 *ec2.DeleteVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpnGateway(ctx context.Context, params *ec2.DeleteVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnGateway")
	}

	var r0 *ec2.DeleteVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) *ec2.DeleteVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprovisionByoipCidr(ctx context.Context, params *ec2.DeprovisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionByoipCidr")
	}

	var r0 *ec2.DeprovisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionIpamByoasn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprovisionIpamByoasn(ctx context.Context, params *ec2.DeprovisionIpamByoasnInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionIpamByoasnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionIpamByoasn")
	}

	var r0 *ec2.DeprovisionIpamByoasnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamByoasnInput, ...func(*ec2.Options)) (*ec2.DeprovisionIpamByoasnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamByoasnInput, ...func(*ec2.Options)) *ec2.DeprovisionIpamByoasnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionIpamByoasnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionIpamByoasnInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprovisionIpamPoolCidr(ctx context.Context, params *ec2.DeprovisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionIpamPoolCidr")
	}

	var r0 *ec2.DeprovisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprovisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.DeprovisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionPublicIpv4PoolCidr")
	}

	var r0 *ec2.DeprovisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterImage(ctx context.Context, params *ec2.DeregisterImageInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterImage")
	}

	var r0 *ec2.DeregisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) *ec2.DeregisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DeregisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterInstanceEventNotificationAttributes")
	}

	var r0 *ec2.DeregisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DeregisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTransitGatewayMulticastGroupMembers")
	}

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTransitGatewayMulticastGroupSources")
	}

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAccountAttributes(ctx context.Context, params *ec2.DescribeAccountAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccountAttributes")
	}

	var r0 *ec2.DescribeAccountAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) *ec2.DescribeAccountAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAccountAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddressTransfers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAddressTransfers(ctx context.Context, params *ec2.DescribeAddressTransfersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressTransfersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddressTransfers")
	}

	var r0 *ec2.DescribeAddressTransfersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressTransfersInput, ...func(*ec2.Options)) (*ec2.DescribeAddressTransfersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressTransfersInput, ...func(*ec2.Options)) *ec2.DescribeAddressTransfersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressTransfersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressTransfersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAddresses(ctx context.Context, params *ec2.DescribeAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddresses")
	}

	var r0 *ec2.DescribeAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) *ec2.DescribeAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddressesAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAddressesAttribute(ctx context.Context, params *ec2.DescribeAddressesAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddressesAttribute")
	}

	var r0 *ec2.DescribeAddressesAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) *ec2.DescribeAddressesAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAggregateIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAggregateIdFormat(ctx context.Context, params *ec2.DescribeAggregateIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAggregateIdFormat")
	}

	var r0 *ec2.DescribeAggregateIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeAggregateIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAggregateIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAvailabilityZones provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAvailabilityZones(ctx context.Context, params *ec2.DescribeAvailabilityZonesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAvailabilityZones")
	}

	var r0 *ec2.DescribeAvailabilityZonesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) *ec2.DescribeAvailabilityZonesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAvailabilityZonesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAwsNetworkPerformanceMetricSubscriptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAwsNetworkPerformanceMetricSubscriptions(ctx context.Context, params *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAwsNetworkPerformanceMetricSubscriptions")
	}

	var r0 *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsInput, ...func(*ec2.Options)) (*ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsInput, ...func(*ec2.Options)) *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAwsNetworkPerformanceMetricSubscriptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBundleTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBundleTasks(ctx context.Context, params *ec2.DescribeBundleTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBundleTasks")
	}

	var r0 *ec2.DescribeBundleTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) *ec2.DescribeBundleTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeBundleTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeByoipCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeByoipCidrs(ctx context.Context, params *ec2.DescribeByoipCidrsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeByoipCidrs")
	}

	var r0 *ec2.DescribeByoipCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) *ec2.DescribeByoipCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeByoipCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityBlockExtensionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityBlockExtensionHistory(ctx context.Context, params *ec2.DescribeCapacityBlockExtensionHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockExtensionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityBlockExtensionHistory")
	}

	var r0 *ec2.DescribeCapacityBlockExtensionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockExtensionHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockExtensionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockExtensionHistoryInput, ...func(*ec2.Options)) *ec2.DescribeCapacityBlockExtensionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityBlockExtensionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityBlockExtensionHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityBlockExtensionOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityBlockExtensionOfferings(ctx context.Context, params *ec2.DescribeCapacityBlockExtensionOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockExtensionOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityBlockExtensionOfferings")
	}

	var r0 *ec2.DescribeCapacityBlockExtensionOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockExtensionOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockExtensionOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockExtensionOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityBlockExtensionOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityBlockExtensionOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityBlockExtensionOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityBlockOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityBlockOfferings(ctx context.Context, params *ec2.DescribeCapacityBlockOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityBlockOfferings")
	}

	var r0 *ec2.DescribeCapacityBlockOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityBlockOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityBlockOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityBlockOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityBlockStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityBlockStatus(ctx context.Context, params *ec2.DescribeCapacityBlockStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityBlockStatus")
	}

	var r0 *ec2.DescribeCapacityBlockStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockStatusInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityBlockStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlockStatusInput, ...func(*ec2.Options)) *ec2.DescribeCapacityBlockStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityBlockStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityBlockStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityBlocks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityBlocks(ctx context.Context, params *ec2.DescribeCapacityBlocksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityBlocksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityBlocks")
	}

	var r0 *ec2.DescribeCapacityBlocksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlocksInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityBlocksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityBlocksInput, ...func(*ec2.Options)) *ec2.DescribeCapacityBlocksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityBlocksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityBlocksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityManagerDataExports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityManagerDataExports(ctx context.Context, params *ec2.DescribeCapacityManagerDataExportsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityManagerDataExportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityManagerDataExports")
	}

	var r0 *ec2.DescribeCapacityManagerDataExportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityManagerDataExportsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityManagerDataExportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityManagerDataExportsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityManagerDataExportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityManagerDataExportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityManagerDataExportsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservationBillingRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityReservationBillingRequests(ctx context.Context, params *ec2.DescribeCapacityReservationBillingRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationBillingRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservationBillingRequests")
	}

	var r0 *ec2.DescribeCapacityReservationBillingRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationBillingRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationBillingRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationBillingRequestsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationBillingRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationBillingRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationBillingRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityReservationFleets(ctx context.Context, params *ec2.DescribeCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservationFleets")
	}

	var r0 *ec2.DescribeCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservationTopology provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityReservationTopology(ctx context.Context, params *ec2.DescribeCapacityReservationTopologyInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationTopologyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservationTopology")
	}

	var r0 *ec2.DescribeCapacityReservationTopologyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationTopologyInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationTopologyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationTopologyInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationTopologyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationTopologyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationTopologyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCapacityReservations(ctx context.Context, params *ec2.DescribeCapacityReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservations")
	}

	var r0 *ec2.DescribeCapacityReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCarrierGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCarrierGateways(ctx context.Context, params *ec2.DescribeCarrierGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCarrierGateways")
	}

	var r0 *ec2.DescribeCarrierGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCarrierGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCarrierGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClassicLinkInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClassicLinkInstances(ctx context.Context, params *ec2.DescribeClassicLinkInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClassicLinkInstances")
	}

	var r0 *ec2.DescribeClassicLinkInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) *ec2.DescribeClassicLinkInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClassicLinkInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnAuthorizationRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClientVpnAuthorizationRules(ctx context.Context, params *ec2.DescribeClientVpnAuthorizationRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnAuthorizationRules")
	}

	var r0 *ec2.DescribeClientVpnAuthorizationRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnAuthorizationRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnAuthorizationRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClientVpnConnections(ctx context.Context, params *ec2.DescribeClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnConnections")
	}

	var r0 *ec2.DescribeClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClientVpnEndpoints(ctx context.Context, params *ec2.DescribeClientVpnEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnEndpoints")
	}

	var r0 *ec2.DescribeClientVpnEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClientVpnRoutes(ctx context.Context, params *ec2.DescribeClientVpnRoutesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnRoutes")
	}

	var r0 *ec2.DescribeClientVpnRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnTargetNetworks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClientVpnTargetNetworks(ctx context.Context, params *ec2.DescribeClientVpnTargetNetworksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnTargetNetworks")
	}

	var r0 *ec2.DescribeClientVpnTargetNetworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnTargetNetworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnTargetNetworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCoipPools provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCoipPools(ctx context.Context, params *ec2.DescribeCoipPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCoipPools")
	}

	var r0 *ec2.DescribeCoipPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) *ec2.DescribeCoipPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCoipPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConversionTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConversionTasks(ctx context.Context, params *ec2.DescribeConversionTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConversionTasks")
	}

	var r0 *ec2.DescribeConversionTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) *ec2.DescribeConversionTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeConversionTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomerGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomerGateways(ctx context.Context, params *ec2.DescribeCustomerGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomerGateways")
	}

	var r0 *ec2.DescribeCustomerGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCustomerGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCustomerGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDeclarativePoliciesReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDeclarativePoliciesReports(ctx context.Context, params *ec2.DescribeDeclarativePoliciesReportsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeDeclarativePoliciesReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDeclarativePoliciesReports")
	}

	var r0 *ec2.DescribeDeclarativePoliciesReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDeclarativePoliciesReportsInput, ...func(*ec2.Options)) (*ec2.DescribeDeclarativePoliciesReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDeclarativePoliciesReportsInput, ...func(*ec2.Options)) *ec2.DescribeDeclarativePoliciesReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeDeclarativePoliciesReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeDeclarativePoliciesReportsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDhcpOptions(ctx context.Context, params *ec2.DescribeDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDhcpOptions")
	}

	var r0 *ec2.DescribeDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DescribeDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEgressOnlyInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEgressOnlyInternetGateways(ctx context.Context, params *ec2.DescribeEgressOnlyInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEgressOnlyInternetGateways")
	}

	var r0 *ec2.DescribeEgressOnlyInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeEgressOnlyInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeEgressOnlyInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticGpus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeElasticGpus(ctx context.Context, params *ec2.DescribeElasticGpusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticGpus")
	}

	var r0 *ec2.DescribeElasticGpusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) *ec2.DescribeElasticGpusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeElasticGpusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExportImageTasks(ctx context.Context, params *ec2.DescribeExportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExportImageTasks")
	}

	var r0 *ec2.DescribeExportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExportTasks(ctx context.Context, params *ec2.DescribeExportTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExportTasks")
	}

	var r0 *ec2.DescribeExportTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFastLaunchImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFastLaunchImages(ctx context.Context, params *ec2.DescribeFastLaunchImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFastLaunchImages")
	}

	var r0 *ec2.DescribeFastLaunchImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) *ec2.DescribeFastLaunchImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastLaunchImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFastSnapshotRestores(ctx context.Context, params *ec2.DescribeFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFastSnapshotRestores")
	}

	var r0 *ec2.DescribeFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DescribeFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetHistory(ctx context.Context, params *ec2.DescribeFleetHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetHistory")
	}

	var r0 *ec2.DescribeFleetHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) *ec2.DescribeFleetHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetInstances(ctx context.Context, params *ec2.DescribeFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetInstances")
	}

	var r0 *ec2.DescribeFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleets(ctx context.Context, params *ec2.DescribeFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleets")
	}

	var r0 *ec2.DescribeFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) *ec2.DescribeFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFlowLogs(ctx context.Context, params *ec2.DescribeFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFlowLogs")
	}

	var r0 *ec2.DescribeFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) *ec2.DescribeFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFpgaImageAttribute(ctx context.Context, params *ec2.DescribeFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFpgaImageAttribute")
	}

	var r0 *ec2.DescribeFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFpgaImages(ctx context.Context, params *ec2.DescribeFpgaImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFpgaImages")
	}

	var r0 *ec2.DescribeFpgaImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservationOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeHostReservationOfferings(ctx context.Context, params *ec2.DescribeHostReservationOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHostReservationOfferings")
	}

	var r0 *ec2.DescribeHostReservationOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeHostReservations(ctx context.Context, params *ec2.DescribeHostReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHostReservations")
	}

	var r0 *ec2.DescribeHostReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHosts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeHosts(ctx context.Context, params *ec2.DescribeHostsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHosts")
	}

	var r0 *ec2.DescribeHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) *ec2.DescribeHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIamInstanceProfileAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIamInstanceProfileAssociations(ctx context.Context, params *ec2.DescribeIamInstanceProfileAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIamInstanceProfileAssociations")
	}

	var r0 *ec2.DescribeIamInstanceProfileAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeIamInstanceProfileAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIamInstanceProfileAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIdFormat(ctx context.Context, params *ec2.DescribeIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIdFormat")
	}

	var r0 *ec2.DescribeIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIdentityIdFormat(ctx context.Context, params *ec2.DescribeIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIdentityIdFormat")
	}

	var r0 *ec2.DescribeIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageAttribute(ctx context.Context, params *ec2.DescribeImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageAttribute")
	}

	var r0 *ec2.DescribeImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageReferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageReferences(ctx context.Context, params *ec2.DescribeImageReferencesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageReferences")
	}

	var r0 *ec2.DescribeImageReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageReferencesInput, ...func(*ec2.Options)) (*ec2.DescribeImageReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageReferencesInput, ...func(*ec2.Options)) *ec2.DescribeImageReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageUsageReportEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageUsageReportEntries(ctx context.Context, params *ec2.DescribeImageUsageReportEntriesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageUsageReportEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageUsageReportEntries")
	}

	var r0 *ec2.DescribeImageUsageReportEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageUsageReportEntriesInput, ...func(*ec2.Options)) (*ec2.DescribeImageUsageReportEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageUsageReportEntriesInput, ...func(*ec2.Options)) *ec2.DescribeImageUsageReportEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageUsageReportEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageUsageReportEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageUsageReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageUsageReports(ctx context.Context, params *ec2.DescribeImageUsageReportsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageUsageReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageUsageReports")
	}

	var r0 *ec2.DescribeImageUsageReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageUsageReportsInput, ...func(*ec2.Options)) (*ec2.DescribeImageUsageReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageUsageReportsInput, ...func(*ec2.Options)) *ec2.DescribeImageUsageReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageUsageReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageUsageReportsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImages(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImages")
	}

	var r0 *ec2.DescribeImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) *ec2.DescribeImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImportImageTasks(ctx context.Context, params *ec2.DescribeImportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImportImageTasks")
	}

	var r0 *ec2.DescribeImportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportSnapshotTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImportSnapshotTasks(ctx context.Context, params *ec2.DescribeImportSnapshotTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImportSnapshotTasks")
	}

	var r0 *ec2.DescribeImportSnapshotTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportSnapshotTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportSnapshotTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceAttribute(ctx context.Context, params *ec2.DescribeInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceAttribute")
	}

	var r0 *ec2.DescribeInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceConnectEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceConnectEndpoints(ctx context.Context, params *ec2.DescribeInstanceConnectEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceConnectEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceConnectEndpoints")
	}

	var r0 *ec2.DescribeInstanceConnectEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceConnectEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceConnectEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceConnectEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceConnectEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceConnectEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceConnectEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceCreditSpecifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceCreditSpecifications(ctx context.Context, params *ec2.DescribeInstanceCreditSpecificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceCreditSpecifications")
	}

	var r0 *ec2.DescribeInstanceCreditSpecificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceCreditSpecificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceCreditSpecificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DescribeInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceEventNotificationAttributes")
	}

	var r0 *ec2.DescribeInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceEventWindows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceEventWindows(ctx context.Context, params *ec2.DescribeInstanceEventWindowsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceEventWindows")
	}

	var r0 *ec2.DescribeInstanceEventWindowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventWindowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventWindowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceImageMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceImageMetadata(ctx context.Context, params *ec2.DescribeInstanceImageMetadataInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceImageMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceImageMetadata")
	}

	var r0 *ec2.DescribeInstanceImageMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceImageMetadataInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceImageMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceImageMetadataInput, ...func(*ec2.Options)) *ec2.DescribeInstanceImageMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceImageMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceImageMetadataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceSqlHaHistoryStates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceSqlHaHistoryStates(ctx context.Context, params *ec2.DescribeInstanceSqlHaHistoryStatesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceSqlHaHistoryStatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceSqlHaHistoryStates")
	}

	var r0 *ec2.DescribeInstanceSqlHaHistoryStatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceSqlHaHistoryStatesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceSqlHaHistoryStatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceSqlHaHistoryStatesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceSqlHaHistoryStatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceSqlHaHistoryStatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceSqlHaHistoryStatesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceSqlHaStates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceSqlHaStates(ctx context.Context, params *ec2.DescribeInstanceSqlHaStatesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceSqlHaStatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceSqlHaStates")
	}

	var r0 *ec2.DescribeInstanceSqlHaStatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceSqlHaStatesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceSqlHaStatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceSqlHaStatesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceSqlHaStatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceSqlHaStatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceSqlHaStatesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceStatus(ctx context.Context, params *ec2.DescribeInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceStatus")
	}

	var r0 *ec2.DescribeInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) *ec2.DescribeInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTopology provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceTopology(ctx context.Context, params *ec2.DescribeInstanceTopologyInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTopologyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTopology")
	}

	var r0 *ec2.DescribeInstanceTopologyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTopologyInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTopologyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTopologyInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTopologyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTopologyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTopologyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceTypeOfferings(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypeOfferings")
	}

	var r0 *ec2.DescribeInstanceTypeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceTypes(ctx context.Context, params *ec2.DescribeInstanceTypesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypes")
	}

	var r0 *ec2.DescribeInstanceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstances")
	}

	var r0 *ec2.DescribeInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) *ec2.DescribeInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInternetGateways(ctx context.Context, params *ec2.DescribeInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInternetGateways")
	}

	var r0 *ec2.DescribeInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamByoasn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamByoasn(ctx context.Context, params *ec2.DescribeIpamByoasnInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamByoasnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamByoasn")
	}

	var r0 *ec2.DescribeIpamByoasnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamByoasnInput, ...func(*ec2.Options)) (*ec2.DescribeIpamByoasnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamByoasnInput, ...func(*ec2.Options)) *ec2.DescribeIpamByoasnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamByoasnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamByoasnInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamExternalResourceVerificationTokens provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamExternalResourceVerificationTokens(ctx context.Context, params *ec2.DescribeIpamExternalResourceVerificationTokensInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamExternalResourceVerificationTokensOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamExternalResourceVerificationTokens")
	}

	var r0 *ec2.DescribeIpamExternalResourceVerificationTokensOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamExternalResourceVerificationTokensInput, ...func(*ec2.Options)) (*ec2.DescribeIpamExternalResourceVerificationTokensOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamExternalResourceVerificationTokensInput, ...func(*ec2.Options)) *ec2.DescribeIpamExternalResourceVerificationTokensOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamExternalResourceVerificationTokensOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamExternalResourceVerificationTokensInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamPolicies(ctx context.Context, params *ec2.DescribeIpamPoliciesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamPolicies")
	}

	var r0 *ec2.DescribeIpamPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoliciesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoliciesInput, ...func(*ec2.Options)) *ec2.DescribeIpamPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPoliciesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamPools provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamPools(ctx context.Context, params *ec2.DescribeIpamPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamPools")
	}

	var r0 *ec2.DescribeIpamPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpamPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamPrefixListResolverTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamPrefixListResolverTargets(ctx context.Context, params *ec2.DescribeIpamPrefixListResolverTargetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPrefixListResolverTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamPrefixListResolverTargets")
	}

	var r0 *ec2.DescribeIpamPrefixListResolverTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPrefixListResolverTargetsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPrefixListResolverTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPrefixListResolverTargetsInput, ...func(*ec2.Options)) *ec2.DescribeIpamPrefixListResolverTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPrefixListResolverTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPrefixListResolverTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamPrefixListResolvers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamPrefixListResolvers(ctx context.Context, params *ec2.DescribeIpamPrefixListResolversInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPrefixListResolversOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamPrefixListResolvers")
	}

	var r0 *ec2.DescribeIpamPrefixListResolversOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPrefixListResolversInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPrefixListResolversOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPrefixListResolversInput, ...func(*ec2.Options)) *ec2.DescribeIpamPrefixListResolversOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPrefixListResolversOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPrefixListResolversInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamResourceDiscoveries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamResourceDiscoveries(ctx context.Context, params *ec2.DescribeIpamResourceDiscoveriesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamResourceDiscoveriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamResourceDiscoveries")
	}

	var r0 *ec2.DescribeIpamResourceDiscoveriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamResourceDiscoveriesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamResourceDiscoveriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamResourceDiscoveriesInput, ...func(*ec2.Options)) *ec2.DescribeIpamResourceDiscoveriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamResourceDiscoveriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamResourceDiscoveriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamResourceDiscoveryAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamResourceDiscoveryAssociations(ctx context.Context, params *ec2.DescribeIpamResourceDiscoveryAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamResourceDiscoveryAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamResourceDiscoveryAssociations")
	}

	var r0 *ec2.DescribeIpamResourceDiscoveryAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamResourceDiscoveryAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamResourceDiscoveryAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamResourceDiscoveryAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeIpamResourceDiscoveryAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamResourceDiscoveryAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamResourceDiscoveryAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamScopes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpamScopes(ctx context.Context, params *ec2.DescribeIpamScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamScopes")
	}

	var r0 *ec2.DescribeIpamScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) *ec2.DescribeIpamScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpams provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpams(ctx context.Context, params *ec2.DescribeIpamsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpams")
	}

	var r0 *ec2.DescribeIpamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) *ec2.DescribeIpamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpv6Pools provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIpv6Pools(ctx context.Context, params *ec2.DescribeIpv6PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpv6Pools")
	}

	var r0 *ec2.DescribeIpv6PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpv6PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpv6PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKeyPairs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeKeyPairs(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeKeyPairs")
	}

	var r0 *ec2.DescribeKeyPairsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) *ec2.DescribeKeyPairsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeKeyPairsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLaunchTemplateVersions(ctx context.Context, params *ec2.DescribeLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLaunchTemplateVersions")
	}

	var r0 *ec2.DescribeLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLaunchTemplates(ctx context.Context, params *ec2.DescribeLaunchTemplatesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLaunchTemplates")
	}

	var r0 *ec2.DescribeLaunchTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVpcAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGatewayRouteTableVpcAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTableVpcAssociations")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGatewayRouteTables(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTables")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfaceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGatewayVirtualInterfaceGroups(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayVirtualInterfaceGroups")
	}

	var r0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGatewayVirtualInterfaces(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayVirtualInterfaces")
	}

	var r0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLocalGateways(ctx context.Context, params *ec2.DescribeLocalGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGateways")
	}

	var r0 *ec2.DescribeLocalGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLockedSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLockedSnapshots(ctx context.Context, params *ec2.DescribeLockedSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLockedSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLockedSnapshots")
	}

	var r0 *ec2.DescribeLockedSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLockedSnapshotsInput, ...func(*ec2.Options)) (*ec2.DescribeLockedSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLockedSnapshotsInput, ...func(*ec2.Options)) *ec2.DescribeLockedSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLockedSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLockedSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMacHosts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMacHosts(ctx context.Context, params *ec2.DescribeMacHostsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeMacHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMacHosts")
	}

	var r0 *ec2.DescribeMacHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMacHostsInput, ...func(*ec2.Options)) (*ec2.DescribeMacHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMacHostsInput, ...func(*ec2.Options)) *ec2.DescribeMacHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMacHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeMacHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMacModificationTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMacModificationTasks(ctx context.Context, params *ec2.DescribeMacModificationTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeMacModificationTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMacModificationTasks")
	}

	var r0 *ec2.DescribeMacModificationTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMacModificationTasksInput, ...func(*ec2.Options)) (*ec2.DescribeMacModificationTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMacModificationTasksInput, ...func(*ec2.Options)) *ec2.DescribeMacModificationTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMacModificationTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeMacModificationTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedPrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeManagedPrefixLists(ctx context.Context, params *ec2.DescribeManagedPrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeManagedPrefixLists")
	}

	var r0 *ec2.DescribeManagedPrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) *ec2.DescribeManagedPrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeManagedPrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMovingAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMovingAddresses(ctx context.Context, params *ec2.DescribeMovingAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMovingAddresses")
	}

	var r0 *ec2.DescribeMovingAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) *ec2.DescribeMovingAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMovingAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNatGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNatGateways(ctx context.Context, params *ec2.DescribeNatGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNatGateways")
	}

	var r0 *ec2.DescribeNatGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeNatGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNatGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkAcls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkAcls(ctx context.Context, params *ec2.DescribeNetworkAclsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkAcls")
	}

	var r0 *ec2.DescribeNetworkAclsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkAclsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkAclsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAccessScopeAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInsightsAccessScopeAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAccessScopeAnalyses")
	}

	var r0 *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAccessScopes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInsightsAccessScopes(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAccessScopes")
	}

	var r0 *ec2.DescribeNetworkInsightsAccessScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInsightsAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAnalyses")
	}

	var r0 *ec2.DescribeNetworkInsightsAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsPaths provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInsightsPaths(ctx context.Context, params *ec2.DescribeNetworkInsightsPathsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsPaths")
	}

	var r0 *ec2.DescribeNetworkInsightsPathsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsPathsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsPathsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInterfaceAttribute(ctx context.Context, params *ec2.DescribeNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfaceAttribute")
	}

	var r0 *ec2.DescribeNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfacePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInterfacePermissions(ctx context.Context, params *ec2.DescribeNetworkInterfacePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfacePermissions")
	}

	var r0 *ec2.DescribeNetworkInterfacePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNetworkInterfaces(ctx context.Context, params *ec2.DescribeNetworkInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfaces")
	}

	var r0 *ec2.DescribeNetworkInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutpostLags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeOutpostLags(ctx context.Context, params *ec2.DescribeOutpostLagsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeOutpostLagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOutpostLags")
	}

	var r0 *ec2.DescribeOutpostLagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeOutpostLagsInput, ...func(*ec2.Options)) (*ec2.DescribeOutpostLagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeOutpostLagsInput, ...func(*ec2.Options)) *ec2.DescribeOutpostLagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeOutpostLagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeOutpostLagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePlacementGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePlacementGroups(ctx context.Context, params *ec2.DescribePlacementGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePlacementGroups")
	}

	var r0 *ec2.DescribePlacementGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) *ec2.DescribePlacementGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePlacementGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePrefixLists(ctx context.Context, params *ec2.DescribePrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrefixLists")
	}

	var r0 *ec2.DescribePrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) *ec2.DescribePrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrincipalIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePrincipalIdFormat(ctx context.Context, params *ec2.DescribePrincipalIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrincipalIdFormat")
	}

	var r0 *ec2.DescribePrincipalIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) *ec2.DescribePrincipalIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrincipalIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePublicIpv4Pools provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePublicIpv4Pools(ctx context.Context, params *ec2.DescribePublicIpv4PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePublicIpv4Pools")
	}

	var r0 *ec2.DescribePublicIpv4PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) *ec2.DescribePublicIpv4PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePublicIpv4PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRegions(ctx context.Context, params *ec2.DescribeRegionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRegions")
	}

	var r0 *ec2.DescribeRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) *ec2.DescribeRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReplaceRootVolumeTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReplaceRootVolumeTasks(ctx context.Context, params *ec2.DescribeReplaceRootVolumeTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReplaceRootVolumeTasks")
	}

	var r0 *ec2.DescribeReplaceRootVolumeTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) *ec2.DescribeReplaceRootVolumeTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReplaceRootVolumeTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstances(ctx context.Context, params *ec2.DescribeReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstances")
	}

	var r0 *ec2.DescribeReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesListings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstancesListings(ctx context.Context, params *ec2.DescribeReservedInstancesListingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesListings")
	}

	var r0 *ec2.DescribeReservedInstancesListingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesListingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesListingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstancesModifications(ctx context.Context, params *ec2.DescribeReservedInstancesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesModifications")
	}

	var r0 *ec2.DescribeReservedInstancesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstancesOfferings(ctx context.Context, params *ec2.DescribeReservedInstancesOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesOfferings")
	}

	var r0 *ec2.DescribeReservedInstancesOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteServerEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRouteServerEndpoints(ctx context.Context, params *ec2.DescribeRouteServerEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteServerEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteServerEndpoints")
	}

	var r0 *ec2.DescribeRouteServerEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServerEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeRouteServerEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServerEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeRouteServerEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteServerEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteServerEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteServerPeers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRouteServerPeers(ctx context.Context, params *ec2.DescribeRouteServerPeersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteServerPeersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteServerPeers")
	}

	var r0 *ec2.DescribeRouteServerPeersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServerPeersInput, ...func(*ec2.Options)) (*ec2.DescribeRouteServerPeersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServerPeersInput, ...func(*ec2.Options)) *ec2.DescribeRouteServerPeersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteServerPeersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteServerPeersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteServers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRouteServers(ctx context.Context, params *ec2.DescribeRouteServersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteServersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteServers")
	}

	var r0 *ec2.DescribeRouteServersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServersInput, ...func(*ec2.Options)) (*ec2.DescribeRouteServersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteServersInput, ...func(*ec2.Options)) *ec2.DescribeRouteServersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteServersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteServersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRouteTables(ctx context.Context, params *ec2.DescribeRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteTables")
	}

	var r0 *ec2.DescribeRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstanceAvailability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeScheduledInstanceAvailability(ctx context.Context, params *ec2.DescribeScheduledInstanceAvailabilityInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScheduledInstanceAvailability")
	}

	var r0 *ec2.DescribeScheduledInstanceAvailabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstanceAvailabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstanceAvailabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeScheduledInstances(ctx context.Context, params *ec2.DescribeScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScheduledInstances")
	}

	var r0 *ec2.DescribeScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupReferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSecurityGroupReferences(ctx context.Context, params *ec2.DescribeSecurityGroupReferencesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroupReferences")
	}

	var r0 *ec2.DescribeSecurityGroupReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSecurityGroupRules(ctx context.Context, params *ec2.DescribeSecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroupRules")
	}

	var r0 *ec2.DescribeSecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupVpcAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSecurityGroupVpcAssociations(ctx context.Context, params *ec2.DescribeSecurityGroupVpcAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupVpcAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroupVpcAssociations")
	}

	var r0 *ec2.DescribeSecurityGroupVpcAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupVpcAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupVpcAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupVpcAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupVpcAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupVpcAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupVpcAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSecurityGroups(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroups")
	}

	var r0 *ec2.DescribeSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServiceLinkVirtualInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeServiceLinkVirtualInterfaces(ctx context.Context, params *ec2.DescribeServiceLinkVirtualInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeServiceLinkVirtualInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServiceLinkVirtualInterfaces")
	}

	var r0 *ec2.DescribeServiceLinkVirtualInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeServiceLinkVirtualInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeServiceLinkVirtualInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeServiceLinkVirtualInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeServiceLinkVirtualInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeServiceLinkVirtualInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeServiceLinkVirtualInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshotAttribute(ctx context.Context, params *ec2.DescribeSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotAttribute")
	}

	var r0 *ec2.DescribeSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotTierStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshotTierStatus(ctx context.Context, params *ec2.DescribeSnapshotTierStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotTierStatus")
	}

	var r0 *ec2.DescribeSnapshotTierStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotTierStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotTierStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshots(ctx context.Context, params *ec2.DescribeSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshots")
	}

	var r0 *ec2.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotDatafeedSubscription(ctx context.Context, params *ec2.DescribeSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotDatafeedSubscription")
	}

	var r0 *ec2.DescribeSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DescribeSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotFleetInstances(ctx context.Context, params *ec2.DescribeSpotFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetInstances")
	}

	var r0 *ec2.DescribeSpotFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequestHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotFleetRequestHistory(ctx context.Context, params *ec2.DescribeSpotFleetRequestHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetRequestHistory")
	}

	var r0 *ec2.DescribeSpotFleetRequestHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotFleetRequests(ctx context.Context, params *ec2.DescribeSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetRequests")
	}

	var r0 *ec2.DescribeSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotInstanceRequests(ctx context.Context, params *ec2.DescribeSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotInstanceRequests")
	}

	var r0 *ec2.DescribeSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotPriceHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSpotPriceHistory(ctx context.Context, params *ec2.DescribeSpotPriceHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotPriceHistory")
	}

	var r0 *ec2.DescribeSpotPriceHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotPriceHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotPriceHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStaleSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStaleSecurityGroups(ctx context.Context, params *ec2.DescribeStaleSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStaleSecurityGroups")
	}

	var r0 *ec2.DescribeStaleSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeStaleSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStaleSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStoreImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStoreImageTasks(ctx context.Context, params *ec2.DescribeStoreImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStoreImageTasks")
	}

	var r0 *ec2.DescribeStoreImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeStoreImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStoreImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSubnets")
	}

	var r0 *ec2.DescribeSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) *ec2.DescribeSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTags(ctx context.Context, params *ec2.DescribeTagsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTags")
	}

	var r0 *ec2.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) *ec2.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorFilterRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrafficMirrorFilterRules(ctx context.Context, params *ec2.DescribeTrafficMirrorFilterRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFilterRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorFilterRules")
	}

	var r0 *ec2.DescribeTrafficMirrorFilterRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFilterRulesInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFilterRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFilterRulesInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorFilterRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorFilterRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorFilterRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorFilters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrafficMirrorFilters(ctx context.Context, params *ec2.DescribeTrafficMirrorFiltersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorFilters")
	}

	var r0 *ec2.DescribeTrafficMirrorFiltersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorFiltersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorFiltersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrafficMirrorSessions(ctx context.Context, params *ec2.DescribeTrafficMirrorSessionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorSessions")
	}

	var r0 *ec2.DescribeTrafficMirrorSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrafficMirrorTargets(ctx context.Context, params *ec2.DescribeTrafficMirrorTargetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorTargets")
	}

	var r0 *ec2.DescribeTrafficMirrorTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayConnectPeers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayConnectPeers(ctx context.Context, params *ec2.DescribeTransitGatewayConnectPeersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayConnectPeers")
	}

	var r0 *ec2.DescribeTransitGatewayConnectPeersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectPeersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectPeersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayConnects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayConnects(ctx context.Context, params *ec2.DescribeTransitGatewayConnectsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayConnects")
	}

	var r0 *ec2.DescribeTransitGatewayConnectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayMeteringPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayMeteringPolicies(ctx context.Context, params *ec2.DescribeTransitGatewayMeteringPoliciesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMeteringPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayMeteringPolicies")
	}

	var r0 *ec2.DescribeTransitGatewayMeteringPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMeteringPoliciesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMeteringPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMeteringPoliciesInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayMeteringPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayMeteringPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayMeteringPoliciesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayMulticastDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayMulticastDomains(ctx context.Context, params *ec2.DescribeTransitGatewayMulticastDomainsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayMulticastDomains")
	}

	var r0 *ec2.DescribeTransitGatewayMulticastDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayMulticastDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayMulticastDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayPeeringAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayPeeringAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayPeeringAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayPeeringAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayPeeringAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayPeeringAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayPolicyTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayPolicyTables(ctx context.Context, params *ec2.DescribeTransitGatewayPolicyTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPolicyTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayPolicyTables")
	}

	var r0 *ec2.DescribeTransitGatewayPolicyTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPolicyTablesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPolicyTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPolicyTablesInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayPolicyTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayPolicyTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayPolicyTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayRouteTableAnnouncements provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayRouteTableAnnouncements(ctx context.Context, params *ec2.DescribeTransitGatewayRouteTableAnnouncementsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTableAnnouncementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayRouteTableAnnouncements")
	}

	var r0 *ec2.DescribeTransitGatewayRouteTableAnnouncementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTableAnnouncementsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTableAnnouncementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTableAnnouncementsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayRouteTableAnnouncementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayRouteTableAnnouncementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayRouteTableAnnouncementsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayRouteTables(ctx context.Context, params *ec2.DescribeTransitGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayRouteTables")
	}

	var r0 *ec2.DescribeTransitGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayVpcAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGatewayVpcAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayVpcAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayVpcAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayVpcAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayVpcAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransitGateways(ctx context.Context, params *ec2.DescribeTransitGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGateways")
	}

	var r0 *ec2.DescribeTransitGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrunkInterfaceAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrunkInterfaceAssociations(ctx context.Context, params *ec2.DescribeTrunkInterfaceAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrunkInterfaceAssociations")
	}

	var r0 *ec2.DescribeTrunkInterfaceAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeTrunkInterfaceAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrunkInterfaceAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVerifiedAccessEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVerifiedAccessEndpoints(ctx context.Context, params *ec2.DescribeVerifiedAccessEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVerifiedAccessEndpoints")
	}

	var r0 *ec2.DescribeVerifiedAccessEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeVerifiedAccessEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVerifiedAccessEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVerifiedAccessEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVerifiedAccessGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVerifiedAccessGroups(ctx context.Context, params *ec2.DescribeVerifiedAccessGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVerifiedAccessGroups")
	}

	var r0 *ec2.DescribeVerifiedAccessGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessGroupsInput, ...func(*ec2.Options)) *ec2.DescribeVerifiedAccessGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVerifiedAccessGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVerifiedAccessGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVerifiedAccessInstanceLoggingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVerifiedAccessInstanceLoggingConfigurations(ctx context.Context, params *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVerifiedAccessInstanceLoggingConfigurations")
	}

	var r0 *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsInput, ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsInput, ...func(*ec2.Options)) *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVerifiedAccessInstanceLoggingConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVerifiedAccessInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVerifiedAccessInstances(ctx context.Context, params *ec2.DescribeVerifiedAccessInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVerifiedAccessInstances")
	}

	var r0 *ec2.DescribeVerifiedAccessInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessInstancesInput, ...func(*ec2.Options)) *ec2.DescribeVerifiedAccessInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVerifiedAccessInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVerifiedAccessInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVerifiedAccessTrustProviders provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVerifiedAccessTrustProviders(ctx context.Context, params *ec2.DescribeVerifiedAccessTrustProvidersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessTrustProvidersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVerifiedAccessTrustProviders")
	}

	var r0 *ec2.DescribeVerifiedAccessTrustProvidersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessTrustProvidersInput, ...func(*ec2.Options)) (*ec2.DescribeVerifiedAccessTrustProvidersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVerifiedAccessTrustProvidersInput, ...func(*ec2.Options)) *ec2.DescribeVerifiedAccessTrustProvidersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVerifiedAccessTrustProvidersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVerifiedAccessTrustProvidersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVolumeAttribute(ctx context.Context, params *ec2.DescribeVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumeAttribute")
	}

	var r0 *ec2.DescribeVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVolumeStatus(ctx context.Context, params *ec2.DescribeVolumeStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumeStatus")
	}

	var r0 *ec2.DescribeVolumeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) *ec2.DescribeVolumeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVolumes(ctx context.Context, params *ec2.DescribeVolumesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumes")
	}

	var r0 *ec2.DescribeVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) *ec2.DescribeVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVolumesModifications(ctx context.Context, params *ec2.DescribeVolumesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumesModifications")
	}

	var r0 *ec2.DescribeVolumesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeVolumesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcAttribute(ctx context.Context, params *ec2.DescribeVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcAttribute")
	}

	var r0 *ec2.DescribeVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcBlockPublicAccessExclusions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcBlockPublicAccessExclusions(ctx context.Context, params *ec2.DescribeVpcBlockPublicAccessExclusionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcBlockPublicAccessExclusionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcBlockPublicAccessExclusions")
	}

	var r0 *ec2.DescribeVpcBlockPublicAccessExclusionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessExclusionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcBlockPublicAccessExclusionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessExclusionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcBlockPublicAccessExclusionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcBlockPublicAccessExclusionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessExclusionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcBlockPublicAccessOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcBlockPublicAccessOptions(ctx context.Context, params *ec2.DescribeVpcBlockPublicAccessOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcBlockPublicAccessOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcBlockPublicAccessOptions")
	}

	var r0 *ec2.DescribeVpcBlockPublicAccessOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcBlockPublicAccessOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcBlockPublicAccessOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcBlockPublicAccessOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcClassicLink(ctx context.Context, params *ec2.DescribeVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcClassicLink")
	}

	var r0 *ec2.DescribeVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DescribeVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.DescribeVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEncryptionControls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEncryptionControls(ctx context.Context, params *ec2.DescribeVpcEncryptionControlsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEncryptionControlsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEncryptionControls")
	}

	var r0 *ec2.DescribeVpcEncryptionControlsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEncryptionControlsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEncryptionControlsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEncryptionControlsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEncryptionControlsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEncryptionControlsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEncryptionControlsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointAssociations(ctx context.Context, params *ec2.DescribeVpcEndpointAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointAssociations")
	}

	var r0 *ec2.DescribeVpcEndpointAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointConnectionNotifications")
	}

	var r0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointConnections(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointConnections")
	}

	var r0 *ec2.DescribeVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DescribeVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServiceConfigurations")
	}

	var r0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointServicePermissions(ctx context.Context, params *ec2.DescribeVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServicePermissions")
	}

	var r0 *ec2.DescribeVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServices provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointServices(ctx context.Context, params *ec2.DescribeVpcEndpointServicesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServices")
	}

	var r0 *ec2.DescribeVpcEndpointServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpoints(ctx context.Context, params *ec2.DescribeVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpoints")
	}

	var r0 *ec2.DescribeVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcPeeringConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcPeeringConnections(ctx context.Context, params *ec2.DescribeVpcPeeringConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcPeeringConnections")
	}

	var r0 *ec2.DescribeVpcPeeringConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcPeeringConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcPeeringConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcs(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcs")
	}

	var r0 *ec2.DescribeVpcsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) *ec2.DescribeVpcsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnConcentrators provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpnConcentrators(ctx context.Context, params *ec2.DescribeVpnConcentratorsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnConcentratorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpnConcentrators")
	}

	var r0 *ec2.DescribeVpnConcentratorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConcentratorsInput, ...func(*ec2.Options)) (*ec2.DescribeVpnConcentratorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConcentratorsInput, ...func(*ec2.Options)) *ec2.DescribeVpnConcentratorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnConcentratorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnConcentratorsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpnConnections(ctx context.Context, params *ec2.DescribeVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpnConnections")
	}

	var r0 *ec2.DescribeVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnGateways provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpnGateways(ctx context.Context, params *ec2.DescribeVpnGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpnGateways")
	}

	var r0 *ec2.DescribeVpnGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeVpnGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachClassicLinkVpc(ctx context.Context, params *ec2.DetachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachClassicLinkVpc")
	}

	var r0 *ec2.DetachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.DetachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachInternetGateway(ctx context.Context, params *ec2.DetachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachInternetGateway")
	}

	var r0 *ec2.DetachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) *ec2.DetachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachNetworkInterface(ctx context.Context, params *ec2.DetachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachNetworkInterface")
	}

	var r0 *ec2.DetachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DetachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVerifiedAccessTrustProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachVerifiedAccessTrustProvider(ctx context.Context, params *ec2.DetachVerifiedAccessTrustProviderInput, optFns ...func(*ec2.Options)) (*ec2.DetachVerifiedAccessTrustProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachVerifiedAccessTrustProvider")
	}

	var r0 *ec2.DetachVerifiedAccessTrustProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) (*ec2.DetachVerifiedAccessTrustProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) *ec2.DetachVerifiedAccessTrustProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVerifiedAccessTrustProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachVolume(ctx context.Context, params *ec2.DetachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachVolume")
	}

	var r0 *ec2.DetachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) *ec2.DetachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetachVpnGateway(ctx context.Context, params *ec2.DetachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachVpnGateway")
	}

	var r0 *ec2.DetachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) *ec2.DetachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableAddressTransfer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableAddressTransfer(ctx context.Context, params *ec2.DisableAddressTransferInput, optFns ...func(*ec2.Options)) (*ec2.DisableAddressTransferOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableAddressTransfer")
	}

	var r0 *ec2.DisableAddressTransferOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAddressTransferInput, ...func(*ec2.Options)) (*ec2.DisableAddressTransferOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAddressTransferInput, ...func(*ec2.Options)) *ec2.DisableAddressTransferOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableAddressTransferOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableAddressTransferInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableAllowedImagesSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableAllowedImagesSettings(ctx context.Context, params *ec2.DisableAllowedImagesSettingsInput, optFns ...func(*ec2.Options)) (*ec2.DisableAllowedImagesSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableAllowedImagesSettings")
	}

	var r0 *ec2.DisableAllowedImagesSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAllowedImagesSettingsInput, ...func(*ec2.Options)) (*ec2.DisableAllowedImagesSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAllowedImagesSettingsInput, ...func(*ec2.Options)) *ec2.DisableAllowedImagesSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableAllowedImagesSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableAllowedImagesSettingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableAwsNetworkPerformanceMetricSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableAwsNetworkPerformanceMetricSubscription(ctx context.Context, params *ec2.DisableAwsNetworkPerformanceMetricSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DisableAwsNetworkPerformanceMetricSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableAwsNetworkPerformanceMetricSubscription")
	}

	var r0 *ec2.DisableAwsNetworkPerformanceMetricSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) (*ec2.DisableAwsNetworkPerformanceMetricSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) *ec2.DisableAwsNetworkPerformanceMetricSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableAwsNetworkPerformanceMetricSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableCapacityManager provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableCapacityManager(ctx context.Context, params *ec2.DisableCapacityManagerInput, optFns ...func(*ec2.Options)) (*ec2.DisableCapacityManagerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableCapacityManager")
	}

	var r0 *ec2.DisableCapacityManagerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableCapacityManagerInput, ...func(*ec2.Options)) (*ec2.DisableCapacityManagerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableCapacityManagerInput, ...func(*ec2.Options)) *ec2.DisableCapacityManagerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableCapacityManagerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableCapacityManagerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableEbsEncryptionByDefault(ctx context.Context, params *ec2.DisableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableEbsEncryptionByDefault")
	}

	var r0 *ec2.DisableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.DisableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableFastLaunch(ctx context.Context, params *ec2.DisableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableFastLaunch")
	}

	var r0 *ec2.DisableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) *ec2.DisableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableFastSnapshotRestores(ctx context.Context, params *ec2.DisableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableFastSnapshotRestores")
	}

	var r0 *ec2.DisableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DisableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableImage(ctx context.Context, params *ec2.DisableImageInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableImage")
	}

	var r0 *ec2.DisableImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageInput, ...func(*ec2.Options)) (*ec2.DisableImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageInput, ...func(*ec2.Options)) *ec2.DisableImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableImageBlockPublicAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableImageBlockPublicAccess(ctx context.Context, params *ec2.DisableImageBlockPublicAccessInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageBlockPublicAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableImageBlockPublicAccess")
	}

	var r0 *ec2.DisableImageBlockPublicAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageBlockPublicAccessInput, ...func(*ec2.Options)) (*ec2.DisableImageBlockPublicAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageBlockPublicAccessInput, ...func(*ec2.Options)) *ec2.DisableImageBlockPublicAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageBlockPublicAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageBlockPublicAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableImageDeprecation(ctx context.Context, params *ec2.DisableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableImageDeprecation")
	}

	var r0 *ec2.DisableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) *ec2.DisableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableImageDeregistrationProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableImageDeregistrationProtection(ctx context.Context, params *ec2.DisableImageDeregistrationProtectionInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageDeregistrationProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableImageDeregistrationProtection")
	}

	var r0 *ec2.DisableImageDeregistrationProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeregistrationProtectionInput, ...func(*ec2.Options)) (*ec2.DisableImageDeregistrationProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeregistrationProtectionInput, ...func(*ec2.Options)) *ec2.DisableImageDeregistrationProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageDeregistrationProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageDeregistrationProtectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableInstanceSqlHaStandbyDetections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableInstanceSqlHaStandbyDetections(ctx context.Context, params *ec2.DisableInstanceSqlHaStandbyDetectionsInput, optFns ...func(*ec2.Options)) (*ec2.DisableInstanceSqlHaStandbyDetectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableInstanceSqlHaStandbyDetections")
	}

	var r0 *ec2.DisableInstanceSqlHaStandbyDetectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) (*ec2.DisableInstanceSqlHaStandbyDetectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) *ec2.DisableInstanceSqlHaStandbyDetectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableInstanceSqlHaStandbyDetectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.DisableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableIpamOrganizationAdminAccount")
	}

	var r0 *ec2.DisableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.DisableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableIpamPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableIpamPolicy(ctx context.Context, params *ec2.DisableIpamPolicyInput, optFns ...func(*ec2.Options)) (*ec2.DisableIpamPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableIpamPolicy")
	}

	var r0 *ec2.DisableIpamPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamPolicyInput, ...func(*ec2.Options)) (*ec2.DisableIpamPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamPolicyInput, ...func(*ec2.Options)) *ec2.DisableIpamPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableIpamPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableIpamPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableRouteServerPropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableRouteServerPropagation(ctx context.Context, params *ec2.DisableRouteServerPropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableRouteServerPropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableRouteServerPropagation")
	}

	var r0 *ec2.DisableRouteServerPropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableRouteServerPropagationInput, ...func(*ec2.Options)) (*ec2.DisableRouteServerPropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableRouteServerPropagationInput, ...func(*ec2.Options)) *ec2.DisableRouteServerPropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableRouteServerPropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableRouteServerPropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableSerialConsoleAccess(ctx context.Context, params *ec2.DisableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableSerialConsoleAccess")
	}

	var r0 *ec2.DisableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.DisableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableSnapshotBlockPublicAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableSnapshotBlockPublicAccess(ctx context.Context, params *ec2.DisableSnapshotBlockPublicAccessInput, optFns ...func(*ec2.Options)) (*ec2.DisableSnapshotBlockPublicAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableSnapshotBlockPublicAccess")
	}

	var r0 *ec2.DisableSnapshotBlockPublicAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) (*ec2.DisableSnapshotBlockPublicAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) *ec2.DisableSnapshotBlockPublicAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableSnapshotBlockPublicAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.DisableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableTransitGatewayRouteTablePropagation")
	}

	var r0 *ec2.DisableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.DisableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableVgwRoutePropagation(ctx context.Context, params *ec2.DisableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVgwRoutePropagation")
	}

	var r0 *ec2.DisableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.DisableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableVpcClassicLink(ctx context.Context, params *ec2.DisableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVpcClassicLink")
	}

	var r0 *ec2.DisableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DisableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.DisableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateAddress(ctx context.Context, params *ec2.DisassociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAddress")
	}

	var r0 *ec2.DisassociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) *ec2.DisassociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateCapacityReservationBillingOwner provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateCapacityReservationBillingOwner(ctx context.Context, params *ec2.DisassociateCapacityReservationBillingOwnerInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateCapacityReservationBillingOwnerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateCapacityReservationBillingOwner")
	}

	var r0 *ec2.DisassociateCapacityReservationBillingOwnerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) (*ec2.DisassociateCapacityReservationBillingOwnerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) *ec2.DisassociateCapacityReservationBillingOwnerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateCapacityReservationBillingOwnerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateCapacityReservationBillingOwnerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateClientVpnTargetNetwork(ctx context.Context, params *ec2.DisassociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateClientVpnTargetNetwork")
	}

	var r0 *ec2.DisassociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.DisassociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.DisassociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateEnclaveCertificateIamRole")
	}

	var r0 *ec2.DisassociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.DisassociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateIamInstanceProfile(ctx context.Context, params *ec2.DisassociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateIamInstanceProfile")
	}

	var r0 *ec2.DisassociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.DisassociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateInstanceEventWindow(ctx context.Context, params *ec2.DisassociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateInstanceEventWindow")
	}

	var r0 *ec2.DisassociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DisassociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIpamByoasn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateIpamByoasn(ctx context.Context, params *ec2.DisassociateIpamByoasnInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateIpamByoasnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateIpamByoasn")
	}

	var r0 *ec2.DisassociateIpamByoasnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIpamByoasnInput, ...func(*ec2.Options)) (*ec2.DisassociateIpamByoasnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIpamByoasnInput, ...func(*ec2.Options)) *ec2.DisassociateIpamByoasnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIpamByoasnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateIpamByoasnInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIpamResourceDiscovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateIpamResourceDiscovery(ctx context.Context, params *ec2.DisassociateIpamResourceDiscoveryInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateIpamResourceDiscoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateIpamResourceDiscovery")
	}

	var r0 *ec2.DisassociateIpamResourceDiscoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) (*ec2.DisassociateIpamResourceDiscoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) *ec2.DisassociateIpamResourceDiscoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIpamResourceDiscoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateIpamResourceDiscoveryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateNatGatewayAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateNatGatewayAddress(ctx context.Context, params *ec2.DisassociateNatGatewayAddressInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateNatGatewayAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateNatGatewayAddress")
	}

	var r0 *ec2.DisassociateNatGatewayAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateNatGatewayAddressInput, ...func(*ec2.Options)) (*ec2.DisassociateNatGatewayAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateNatGatewayAddressInput, ...func(*ec2.Options)) *ec2.DisassociateNatGatewayAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateNatGatewayAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateNatGatewayAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateRouteServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateRouteServer(ctx context.Context, params *ec2.DisassociateRouteServerInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateRouteServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateRouteServer")
	}

	var r0 *ec2.DisassociateRouteServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteServerInput, ...func(*ec2.Options)) (*ec2.DisassociateRouteServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteServerInput, ...func(*ec2.Options)) *ec2.DisassociateRouteServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateRouteServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateRouteServerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateRouteTable(ctx context.Context, params *ec2.DisassociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateRouteTable")
	}

	var r0 *ec2.DisassociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateSecurityGroupVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateSecurityGroupVpc(ctx context.Context, params *ec2.DisassociateSecurityGroupVpcInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateSecurityGroupVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateSecurityGroupVpc")
	}

	var r0 *ec2.DisassociateSecurityGroupVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSecurityGroupVpcInput, ...func(*ec2.Options)) (*ec2.DisassociateSecurityGroupVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSecurityGroupVpcInput, ...func(*ec2.Options)) *ec2.DisassociateSecurityGroupVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateSecurityGroupVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateSecurityGroupVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateSubnetCidrBlock(ctx context.Context, params *ec2.DisassociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateSubnetCidrBlock")
	}

	var r0 *ec2.DisassociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DisassociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.DisassociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayPolicyTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateTransitGatewayPolicyTable(ctx context.Context, params *ec2.DisassociateTransitGatewayPolicyTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayPolicyTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTransitGatewayPolicyTable")
	}

	var r0 *ec2.DisassociateTransitGatewayPolicyTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayPolicyTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayPolicyTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayPolicyTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayPolicyTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateTransitGatewayRouteTable(ctx context.Context, params *ec2.DisassociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTransitGatewayRouteTable")
	}

	var r0 *ec2.DisassociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateTrunkInterface(ctx context.Context, params *ec2.DisassociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTrunkInterface")
	}

	var r0 *ec2.DisassociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.DisassociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateVpcCidrBlock(ctx context.Context, params *ec2.DisassociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateVpcCidrBlock")
	}

	var r0 *ec2.DisassociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableAddressTransfer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableAddressTransfer(ctx context.Context, params *ec2.EnableAddressTransferInput, optFns ...func(*ec2.Options)) (*ec2.EnableAddressTransferOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableAddressTransfer")
	}

	var r0 *ec2.EnableAddressTransferOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAddressTransferInput, ...func(*ec2.Options)) (*ec2.EnableAddressTransferOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAddressTransferInput, ...func(*ec2.Options)) *ec2.EnableAddressTransferOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableAddressTransferOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableAddressTransferInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableAllowedImagesSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableAllowedImagesSettings(ctx context.Context, params *ec2.EnableAllowedImagesSettingsInput, optFns ...func(*ec2.Options)) (*ec2.EnableAllowedImagesSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableAllowedImagesSettings")
	}

	var r0 *ec2.EnableAllowedImagesSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAllowedImagesSettingsInput, ...func(*ec2.Options)) (*ec2.EnableAllowedImagesSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAllowedImagesSettingsInput, ...func(*ec2.Options)) *ec2.EnableAllowedImagesSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableAllowedImagesSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableAllowedImagesSettingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableAwsNetworkPerformanceMetricSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableAwsNetworkPerformanceMetricSubscription(ctx context.Context, params *ec2.EnableAwsNetworkPerformanceMetricSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.EnableAwsNetworkPerformanceMetricSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableAwsNetworkPerformanceMetricSubscription")
	}

	var r0 *ec2.EnableAwsNetworkPerformanceMetricSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) (*ec2.EnableAwsNetworkPerformanceMetricSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) *ec2.EnableAwsNetworkPerformanceMetricSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableAwsNetworkPerformanceMetricSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableAwsNetworkPerformanceMetricSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableCapacityManager provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableCapacityManager(ctx context.Context, params *ec2.EnableCapacityManagerInput, optFns ...func(*ec2.Options)) (*ec2.EnableCapacityManagerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableCapacityManager")
	}

	var r0 *ec2.EnableCapacityManagerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableCapacityManagerInput, ...func(*ec2.Options)) (*ec2.EnableCapacityManagerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableCapacityManagerInput, ...func(*ec2.Options)) *ec2.EnableCapacityManagerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableCapacityManagerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableCapacityManagerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableEbsEncryptionByDefault(ctx context.Context, params *ec2.EnableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableEbsEncryptionByDefault")
	}

	var r0 *ec2.EnableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.EnableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableFastLaunch(ctx context.Context, params *ec2.EnableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableFastLaunch")
	}

	var r0 *ec2.EnableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) *ec2.EnableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableFastSnapshotRestores(ctx context.Context, params *ec2.EnableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableFastSnapshotRestores")
	}

	var r0 *ec2.EnableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.EnableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableImage(ctx context.Context, params *ec2.EnableImageInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableImage")
	}

	var r0 *ec2.EnableImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageInput, ...func(*ec2.Options)) (*ec2.EnableImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageInput, ...func(*ec2.Options)) *ec2.EnableImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableImageBlockPublicAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableImageBlockPublicAccess(ctx context.Context, params *ec2.EnableImageBlockPublicAccessInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageBlockPublicAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableImageBlockPublicAccess")
	}

	var r0 *ec2.EnableImageBlockPublicAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageBlockPublicAccessInput, ...func(*ec2.Options)) (*ec2.EnableImageBlockPublicAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageBlockPublicAccessInput, ...func(*ec2.Options)) *ec2.EnableImageBlockPublicAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageBlockPublicAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageBlockPublicAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableImageDeprecation(ctx context.Context, params *ec2.EnableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableImageDeprecation")
	}

	var r0 *ec2.EnableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) *ec2.EnableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableImageDeregistrationProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableImageDeregistrationProtection(ctx context.Context, params *ec2.EnableImageDeregistrationProtectionInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageDeregistrationProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableImageDeregistrationProtection")
	}

	var r0 *ec2.EnableImageDeregistrationProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeregistrationProtectionInput, ...func(*ec2.Options)) (*ec2.EnableImageDeregistrationProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeregistrationProtectionInput, ...func(*ec2.Options)) *ec2.EnableImageDeregistrationProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageDeregistrationProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageDeregistrationProtectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableInstanceSqlHaStandbyDetections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableInstanceSqlHaStandbyDetections(ctx context.Context, params *ec2.EnableInstanceSqlHaStandbyDetectionsInput, optFns ...func(*ec2.Options)) (*ec2.EnableInstanceSqlHaStandbyDetectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableInstanceSqlHaStandbyDetections")
	}

	var r0 *ec2.EnableInstanceSqlHaStandbyDetectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) (*ec2.EnableInstanceSqlHaStandbyDetectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) *ec2.EnableInstanceSqlHaStandbyDetectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableInstanceSqlHaStandbyDetectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableInstanceSqlHaStandbyDetectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.EnableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableIpamOrganizationAdminAccount")
	}

	var r0 *ec2.EnableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.EnableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableIpamPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableIpamPolicy(ctx context.Context, params *ec2.EnableIpamPolicyInput, optFns ...func(*ec2.Options)) (*ec2.EnableIpamPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableIpamPolicy")
	}

	var r0 *ec2.EnableIpamPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamPolicyInput, ...func(*ec2.Options)) (*ec2.EnableIpamPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamPolicyInput, ...func(*ec2.Options)) *ec2.EnableIpamPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableIpamPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableIpamPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableReachabilityAnalyzerOrganizationSharing provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableReachabilityAnalyzerOrganizationSharing(ctx context.Context, params *ec2.EnableReachabilityAnalyzerOrganizationSharingInput, optFns ...func(*ec2.Options)) (*ec2.EnableReachabilityAnalyzerOrganizationSharingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableReachabilityAnalyzerOrganizationSharing")
	}

	var r0 *ec2.EnableReachabilityAnalyzerOrganizationSharingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableReachabilityAnalyzerOrganizationSharingInput, ...func(*ec2.Options)) (*ec2.EnableReachabilityAnalyzerOrganizationSharingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableReachabilityAnalyzerOrganizationSharingInput, ...func(*ec2.Options)) *ec2.EnableReachabilityAnalyzerOrganizationSharingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableReachabilityAnalyzerOrganizationSharingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableReachabilityAnalyzerOrganizationSharingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableRouteServerPropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableRouteServerPropagation(ctx context.Context, params *ec2.EnableRouteServerPropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableRouteServerPropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableRouteServerPropagation")
	}

	var r0 *ec2.EnableRouteServerPropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableRouteServerPropagationInput, ...func(*ec2.Options)) (*ec2.EnableRouteServerPropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableRouteServerPropagationInput, ...func(*ec2.Options)) *ec2.EnableRouteServerPropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableRouteServerPropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableRouteServerPropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableSerialConsoleAccess(ctx context.Context, params *ec2.EnableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableSerialConsoleAccess")
	}

	var r0 *ec2.EnableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.EnableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableSnapshotBlockPublicAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableSnapshotBlockPublicAccess(ctx context.Context, params *ec2.EnableSnapshotBlockPublicAccessInput, optFns ...func(*ec2.Options)) (*ec2.EnableSnapshotBlockPublicAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableSnapshotBlockPublicAccess")
	}

	var r0 *ec2.EnableSnapshotBlockPublicAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) (*ec2.EnableSnapshotBlockPublicAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) *ec2.EnableSnapshotBlockPublicAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableSnapshotBlockPublicAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableSnapshotBlockPublicAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.EnableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableTransitGatewayRouteTablePropagation")
	}

	var r0 *ec2.EnableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.EnableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableVgwRoutePropagation(ctx context.Context, params *ec2.EnableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVgwRoutePropagation")
	}

	var r0 *ec2.EnableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.EnableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVolumeIO provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableVolumeIO(ctx context.Context, params *ec2.EnableVolumeIOInput, optFns ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVolumeIO")
	}

	var r0 *ec2.EnableVolumeIOOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) *ec2.EnableVolumeIOOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVolumeIOOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableVpcClassicLink(ctx context.Context, params *ec2.EnableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVpcClassicLink")
	}

	var r0 *ec2.EnableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.EnableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.EnableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ExportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportClientVpnClientCertificateRevocationList")
	}

	var r0 *ec2.ExportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportClientVpnClientConfiguration(ctx context.Context, params *ec2.ExportClientVpnClientConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportClientVpnClientConfiguration")
	}

	var r0 *ec2.ExportClientVpnClientConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportImage(ctx context.Context, params *ec2.ExportImageInput, optFns ...func(*ec2.Options)) (*ec2.ExportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportImage")
	}

	var r0 *ec2.ExportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) (*ec2.ExportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) *ec2.ExportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportTransitGatewayRoutes(ctx context.Context, params *ec2.ExportTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportTransitGatewayRoutes")
	}

	var r0 *ec2.ExportTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.ExportTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportVerifiedAccessInstanceClientConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportVerifiedAccessInstanceClientConfiguration(ctx context.Context, params *ec2.ExportVerifiedAccessInstanceClientConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ExportVerifiedAccessInstanceClientConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportVerifiedAccessInstanceClientConfiguration")
	}

	var r0 *ec2.ExportVerifiedAccessInstanceClientConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportVerifiedAccessInstanceClientConfigurationInput, ...func(*ec2.Options)) (*ec2.ExportVerifiedAccessInstanceClientConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportVerifiedAccessInstanceClientConfigurationInput, ...func(*ec2.Options)) *ec2.ExportVerifiedAccessInstanceClientConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportVerifiedAccessInstanceClientConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportVerifiedAccessInstanceClientConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActiveVpnTunnelStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetActiveVpnTunnelStatus(ctx context.Context, params *ec2.GetActiveVpnTunnelStatusInput, optFns ...func(*ec2.Options)) (*ec2.GetActiveVpnTunnelStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveVpnTunnelStatus")
	}

	var r0 *ec2.GetActiveVpnTunnelStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetActiveVpnTunnelStatusInput, ...func(*ec2.Options)) (*ec2.GetActiveVpnTunnelStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetActiveVpnTunnelStatusInput, ...func(*ec2.Options)) *ec2.GetActiveVpnTunnelStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetActiveVpnTunnelStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetActiveVpnTunnelStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllowedImagesSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAllowedImagesSettings(ctx context.Context, params *ec2.GetAllowedImagesSettingsInput, optFns ...func(*ec2.Options)) (*ec2.GetAllowedImagesSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllowedImagesSettings")
	}

	var r0 *ec2.GetAllowedImagesSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAllowedImagesSettingsInput, ...func(*ec2.Options)) (*ec2.GetAllowedImagesSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAllowedImagesSettingsInput, ...func(*ec2.Options)) *ec2.GetAllowedImagesSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAllowedImagesSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAllowedImagesSettingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedEnclaveCertificateIamRoles provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssociatedEnclaveCertificateIamRoles(ctx context.Context, params *ec2.GetAssociatedEnclaveCertificateIamRolesInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssociatedEnclaveCertificateIamRoles")
	}

	var r0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) *ec2.GetAssociatedEnclaveCertificateIamRolesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedEnclaveCertificateIamRolesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedIpv6PoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssociatedIpv6PoolCidrs(ctx context.Context, params *ec2.GetAssociatedIpv6PoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssociatedIpv6PoolCidrs")
	}

	var r0 *ec2.GetAssociatedIpv6PoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) *ec2.GetAssociatedIpv6PoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedIpv6PoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAwsNetworkPerformanceData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAwsNetworkPerformanceData(ctx context.Context, params *ec2.GetAwsNetworkPerformanceDataInput, optFns ...func(*ec2.Options)) (*ec2.GetAwsNetworkPerformanceDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAwsNetworkPerformanceData")
	}

	var r0 *ec2.GetAwsNetworkPerformanceDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAwsNetworkPerformanceDataInput, ...func(*ec2.Options)) (*ec2.GetAwsNetworkPerformanceDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAwsNetworkPerformanceDataInput, ...func(*ec2.Options)) *ec2.GetAwsNetworkPerformanceDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAwsNetworkPerformanceDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAwsNetworkPerformanceDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityManagerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCapacityManagerAttributes(ctx context.Context, params *ec2.GetCapacityManagerAttributesInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityManagerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCapacityManagerAttributes")
	}

	var r0 *ec2.GetCapacityManagerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerAttributesInput, ...func(*ec2.Options)) (*ec2.GetCapacityManagerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerAttributesInput, ...func(*ec2.Options)) *ec2.GetCapacityManagerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityManagerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityManagerAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityManagerMetricData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCapacityManagerMetricData(ctx context.Context, params *ec2.GetCapacityManagerMetricDataInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityManagerMetricDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCapacityManagerMetricData")
	}

	var r0 *ec2.GetCapacityManagerMetricDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerMetricDataInput, ...func(*ec2.Options)) (*ec2.GetCapacityManagerMetricDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerMetricDataInput, ...func(*ec2.Options)) *ec2.GetCapacityManagerMetricDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityManagerMetricDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityManagerMetricDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityManagerMetricDimensions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCapacityManagerMetricDimensions(ctx context.Context, params *ec2.GetCapacityManagerMetricDimensionsInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityManagerMetricDimensionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCapacityManagerMetricDimensions")
	}

	var r0 *ec2.GetCapacityManagerMetricDimensionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerMetricDimensionsInput, ...func(*ec2.Options)) (*ec2.GetCapacityManagerMetricDimensionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityManagerMetricDimensionsInput, ...func(*ec2.Options)) *ec2.GetCapacityManagerMetricDimensionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityManagerMetricDimensionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityManagerMetricDimensionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityReservationUsage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCapacityReservationUsage(ctx context.Context, params *ec2.GetCapacityReservationUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCapacityReservationUsage")
	}

	var r0 *ec2.GetCapacityReservationUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) *ec2.GetCapacityReservationUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityReservationUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCoipPoolUsage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCoipPoolUsage(ctx context.Context, params *ec2.GetCoipPoolUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCoipPoolUsage")
	}

	var r0 *ec2.GetCoipPoolUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) *ec2.GetCoipPoolUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCoipPoolUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleOutput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConsoleOutput(ctx context.Context, params *ec2.GetConsoleOutputInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConsoleOutput")
	}

	var r0 *ec2.GetConsoleOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) *ec2.GetConsoleOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleScreenshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConsoleScreenshot(ctx context.Context, params *ec2.GetConsoleScreenshotInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConsoleScreenshot")
	}

	var r0 *ec2.GetConsoleScreenshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) *ec2.GetConsoleScreenshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleScreenshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDeclarativePoliciesReportSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDeclarativePoliciesReportSummary(ctx context.Context, params *ec2.GetDeclarativePoliciesReportSummaryInput, optFns ...func(*ec2.Options)) (*ec2.GetDeclarativePoliciesReportSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDeclarativePoliciesReportSummary")
	}

	var r0 *ec2.GetDeclarativePoliciesReportSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDeclarativePoliciesReportSummaryInput, ...func(*ec2.Options)) (*ec2.GetDeclarativePoliciesReportSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDeclarativePoliciesReportSummaryInput, ...func(*ec2.Options)) *ec2.GetDeclarativePoliciesReportSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetDeclarativePoliciesReportSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetDeclarativePoliciesReportSummaryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDefaultCreditSpecification(ctx context.Context, params *ec2.GetDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDefaultCreditSpecification")
	}

	var r0 *ec2.GetDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.GetDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.GetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEbsDefaultKmsKeyId")
	}

	var r0 *ec2.GetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.GetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEbsEncryptionByDefault(ctx context.Context, params *ec2.GetEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEbsEncryptionByDefault")
	}

	var r0 *ec2.GetEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.GetEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnabledIpamPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEnabledIpamPolicy(ctx context.Context, params *ec2.GetEnabledIpamPolicyInput, optFns ...func(*ec2.Options)) (*ec2.GetEnabledIpamPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEnabledIpamPolicy")
	}

	var r0 *ec2.GetEnabledIpamPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEnabledIpamPolicyInput, ...func(*ec2.Options)) (*ec2.GetEnabledIpamPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEnabledIpamPolicyInput, ...func(*ec2.Options)) *ec2.GetEnabledIpamPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEnabledIpamPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEnabledIpamPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlowLogsIntegrationTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFlowLogsIntegrationTemplate(ctx context.Context, params *ec2.GetFlowLogsIntegrationTemplateInput, optFns ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowLogsIntegrationTemplate")
	}

	var r0 *ec2.GetFlowLogsIntegrationTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) *ec2.GetFlowLogsIntegrationTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetFlowLogsIntegrationTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsForCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGroupsForCapacityReservation(ctx context.Context, params *ec2.GetGroupsForCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupsForCapacityReservation")
	}

	var r0 *ec2.GetGroupsForCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) *ec2.GetGroupsForCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetGroupsForCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostReservationPurchasePreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetHostReservationPurchasePreview(ctx context.Context, params *ec2.GetHostReservationPurchasePreviewInput, optFns ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHostReservationPurchasePreview")
	}

	var r0 *ec2.GetHostReservationPurchasePreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) *ec2.GetHostReservationPurchasePreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetHostReservationPurchasePreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImageAncestry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImageAncestry(ctx context.Context, params *ec2.GetImageAncestryInput, optFns ...func(*ec2.Options)) (*ec2.GetImageAncestryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImageAncestry")
	}

	var r0 *ec2.GetImageAncestryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetImageAncestryInput, ...func(*ec2.Options)) (*ec2.GetImageAncestryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetImageAncestryInput, ...func(*ec2.Options)) *ec2.GetImageAncestryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetImageAncestryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetImageAncestryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImageBlockPublicAccessState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImageBlockPublicAccessState(ctx context.Context, params *ec2.GetImageBlockPublicAccessStateInput, optFns ...func(*ec2.Options)) (*ec2.GetImageBlockPublicAccessStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImageBlockPublicAccessState")
	}

	var r0 *ec2.GetImageBlockPublicAccessStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetImageBlockPublicAccessStateInput, ...func(*ec2.Options)) (*ec2.GetImageBlockPublicAccessStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetImageBlockPublicAccessStateInput, ...func(*ec2.Options)) *ec2.GetImageBlockPublicAccessStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetImageBlockPublicAccessStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetImageBlockPublicAccessStateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceMetadataDefaults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInstanceMetadataDefaults(ctx context.Context, params *ec2.GetInstanceMetadataDefaultsInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceMetadataDefaultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceMetadataDefaults")
	}

	var r0 *ec2.GetInstanceMetadataDefaultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceMetadataDefaultsInput, ...func(*ec2.Options)) (*ec2.GetInstanceMetadataDefaultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceMetadataDefaultsInput, ...func(*ec2.Options)) *ec2.GetInstanceMetadataDefaultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceMetadataDefaultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceMetadataDefaultsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceTpmEkPub provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInstanceTpmEkPub(ctx context.Context, params *ec2.GetInstanceTpmEkPubInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceTpmEkPubOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceTpmEkPub")
	}

	var r0 *ec2.GetInstanceTpmEkPubOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTpmEkPubInput, ...func(*ec2.Options)) (*ec2.GetInstanceTpmEkPubOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTpmEkPubInput, ...func(*ec2.Options)) *ec2.GetInstanceTpmEkPubOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceTpmEkPubOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceTpmEkPubInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceTypesFromInstanceRequirements provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInstanceTypesFromInstanceRequirements(ctx context.Context, params *ec2.GetInstanceTypesFromInstanceRequirementsInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceTypesFromInstanceRequirements")
	}

	var r0 *ec2.GetInstanceTypesFromInstanceRequirementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) *ec2.GetInstanceTypesFromInstanceRequirementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceTypesFromInstanceRequirementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceUefiData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInstanceUefiData(ctx context.Context, params *ec2.GetInstanceUefiDataInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceUefiDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceUefiData")
	}

	var r0 *ec2.GetInstanceUefiDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceUefiDataInput, ...func(*ec2.Options)) (*ec2.GetInstanceUefiDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceUefiDataInput, ...func(*ec2.Options)) *ec2.GetInstanceUefiDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceUefiDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceUefiDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamAddressHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamAddressHistory(ctx context.Context, params *ec2.GetIpamAddressHistoryInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamAddressHistory")
	}

	var r0 *ec2.GetIpamAddressHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) *ec2.GetIpamAddressHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamAddressHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamDiscoveredAccounts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamDiscoveredAccounts(ctx context.Context, params *ec2.GetIpamDiscoveredAccountsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredAccountsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamDiscoveredAccounts")
	}

	var r0 *ec2.GetIpamDiscoveredAccountsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredAccountsInput, ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredAccountsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredAccountsInput, ...func(*ec2.Options)) *ec2.GetIpamDiscoveredAccountsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamDiscoveredAccountsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamDiscoveredAccountsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamDiscoveredPublicAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamDiscoveredPublicAddresses(ctx context.Context, params *ec2.GetIpamDiscoveredPublicAddressesInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredPublicAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamDiscoveredPublicAddresses")
	}

	var r0 *ec2.GetIpamDiscoveredPublicAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredPublicAddressesInput, ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredPublicAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredPublicAddressesInput, ...func(*ec2.Options)) *ec2.GetIpamDiscoveredPublicAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamDiscoveredPublicAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamDiscoveredPublicAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamDiscoveredResourceCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamDiscoveredResourceCidrs(ctx context.Context, params *ec2.GetIpamDiscoveredResourceCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredResourceCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamDiscoveredResourceCidrs")
	}

	var r0 *ec2.GetIpamDiscoveredResourceCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredResourceCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamDiscoveredResourceCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamDiscoveredResourceCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamDiscoveredResourceCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamDiscoveredResourceCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamDiscoveredResourceCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPolicyAllocationRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPolicyAllocationRules(ctx context.Context, params *ec2.GetIpamPolicyAllocationRulesInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPolicyAllocationRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPolicyAllocationRules")
	}

	var r0 *ec2.GetIpamPolicyAllocationRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) (*ec2.GetIpamPolicyAllocationRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) *ec2.GetIpamPolicyAllocationRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPolicyAllocationRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPolicyOrganizationTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPolicyOrganizationTargets(ctx context.Context, params *ec2.GetIpamPolicyOrganizationTargetsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPolicyOrganizationTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPolicyOrganizationTargets")
	}

	var r0 *ec2.GetIpamPolicyOrganizationTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPolicyOrganizationTargetsInput, ...func(*ec2.Options)) (*ec2.GetIpamPolicyOrganizationTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPolicyOrganizationTargetsInput, ...func(*ec2.Options)) *ec2.GetIpamPolicyOrganizationTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPolicyOrganizationTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPolicyOrganizationTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPoolAllocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPoolAllocations(ctx context.Context, params *ec2.GetIpamPoolAllocationsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPoolAllocations")
	}

	var r0 *ec2.GetIpamPoolAllocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolAllocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolAllocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPoolCidrs(ctx context.Context, params *ec2.GetIpamPoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPoolCidrs")
	}

	var r0 *ec2.GetIpamPoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPrefixListResolverRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPrefixListResolverRules(ctx context.Context, params *ec2.GetIpamPrefixListResolverRulesInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPrefixListResolverRules")
	}

	var r0 *ec2.GetIpamPrefixListResolverRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverRulesInput, ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverRulesInput, ...func(*ec2.Options)) *ec2.GetIpamPrefixListResolverRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPrefixListResolverRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPrefixListResolverRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPrefixListResolverVersionEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPrefixListResolverVersionEntries(ctx context.Context, params *ec2.GetIpamPrefixListResolverVersionEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverVersionEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPrefixListResolverVersionEntries")
	}

	var r0 *ec2.GetIpamPrefixListResolverVersionEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionEntriesInput, ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverVersionEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionEntriesInput, ...func(*ec2.Options)) *ec2.GetIpamPrefixListResolverVersionEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPrefixListResolverVersionEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPrefixListResolverVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamPrefixListResolverVersions(ctx context.Context, params *ec2.GetIpamPrefixListResolverVersionsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPrefixListResolverVersions")
	}

	var r0 *ec2.GetIpamPrefixListResolverVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionsInput, ...func(*ec2.Options)) (*ec2.GetIpamPrefixListResolverVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionsInput, ...func(*ec2.Options)) *ec2.GetIpamPrefixListResolverVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPrefixListResolverVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPrefixListResolverVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamResourceCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIpamResourceCidrs(ctx context.Context, params *ec2.GetIpamResourceCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamResourceCidrs")
	}

	var r0 *ec2.GetIpamResourceCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamResourceCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamResourceCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLaunchTemplateData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLaunchTemplateData(ctx context.Context, params *ec2.GetLaunchTemplateDataInput, optFns ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLaunchTemplateData")
	}

	var r0 *ec2.GetLaunchTemplateDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) *ec2.GetLaunchTemplateDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetLaunchTemplateDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetManagedPrefixListAssociations(ctx context.Context, params *ec2.GetManagedPrefixListAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedPrefixListAssociations")
	}

	var r0 *ec2.GetManagedPrefixListAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetManagedPrefixListEntries(ctx context.Context, params *ec2.GetManagedPrefixListEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedPrefixListEntries")
	}

	var r0 *ec2.GetManagedPrefixListEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkInsightsAccessScopeAnalysisFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNetworkInsightsAccessScopeAnalysisFindings(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkInsightsAccessScopeAnalysisFindings")
	}

	var r0 *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkInsightsAccessScopeContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNetworkInsightsAccessScopeContent(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeContentInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkInsightsAccessScopeContent")
	}

	var r0 *ec2.GetNetworkInsightsAccessScopeContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPasswordData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPasswordData(ctx context.Context, params *ec2.GetPasswordDataInput, optFns ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPasswordData")
	}

	var r0 *ec2.GetPasswordDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) *ec2.GetPasswordDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetPasswordDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReservedInstancesExchangeQuote(ctx context.Context, params *ec2.GetReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReservedInstancesExchangeQuote")
	}

	var r0 *ec2.GetReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.GetReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRouteServerAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRouteServerAssociations(ctx context.Context, params *ec2.GetRouteServerAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetRouteServerAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRouteServerAssociations")
	}

	var r0 *ec2.GetRouteServerAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerAssociationsInput, ...func(*ec2.Options)) (*ec2.GetRouteServerAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerAssociationsInput, ...func(*ec2.Options)) *ec2.GetRouteServerAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetRouteServerAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetRouteServerAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRouteServerPropagations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRouteServerPropagations(ctx context.Context, params *ec2.GetRouteServerPropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetRouteServerPropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRouteServerPropagations")
	}

	var r0 *ec2.GetRouteServerPropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerPropagationsInput, ...func(*ec2.Options)) (*ec2.GetRouteServerPropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerPropagationsInput, ...func(*ec2.Options)) *ec2.GetRouteServerPropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetRouteServerPropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetRouteServerPropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRouteServerRoutingDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRouteServerRoutingDatabase(ctx context.Context, params *ec2.GetRouteServerRoutingDatabaseInput, optFns ...func(*ec2.Options)) (*ec2.GetRouteServerRoutingDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRouteServerRoutingDatabase")
	}

	var r0 *ec2.GetRouteServerRoutingDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerRoutingDatabaseInput, ...func(*ec2.Options)) (*ec2.GetRouteServerRoutingDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetRouteServerRoutingDatabaseInput, ...func(*ec2.Options)) *ec2.GetRouteServerRoutingDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetRouteServerRoutingDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetRouteServerRoutingDatabaseInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecurityGroupsForVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSecurityGroupsForVpc(ctx context.Context, params *ec2.GetSecurityGroupsForVpcInput, optFns ...func(*ec2.Options)) (*ec2.GetSecurityGroupsForVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSecurityGroupsForVpc")
	}

	var r0 *ec2.GetSecurityGroupsForVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSecurityGroupsForVpcInput, ...func(*ec2.Options)) (*ec2.GetSecurityGroupsForVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSecurityGroupsForVpcInput, ...func(*ec2.Options)) *ec2.GetSecurityGroupsForVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSecurityGroupsForVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSecurityGroupsForVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSerialConsoleAccessStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSerialConsoleAccessStatus(ctx context.Context, params *ec2.GetSerialConsoleAccessStatusInput, optFns ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSerialConsoleAccessStatus")
	}

	var r0 *ec2.GetSerialConsoleAccessStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) *ec2.GetSerialConsoleAccessStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSerialConsoleAccessStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshotBlockPublicAccessState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSnapshotBlockPublicAccessState(ctx context.Context, params *ec2.GetSnapshotBlockPublicAccessStateInput, optFns ...func(*ec2.Options)) (*ec2.GetSnapshotBlockPublicAccessStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnapshotBlockPublicAccessState")
	}

	var r0 *ec2.GetSnapshotBlockPublicAccessStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSnapshotBlockPublicAccessStateInput, ...func(*ec2.Options)) (*ec2.GetSnapshotBlockPublicAccessStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSnapshotBlockPublicAccessStateInput, ...func(*ec2.Options)) *ec2.GetSnapshotBlockPublicAccessStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSnapshotBlockPublicAccessStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSnapshotBlockPublicAccessStateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSpotPlacementScores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSpotPlacementScores(ctx context.Context, params *ec2.GetSpotPlacementScoresInput, optFns ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSpotPlacementScores")
	}

	var r0 *ec2.GetSpotPlacementScoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) *ec2.GetSpotPlacementScoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSpotPlacementScoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubnetCidrReservations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSubnetCidrReservations(ctx context.Context, params *ec2.GetSubnetCidrReservationsInput, optFns ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSubnetCidrReservations")
	}

	var r0 *ec2.GetSubnetCidrReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) *ec2.GetSubnetCidrReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSubnetCidrReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayAttachmentPropagations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayAttachmentPropagations(ctx context.Context, params *ec2.GetTransitGatewayAttachmentPropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayAttachmentPropagations")
	}

	var r0 *ec2.GetTransitGatewayAttachmentPropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayAttachmentPropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayAttachmentPropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayMeteringPolicyEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayMeteringPolicyEntries(ctx context.Context, params *ec2.GetTransitGatewayMeteringPolicyEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayMeteringPolicyEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayMeteringPolicyEntries")
	}

	var r0 *ec2.GetTransitGatewayMeteringPolicyEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMeteringPolicyEntriesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayMeteringPolicyEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMeteringPolicyEntriesInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayMeteringPolicyEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayMeteringPolicyEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayMeteringPolicyEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.GetTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayPolicyTableAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayPolicyTableAssociations(ctx context.Context, params *ec2.GetTransitGatewayPolicyTableAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayPolicyTableAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayPolicyTableAssociations")
	}

	var r0 *ec2.GetTransitGatewayPolicyTableAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPolicyTableAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPolicyTableAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPolicyTableAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayPolicyTableAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPolicyTableAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayPolicyTableAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayPolicyTableEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayPolicyTableEntries(ctx context.Context, params *ec2.GetTransitGatewayPolicyTableEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayPolicyTableEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayPolicyTableEntries")
	}

	var r0 *ec2.GetTransitGatewayPolicyTableEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPolicyTableEntriesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPolicyTableEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPolicyTableEntriesInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayPolicyTableEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPolicyTableEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayPolicyTableEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayPrefixListReferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayPrefixListReferences(ctx context.Context, params *ec2.GetTransitGatewayPrefixListReferencesInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayPrefixListReferences")
	}

	var r0 *ec2.GetTransitGatewayPrefixListReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayPrefixListReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPrefixListReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTableAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayRouteTableAssociations(ctx context.Context, params *ec2.GetTransitGatewayRouteTableAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayRouteTableAssociations")
	}

	var r0 *ec2.GetTransitGatewayRouteTableAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTableAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTableAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTablePropagations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTransitGatewayRouteTablePropagations(ctx context.Context, params *ec2.GetTransitGatewayRouteTablePropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayRouteTablePropagations")
	}

	var r0 *ec2.GetTransitGatewayRouteTablePropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTablePropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTablePropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiedAccessEndpointPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVerifiedAccessEndpointPolicy(ctx context.Context, params *ec2.GetVerifiedAccessEndpointPolicyInput, optFns ...func(*ec2.Options)) (*ec2.GetVerifiedAccessEndpointPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifiedAccessEndpointPolicy")
	}

	var r0 *ec2.GetVerifiedAccessEndpointPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) (*ec2.GetVerifiedAccessEndpointPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) *ec2.GetVerifiedAccessEndpointPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVerifiedAccessEndpointPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiedAccessEndpointTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVerifiedAccessEndpointTargets(ctx context.Context, params *ec2.GetVerifiedAccessEndpointTargetsInput, optFns ...func(*ec2.Options)) (*ec2.GetVerifiedAccessEndpointTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifiedAccessEndpointTargets")
	}

	var r0 *ec2.GetVerifiedAccessEndpointTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessEndpointTargetsInput, ...func(*ec2.Options)) (*ec2.GetVerifiedAccessEndpointTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessEndpointTargetsInput, ...func(*ec2.Options)) *ec2.GetVerifiedAccessEndpointTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVerifiedAccessEndpointTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVerifiedAccessEndpointTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiedAccessGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVerifiedAccessGroupPolicy(ctx context.Context, params *ec2.GetVerifiedAccessGroupPolicyInput, optFns ...func(*ec2.Options)) (*ec2.GetVerifiedAccessGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifiedAccessGroupPolicy")
	}

	var r0 *ec2.GetVerifiedAccessGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) (*ec2.GetVerifiedAccessGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) *ec2.GetVerifiedAccessGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVerifiedAccessGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpcResourcesBlockingEncryptionEnforcement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVpcResourcesBlockingEncryptionEnforcement(ctx context.Context, params *ec2.GetVpcResourcesBlockingEncryptionEnforcementInput, optFns ...func(*ec2.Options)) (*ec2.GetVpcResourcesBlockingEncryptionEnforcementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpcResourcesBlockingEncryptionEnforcement")
	}

	var r0 *ec2.GetVpcResourcesBlockingEncryptionEnforcementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpcResourcesBlockingEncryptionEnforcementInput, ...func(*ec2.Options)) (*ec2.GetVpcResourcesBlockingEncryptionEnforcementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpcResourcesBlockingEncryptionEnforcementInput, ...func(*ec2.Options)) *ec2.GetVpcResourcesBlockingEncryptionEnforcementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpcResourcesBlockingEncryptionEnforcementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpcResourcesBlockingEncryptionEnforcementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpnConnectionDeviceSampleConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVpnConnectionDeviceSampleConfiguration(ctx context.Context, params *ec2.GetVpnConnectionDeviceSampleConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpnConnectionDeviceSampleConfiguration")
	}

	var r0 *ec2.GetVpnConnectionDeviceSampleConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceSampleConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceSampleConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpnConnectionDeviceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVpnConnectionDeviceTypes(ctx context.Context, params *ec2.GetVpnConnectionDeviceTypesInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpnConnectionDeviceTypes")
	}

	var r0 *ec2.GetVpnConnectionDeviceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpnTunnelReplacementStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVpnTunnelReplacementStatus(ctx context.Context, params *ec2.GetVpnTunnelReplacementStatusInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnTunnelReplacementStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpnTunnelReplacementStatus")
	}

	var r0 *ec2.GetVpnTunnelReplacementStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnTunnelReplacementStatusInput, ...func(*ec2.Options)) (*ec2.GetVpnTunnelReplacementStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnTunnelReplacementStatusInput, ...func(*ec2.Options)) *ec2.GetVpnTunnelReplacementStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnTunnelReplacementStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnTunnelReplacementStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ImportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportClientVpnClientCertificateRevocationList")
	}

	var r0 *ec2.ImportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ImportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportImage(ctx context.Context, params *ec2.ImportImageInput, optFns ...func(*ec2.Options)) (*ec2.ImportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportImage")
	}

	var r0 *ec2.ImportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) (*ec2.ImportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) *ec2.ImportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportInstance(ctx context.Context, params *ec2.ImportInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportInstance")
	}

	var r0 *ec2.ImportInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) *ec2.ImportInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportKeyPair(ctx context.Context, params *ec2.ImportKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportKeyPair")
	}

	var r0 *ec2.ImportKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) *ec2.ImportKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportSnapshot(ctx context.Context, params *ec2.ImportSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportSnapshot")
	}

	var r0 *ec2.ImportSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) *ec2.ImportSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportVolume(ctx context.Context, params *ec2.ImportVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportVolume")
	}

	var r0 *ec2.ImportVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) *ec2.ImportVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImagesInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImagesInRecycleBin(ctx context.Context, params *ec2.ListImagesInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImagesInRecycleBin")
	}

	var r0 *ec2.ListImagesInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListImagesInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListImagesInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshotsInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSnapshotsInRecycleBin(ctx context.Context, params *ec2.ListSnapshotsInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnapshotsInRecycleBin")
	}

	var r0 *ec2.ListSnapshotsInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListSnapshotsInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListSnapshotsInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVolumesInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVolumesInRecycleBin(ctx context.Context, params *ec2.ListVolumesInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListVolumesInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVolumesInRecycleBin")
	}

	var r0 *ec2.ListVolumesInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListVolumesInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListVolumesInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListVolumesInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListVolumesInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListVolumesInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListVolumesInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LockSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) LockSnapshot(ctx context.Context, params *ec2.LockSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.LockSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LockSnapshot")
	}

	var r0 *ec2.LockSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.LockSnapshotInput, ...func(*ec2.Options)) (*ec2.LockSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.LockSnapshotInput, ...func(*ec2.Options)) *ec2.LockSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.LockSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.LockSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyAddressAttribute(ctx context.Context, params *ec2.ModifyAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAddressAttribute")
	}

	var r0 *ec2.ModifyAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) *ec2.ModifyAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAvailabilityZoneGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyAvailabilityZoneGroup(ctx context.Context, params *ec2.ModifyAvailabilityZoneGroupInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAvailabilityZoneGroup")
	}

	var r0 *ec2.ModifyAvailabilityZoneGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) *ec2.ModifyAvailabilityZoneGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAvailabilityZoneGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCapacityReservation(ctx context.Context, params *ec2.ModifyCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCapacityReservation")
	}

	var r0 *ec2.ModifyCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCapacityReservationFleet(ctx context.Context, params *ec2.ModifyCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCapacityReservationFleet")
	}

	var r0 *ec2.ModifyCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClientVpnEndpoint(ctx context.Context, params *ec2.ModifyClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClientVpnEndpoint")
	}

	var r0 *ec2.ModifyClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.ModifyClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyDefaultCreditSpecification(ctx context.Context, params *ec2.ModifyDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyDefaultCreditSpecification")
	}

	var r0 *ec2.ModifyDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ModifyEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyEbsDefaultKmsKeyId")
	}

	var r0 *ec2.ModifyEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ModifyEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyFleet(ctx context.Context, params *ec2.ModifyFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyFleet")
	}

	var r0 *ec2.ModifyFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) *ec2.ModifyFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyFpgaImageAttribute(ctx context.Context, params *ec2.ModifyFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyFpgaImageAttribute")
	}

	var r0 *ec2.ModifyFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyHosts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyHosts(ctx context.Context, params *ec2.ModifyHostsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyHosts")
	}

	var r0 *ec2.ModifyHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) *ec2.ModifyHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIdFormat(ctx context.Context, params *ec2.ModifyIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIdFormat")
	}

	var r0 *ec2.ModifyIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIdentityIdFormat(ctx context.Context, params *ec2.ModifyIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIdentityIdFormat")
	}

	var r0 *ec2.ModifyIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyImageAttribute(ctx context.Context, params *ec2.ModifyImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyImageAttribute")
	}

	var r0 *ec2.ModifyImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceAttribute(ctx context.Context, params *ec2.ModifyInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceAttribute")
	}

	var r0 *ec2.ModifyInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCapacityReservationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceCapacityReservationAttributes(ctx context.Context, params *ec2.ModifyInstanceCapacityReservationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceCapacityReservationAttributes")
	}

	var r0 *ec2.ModifyInstanceCapacityReservationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCapacityReservationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCapacityReservationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceConnectEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceConnectEndpoint(ctx context.Context, params *ec2.ModifyInstanceConnectEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceConnectEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceConnectEndpoint")
	}

	var r0 *ec2.ModifyInstanceConnectEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceConnectEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceConnectEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceConnectEndpointInput, ...func(*ec2.Options)) *ec2.ModifyInstanceConnectEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceConnectEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceConnectEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCpuOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceCpuOptions(ctx context.Context, params *ec2.ModifyInstanceCpuOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCpuOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceCpuOptions")
	}

	var r0 *ec2.ModifyInstanceCpuOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCpuOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCpuOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCpuOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCpuOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCpuOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCpuOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceCreditSpecification(ctx context.Context, params *ec2.ModifyInstanceCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceCreditSpecification")
	}

	var r0 *ec2.ModifyInstanceCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceEventStartTime provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceEventStartTime(ctx context.Context, params *ec2.ModifyInstanceEventStartTimeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceEventStartTime")
	}

	var r0 *ec2.ModifyInstanceEventStartTimeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventStartTimeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventStartTimeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceEventWindow(ctx context.Context, params *ec2.ModifyInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceEventWindow")
	}

	var r0 *ec2.ModifyInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMaintenanceOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceMaintenanceOptions(ctx context.Context, params *ec2.ModifyInstanceMaintenanceOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceMaintenanceOptions")
	}

	var r0 *ec2.ModifyInstanceMaintenanceOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMaintenanceOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMaintenanceOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMetadataDefaults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceMetadataDefaults(ctx context.Context, params *ec2.ModifyInstanceMetadataDefaultsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataDefaultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceMetadataDefaults")
	}

	var r0 *ec2.ModifyInstanceMetadataDefaultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataDefaultsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataDefaultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataDefaultsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMetadataDefaultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMetadataDefaultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMetadataDefaultsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMetadataOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceMetadataOptions(ctx context.Context, params *ec2.ModifyInstanceMetadataOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceMetadataOptions")
	}

	var r0 *ec2.ModifyInstanceMetadataOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMetadataOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMetadataOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceNetworkPerformanceOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstanceNetworkPerformanceOptions(ctx context.Context, params *ec2.ModifyInstanceNetworkPerformanceOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceNetworkPerformanceOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceNetworkPerformanceOptions")
	}

	var r0 *ec2.ModifyInstanceNetworkPerformanceOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceNetworkPerformanceOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceNetworkPerformanceOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceNetworkPerformanceOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceNetworkPerformanceOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceNetworkPerformanceOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceNetworkPerformanceOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstancePlacement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyInstancePlacement(ctx context.Context, params *ec2.ModifyInstancePlacementInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstancePlacement")
	}

	var r0 *ec2.ModifyInstancePlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) *ec2.ModifyInstancePlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstancePlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpam provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpam(ctx context.Context, params *ec2.ModifyIpamInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpam")
	}

	var r0 *ec2.ModifyIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) *ec2.ModifyIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamPolicyAllocationRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamPolicyAllocationRules(ctx context.Context, params *ec2.ModifyIpamPolicyAllocationRulesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPolicyAllocationRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamPolicyAllocationRules")
	}

	var r0 *ec2.ModifyIpamPolicyAllocationRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPolicyAllocationRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) *ec2.ModifyIpamPolicyAllocationRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPolicyAllocationRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPolicyAllocationRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamPool(ctx context.Context, params *ec2.ModifyIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamPool")
	}

	var r0 *ec2.ModifyIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) *ec2.ModifyIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamPrefixListResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamPrefixListResolver(ctx context.Context, params *ec2.ModifyIpamPrefixListResolverInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPrefixListResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamPrefixListResolver")
	}

	var r0 *ec2.ModifyIpamPrefixListResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPrefixListResolverInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPrefixListResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPrefixListResolverInput, ...func(*ec2.Options)) *ec2.ModifyIpamPrefixListResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPrefixListResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPrefixListResolverInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamPrefixListResolverTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamPrefixListResolverTarget(ctx context.Context, params *ec2.ModifyIpamPrefixListResolverTargetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPrefixListResolverTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamPrefixListResolverTarget")
	}

	var r0 *ec2.ModifyIpamPrefixListResolverTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPrefixListResolverTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) *ec2.ModifyIpamPrefixListResolverTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPrefixListResolverTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPrefixListResolverTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamResourceCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamResourceCidr(ctx context.Context, params *ec2.ModifyIpamResourceCidrInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamResourceCidr")
	}

	var r0 *ec2.ModifyIpamResourceCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) *ec2.ModifyIpamResourceCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamResourceCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamResourceDiscovery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamResourceDiscovery(ctx context.Context, params *ec2.ModifyIpamResourceDiscoveryInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamResourceDiscoveryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamResourceDiscovery")
	}

	var r0 *ec2.ModifyIpamResourceDiscoveryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceDiscoveryInput, ...func(*ec2.Options)) (*ec2.ModifyIpamResourceDiscoveryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceDiscoveryInput, ...func(*ec2.Options)) *ec2.ModifyIpamResourceDiscoveryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamResourceDiscoveryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamResourceDiscoveryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIpamScope(ctx context.Context, params *ec2.ModifyIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamScope")
	}

	var r0 *ec2.ModifyIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) *ec2.ModifyIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyLaunchTemplate(ctx context.Context, params *ec2.ModifyLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyLaunchTemplate")
	}

	var r0 *ec2.ModifyLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) *ec2.ModifyLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyLocalGatewayRoute(ctx context.Context, params *ec2.ModifyLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.ModifyLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyLocalGatewayRoute")
	}

	var r0 *ec2.ModifyLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.ModifyLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.ModifyLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyManagedPrefixList(ctx context.Context, params *ec2.ModifyManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyManagedPrefixList")
	}

	var r0 *ec2.ModifyManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) *ec2.ModifyManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyNetworkInterfaceAttribute(ctx context.Context, params *ec2.ModifyNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyNetworkInterfaceAttribute")
	}

	var r0 *ec2.ModifyNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyPrivateDnsNameOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyPrivateDnsNameOptions(ctx context.Context, params *ec2.ModifyPrivateDnsNameOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyPrivateDnsNameOptions")
	}

	var r0 *ec2.ModifyPrivateDnsNameOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) *ec2.ModifyPrivateDnsNameOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyPrivateDnsNameOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyPublicIpDnsNameOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyPublicIpDnsNameOptions(ctx context.Context, params *ec2.ModifyPublicIpDnsNameOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyPublicIpDnsNameOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyPublicIpDnsNameOptions")
	}

	var r0 *ec2.ModifyPublicIpDnsNameOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPublicIpDnsNameOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyPublicIpDnsNameOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPublicIpDnsNameOptionsInput, ...func(*ec2.Options)) *ec2.ModifyPublicIpDnsNameOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyPublicIpDnsNameOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyPublicIpDnsNameOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyReservedInstances(ctx context.Context, params *ec2.ModifyReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyReservedInstances")
	}

	var r0 *ec2.ModifyReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) *ec2.ModifyReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyRouteServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyRouteServer(ctx context.Context, params *ec2.ModifyRouteServerInput, optFns ...func(*ec2.Options)) (*ec2.ModifyRouteServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyRouteServer")
	}

	var r0 *ec2.ModifyRouteServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyRouteServerInput, ...func(*ec2.Options)) (*ec2.ModifyRouteServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyRouteServerInput, ...func(*ec2.Options)) *ec2.ModifyRouteServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyRouteServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyRouteServerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySecurityGroupRules(ctx context.Context, params *ec2.ModifySecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySecurityGroupRules")
	}

	var r0 *ec2.ModifySecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.ModifySecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySnapshotAttribute(ctx context.Context, params *ec2.ModifySnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotAttribute")
	}

	var r0 *ec2.ModifySnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ModifySnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySnapshotTier(ctx context.Context, params *ec2.ModifySnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotTier")
	}

	var r0 *ec2.ModifySnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) *ec2.ModifySnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySpotFleetRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySpotFleetRequest(ctx context.Context, params *ec2.ModifySpotFleetRequestInput, optFns ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySpotFleetRequest")
	}

	var r0 *ec2.ModifySpotFleetRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) *ec2.ModifySpotFleetRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySpotFleetRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySubnetAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySubnetAttribute(ctx context.Context, params *ec2.ModifySubnetAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySubnetAttribute")
	}

	var r0 *ec2.ModifySubnetAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) *ec2.ModifySubnetAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySubnetAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterNetworkServices provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTrafficMirrorFilterNetworkServices(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorFilterNetworkServices")
	}

	var r0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTrafficMirrorFilterRule(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorFilterRule")
	}

	var r0 *ec2.ModifyTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTrafficMirrorSession(ctx context.Context, params *ec2.ModifyTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorSession")
	}

	var r0 *ec2.ModifyTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTransitGateway(ctx context.Context, params *ec2.ModifyTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGateway")
	}

	var r0 *ec2.ModifyTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayMeteringPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTransitGatewayMeteringPolicy(ctx context.Context, params *ec2.ModifyTransitGatewayMeteringPolicyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayMeteringPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGatewayMeteringPolicy")
	}

	var r0 *ec2.ModifyTransitGatewayMeteringPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayMeteringPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayMeteringPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayMeteringPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayMeteringPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTransitGatewayPrefixListReference(ctx context.Context, params *ec2.ModifyTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGatewayPrefixListReference")
	}

	var r0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTransitGatewayVpcAttachment(ctx context.Context, params *ec2.ModifyTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGatewayVpcAttachment")
	}

	var r0 *ec2.ModifyTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessEndpoint(ctx context.Context, params *ec2.ModifyVerifiedAccessEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessEndpoint")
	}

	var r0 *ec2.ModifyVerifiedAccessEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessEndpointPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessEndpointPolicy(ctx context.Context, params *ec2.ModifyVerifiedAccessEndpointPolicyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessEndpointPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessEndpointPolicy")
	}

	var r0 *ec2.ModifyVerifiedAccessEndpointPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessEndpointPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessEndpointPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessEndpointPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessEndpointPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessGroup(ctx context.Context, params *ec2.ModifyVerifiedAccessGroupInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessGroup")
	}

	var r0 *ec2.ModifyVerifiedAccessGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessGroupInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessGroupInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessGroupPolicy(ctx context.Context, params *ec2.ModifyVerifiedAccessGroupPolicyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessGroupPolicy")
	}

	var r0 *ec2.ModifyVerifiedAccessGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessGroupPolicyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessInstance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessInstance(ctx context.Context, params *ec2.ModifyVerifiedAccessInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessInstance")
	}

	var r0 *ec2.ModifyVerifiedAccessInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessInstanceLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessInstanceLoggingConfiguration(ctx context.Context, params *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessInstanceLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessInstanceLoggingConfiguration")
	}

	var r0 *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessInstanceLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessInstanceLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessInstanceLoggingConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVerifiedAccessTrustProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVerifiedAccessTrustProvider(ctx context.Context, params *ec2.ModifyVerifiedAccessTrustProviderInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessTrustProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVerifiedAccessTrustProvider")
	}

	var r0 *ec2.ModifyVerifiedAccessTrustProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) (*ec2.ModifyVerifiedAccessTrustProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) *ec2.ModifyVerifiedAccessTrustProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVerifiedAccessTrustProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVerifiedAccessTrustProviderInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolume provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVolume(ctx context.Context, params *ec2.ModifyVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVolume")
	}

	var r0 *ec2.ModifyVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVolumeAttribute(ctx context.Context, params *ec2.ModifyVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVolumeAttribute")
	}

	var r0 *ec2.ModifyVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcAttribute(ctx context.Context, params *ec2.ModifyVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcAttribute")
	}

	var r0 *ec2.ModifyVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcBlockPublicAccessExclusion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcBlockPublicAccessExclusion(ctx context.Context, params *ec2.ModifyVpcBlockPublicAccessExclusionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcBlockPublicAccessExclusionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcBlockPublicAccessExclusion")
	}

	var r0 *ec2.ModifyVpcBlockPublicAccessExclusionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) (*ec2.ModifyVpcBlockPublicAccessExclusionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) *ec2.ModifyVpcBlockPublicAccessExclusionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcBlockPublicAccessExclusionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessExclusionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcBlockPublicAccessOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcBlockPublicAccessOptions(ctx context.Context, params *ec2.ModifyVpcBlockPublicAccessOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcBlockPublicAccessOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcBlockPublicAccessOptions")
	}

	var r0 *ec2.ModifyVpcBlockPublicAccessOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcBlockPublicAccessOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcBlockPublicAccessOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcBlockPublicAccessOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcBlockPublicAccessOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEncryptionControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEncryptionControl(ctx context.Context, params *ec2.ModifyVpcEncryptionControlInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEncryptionControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEncryptionControl")
	}

	var r0 *ec2.ModifyVpcEncryptionControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEncryptionControlInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEncryptionControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEncryptionControlInput, ...func(*ec2.Options)) *ec2.ModifyVpcEncryptionControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEncryptionControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEncryptionControlInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEndpoint(ctx context.Context, params *ec2.ModifyVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpoint")
	}

	var r0 *ec2.ModifyVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEndpointConnectionNotification(ctx context.Context, params *ec2.ModifyVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointConnectionNotification")
	}

	var r0 *ec2.ModifyVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.ModifyVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServiceConfiguration")
	}

	var r0 *ec2.ModifyVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServicePayerResponsibility provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEndpointServicePayerResponsibility(ctx context.Context, params *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServicePayerResponsibility")
	}

	var r0 *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcEndpointServicePermissions(ctx context.Context, params *ec2.ModifyVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServicePermissions")
	}

	var r0 *ec2.ModifyVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcPeeringConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcPeeringConnectionOptions(ctx context.Context, params *ec2.ModifyVpcPeeringConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcPeeringConnectionOptions")
	}

	var r0 *ec2.ModifyVpcPeeringConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcPeeringConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcPeeringConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcTenancy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpcTenancy(ctx context.Context, params *ec2.ModifyVpcTenancyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcTenancy")
	}

	var r0 *ec2.ModifyVpcTenancyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) *ec2.ModifyVpcTenancyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcTenancyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpnConnection(ctx context.Context, params *ec2.ModifyVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnConnection")
	}

	var r0 *ec2.ModifyVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpnConnectionOptions(ctx context.Context, params *ec2.ModifyVpnConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnConnectionOptions")
	}

	var r0 *ec2.ModifyVpnConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpnTunnelCertificate(ctx context.Context, params *ec2.ModifyVpnTunnelCertificateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnTunnelCertificate")
	}

	var r0 *ec2.ModifyVpnTunnelCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyVpnTunnelOptions(ctx context.Context, params *ec2.ModifyVpnTunnelOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnTunnelOptions")
	}

	var r0 *ec2.ModifyVpnTunnelOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MonitorInstances(ctx context.Context, params *ec2.MonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MonitorInstances")
	}

	var r0 *ec2.MonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) *ec2.MonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveAddressToVpc provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MoveAddressToVpc(ctx context.Context, params *ec2.MoveAddressToVpcInput, optFns ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveAddressToVpc")
	}

	var r0 *ec2.MoveAddressToVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) *ec2.MoveAddressToVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveAddressToVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveByoipCidrToIpam provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MoveByoipCidrToIpam(ctx context.Context, params *ec2.MoveByoipCidrToIpamInput, optFns ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveByoipCidrToIpam")
	}

	var r0 *ec2.MoveByoipCidrToIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) *ec2.MoveByoipCidrToIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveByoipCidrToIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveCapacityReservationInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MoveCapacityReservationInstances(ctx context.Context, params *ec2.MoveCapacityReservationInstancesInput, optFns ...func(*ec2.Options)) (*ec2.MoveCapacityReservationInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveCapacityReservationInstances")
	}

	var r0 *ec2.MoveCapacityReservationInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveCapacityReservationInstancesInput, ...func(*ec2.Options)) (*ec2.MoveCapacityReservationInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveCapacityReservationInstancesInput, ...func(*ec2.Options)) *ec2.MoveCapacityReservationInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveCapacityReservationInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveCapacityReservationInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() ec2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 ec2.Options
	if rf, ok := ret.Get(0).(func() ec2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ec2.Options)
	}

	return r0
}

// ProvisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ProvisionByoipCidr(ctx context.Context, params *ec2.ProvisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionByoipCidr")
	}

	var r0 *ec2.ProvisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) *ec2.ProvisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionIpamByoasn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ProvisionIpamByoasn(ctx context.Context, params *ec2.ProvisionIpamByoasnInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionIpamByoasnOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionIpamByoasn")
	}

	var r0 *ec2.ProvisionIpamByoasnOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamByoasnInput, ...func(*ec2.Options)) (*ec2.ProvisionIpamByoasnOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamByoasnInput, ...func(*ec2.Options)) *ec2.ProvisionIpamByoasnOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionIpamByoasnOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionIpamByoasnInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ProvisionIpamPoolCidr(ctx context.Context, params *ec2.ProvisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionIpamPoolCidr")
	}

	var r0 *ec2.ProvisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ProvisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.ProvisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionPublicIpv4PoolCidr")
	}

	var r0 *ec2.ProvisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseCapacityBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseCapacityBlock(ctx context.Context, params *ec2.PurchaseCapacityBlockInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseCapacityBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseCapacityBlock")
	}

	var r0 *ec2.PurchaseCapacityBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseCapacityBlockInput, ...func(*ec2.Options)) (*ec2.PurchaseCapacityBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseCapacityBlockInput, ...func(*ec2.Options)) *ec2.PurchaseCapacityBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseCapacityBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseCapacityBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseCapacityBlockExtension provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseCapacityBlockExtension(ctx context.Context, params *ec2.PurchaseCapacityBlockExtensionInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseCapacityBlockExtensionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseCapacityBlockExtension")
	}

	var r0 *ec2.PurchaseCapacityBlockExtensionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseCapacityBlockExtensionInput, ...func(*ec2.Options)) (*ec2.PurchaseCapacityBlockExtensionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseCapacityBlockExtensionInput, ...func(*ec2.Options)) *ec2.PurchaseCapacityBlockExtensionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseCapacityBlockExtensionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseCapacityBlockExtensionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseHostReservation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseHostReservation(ctx context.Context, params *ec2.PurchaseHostReservationInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseHostReservation")
	}

	var r0 *ec2.PurchaseHostReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) *ec2.PurchaseHostReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseHostReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseReservedInstancesOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedInstancesOffering(ctx context.Context, params *ec2.PurchaseReservedInstancesOfferingInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedInstancesOffering")
	}

	var r0 *ec2.PurchaseReservedInstancesOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) *ec2.PurchaseReservedInstancesOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseReservedInstancesOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseScheduledInstances(ctx context.Context, params *ec2.PurchaseScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseScheduledInstances")
	}

	var r0 *ec2.PurchaseScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) *ec2.PurchaseScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootInstances(ctx context.Context, params *ec2.RebootInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootInstances")
	}

	var r0 *ec2.RebootInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) *ec2.RebootInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RebootInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterImage(ctx context.Context, params *ec2.RegisterImageInput, optFns ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterImage")
	}

	var r0 *ec2.RegisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) *ec2.RegisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.RegisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterInstanceEventNotificationAttributes")
	}

	var r0 *ec2.RegisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.RegisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTransitGatewayMulticastGroupMembers")
	}

	var r0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTransitGatewayMulticastGroupSources")
	}

	var r0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectCapacityReservationBillingOwnership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectCapacityReservationBillingOwnership(ctx context.Context, params *ec2.RejectCapacityReservationBillingOwnershipInput, optFns ...func(*ec2.Options)) (*ec2.RejectCapacityReservationBillingOwnershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectCapacityReservationBillingOwnership")
	}

	var r0 *ec2.RejectCapacityReservationBillingOwnershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) (*ec2.RejectCapacityReservationBillingOwnershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) *ec2.RejectCapacityReservationBillingOwnershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectCapacityReservationBillingOwnershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectCapacityReservationBillingOwnershipInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.RejectTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.RejectTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectTransitGatewayVpcAttachment(ctx context.Context, params *ec2.RejectTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayVpcAttachment")
	}

	var r0 *ec2.RejectTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectVpcEndpointConnections(ctx context.Context, params *ec2.RejectVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectVpcEndpointConnections")
	}

	var r0 *ec2.RejectVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.RejectVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectVpcPeeringConnection(ctx context.Context, params *ec2.RejectVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectVpcPeeringConnection")
	}

	var r0 *ec2.RejectVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.RejectVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReleaseAddress(ctx context.Context, params *ec2.ReleaseAddressInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseAddress")
	}

	var r0 *ec2.ReleaseAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) *ec2.ReleaseAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseHosts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReleaseHosts(ctx context.Context, params *ec2.ReleaseHostsInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseHosts")
	}

	var r0 *ec2.ReleaseHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) *ec2.ReleaseHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseIpamPoolAllocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReleaseIpamPoolAllocation(ctx context.Context, params *ec2.ReleaseIpamPoolAllocationInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseIpamPoolAllocation")
	}

	var r0 *ec2.ReleaseIpamPoolAllocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) *ec2.ReleaseIpamPoolAllocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseIpamPoolAllocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceIamInstanceProfileAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceIamInstanceProfileAssociation(ctx context.Context, params *ec2.ReplaceIamInstanceProfileAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceIamInstanceProfileAssociation")
	}

	var r0 *ec2.ReplaceIamInstanceProfileAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceIamInstanceProfileAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceIamInstanceProfileAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceImageCriteriaInAllowedImagesSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceImageCriteriaInAllowedImagesSettings(ctx context.Context, params *ec2.ReplaceImageCriteriaInAllowedImagesSettingsInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceImageCriteriaInAllowedImagesSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceImageCriteriaInAllowedImagesSettings")
	}

	var r0 *ec2.ReplaceImageCriteriaInAllowedImagesSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceImageCriteriaInAllowedImagesSettingsInput, ...func(*ec2.Options)) (*ec2.ReplaceImageCriteriaInAllowedImagesSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceImageCriteriaInAllowedImagesSettingsInput, ...func(*ec2.Options)) *ec2.ReplaceImageCriteriaInAllowedImagesSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceImageCriteriaInAllowedImagesSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceImageCriteriaInAllowedImagesSettingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceNetworkAclAssociation(ctx context.Context, params *ec2.ReplaceNetworkAclAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceNetworkAclAssociation")
	}

	var r0 *ec2.ReplaceNetworkAclAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceNetworkAclEntry(ctx context.Context, params *ec2.ReplaceNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceNetworkAclEntry")
	}

	var r0 *ec2.ReplaceNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceRoute(ctx context.Context, params *ec2.ReplaceRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceRoute")
	}

	var r0 *ec2.ReplaceRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) *ec2.ReplaceRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRouteTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceRouteTableAssociation(ctx context.Context, params *ec2.ReplaceRouteTableAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceRouteTableAssociation")
	}

	var r0 *ec2.ReplaceRouteTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceRouteTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceTransitGatewayRoute(ctx context.Context, params *ec2.ReplaceTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceTransitGatewayRoute")
	}

	var r0 *ec2.ReplaceTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.ReplaceTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceVpnTunnel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplaceVpnTunnel(ctx context.Context, params *ec2.ReplaceVpnTunnelInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceVpnTunnelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceVpnTunnel")
	}

	var r0 *ec2.ReplaceVpnTunnelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceVpnTunnelInput, ...func(*ec2.Options)) (*ec2.ReplaceVpnTunnelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceVpnTunnelInput, ...func(*ec2.Options)) *ec2.ReplaceVpnTunnelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceVpnTunnelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceVpnTunnelInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReportInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReportInstanceStatus(ctx context.Context, params *ec2.ReportInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReportInstanceStatus")
	}

	var r0 *ec2.ReportInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) *ec2.ReportInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReportInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RequestSpotFleet(ctx context.Context, params *ec2.RequestSpotFleetInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestSpotFleet")
	}

	var r0 *ec2.RequestSpotFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) *ec2.RequestSpotFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RequestSpotInstances(ctx context.Context, params *ec2.RequestSpotInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestSpotInstances")
	}

	var r0 *ec2.RequestSpotInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) *ec2.RequestSpotInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetAddressAttribute(ctx context.Context, params *ec2.ResetAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetAddressAttribute")
	}

	var r0 *ec2.ResetAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) *ec2.ResetAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ResetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetEbsDefaultKmsKeyId")
	}

	var r0 *ec2.ResetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ResetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetFpgaImageAttribute(ctx context.Context, params *ec2.ResetFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetFpgaImageAttribute")
	}

	var r0 *ec2.ResetFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetImageAttribute(ctx context.Context, params *ec2.ResetImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetImageAttribute")
	}

	var r0 *ec2.ResetImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetInstanceAttribute(ctx context.Context, params *ec2.ResetInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetInstanceAttribute")
	}

	var r0 *ec2.ResetInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ResetInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetNetworkInterfaceAttribute(ctx context.Context, params *ec2.ResetNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetNetworkInterfaceAttribute")
	}

	var r0 *ec2.ResetNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ResetNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetSnapshotAttribute(ctx context.Context, params *ec2.ResetSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetSnapshotAttribute")
	}

	var r0 *ec2.ResetSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ResetSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreAddressToClassic provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreAddressToClassic(ctx context.Context, params *ec2.RestoreAddressToClassicInput, optFns ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreAddressToClassic")
	}

	var r0 *ec2.RestoreAddressToClassicOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) *ec2.RestoreAddressToClassicOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreAddressToClassicOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreImageFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreImageFromRecycleBin(ctx context.Context, params *ec2.RestoreImageFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreImageFromRecycleBin")
	}

	var r0 *ec2.RestoreImageFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreImageFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreImageFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreManagedPrefixListVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreManagedPrefixListVersion(ctx context.Context, params *ec2.RestoreManagedPrefixListVersionInput, optFns ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreManagedPrefixListVersion")
	}

	var r0 *ec2.RestoreManagedPrefixListVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) *ec2.RestoreManagedPrefixListVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreManagedPrefixListVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshotFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreSnapshotFromRecycleBin(ctx context.Context, params *ec2.RestoreSnapshotFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreSnapshotFromRecycleBin")
	}

	var r0 *ec2.RestoreSnapshotFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreSnapshotTier(ctx context.Context, params *ec2.RestoreSnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreSnapshotTier")
	}

	var r0 *ec2.RestoreSnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreVolumeFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreVolumeFromRecycleBin(ctx context.Context, params *ec2.RestoreVolumeFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreVolumeFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreVolumeFromRecycleBin")
	}

	var r0 *ec2.RestoreVolumeFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreVolumeFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreVolumeFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreVolumeFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreVolumeFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreVolumeFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreVolumeFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeClientVpnIngress(ctx context.Context, params *ec2.RevokeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeClientVpnIngress")
	}

	var r0 *ec2.RevokeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.RevokeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeSecurityGroupEgress(ctx context.Context, params *ec2.RevokeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSecurityGroupEgress")
	}

	var r0 *ec2.RevokeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeSecurityGroupIngress(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSecurityGroupIngress")
	}

	var r0 *ec2.RevokeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RunInstances(ctx context.Context, params *ec2.RunInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunInstances")
	}

	var r0 *ec2.RunInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) *ec2.RunInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RunScheduledInstances(ctx context.Context, params *ec2.RunScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunScheduledInstances")
	}

	var r0 *ec2.RunScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) *ec2.RunScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchLocalGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchLocalGatewayRoutes(ctx context.Context, params *ec2.SearchLocalGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchLocalGatewayRoutes")
	}

	var r0 *ec2.SearchLocalGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchLocalGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchLocalGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayMulticastGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchTransitGatewayMulticastGroups(ctx context.Context, params *ec2.SearchTransitGatewayMulticastGroupsInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTransitGatewayMulticastGroups")
	}

	var r0 *ec2.SearchTransitGatewayMulticastGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayMulticastGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayMulticastGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchTransitGatewayRoutes(ctx context.Context, params *ec2.SearchTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTransitGatewayRoutes")
	}

	var r0 *ec2.SearchTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendDiagnosticInterrupt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendDiagnosticInterrupt(ctx context.Context, params *ec2.SendDiagnosticInterruptInput, optFns ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendDiagnosticInterrupt")
	}

	var r0 *ec2.SendDiagnosticInterruptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) *ec2.SendDiagnosticInterruptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SendDiagnosticInterruptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDeclarativePoliciesReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDeclarativePoliciesReport(ctx context.Context, params *ec2.StartDeclarativePoliciesReportInput, optFns ...func(*ec2.Options)) (*ec2.StartDeclarativePoliciesReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDeclarativePoliciesReport")
	}

	var r0 *ec2.StartDeclarativePoliciesReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartDeclarativePoliciesReportInput, ...func(*ec2.Options)) (*ec2.StartDeclarativePoliciesReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartDeclarativePoliciesReportInput, ...func(*ec2.Options)) *ec2.StartDeclarativePoliciesReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartDeclarativePoliciesReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartDeclarativePoliciesReportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartInstances(ctx context.Context, params *ec2.StartInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartInstances")
	}

	var r0 *ec2.StartInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) *ec2.StartInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartNetworkInsightsAccessScopeAnalysis")
	}

	var r0 *ec2.StartNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartNetworkInsightsAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartNetworkInsightsAnalysis")
	}

	var r0 *ec2.StartNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartVpcEndpointServicePrivateDnsVerification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartVpcEndpointServicePrivateDnsVerification(ctx context.Context, params *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, optFns ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartVpcEndpointServicePrivateDnsVerification")
	}

	var r0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopInstances(ctx context.Context, params *ec2.StopInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopInstances")
	}

	var r0 *ec2.StopInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) *ec2.StopInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StopInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateClientVpnConnections(ctx context.Context, params *ec2.TerminateClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateClientVpnConnections")
	}

	var r0 *ec2.TerminateClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.TerminateClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateInstances(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateInstances")
	}

	var r0 *ec2.TerminateInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) *ec2.TerminateInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnassignIpv6Addresses(ctx context.Context, params *ec2.UnassignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnassignIpv6Addresses")
	}

	var r0 *ec2.UnassignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.UnassignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnassignPrivateIpAddresses(ctx context.Context, params *ec2.UnassignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnassignPrivateIpAddresses")
	}

	var r0 *ec2.UnassignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.UnassignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignPrivateNatGatewayAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnassignPrivateNatGatewayAddress(ctx context.Context, params *ec2.UnassignPrivateNatGatewayAddressInput, optFns ...func(*ec2.Options)) (*ec2.UnassignPrivateNatGatewayAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnassignPrivateNatGatewayAddress")
	}

	var r0 *ec2.UnassignPrivateNatGatewayAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) (*ec2.UnassignPrivateNatGatewayAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) *ec2.UnassignPrivateNatGatewayAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignPrivateNatGatewayAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignPrivateNatGatewayAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnlockSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnlockSnapshot(ctx context.Context, params *ec2.UnlockSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.UnlockSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnlockSnapshot")
	}

	var r0 *ec2.UnlockSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnlockSnapshotInput, ...func(*ec2.Options)) (*ec2.UnlockSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnlockSnapshotInput, ...func(*ec2.Options)) *ec2.UnlockSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnlockSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnlockSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnmonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnmonitorInstances(ctx context.Context, params *ec2.UnmonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnmonitorInstances")
	}

	var r0 *ec2.UnmonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) *ec2.UnmonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnmonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCapacityManagerOrganizationsAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCapacityManagerOrganizationsAccess(ctx context.Context, params *ec2.UpdateCapacityManagerOrganizationsAccessInput, optFns ...func(*ec2.Options)) (*ec2.UpdateCapacityManagerOrganizationsAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCapacityManagerOrganizationsAccess")
	}

	var r0 *ec2.UpdateCapacityManagerOrganizationsAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateCapacityManagerOrganizationsAccessInput, ...func(*ec2.Options)) (*ec2.UpdateCapacityManagerOrganizationsAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateCapacityManagerOrganizationsAccessInput, ...func(*ec2.Options)) *ec2.UpdateCapacityManagerOrganizationsAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateCapacityManagerOrganizationsAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateCapacityManagerOrganizationsAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateInterruptibleCapacityReservationAllocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateInterruptibleCapacityReservationAllocation(ctx context.Context, params *ec2.UpdateInterruptibleCapacityReservationAllocationInput, optFns ...func(*ec2.Options)) (*ec2.UpdateInterruptibleCapacityReservationAllocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInterruptibleCapacityReservationAllocation")
	}

	var r0 *ec2.UpdateInterruptibleCapacityReservationAllocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) (*ec2.UpdateInterruptibleCapacityReservationAllocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) *ec2.UpdateInterruptibleCapacityReservationAllocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateInterruptibleCapacityReservationAllocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateInterruptibleCapacityReservationAllocationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsEgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSecurityGroupRuleDescriptionsEgress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurityGroupRuleDescriptionsEgress")
	}

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSecurityGroupRuleDescriptionsIngress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurityGroupRuleDescriptionsIngress")
	}

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) WithdrawByoipCidr(ctx context.Context, params *ec2.WithdrawByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawByoipCidr")
	}

	var r0 *ec2.WithdrawByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) *ec2.WithdrawByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.WithdrawByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
