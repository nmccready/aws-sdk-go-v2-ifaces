// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	ecr "github.com/aws/aws-sdk-go-v2/service/ecr"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchCheckLayerAvailability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCheckLayerAvailability(ctx context.Context, params *ecr.BatchCheckLayerAvailabilityInput, optFns ...func(*ecr.Options)) (*ecr.BatchCheckLayerAvailabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCheckLayerAvailability")
	}

	var r0 *ecr.BatchCheckLayerAvailabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchCheckLayerAvailabilityInput, ...func(*ecr.Options)) (*ecr.BatchCheckLayerAvailabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchCheckLayerAvailabilityInput, ...func(*ecr.Options)) *ecr.BatchCheckLayerAvailabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.BatchCheckLayerAvailabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.BatchCheckLayerAvailabilityInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteImage(ctx context.Context, params *ecr.BatchDeleteImageInput, optFns ...func(*ecr.Options)) (*ecr.BatchDeleteImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteImage")
	}

	var r0 *ecr.BatchDeleteImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchDeleteImageInput, ...func(*ecr.Options)) (*ecr.BatchDeleteImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchDeleteImageInput, ...func(*ecr.Options)) *ecr.BatchDeleteImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.BatchDeleteImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.BatchDeleteImageInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetImage(ctx context.Context, params *ecr.BatchGetImageInput, optFns ...func(*ecr.Options)) (*ecr.BatchGetImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetImage")
	}

	var r0 *ecr.BatchGetImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchGetImageInput, ...func(*ecr.Options)) (*ecr.BatchGetImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchGetImageInput, ...func(*ecr.Options)) *ecr.BatchGetImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.BatchGetImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.BatchGetImageInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetRepositoryScanningConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetRepositoryScanningConfiguration(ctx context.Context, params *ecr.BatchGetRepositoryScanningConfigurationInput, optFns ...func(*ecr.Options)) (*ecr.BatchGetRepositoryScanningConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetRepositoryScanningConfiguration")
	}

	var r0 *ecr.BatchGetRepositoryScanningConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchGetRepositoryScanningConfigurationInput, ...func(*ecr.Options)) (*ecr.BatchGetRepositoryScanningConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.BatchGetRepositoryScanningConfigurationInput, ...func(*ecr.Options)) *ecr.BatchGetRepositoryScanningConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.BatchGetRepositoryScanningConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.BatchGetRepositoryScanningConfigurationInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteLayerUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompleteLayerUpload(ctx context.Context, params *ecr.CompleteLayerUploadInput, optFns ...func(*ecr.Options)) (*ecr.CompleteLayerUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompleteLayerUpload")
	}

	var r0 *ecr.CompleteLayerUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CompleteLayerUploadInput, ...func(*ecr.Options)) (*ecr.CompleteLayerUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CompleteLayerUploadInput, ...func(*ecr.Options)) *ecr.CompleteLayerUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.CompleteLayerUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.CompleteLayerUploadInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePullThroughCacheRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePullThroughCacheRule(ctx context.Context, params *ecr.CreatePullThroughCacheRuleInput, optFns ...func(*ecr.Options)) (*ecr.CreatePullThroughCacheRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePullThroughCacheRule")
	}

	var r0 *ecr.CreatePullThroughCacheRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CreatePullThroughCacheRuleInput, ...func(*ecr.Options)) (*ecr.CreatePullThroughCacheRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CreatePullThroughCacheRuleInput, ...func(*ecr.Options)) *ecr.CreatePullThroughCacheRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.CreatePullThroughCacheRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.CreatePullThroughCacheRuleInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRepository(ctx context.Context, params *ecr.CreateRepositoryInput, optFns ...func(*ecr.Options)) (*ecr.CreateRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepository")
	}

	var r0 *ecr.CreateRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CreateRepositoryInput, ...func(*ecr.Options)) (*ecr.CreateRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.CreateRepositoryInput, ...func(*ecr.Options)) *ecr.CreateRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.CreateRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.CreateRepositoryInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLifecyclePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLifecyclePolicy(ctx context.Context, params *ecr.DeleteLifecyclePolicyInput, optFns ...func(*ecr.Options)) (*ecr.DeleteLifecyclePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLifecyclePolicy")
	}

	var r0 *ecr.DeleteLifecyclePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteLifecyclePolicyInput, ...func(*ecr.Options)) (*ecr.DeleteLifecyclePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteLifecyclePolicyInput, ...func(*ecr.Options)) *ecr.DeleteLifecyclePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DeleteLifecyclePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DeleteLifecyclePolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePullThroughCacheRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePullThroughCacheRule(ctx context.Context, params *ecr.DeletePullThroughCacheRuleInput, optFns ...func(*ecr.Options)) (*ecr.DeletePullThroughCacheRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePullThroughCacheRule")
	}

	var r0 *ecr.DeletePullThroughCacheRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeletePullThroughCacheRuleInput, ...func(*ecr.Options)) (*ecr.DeletePullThroughCacheRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeletePullThroughCacheRuleInput, ...func(*ecr.Options)) *ecr.DeletePullThroughCacheRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DeletePullThroughCacheRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DeletePullThroughCacheRuleInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegistryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegistryPolicy(ctx context.Context, params *ecr.DeleteRegistryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.DeleteRegistryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistryPolicy")
	}

	var r0 *ecr.DeleteRegistryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRegistryPolicyInput, ...func(*ecr.Options)) (*ecr.DeleteRegistryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRegistryPolicyInput, ...func(*ecr.Options)) *ecr.DeleteRegistryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DeleteRegistryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DeleteRegistryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRepository(ctx context.Context, params *ecr.DeleteRepositoryInput, optFns ...func(*ecr.Options)) (*ecr.DeleteRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepository")
	}

	var r0 *ecr.DeleteRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRepositoryInput, ...func(*ecr.Options)) (*ecr.DeleteRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRepositoryInput, ...func(*ecr.Options)) *ecr.DeleteRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DeleteRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DeleteRepositoryInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRepositoryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRepositoryPolicy(ctx context.Context, params *ecr.DeleteRepositoryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.DeleteRepositoryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepositoryPolicy")
	}

	var r0 *ecr.DeleteRepositoryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRepositoryPolicyInput, ...func(*ecr.Options)) (*ecr.DeleteRepositoryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DeleteRepositoryPolicyInput, ...func(*ecr.Options)) *ecr.DeleteRepositoryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DeleteRepositoryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DeleteRepositoryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageReplicationStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageReplicationStatus(ctx context.Context, params *ecr.DescribeImageReplicationStatusInput, optFns ...func(*ecr.Options)) (*ecr.DescribeImageReplicationStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageReplicationStatus")
	}

	var r0 *ecr.DescribeImageReplicationStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImageReplicationStatusInput, ...func(*ecr.Options)) (*ecr.DescribeImageReplicationStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImageReplicationStatusInput, ...func(*ecr.Options)) *ecr.DescribeImageReplicationStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribeImageReplicationStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribeImageReplicationStatusInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageScanFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImageScanFindings(ctx context.Context, params *ecr.DescribeImageScanFindingsInput, optFns ...func(*ecr.Options)) (*ecr.DescribeImageScanFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageScanFindings")
	}

	var r0 *ecr.DescribeImageScanFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImageScanFindingsInput, ...func(*ecr.Options)) (*ecr.DescribeImageScanFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImageScanFindingsInput, ...func(*ecr.Options)) *ecr.DescribeImageScanFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribeImageScanFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribeImageScanFindingsInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeImages(ctx context.Context, params *ecr.DescribeImagesInput, optFns ...func(*ecr.Options)) (*ecr.DescribeImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImages")
	}

	var r0 *ecr.DescribeImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImagesInput, ...func(*ecr.Options)) (*ecr.DescribeImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeImagesInput, ...func(*ecr.Options)) *ecr.DescribeImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribeImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribeImagesInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePullThroughCacheRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePullThroughCacheRules(ctx context.Context, params *ecr.DescribePullThroughCacheRulesInput, optFns ...func(*ecr.Options)) (*ecr.DescribePullThroughCacheRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePullThroughCacheRules")
	}

	var r0 *ecr.DescribePullThroughCacheRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribePullThroughCacheRulesInput, ...func(*ecr.Options)) (*ecr.DescribePullThroughCacheRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribePullThroughCacheRulesInput, ...func(*ecr.Options)) *ecr.DescribePullThroughCacheRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribePullThroughCacheRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribePullThroughCacheRulesInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRegistry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRegistry(ctx context.Context, params *ecr.DescribeRegistryInput, optFns ...func(*ecr.Options)) (*ecr.DescribeRegistryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRegistry")
	}

	var r0 *ecr.DescribeRegistryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeRegistryInput, ...func(*ecr.Options)) (*ecr.DescribeRegistryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeRegistryInput, ...func(*ecr.Options)) *ecr.DescribeRegistryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribeRegistryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribeRegistryInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRepositories(ctx context.Context, params *ecr.DescribeRepositoriesInput, optFns ...func(*ecr.Options)) (*ecr.DescribeRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRepositories")
	}

	var r0 *ecr.DescribeRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeRepositoriesInput, ...func(*ecr.Options)) (*ecr.DescribeRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.DescribeRepositoriesInput, ...func(*ecr.Options)) *ecr.DescribeRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.DescribeRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.DescribeRepositoriesInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthorizationToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAuthorizationToken(ctx context.Context, params *ecr.GetAuthorizationTokenInput, optFns ...func(*ecr.Options)) (*ecr.GetAuthorizationTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAuthorizationToken")
	}

	var r0 *ecr.GetAuthorizationTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetAuthorizationTokenInput, ...func(*ecr.Options)) (*ecr.GetAuthorizationTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetAuthorizationTokenInput, ...func(*ecr.Options)) *ecr.GetAuthorizationTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetAuthorizationTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetAuthorizationTokenInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDownloadUrlForLayer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDownloadUrlForLayer(ctx context.Context, params *ecr.GetDownloadUrlForLayerInput, optFns ...func(*ecr.Options)) (*ecr.GetDownloadUrlForLayerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDownloadUrlForLayer")
	}

	var r0 *ecr.GetDownloadUrlForLayerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetDownloadUrlForLayerInput, ...func(*ecr.Options)) (*ecr.GetDownloadUrlForLayerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetDownloadUrlForLayerInput, ...func(*ecr.Options)) *ecr.GetDownloadUrlForLayerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetDownloadUrlForLayerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetDownloadUrlForLayerInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLifecyclePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLifecyclePolicy(ctx context.Context, params *ecr.GetLifecyclePolicyInput, optFns ...func(*ecr.Options)) (*ecr.GetLifecyclePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLifecyclePolicy")
	}

	var r0 *ecr.GetLifecyclePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetLifecyclePolicyInput, ...func(*ecr.Options)) (*ecr.GetLifecyclePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetLifecyclePolicyInput, ...func(*ecr.Options)) *ecr.GetLifecyclePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetLifecyclePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetLifecyclePolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLifecyclePolicyPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLifecyclePolicyPreview(ctx context.Context, params *ecr.GetLifecyclePolicyPreviewInput, optFns ...func(*ecr.Options)) (*ecr.GetLifecyclePolicyPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLifecyclePolicyPreview")
	}

	var r0 *ecr.GetLifecyclePolicyPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetLifecyclePolicyPreviewInput, ...func(*ecr.Options)) (*ecr.GetLifecyclePolicyPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetLifecyclePolicyPreviewInput, ...func(*ecr.Options)) *ecr.GetLifecyclePolicyPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetLifecyclePolicyPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetLifecyclePolicyPreviewInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegistryPolicy(ctx context.Context, params *ecr.GetRegistryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.GetRegistryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryPolicy")
	}

	var r0 *ecr.GetRegistryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRegistryPolicyInput, ...func(*ecr.Options)) (*ecr.GetRegistryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRegistryPolicyInput, ...func(*ecr.Options)) *ecr.GetRegistryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetRegistryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetRegistryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryScanningConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegistryScanningConfiguration(ctx context.Context, params *ecr.GetRegistryScanningConfigurationInput, optFns ...func(*ecr.Options)) (*ecr.GetRegistryScanningConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryScanningConfiguration")
	}

	var r0 *ecr.GetRegistryScanningConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRegistryScanningConfigurationInput, ...func(*ecr.Options)) (*ecr.GetRegistryScanningConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRegistryScanningConfigurationInput, ...func(*ecr.Options)) *ecr.GetRegistryScanningConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetRegistryScanningConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetRegistryScanningConfigurationInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRepositoryPolicy(ctx context.Context, params *ecr.GetRepositoryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.GetRepositoryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryPolicy")
	}

	var r0 *ecr.GetRepositoryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRepositoryPolicyInput, ...func(*ecr.Options)) (*ecr.GetRepositoryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.GetRepositoryPolicyInput, ...func(*ecr.Options)) *ecr.GetRepositoryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.GetRepositoryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.GetRepositoryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitiateLayerUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InitiateLayerUpload(ctx context.Context, params *ecr.InitiateLayerUploadInput, optFns ...func(*ecr.Options)) (*ecr.InitiateLayerUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InitiateLayerUpload")
	}

	var r0 *ecr.InitiateLayerUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.InitiateLayerUploadInput, ...func(*ecr.Options)) (*ecr.InitiateLayerUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.InitiateLayerUploadInput, ...func(*ecr.Options)) *ecr.InitiateLayerUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.InitiateLayerUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.InitiateLayerUploadInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImages(ctx context.Context, params *ecr.ListImagesInput, optFns ...func(*ecr.Options)) (*ecr.ListImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImages")
	}

	var r0 *ecr.ListImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ListImagesInput, ...func(*ecr.Options)) (*ecr.ListImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ListImagesInput, ...func(*ecr.Options)) *ecr.ListImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.ListImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.ListImagesInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *ecr.ListTagsForResourceInput, optFns ...func(*ecr.Options)) (*ecr.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *ecr.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ListTagsForResourceInput, ...func(*ecr.Options)) (*ecr.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ListTagsForResourceInput, ...func(*ecr.Options)) *ecr.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.ListTagsForResourceInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() ecr.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 ecr.Options
	if rf, ok := ret.Get(0).(func() ecr.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ecr.Options)
	}

	return r0
}

// PutImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutImage(ctx context.Context, params *ecr.PutImageInput, optFns ...func(*ecr.Options)) (*ecr.PutImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutImage")
	}

	var r0 *ecr.PutImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageInput, ...func(*ecr.Options)) (*ecr.PutImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageInput, ...func(*ecr.Options)) *ecr.PutImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutImageInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutImageScanningConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutImageScanningConfiguration(ctx context.Context, params *ecr.PutImageScanningConfigurationInput, optFns ...func(*ecr.Options)) (*ecr.PutImageScanningConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutImageScanningConfiguration")
	}

	var r0 *ecr.PutImageScanningConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageScanningConfigurationInput, ...func(*ecr.Options)) (*ecr.PutImageScanningConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageScanningConfigurationInput, ...func(*ecr.Options)) *ecr.PutImageScanningConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutImageScanningConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutImageScanningConfigurationInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutImageTagMutability provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutImageTagMutability(ctx context.Context, params *ecr.PutImageTagMutabilityInput, optFns ...func(*ecr.Options)) (*ecr.PutImageTagMutabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutImageTagMutability")
	}

	var r0 *ecr.PutImageTagMutabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageTagMutabilityInput, ...func(*ecr.Options)) (*ecr.PutImageTagMutabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutImageTagMutabilityInput, ...func(*ecr.Options)) *ecr.PutImageTagMutabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutImageTagMutabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutImageTagMutabilityInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutLifecyclePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLifecyclePolicy(ctx context.Context, params *ecr.PutLifecyclePolicyInput, optFns ...func(*ecr.Options)) (*ecr.PutLifecyclePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLifecyclePolicy")
	}

	var r0 *ecr.PutLifecyclePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutLifecyclePolicyInput, ...func(*ecr.Options)) (*ecr.PutLifecyclePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutLifecyclePolicyInput, ...func(*ecr.Options)) *ecr.PutLifecyclePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutLifecyclePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutLifecyclePolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRegistryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRegistryPolicy(ctx context.Context, params *ecr.PutRegistryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.PutRegistryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRegistryPolicy")
	}

	var r0 *ecr.PutRegistryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutRegistryPolicyInput, ...func(*ecr.Options)) (*ecr.PutRegistryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutRegistryPolicyInput, ...func(*ecr.Options)) *ecr.PutRegistryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutRegistryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutRegistryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRegistryScanningConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRegistryScanningConfiguration(ctx context.Context, params *ecr.PutRegistryScanningConfigurationInput, optFns ...func(*ecr.Options)) (*ecr.PutRegistryScanningConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRegistryScanningConfiguration")
	}

	var r0 *ecr.PutRegistryScanningConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutRegistryScanningConfigurationInput, ...func(*ecr.Options)) (*ecr.PutRegistryScanningConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutRegistryScanningConfigurationInput, ...func(*ecr.Options)) *ecr.PutRegistryScanningConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutRegistryScanningConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutRegistryScanningConfigurationInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutReplicationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutReplicationConfiguration(ctx context.Context, params *ecr.PutReplicationConfigurationInput, optFns ...func(*ecr.Options)) (*ecr.PutReplicationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutReplicationConfiguration")
	}

	var r0 *ecr.PutReplicationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutReplicationConfigurationInput, ...func(*ecr.Options)) (*ecr.PutReplicationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.PutReplicationConfigurationInput, ...func(*ecr.Options)) *ecr.PutReplicationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.PutReplicationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.PutReplicationConfigurationInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRepositoryPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetRepositoryPolicy(ctx context.Context, params *ecr.SetRepositoryPolicyInput, optFns ...func(*ecr.Options)) (*ecr.SetRepositoryPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRepositoryPolicy")
	}

	var r0 *ecr.SetRepositoryPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.SetRepositoryPolicyInput, ...func(*ecr.Options)) (*ecr.SetRepositoryPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.SetRepositoryPolicyInput, ...func(*ecr.Options)) *ecr.SetRepositoryPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.SetRepositoryPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.SetRepositoryPolicyInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImageScan provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImageScan(ctx context.Context, params *ecr.StartImageScanInput, optFns ...func(*ecr.Options)) (*ecr.StartImageScanOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImageScan")
	}

	var r0 *ecr.StartImageScanOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.StartImageScanInput, ...func(*ecr.Options)) (*ecr.StartImageScanOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.StartImageScanInput, ...func(*ecr.Options)) *ecr.StartImageScanOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.StartImageScanOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.StartImageScanInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartLifecyclePolicyPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartLifecyclePolicyPreview(ctx context.Context, params *ecr.StartLifecyclePolicyPreviewInput, optFns ...func(*ecr.Options)) (*ecr.StartLifecyclePolicyPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartLifecyclePolicyPreview")
	}

	var r0 *ecr.StartLifecyclePolicyPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.StartLifecyclePolicyPreviewInput, ...func(*ecr.Options)) (*ecr.StartLifecyclePolicyPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.StartLifecyclePolicyPreviewInput, ...func(*ecr.Options)) *ecr.StartLifecyclePolicyPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.StartLifecyclePolicyPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.StartLifecyclePolicyPreviewInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *ecr.TagResourceInput, optFns ...func(*ecr.Options)) (*ecr.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *ecr.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.TagResourceInput, ...func(*ecr.Options)) (*ecr.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.TagResourceInput, ...func(*ecr.Options)) *ecr.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.TagResourceInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *ecr.UntagResourceInput, optFns ...func(*ecr.Options)) (*ecr.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *ecr.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UntagResourceInput, ...func(*ecr.Options)) (*ecr.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UntagResourceInput, ...func(*ecr.Options)) *ecr.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.UntagResourceInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullThroughCacheRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullThroughCacheRule(ctx context.Context, params *ecr.UpdatePullThroughCacheRuleInput, optFns ...func(*ecr.Options)) (*ecr.UpdatePullThroughCacheRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullThroughCacheRule")
	}

	var r0 *ecr.UpdatePullThroughCacheRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UpdatePullThroughCacheRuleInput, ...func(*ecr.Options)) (*ecr.UpdatePullThroughCacheRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UpdatePullThroughCacheRuleInput, ...func(*ecr.Options)) *ecr.UpdatePullThroughCacheRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.UpdatePullThroughCacheRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.UpdatePullThroughCacheRuleInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadLayerPart provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UploadLayerPart(ctx context.Context, params *ecr.UploadLayerPartInput, optFns ...func(*ecr.Options)) (*ecr.UploadLayerPartOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadLayerPart")
	}

	var r0 *ecr.UploadLayerPartOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UploadLayerPartInput, ...func(*ecr.Options)) (*ecr.UploadLayerPartOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.UploadLayerPartInput, ...func(*ecr.Options)) *ecr.UploadLayerPartOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.UploadLayerPartOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.UploadLayerPartInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePullThroughCacheRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidatePullThroughCacheRule(ctx context.Context, params *ecr.ValidatePullThroughCacheRuleInput, optFns ...func(*ecr.Options)) (*ecr.ValidatePullThroughCacheRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePullThroughCacheRule")
	}

	var r0 *ecr.ValidatePullThroughCacheRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ValidatePullThroughCacheRuleInput, ...func(*ecr.Options)) (*ecr.ValidatePullThroughCacheRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecr.ValidatePullThroughCacheRuleInput, ...func(*ecr.Options)) *ecr.ValidatePullThroughCacheRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecr.ValidatePullThroughCacheRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecr.ValidatePullThroughCacheRuleInput, ...func(*ecr.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
