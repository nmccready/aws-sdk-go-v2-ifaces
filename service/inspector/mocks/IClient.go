// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	inspector "github.com/aws/aws-sdk-go-v2/service/inspector"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddAttributesToFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddAttributesToFindings(ctx context.Context, params *inspector.AddAttributesToFindingsInput, optFns ...func(*inspector.Options)) (*inspector.AddAttributesToFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddAttributesToFindings")
	}

	var r0 *inspector.AddAttributesToFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.AddAttributesToFindingsInput, ...func(*inspector.Options)) (*inspector.AddAttributesToFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.AddAttributesToFindingsInput, ...func(*inspector.Options)) *inspector.AddAttributesToFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.AddAttributesToFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.AddAttributesToFindingsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssessmentTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssessmentTarget(ctx context.Context, params *inspector.CreateAssessmentTargetInput, optFns ...func(*inspector.Options)) (*inspector.CreateAssessmentTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssessmentTarget")
	}

	var r0 *inspector.CreateAssessmentTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateAssessmentTargetInput, ...func(*inspector.Options)) (*inspector.CreateAssessmentTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateAssessmentTargetInput, ...func(*inspector.Options)) *inspector.CreateAssessmentTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.CreateAssessmentTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.CreateAssessmentTargetInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssessmentTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssessmentTemplate(ctx context.Context, params *inspector.CreateAssessmentTemplateInput, optFns ...func(*inspector.Options)) (*inspector.CreateAssessmentTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssessmentTemplate")
	}

	var r0 *inspector.CreateAssessmentTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateAssessmentTemplateInput, ...func(*inspector.Options)) (*inspector.CreateAssessmentTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateAssessmentTemplateInput, ...func(*inspector.Options)) *inspector.CreateAssessmentTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.CreateAssessmentTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.CreateAssessmentTemplateInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateExclusionsPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateExclusionsPreview(ctx context.Context, params *inspector.CreateExclusionsPreviewInput, optFns ...func(*inspector.Options)) (*inspector.CreateExclusionsPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExclusionsPreview")
	}

	var r0 *inspector.CreateExclusionsPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateExclusionsPreviewInput, ...func(*inspector.Options)) (*inspector.CreateExclusionsPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateExclusionsPreviewInput, ...func(*inspector.Options)) *inspector.CreateExclusionsPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.CreateExclusionsPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.CreateExclusionsPreviewInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResourceGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResourceGroup(ctx context.Context, params *inspector.CreateResourceGroupInput, optFns ...func(*inspector.Options)) (*inspector.CreateResourceGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResourceGroup")
	}

	var r0 *inspector.CreateResourceGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateResourceGroupInput, ...func(*inspector.Options)) (*inspector.CreateResourceGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.CreateResourceGroupInput, ...func(*inspector.Options)) *inspector.CreateResourceGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.CreateResourceGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.CreateResourceGroupInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentRun(ctx context.Context, params *inspector.DeleteAssessmentRunInput, optFns ...func(*inspector.Options)) (*inspector.DeleteAssessmentRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentRun")
	}

	var r0 *inspector.DeleteAssessmentRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentRunInput, ...func(*inspector.Options)) (*inspector.DeleteAssessmentRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentRunInput, ...func(*inspector.Options)) *inspector.DeleteAssessmentRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DeleteAssessmentRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DeleteAssessmentRunInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentTarget(ctx context.Context, params *inspector.DeleteAssessmentTargetInput, optFns ...func(*inspector.Options)) (*inspector.DeleteAssessmentTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentTarget")
	}

	var r0 *inspector.DeleteAssessmentTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentTargetInput, ...func(*inspector.Options)) (*inspector.DeleteAssessmentTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentTargetInput, ...func(*inspector.Options)) *inspector.DeleteAssessmentTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DeleteAssessmentTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DeleteAssessmentTargetInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentTemplate(ctx context.Context, params *inspector.DeleteAssessmentTemplateInput, optFns ...func(*inspector.Options)) (*inspector.DeleteAssessmentTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentTemplate")
	}

	var r0 *inspector.DeleteAssessmentTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentTemplateInput, ...func(*inspector.Options)) (*inspector.DeleteAssessmentTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DeleteAssessmentTemplateInput, ...func(*inspector.Options)) *inspector.DeleteAssessmentTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DeleteAssessmentTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DeleteAssessmentTemplateInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAssessmentRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAssessmentRuns(ctx context.Context, params *inspector.DescribeAssessmentRunsInput, optFns ...func(*inspector.Options)) (*inspector.DescribeAssessmentRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAssessmentRuns")
	}

	var r0 *inspector.DescribeAssessmentRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentRunsInput, ...func(*inspector.Options)) (*inspector.DescribeAssessmentRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentRunsInput, ...func(*inspector.Options)) *inspector.DescribeAssessmentRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeAssessmentRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeAssessmentRunsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAssessmentTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAssessmentTargets(ctx context.Context, params *inspector.DescribeAssessmentTargetsInput, optFns ...func(*inspector.Options)) (*inspector.DescribeAssessmentTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAssessmentTargets")
	}

	var r0 *inspector.DescribeAssessmentTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentTargetsInput, ...func(*inspector.Options)) (*inspector.DescribeAssessmentTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentTargetsInput, ...func(*inspector.Options)) *inspector.DescribeAssessmentTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeAssessmentTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeAssessmentTargetsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAssessmentTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAssessmentTemplates(ctx context.Context, params *inspector.DescribeAssessmentTemplatesInput, optFns ...func(*inspector.Options)) (*inspector.DescribeAssessmentTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAssessmentTemplates")
	}

	var r0 *inspector.DescribeAssessmentTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentTemplatesInput, ...func(*inspector.Options)) (*inspector.DescribeAssessmentTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeAssessmentTemplatesInput, ...func(*inspector.Options)) *inspector.DescribeAssessmentTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeAssessmentTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeAssessmentTemplatesInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCrossAccountAccessRole provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCrossAccountAccessRole(ctx context.Context, params *inspector.DescribeCrossAccountAccessRoleInput, optFns ...func(*inspector.Options)) (*inspector.DescribeCrossAccountAccessRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCrossAccountAccessRole")
	}

	var r0 *inspector.DescribeCrossAccountAccessRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeCrossAccountAccessRoleInput, ...func(*inspector.Options)) (*inspector.DescribeCrossAccountAccessRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeCrossAccountAccessRoleInput, ...func(*inspector.Options)) *inspector.DescribeCrossAccountAccessRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeCrossAccountAccessRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeCrossAccountAccessRoleInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExclusions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExclusions(ctx context.Context, params *inspector.DescribeExclusionsInput, optFns ...func(*inspector.Options)) (*inspector.DescribeExclusionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExclusions")
	}

	var r0 *inspector.DescribeExclusionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeExclusionsInput, ...func(*inspector.Options)) (*inspector.DescribeExclusionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeExclusionsInput, ...func(*inspector.Options)) *inspector.DescribeExclusionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeExclusionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeExclusionsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFindings(ctx context.Context, params *inspector.DescribeFindingsInput, optFns ...func(*inspector.Options)) (*inspector.DescribeFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFindings")
	}

	var r0 *inspector.DescribeFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeFindingsInput, ...func(*inspector.Options)) (*inspector.DescribeFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeFindingsInput, ...func(*inspector.Options)) *inspector.DescribeFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeFindingsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResourceGroups(ctx context.Context, params *inspector.DescribeResourceGroupsInput, optFns ...func(*inspector.Options)) (*inspector.DescribeResourceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourceGroups")
	}

	var r0 *inspector.DescribeResourceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeResourceGroupsInput, ...func(*inspector.Options)) (*inspector.DescribeResourceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeResourceGroupsInput, ...func(*inspector.Options)) *inspector.DescribeResourceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeResourceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeResourceGroupsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRulesPackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRulesPackages(ctx context.Context, params *inspector.DescribeRulesPackagesInput, optFns ...func(*inspector.Options)) (*inspector.DescribeRulesPackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRulesPackages")
	}

	var r0 *inspector.DescribeRulesPackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeRulesPackagesInput, ...func(*inspector.Options)) (*inspector.DescribeRulesPackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.DescribeRulesPackagesInput, ...func(*inspector.Options)) *inspector.DescribeRulesPackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.DescribeRulesPackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.DescribeRulesPackagesInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssessmentReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssessmentReport(ctx context.Context, params *inspector.GetAssessmentReportInput, optFns ...func(*inspector.Options)) (*inspector.GetAssessmentReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssessmentReport")
	}

	var r0 *inspector.GetAssessmentReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetAssessmentReportInput, ...func(*inspector.Options)) (*inspector.GetAssessmentReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetAssessmentReportInput, ...func(*inspector.Options)) *inspector.GetAssessmentReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.GetAssessmentReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.GetAssessmentReportInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExclusionsPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetExclusionsPreview(ctx context.Context, params *inspector.GetExclusionsPreviewInput, optFns ...func(*inspector.Options)) (*inspector.GetExclusionsPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExclusionsPreview")
	}

	var r0 *inspector.GetExclusionsPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetExclusionsPreviewInput, ...func(*inspector.Options)) (*inspector.GetExclusionsPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetExclusionsPreviewInput, ...func(*inspector.Options)) *inspector.GetExclusionsPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.GetExclusionsPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.GetExclusionsPreviewInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTelemetryMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTelemetryMetadata(ctx context.Context, params *inspector.GetTelemetryMetadataInput, optFns ...func(*inspector.Options)) (*inspector.GetTelemetryMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTelemetryMetadata")
	}

	var r0 *inspector.GetTelemetryMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetTelemetryMetadataInput, ...func(*inspector.Options)) (*inspector.GetTelemetryMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.GetTelemetryMetadataInput, ...func(*inspector.Options)) *inspector.GetTelemetryMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.GetTelemetryMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.GetTelemetryMetadataInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentRunAgents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentRunAgents(ctx context.Context, params *inspector.ListAssessmentRunAgentsInput, optFns ...func(*inspector.Options)) (*inspector.ListAssessmentRunAgentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentRunAgents")
	}

	var r0 *inspector.ListAssessmentRunAgentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentRunAgentsInput, ...func(*inspector.Options)) (*inspector.ListAssessmentRunAgentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentRunAgentsInput, ...func(*inspector.Options)) *inspector.ListAssessmentRunAgentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListAssessmentRunAgentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListAssessmentRunAgentsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentRuns(ctx context.Context, params *inspector.ListAssessmentRunsInput, optFns ...func(*inspector.Options)) (*inspector.ListAssessmentRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentRuns")
	}

	var r0 *inspector.ListAssessmentRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentRunsInput, ...func(*inspector.Options)) (*inspector.ListAssessmentRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentRunsInput, ...func(*inspector.Options)) *inspector.ListAssessmentRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListAssessmentRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListAssessmentRunsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentTargets(ctx context.Context, params *inspector.ListAssessmentTargetsInput, optFns ...func(*inspector.Options)) (*inspector.ListAssessmentTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentTargets")
	}

	var r0 *inspector.ListAssessmentTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentTargetsInput, ...func(*inspector.Options)) (*inspector.ListAssessmentTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentTargetsInput, ...func(*inspector.Options)) *inspector.ListAssessmentTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListAssessmentTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListAssessmentTargetsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentTemplates(ctx context.Context, params *inspector.ListAssessmentTemplatesInput, optFns ...func(*inspector.Options)) (*inspector.ListAssessmentTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentTemplates")
	}

	var r0 *inspector.ListAssessmentTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentTemplatesInput, ...func(*inspector.Options)) (*inspector.ListAssessmentTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListAssessmentTemplatesInput, ...func(*inspector.Options)) *inspector.ListAssessmentTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListAssessmentTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListAssessmentTemplatesInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventSubscriptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventSubscriptions(ctx context.Context, params *inspector.ListEventSubscriptionsInput, optFns ...func(*inspector.Options)) (*inspector.ListEventSubscriptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventSubscriptions")
	}

	var r0 *inspector.ListEventSubscriptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListEventSubscriptionsInput, ...func(*inspector.Options)) (*inspector.ListEventSubscriptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListEventSubscriptionsInput, ...func(*inspector.Options)) *inspector.ListEventSubscriptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListEventSubscriptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListEventSubscriptionsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExclusions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExclusions(ctx context.Context, params *inspector.ListExclusionsInput, optFns ...func(*inspector.Options)) (*inspector.ListExclusionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExclusions")
	}

	var r0 *inspector.ListExclusionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListExclusionsInput, ...func(*inspector.Options)) (*inspector.ListExclusionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListExclusionsInput, ...func(*inspector.Options)) *inspector.ListExclusionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListExclusionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListExclusionsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFindings(ctx context.Context, params *inspector.ListFindingsInput, optFns ...func(*inspector.Options)) (*inspector.ListFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFindings")
	}

	var r0 *inspector.ListFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListFindingsInput, ...func(*inspector.Options)) (*inspector.ListFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListFindingsInput, ...func(*inspector.Options)) *inspector.ListFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListFindingsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRulesPackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRulesPackages(ctx context.Context, params *inspector.ListRulesPackagesInput, optFns ...func(*inspector.Options)) (*inspector.ListRulesPackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesPackages")
	}

	var r0 *inspector.ListRulesPackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListRulesPackagesInput, ...func(*inspector.Options)) (*inspector.ListRulesPackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListRulesPackagesInput, ...func(*inspector.Options)) *inspector.ListRulesPackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListRulesPackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListRulesPackagesInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *inspector.ListTagsForResourceInput, optFns ...func(*inspector.Options)) (*inspector.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *inspector.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListTagsForResourceInput, ...func(*inspector.Options)) (*inspector.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.ListTagsForResourceInput, ...func(*inspector.Options)) *inspector.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.ListTagsForResourceInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() inspector.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 inspector.Options
	if rf, ok := ret.Get(0).(func() inspector.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(inspector.Options)
	}

	return r0
}

// PreviewAgents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PreviewAgents(ctx context.Context, params *inspector.PreviewAgentsInput, optFns ...func(*inspector.Options)) (*inspector.PreviewAgentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PreviewAgents")
	}

	var r0 *inspector.PreviewAgentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.PreviewAgentsInput, ...func(*inspector.Options)) (*inspector.PreviewAgentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.PreviewAgentsInput, ...func(*inspector.Options)) *inspector.PreviewAgentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.PreviewAgentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.PreviewAgentsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterCrossAccountAccessRole provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterCrossAccountAccessRole(ctx context.Context, params *inspector.RegisterCrossAccountAccessRoleInput, optFns ...func(*inspector.Options)) (*inspector.RegisterCrossAccountAccessRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterCrossAccountAccessRole")
	}

	var r0 *inspector.RegisterCrossAccountAccessRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.RegisterCrossAccountAccessRoleInput, ...func(*inspector.Options)) (*inspector.RegisterCrossAccountAccessRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.RegisterCrossAccountAccessRoleInput, ...func(*inspector.Options)) *inspector.RegisterCrossAccountAccessRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.RegisterCrossAccountAccessRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.RegisterCrossAccountAccessRoleInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveAttributesFromFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveAttributesFromFindings(ctx context.Context, params *inspector.RemoveAttributesFromFindingsInput, optFns ...func(*inspector.Options)) (*inspector.RemoveAttributesFromFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAttributesFromFindings")
	}

	var r0 *inspector.RemoveAttributesFromFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.RemoveAttributesFromFindingsInput, ...func(*inspector.Options)) (*inspector.RemoveAttributesFromFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.RemoveAttributesFromFindingsInput, ...func(*inspector.Options)) *inspector.RemoveAttributesFromFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.RemoveAttributesFromFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.RemoveAttributesFromFindingsInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetTagsForResource(ctx context.Context, params *inspector.SetTagsForResourceInput, optFns ...func(*inspector.Options)) (*inspector.SetTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTagsForResource")
	}

	var r0 *inspector.SetTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.SetTagsForResourceInput, ...func(*inspector.Options)) (*inspector.SetTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.SetTagsForResourceInput, ...func(*inspector.Options)) *inspector.SetTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.SetTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.SetTagsForResourceInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartAssessmentRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartAssessmentRun(ctx context.Context, params *inspector.StartAssessmentRunInput, optFns ...func(*inspector.Options)) (*inspector.StartAssessmentRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartAssessmentRun")
	}

	var r0 *inspector.StartAssessmentRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.StartAssessmentRunInput, ...func(*inspector.Options)) (*inspector.StartAssessmentRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.StartAssessmentRunInput, ...func(*inspector.Options)) *inspector.StartAssessmentRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.StartAssessmentRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.StartAssessmentRunInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopAssessmentRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopAssessmentRun(ctx context.Context, params *inspector.StopAssessmentRunInput, optFns ...func(*inspector.Options)) (*inspector.StopAssessmentRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopAssessmentRun")
	}

	var r0 *inspector.StopAssessmentRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.StopAssessmentRunInput, ...func(*inspector.Options)) (*inspector.StopAssessmentRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.StopAssessmentRunInput, ...func(*inspector.Options)) *inspector.StopAssessmentRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.StopAssessmentRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.StopAssessmentRunInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeToEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SubscribeToEvent(ctx context.Context, params *inspector.SubscribeToEventInput, optFns ...func(*inspector.Options)) (*inspector.SubscribeToEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToEvent")
	}

	var r0 *inspector.SubscribeToEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.SubscribeToEventInput, ...func(*inspector.Options)) (*inspector.SubscribeToEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.SubscribeToEventInput, ...func(*inspector.Options)) *inspector.SubscribeToEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.SubscribeToEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.SubscribeToEventInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnsubscribeFromEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UnsubscribeFromEvent(ctx context.Context, params *inspector.UnsubscribeFromEventInput, optFns ...func(*inspector.Options)) (*inspector.UnsubscribeFromEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromEvent")
	}

	var r0 *inspector.UnsubscribeFromEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.UnsubscribeFromEventInput, ...func(*inspector.Options)) (*inspector.UnsubscribeFromEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.UnsubscribeFromEventInput, ...func(*inspector.Options)) *inspector.UnsubscribeFromEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.UnsubscribeFromEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.UnsubscribeFromEventInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentTarget(ctx context.Context, params *inspector.UpdateAssessmentTargetInput, optFns ...func(*inspector.Options)) (*inspector.UpdateAssessmentTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentTarget")
	}

	var r0 *inspector.UpdateAssessmentTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.UpdateAssessmentTargetInput, ...func(*inspector.Options)) (*inspector.UpdateAssessmentTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *inspector.UpdateAssessmentTargetInput, ...func(*inspector.Options)) *inspector.UpdateAssessmentTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inspector.UpdateAssessmentTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *inspector.UpdateAssessmentTargetInput, ...func(*inspector.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
