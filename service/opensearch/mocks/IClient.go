// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	opensearch "github.com/aws/aws-sdk-go-v2/service/opensearch"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptInboundConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptInboundConnection(ctx context.Context, params *opensearch.AcceptInboundConnectionInput, optFns ...func(*opensearch.Options)) (*opensearch.AcceptInboundConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptInboundConnection")
	}

	var r0 *opensearch.AcceptInboundConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AcceptInboundConnectionInput, ...func(*opensearch.Options)) (*opensearch.AcceptInboundConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AcceptInboundConnectionInput, ...func(*opensearch.Options)) *opensearch.AcceptInboundConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AcceptInboundConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AcceptInboundConnectionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddDataSource(ctx context.Context, params *opensearch.AddDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.AddDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddDataSource")
	}

	var r0 *opensearch.AddDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddDataSourceInput, ...func(*opensearch.Options)) (*opensearch.AddDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddDataSourceInput, ...func(*opensearch.Options)) *opensearch.AddDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AddDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AddDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddDirectQueryDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddDirectQueryDataSource(ctx context.Context, params *opensearch.AddDirectQueryDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.AddDirectQueryDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddDirectQueryDataSource")
	}

	var r0 *opensearch.AddDirectQueryDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddDirectQueryDataSourceInput, ...func(*opensearch.Options)) (*opensearch.AddDirectQueryDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddDirectQueryDataSourceInput, ...func(*opensearch.Options)) *opensearch.AddDirectQueryDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AddDirectQueryDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AddDirectQueryDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *opensearch.AddTagsInput, optFns ...func(*opensearch.Options)) (*opensearch.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *opensearch.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddTagsInput, ...func(*opensearch.Options)) (*opensearch.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AddTagsInput, ...func(*opensearch.Options)) *opensearch.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AddTagsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociatePackage(ctx context.Context, params *opensearch.AssociatePackageInput, optFns ...func(*opensearch.Options)) (*opensearch.AssociatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociatePackage")
	}

	var r0 *opensearch.AssociatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AssociatePackageInput, ...func(*opensearch.Options)) (*opensearch.AssociatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AssociatePackageInput, ...func(*opensearch.Options)) *opensearch.AssociatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AssociatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AssociatePackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociatePackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociatePackages(ctx context.Context, params *opensearch.AssociatePackagesInput, optFns ...func(*opensearch.Options)) (*opensearch.AssociatePackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociatePackages")
	}

	var r0 *opensearch.AssociatePackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AssociatePackagesInput, ...func(*opensearch.Options)) (*opensearch.AssociatePackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AssociatePackagesInput, ...func(*opensearch.Options)) *opensearch.AssociatePackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AssociatePackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AssociatePackagesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeVpcEndpointAccess(ctx context.Context, params *opensearch.AuthorizeVpcEndpointAccessInput, optFns ...func(*opensearch.Options)) (*opensearch.AuthorizeVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeVpcEndpointAccess")
	}

	var r0 *opensearch.AuthorizeVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AuthorizeVpcEndpointAccessInput, ...func(*opensearch.Options)) (*opensearch.AuthorizeVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.AuthorizeVpcEndpointAccessInput, ...func(*opensearch.Options)) *opensearch.AuthorizeVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.AuthorizeVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.AuthorizeVpcEndpointAccessInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDomainConfigChange provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDomainConfigChange(ctx context.Context, params *opensearch.CancelDomainConfigChangeInput, optFns ...func(*opensearch.Options)) (*opensearch.CancelDomainConfigChangeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDomainConfigChange")
	}

	var r0 *opensearch.CancelDomainConfigChangeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CancelDomainConfigChangeInput, ...func(*opensearch.Options)) (*opensearch.CancelDomainConfigChangeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CancelDomainConfigChangeInput, ...func(*opensearch.Options)) *opensearch.CancelDomainConfigChangeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CancelDomainConfigChangeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CancelDomainConfigChangeInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelServiceSoftwareUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelServiceSoftwareUpdate(ctx context.Context, params *opensearch.CancelServiceSoftwareUpdateInput, optFns ...func(*opensearch.Options)) (*opensearch.CancelServiceSoftwareUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelServiceSoftwareUpdate")
	}

	var r0 *opensearch.CancelServiceSoftwareUpdateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CancelServiceSoftwareUpdateInput, ...func(*opensearch.Options)) (*opensearch.CancelServiceSoftwareUpdateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CancelServiceSoftwareUpdateInput, ...func(*opensearch.Options)) *opensearch.CancelServiceSoftwareUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CancelServiceSoftwareUpdateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CancelServiceSoftwareUpdateInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApplication(ctx context.Context, params *opensearch.CreateApplicationInput, optFns ...func(*opensearch.Options)) (*opensearch.CreateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApplication")
	}

	var r0 *opensearch.CreateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateApplicationInput, ...func(*opensearch.Options)) (*opensearch.CreateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateApplicationInput, ...func(*opensearch.Options)) *opensearch.CreateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CreateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CreateApplicationInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDomain(ctx context.Context, params *opensearch.CreateDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.CreateDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDomain")
	}

	var r0 *opensearch.CreateDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateDomainInput, ...func(*opensearch.Options)) (*opensearch.CreateDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateDomainInput, ...func(*opensearch.Options)) *opensearch.CreateDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CreateDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CreateDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOutboundConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateOutboundConnection(ctx context.Context, params *opensearch.CreateOutboundConnectionInput, optFns ...func(*opensearch.Options)) (*opensearch.CreateOutboundConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateOutboundConnection")
	}

	var r0 *opensearch.CreateOutboundConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateOutboundConnectionInput, ...func(*opensearch.Options)) (*opensearch.CreateOutboundConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateOutboundConnectionInput, ...func(*opensearch.Options)) *opensearch.CreateOutboundConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CreateOutboundConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CreateOutboundConnectionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePackage(ctx context.Context, params *opensearch.CreatePackageInput, optFns ...func(*opensearch.Options)) (*opensearch.CreatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackage")
	}

	var r0 *opensearch.CreatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreatePackageInput, ...func(*opensearch.Options)) (*opensearch.CreatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreatePackageInput, ...func(*opensearch.Options)) *opensearch.CreatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CreatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CreatePackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpoint(ctx context.Context, params *opensearch.CreateVpcEndpointInput, optFns ...func(*opensearch.Options)) (*opensearch.CreateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpoint")
	}

	var r0 *opensearch.CreateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateVpcEndpointInput, ...func(*opensearch.Options)) (*opensearch.CreateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.CreateVpcEndpointInput, ...func(*opensearch.Options)) *opensearch.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.CreateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.CreateVpcEndpointInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplication(ctx context.Context, params *opensearch.DeleteApplicationInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplication")
	}

	var r0 *opensearch.DeleteApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteApplicationInput, ...func(*opensearch.Options)) (*opensearch.DeleteApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteApplicationInput, ...func(*opensearch.Options)) *opensearch.DeleteApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteApplicationInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataSource(ctx context.Context, params *opensearch.DeleteDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataSource")
	}

	var r0 *opensearch.DeleteDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDataSourceInput, ...func(*opensearch.Options)) (*opensearch.DeleteDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDataSourceInput, ...func(*opensearch.Options)) *opensearch.DeleteDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDirectQueryDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDirectQueryDataSource(ctx context.Context, params *opensearch.DeleteDirectQueryDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteDirectQueryDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDirectQueryDataSource")
	}

	var r0 *opensearch.DeleteDirectQueryDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDirectQueryDataSourceInput, ...func(*opensearch.Options)) (*opensearch.DeleteDirectQueryDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDirectQueryDataSourceInput, ...func(*opensearch.Options)) *opensearch.DeleteDirectQueryDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteDirectQueryDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteDirectQueryDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDomain(ctx context.Context, params *opensearch.DeleteDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomain")
	}

	var r0 *opensearch.DeleteDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDomainInput, ...func(*opensearch.Options)) (*opensearch.DeleteDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteDomainInput, ...func(*opensearch.Options)) *opensearch.DeleteDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInboundConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInboundConnection(ctx context.Context, params *opensearch.DeleteInboundConnectionInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteInboundConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInboundConnection")
	}

	var r0 *opensearch.DeleteInboundConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteInboundConnectionInput, ...func(*opensearch.Options)) (*opensearch.DeleteInboundConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteInboundConnectionInput, ...func(*opensearch.Options)) *opensearch.DeleteInboundConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteInboundConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteInboundConnectionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteOutboundConnection(ctx context.Context, params *opensearch.DeleteOutboundConnectionInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteOutboundConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundConnection")
	}

	var r0 *opensearch.DeleteOutboundConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteOutboundConnectionInput, ...func(*opensearch.Options)) (*opensearch.DeleteOutboundConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteOutboundConnectionInput, ...func(*opensearch.Options)) *opensearch.DeleteOutboundConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteOutboundConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteOutboundConnectionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePackage(ctx context.Context, params *opensearch.DeletePackageInput, optFns ...func(*opensearch.Options)) (*opensearch.DeletePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 *opensearch.DeletePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeletePackageInput, ...func(*opensearch.Options)) (*opensearch.DeletePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeletePackageInput, ...func(*opensearch.Options)) *opensearch.DeletePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeletePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeletePackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpoint(ctx context.Context, params *opensearch.DeleteVpcEndpointInput, optFns ...func(*opensearch.Options)) (*opensearch.DeleteVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpoint")
	}

	var r0 *opensearch.DeleteVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteVpcEndpointInput, ...func(*opensearch.Options)) (*opensearch.DeleteVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DeleteVpcEndpointInput, ...func(*opensearch.Options)) *opensearch.DeleteVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DeleteVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DeleteVpcEndpointInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomain(ctx context.Context, params *opensearch.DescribeDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomain")
	}

	var r0 *opensearch.DescribeDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainAutoTunes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainAutoTunes(ctx context.Context, params *opensearch.DescribeDomainAutoTunesInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainAutoTunesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainAutoTunes")
	}

	var r0 *opensearch.DescribeDomainAutoTunesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainAutoTunesInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainAutoTunesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainAutoTunesInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainAutoTunesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainAutoTunesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainAutoTunesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainChangeProgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainChangeProgress(ctx context.Context, params *opensearch.DescribeDomainChangeProgressInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainChangeProgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainChangeProgress")
	}

	var r0 *opensearch.DescribeDomainChangeProgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainChangeProgressInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainChangeProgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainChangeProgressInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainChangeProgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainChangeProgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainChangeProgressInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainConfig(ctx context.Context, params *opensearch.DescribeDomainConfigInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainConfig")
	}

	var r0 *opensearch.DescribeDomainConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainConfigInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainConfigInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainConfigInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainHealth provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainHealth(ctx context.Context, params *opensearch.DescribeDomainHealthInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainHealth")
	}

	var r0 *opensearch.DescribeDomainHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainHealthInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainHealthInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainHealthInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomainNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomainNodes(ctx context.Context, params *opensearch.DescribeDomainNodesInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomainNodes")
	}

	var r0 *opensearch.DescribeDomainNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainNodesInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainNodesInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainNodesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomains(ctx context.Context, params *opensearch.DescribeDomainsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomains")
	}

	var r0 *opensearch.DescribeDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainsInput, ...func(*opensearch.Options)) (*opensearch.DescribeDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDomainsInput, ...func(*opensearch.Options)) *opensearch.DescribeDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDomainsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDryRunProgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDryRunProgress(ctx context.Context, params *opensearch.DescribeDryRunProgressInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeDryRunProgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDryRunProgress")
	}

	var r0 *opensearch.DescribeDryRunProgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDryRunProgressInput, ...func(*opensearch.Options)) (*opensearch.DescribeDryRunProgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeDryRunProgressInput, ...func(*opensearch.Options)) *opensearch.DescribeDryRunProgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeDryRunProgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeDryRunProgressInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInboundConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInboundConnections(ctx context.Context, params *opensearch.DescribeInboundConnectionsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeInboundConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInboundConnections")
	}

	var r0 *opensearch.DescribeInboundConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeInboundConnectionsInput, ...func(*opensearch.Options)) (*opensearch.DescribeInboundConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeInboundConnectionsInput, ...func(*opensearch.Options)) *opensearch.DescribeInboundConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeInboundConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeInboundConnectionsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypeLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstanceTypeLimits(ctx context.Context, params *opensearch.DescribeInstanceTypeLimitsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeInstanceTypeLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypeLimits")
	}

	var r0 *opensearch.DescribeInstanceTypeLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeInstanceTypeLimitsInput, ...func(*opensearch.Options)) (*opensearch.DescribeInstanceTypeLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeInstanceTypeLimitsInput, ...func(*opensearch.Options)) *opensearch.DescribeInstanceTypeLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeInstanceTypeLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeInstanceTypeLimitsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutboundConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeOutboundConnections(ctx context.Context, params *opensearch.DescribeOutboundConnectionsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeOutboundConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOutboundConnections")
	}

	var r0 *opensearch.DescribeOutboundConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeOutboundConnectionsInput, ...func(*opensearch.Options)) (*opensearch.DescribeOutboundConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeOutboundConnectionsInput, ...func(*opensearch.Options)) *opensearch.DescribeOutboundConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeOutboundConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeOutboundConnectionsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePackages(ctx context.Context, params *opensearch.DescribePackagesInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribePackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePackages")
	}

	var r0 *opensearch.DescribePackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribePackagesInput, ...func(*opensearch.Options)) (*opensearch.DescribePackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribePackagesInput, ...func(*opensearch.Options)) *opensearch.DescribePackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribePackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribePackagesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstanceOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstanceOfferings(ctx context.Context, params *opensearch.DescribeReservedInstanceOfferingsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeReservedInstanceOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstanceOfferings")
	}

	var r0 *opensearch.DescribeReservedInstanceOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeReservedInstanceOfferingsInput, ...func(*opensearch.Options)) (*opensearch.DescribeReservedInstanceOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeReservedInstanceOfferingsInput, ...func(*opensearch.Options)) *opensearch.DescribeReservedInstanceOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeReservedInstanceOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeReservedInstanceOfferingsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedInstances(ctx context.Context, params *opensearch.DescribeReservedInstancesInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstances")
	}

	var r0 *opensearch.DescribeReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeReservedInstancesInput, ...func(*opensearch.Options)) (*opensearch.DescribeReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeReservedInstancesInput, ...func(*opensearch.Options)) *opensearch.DescribeReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeReservedInstancesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpoints(ctx context.Context, params *opensearch.DescribeVpcEndpointsInput, optFns ...func(*opensearch.Options)) (*opensearch.DescribeVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpoints")
	}

	var r0 *opensearch.DescribeVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeVpcEndpointsInput, ...func(*opensearch.Options)) (*opensearch.DescribeVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DescribeVpcEndpointsInput, ...func(*opensearch.Options)) *opensearch.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DescribeVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DescribeVpcEndpointsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DissociatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DissociatePackage(ctx context.Context, params *opensearch.DissociatePackageInput, optFns ...func(*opensearch.Options)) (*opensearch.DissociatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DissociatePackage")
	}

	var r0 *opensearch.DissociatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DissociatePackageInput, ...func(*opensearch.Options)) (*opensearch.DissociatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DissociatePackageInput, ...func(*opensearch.Options)) *opensearch.DissociatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DissociatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DissociatePackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DissociatePackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DissociatePackages(ctx context.Context, params *opensearch.DissociatePackagesInput, optFns ...func(*opensearch.Options)) (*opensearch.DissociatePackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DissociatePackages")
	}

	var r0 *opensearch.DissociatePackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DissociatePackagesInput, ...func(*opensearch.Options)) (*opensearch.DissociatePackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.DissociatePackagesInput, ...func(*opensearch.Options)) *opensearch.DissociatePackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.DissociatePackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.DissociatePackagesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetApplication(ctx context.Context, params *opensearch.GetApplicationInput, optFns ...func(*opensearch.Options)) (*opensearch.GetApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApplication")
	}

	var r0 *opensearch.GetApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetApplicationInput, ...func(*opensearch.Options)) (*opensearch.GetApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetApplicationInput, ...func(*opensearch.Options)) *opensearch.GetApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetApplicationInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompatibleVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCompatibleVersions(ctx context.Context, params *opensearch.GetCompatibleVersionsInput, optFns ...func(*opensearch.Options)) (*opensearch.GetCompatibleVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCompatibleVersions")
	}

	var r0 *opensearch.GetCompatibleVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetCompatibleVersionsInput, ...func(*opensearch.Options)) (*opensearch.GetCompatibleVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetCompatibleVersionsInput, ...func(*opensearch.Options)) *opensearch.GetCompatibleVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetCompatibleVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetCompatibleVersionsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataSource(ctx context.Context, params *opensearch.GetDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.GetDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSource")
	}

	var r0 *opensearch.GetDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDataSourceInput, ...func(*opensearch.Options)) (*opensearch.GetDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDataSourceInput, ...func(*opensearch.Options)) *opensearch.GetDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDirectQueryDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDirectQueryDataSource(ctx context.Context, params *opensearch.GetDirectQueryDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.GetDirectQueryDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDirectQueryDataSource")
	}

	var r0 *opensearch.GetDirectQueryDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDirectQueryDataSourceInput, ...func(*opensearch.Options)) (*opensearch.GetDirectQueryDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDirectQueryDataSourceInput, ...func(*opensearch.Options)) *opensearch.GetDirectQueryDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetDirectQueryDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetDirectQueryDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDomainMaintenanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDomainMaintenanceStatus(ctx context.Context, params *opensearch.GetDomainMaintenanceStatusInput, optFns ...func(*opensearch.Options)) (*opensearch.GetDomainMaintenanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDomainMaintenanceStatus")
	}

	var r0 *opensearch.GetDomainMaintenanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDomainMaintenanceStatusInput, ...func(*opensearch.Options)) (*opensearch.GetDomainMaintenanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetDomainMaintenanceStatusInput, ...func(*opensearch.Options)) *opensearch.GetDomainMaintenanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetDomainMaintenanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetDomainMaintenanceStatusInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPackageVersionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPackageVersionHistory(ctx context.Context, params *opensearch.GetPackageVersionHistoryInput, optFns ...func(*opensearch.Options)) (*opensearch.GetPackageVersionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageVersionHistory")
	}

	var r0 *opensearch.GetPackageVersionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetPackageVersionHistoryInput, ...func(*opensearch.Options)) (*opensearch.GetPackageVersionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetPackageVersionHistoryInput, ...func(*opensearch.Options)) *opensearch.GetPackageVersionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetPackageVersionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetPackageVersionHistoryInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpgradeHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUpgradeHistory(ctx context.Context, params *opensearch.GetUpgradeHistoryInput, optFns ...func(*opensearch.Options)) (*opensearch.GetUpgradeHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUpgradeHistory")
	}

	var r0 *opensearch.GetUpgradeHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetUpgradeHistoryInput, ...func(*opensearch.Options)) (*opensearch.GetUpgradeHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetUpgradeHistoryInput, ...func(*opensearch.Options)) *opensearch.GetUpgradeHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetUpgradeHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetUpgradeHistoryInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpgradeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUpgradeStatus(ctx context.Context, params *opensearch.GetUpgradeStatusInput, optFns ...func(*opensearch.Options)) (*opensearch.GetUpgradeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUpgradeStatus")
	}

	var r0 *opensearch.GetUpgradeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetUpgradeStatusInput, ...func(*opensearch.Options)) (*opensearch.GetUpgradeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.GetUpgradeStatusInput, ...func(*opensearch.Options)) *opensearch.GetUpgradeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.GetUpgradeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.GetUpgradeStatusInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplications(ctx context.Context, params *opensearch.ListApplicationsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplications")
	}

	var r0 *opensearch.ListApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListApplicationsInput, ...func(*opensearch.Options)) (*opensearch.ListApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListApplicationsInput, ...func(*opensearch.Options)) *opensearch.ListApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListApplicationsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSources(ctx context.Context, params *opensearch.ListDataSourcesInput, optFns ...func(*opensearch.Options)) (*opensearch.ListDataSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSources")
	}

	var r0 *opensearch.ListDataSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDataSourcesInput, ...func(*opensearch.Options)) (*opensearch.ListDataSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDataSourcesInput, ...func(*opensearch.Options)) *opensearch.ListDataSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListDataSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListDataSourcesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDirectQueryDataSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDirectQueryDataSources(ctx context.Context, params *opensearch.ListDirectQueryDataSourcesInput, optFns ...func(*opensearch.Options)) (*opensearch.ListDirectQueryDataSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDirectQueryDataSources")
	}

	var r0 *opensearch.ListDirectQueryDataSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDirectQueryDataSourcesInput, ...func(*opensearch.Options)) (*opensearch.ListDirectQueryDataSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDirectQueryDataSourcesInput, ...func(*opensearch.Options)) *opensearch.ListDirectQueryDataSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListDirectQueryDataSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListDirectQueryDataSourcesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomainMaintenances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomainMaintenances(ctx context.Context, params *opensearch.ListDomainMaintenancesInput, optFns ...func(*opensearch.Options)) (*opensearch.ListDomainMaintenancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomainMaintenances")
	}

	var r0 *opensearch.ListDomainMaintenancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainMaintenancesInput, ...func(*opensearch.Options)) (*opensearch.ListDomainMaintenancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainMaintenancesInput, ...func(*opensearch.Options)) *opensearch.ListDomainMaintenancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListDomainMaintenancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListDomainMaintenancesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomainNames provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomainNames(ctx context.Context, params *opensearch.ListDomainNamesInput, optFns ...func(*opensearch.Options)) (*opensearch.ListDomainNamesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomainNames")
	}

	var r0 *opensearch.ListDomainNamesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainNamesInput, ...func(*opensearch.Options)) (*opensearch.ListDomainNamesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainNamesInput, ...func(*opensearch.Options)) *opensearch.ListDomainNamesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListDomainNamesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListDomainNamesInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomainsForPackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomainsForPackage(ctx context.Context, params *opensearch.ListDomainsForPackageInput, optFns ...func(*opensearch.Options)) (*opensearch.ListDomainsForPackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomainsForPackage")
	}

	var r0 *opensearch.ListDomainsForPackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainsForPackageInput, ...func(*opensearch.Options)) (*opensearch.ListDomainsForPackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListDomainsForPackageInput, ...func(*opensearch.Options)) *opensearch.ListDomainsForPackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListDomainsForPackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListDomainsForPackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceTypeDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInstanceTypeDetails(ctx context.Context, params *opensearch.ListInstanceTypeDetailsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListInstanceTypeDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInstanceTypeDetails")
	}

	var r0 *opensearch.ListInstanceTypeDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListInstanceTypeDetailsInput, ...func(*opensearch.Options)) (*opensearch.ListInstanceTypeDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListInstanceTypeDetailsInput, ...func(*opensearch.Options)) *opensearch.ListInstanceTypeDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListInstanceTypeDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListInstanceTypeDetailsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackagesForDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackagesForDomain(ctx context.Context, params *opensearch.ListPackagesForDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.ListPackagesForDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackagesForDomain")
	}

	var r0 *opensearch.ListPackagesForDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListPackagesForDomainInput, ...func(*opensearch.Options)) (*opensearch.ListPackagesForDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListPackagesForDomainInput, ...func(*opensearch.Options)) *opensearch.ListPackagesForDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListPackagesForDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListPackagesForDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListScheduledActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListScheduledActions(ctx context.Context, params *opensearch.ListScheduledActionsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListScheduledActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListScheduledActions")
	}

	var r0 *opensearch.ListScheduledActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListScheduledActionsInput, ...func(*opensearch.Options)) (*opensearch.ListScheduledActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListScheduledActionsInput, ...func(*opensearch.Options)) *opensearch.ListScheduledActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListScheduledActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListScheduledActionsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *opensearch.ListTagsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *opensearch.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListTagsInput, ...func(*opensearch.Options)) (*opensearch.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListTagsInput, ...func(*opensearch.Options)) *opensearch.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListTagsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVersions(ctx context.Context, params *opensearch.ListVersionsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVersions")
	}

	var r0 *opensearch.ListVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVersionsInput, ...func(*opensearch.Options)) (*opensearch.ListVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVersionsInput, ...func(*opensearch.Options)) *opensearch.ListVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListVersionsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpointAccess(ctx context.Context, params *opensearch.ListVpcEndpointAccessInput, optFns ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpointAccess")
	}

	var r0 *opensearch.ListVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointAccessInput, ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointAccessInput, ...func(*opensearch.Options)) *opensearch.ListVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListVpcEndpointAccessInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpoints(ctx context.Context, params *opensearch.ListVpcEndpointsInput, optFns ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpoints")
	}

	var r0 *opensearch.ListVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointsInput, ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointsInput, ...func(*opensearch.Options)) *opensearch.ListVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListVpcEndpointsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpointsForDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpointsForDomain(ctx context.Context, params *opensearch.ListVpcEndpointsForDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointsForDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpointsForDomain")
	}

	var r0 *opensearch.ListVpcEndpointsForDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointsForDomainInput, ...func(*opensearch.Options)) (*opensearch.ListVpcEndpointsForDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.ListVpcEndpointsForDomainInput, ...func(*opensearch.Options)) *opensearch.ListVpcEndpointsForDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.ListVpcEndpointsForDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.ListVpcEndpointsForDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() opensearch.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 opensearch.Options
	if rf, ok := ret.Get(0).(func() opensearch.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(opensearch.Options)
	}

	return r0
}

// PurchaseReservedInstanceOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedInstanceOffering(ctx context.Context, params *opensearch.PurchaseReservedInstanceOfferingInput, optFns ...func(*opensearch.Options)) (*opensearch.PurchaseReservedInstanceOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedInstanceOffering")
	}

	var r0 *opensearch.PurchaseReservedInstanceOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.PurchaseReservedInstanceOfferingInput, ...func(*opensearch.Options)) (*opensearch.PurchaseReservedInstanceOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.PurchaseReservedInstanceOfferingInput, ...func(*opensearch.Options)) *opensearch.PurchaseReservedInstanceOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.PurchaseReservedInstanceOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.PurchaseReservedInstanceOfferingInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectInboundConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectInboundConnection(ctx context.Context, params *opensearch.RejectInboundConnectionInput, optFns ...func(*opensearch.Options)) (*opensearch.RejectInboundConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectInboundConnection")
	}

	var r0 *opensearch.RejectInboundConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RejectInboundConnectionInput, ...func(*opensearch.Options)) (*opensearch.RejectInboundConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RejectInboundConnectionInput, ...func(*opensearch.Options)) *opensearch.RejectInboundConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.RejectInboundConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.RejectInboundConnectionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *opensearch.RemoveTagsInput, optFns ...func(*opensearch.Options)) (*opensearch.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *opensearch.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RemoveTagsInput, ...func(*opensearch.Options)) (*opensearch.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RemoveTagsInput, ...func(*opensearch.Options)) *opensearch.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.RemoveTagsInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeVpcEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeVpcEndpointAccess(ctx context.Context, params *opensearch.RevokeVpcEndpointAccessInput, optFns ...func(*opensearch.Options)) (*opensearch.RevokeVpcEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeVpcEndpointAccess")
	}

	var r0 *opensearch.RevokeVpcEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RevokeVpcEndpointAccessInput, ...func(*opensearch.Options)) (*opensearch.RevokeVpcEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.RevokeVpcEndpointAccessInput, ...func(*opensearch.Options)) *opensearch.RevokeVpcEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.RevokeVpcEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.RevokeVpcEndpointAccessInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDomainMaintenance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDomainMaintenance(ctx context.Context, params *opensearch.StartDomainMaintenanceInput, optFns ...func(*opensearch.Options)) (*opensearch.StartDomainMaintenanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDomainMaintenance")
	}

	var r0 *opensearch.StartDomainMaintenanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.StartDomainMaintenanceInput, ...func(*opensearch.Options)) (*opensearch.StartDomainMaintenanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.StartDomainMaintenanceInput, ...func(*opensearch.Options)) *opensearch.StartDomainMaintenanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.StartDomainMaintenanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.StartDomainMaintenanceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartServiceSoftwareUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartServiceSoftwareUpdate(ctx context.Context, params *opensearch.StartServiceSoftwareUpdateInput, optFns ...func(*opensearch.Options)) (*opensearch.StartServiceSoftwareUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartServiceSoftwareUpdate")
	}

	var r0 *opensearch.StartServiceSoftwareUpdateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.StartServiceSoftwareUpdateInput, ...func(*opensearch.Options)) (*opensearch.StartServiceSoftwareUpdateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.StartServiceSoftwareUpdateInput, ...func(*opensearch.Options)) *opensearch.StartServiceSoftwareUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.StartServiceSoftwareUpdateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.StartServiceSoftwareUpdateInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApplication(ctx context.Context, params *opensearch.UpdateApplicationInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApplication")
	}

	var r0 *opensearch.UpdateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateApplicationInput, ...func(*opensearch.Options)) (*opensearch.UpdateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateApplicationInput, ...func(*opensearch.Options)) *opensearch.UpdateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateApplicationInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataSource(ctx context.Context, params *opensearch.UpdateDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataSource")
	}

	var r0 *opensearch.UpdateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDataSourceInput, ...func(*opensearch.Options)) (*opensearch.UpdateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDataSourceInput, ...func(*opensearch.Options)) *opensearch.UpdateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDirectQueryDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDirectQueryDataSource(ctx context.Context, params *opensearch.UpdateDirectQueryDataSourceInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateDirectQueryDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDirectQueryDataSource")
	}

	var r0 *opensearch.UpdateDirectQueryDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDirectQueryDataSourceInput, ...func(*opensearch.Options)) (*opensearch.UpdateDirectQueryDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDirectQueryDataSourceInput, ...func(*opensearch.Options)) *opensearch.UpdateDirectQueryDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateDirectQueryDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateDirectQueryDataSourceInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDomainConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDomainConfig(ctx context.Context, params *opensearch.UpdateDomainConfigInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateDomainConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDomainConfig")
	}

	var r0 *opensearch.UpdateDomainConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDomainConfigInput, ...func(*opensearch.Options)) (*opensearch.UpdateDomainConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateDomainConfigInput, ...func(*opensearch.Options)) *opensearch.UpdateDomainConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateDomainConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateDomainConfigInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackage(ctx context.Context, params *opensearch.UpdatePackageInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdatePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackage")
	}

	var r0 *opensearch.UpdatePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdatePackageInput, ...func(*opensearch.Options)) (*opensearch.UpdatePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdatePackageInput, ...func(*opensearch.Options)) *opensearch.UpdatePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdatePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdatePackageInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackageScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackageScope(ctx context.Context, params *opensearch.UpdatePackageScopeInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdatePackageScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageScope")
	}

	var r0 *opensearch.UpdatePackageScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdatePackageScopeInput, ...func(*opensearch.Options)) (*opensearch.UpdatePackageScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdatePackageScopeInput, ...func(*opensearch.Options)) *opensearch.UpdatePackageScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdatePackageScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdatePackageScopeInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateScheduledAction(ctx context.Context, params *opensearch.UpdateScheduledActionInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScheduledAction")
	}

	var r0 *opensearch.UpdateScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateScheduledActionInput, ...func(*opensearch.Options)) (*opensearch.UpdateScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateScheduledActionInput, ...func(*opensearch.Options)) *opensearch.UpdateScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateScheduledActionInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVpcEndpoint(ctx context.Context, params *opensearch.UpdateVpcEndpointInput, optFns ...func(*opensearch.Options)) (*opensearch.UpdateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVpcEndpoint")
	}

	var r0 *opensearch.UpdateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateVpcEndpointInput, ...func(*opensearch.Options)) (*opensearch.UpdateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpdateVpcEndpointInput, ...func(*opensearch.Options)) *opensearch.UpdateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpdateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpdateVpcEndpointInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpgradeDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpgradeDomain(ctx context.Context, params *opensearch.UpgradeDomainInput, optFns ...func(*opensearch.Options)) (*opensearch.UpgradeDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpgradeDomain")
	}

	var r0 *opensearch.UpgradeDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpgradeDomainInput, ...func(*opensearch.Options)) (*opensearch.UpgradeDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *opensearch.UpgradeDomainInput, ...func(*opensearch.Options)) *opensearch.UpgradeDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*opensearch.UpgradeDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *opensearch.UpgradeDomainInput, ...func(*opensearch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
