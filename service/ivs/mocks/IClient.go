// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	ivs "github.com/aws/aws-sdk-go-v2/service/ivs"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchGetChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetChannel(ctx context.Context, params *ivs.BatchGetChannelInput, optFns ...func(*ivs.Options)) (*ivs.BatchGetChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetChannel")
	}

	var r0 *ivs.BatchGetChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchGetChannelInput, ...func(*ivs.Options)) (*ivs.BatchGetChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchGetChannelInput, ...func(*ivs.Options)) *ivs.BatchGetChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.BatchGetChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.BatchGetChannelInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetStreamKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetStreamKey(ctx context.Context, params *ivs.BatchGetStreamKeyInput, optFns ...func(*ivs.Options)) (*ivs.BatchGetStreamKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetStreamKey")
	}

	var r0 *ivs.BatchGetStreamKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchGetStreamKeyInput, ...func(*ivs.Options)) (*ivs.BatchGetStreamKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchGetStreamKeyInput, ...func(*ivs.Options)) *ivs.BatchGetStreamKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.BatchGetStreamKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.BatchGetStreamKeyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchStartViewerSessionRevocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchStartViewerSessionRevocation(ctx context.Context, params *ivs.BatchStartViewerSessionRevocationInput, optFns ...func(*ivs.Options)) (*ivs.BatchStartViewerSessionRevocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchStartViewerSessionRevocation")
	}

	var r0 *ivs.BatchStartViewerSessionRevocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchStartViewerSessionRevocationInput, ...func(*ivs.Options)) (*ivs.BatchStartViewerSessionRevocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.BatchStartViewerSessionRevocationInput, ...func(*ivs.Options)) *ivs.BatchStartViewerSessionRevocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.BatchStartViewerSessionRevocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.BatchStartViewerSessionRevocationInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateChannel(ctx context.Context, params *ivs.CreateChannelInput, optFns ...func(*ivs.Options)) (*ivs.CreateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateChannel")
	}

	var r0 *ivs.CreateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateChannelInput, ...func(*ivs.Options)) (*ivs.CreateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateChannelInput, ...func(*ivs.Options)) *ivs.CreateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.CreateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.CreateChannelInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlaybackRestrictionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePlaybackRestrictionPolicy(ctx context.Context, params *ivs.CreatePlaybackRestrictionPolicyInput, optFns ...func(*ivs.Options)) (*ivs.CreatePlaybackRestrictionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlaybackRestrictionPolicy")
	}

	var r0 *ivs.CreatePlaybackRestrictionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) (*ivs.CreatePlaybackRestrictionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) *ivs.CreatePlaybackRestrictionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.CreatePlaybackRestrictionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.CreatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRecordingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRecordingConfiguration(ctx context.Context, params *ivs.CreateRecordingConfigurationInput, optFns ...func(*ivs.Options)) (*ivs.CreateRecordingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRecordingConfiguration")
	}

	var r0 *ivs.CreateRecordingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateRecordingConfigurationInput, ...func(*ivs.Options)) (*ivs.CreateRecordingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateRecordingConfigurationInput, ...func(*ivs.Options)) *ivs.CreateRecordingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.CreateRecordingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.CreateRecordingConfigurationInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStreamKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStreamKey(ctx context.Context, params *ivs.CreateStreamKeyInput, optFns ...func(*ivs.Options)) (*ivs.CreateStreamKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStreamKey")
	}

	var r0 *ivs.CreateStreamKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateStreamKeyInput, ...func(*ivs.Options)) (*ivs.CreateStreamKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.CreateStreamKeyInput, ...func(*ivs.Options)) *ivs.CreateStreamKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.CreateStreamKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.CreateStreamKeyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteChannel(ctx context.Context, params *ivs.DeleteChannelInput, optFns ...func(*ivs.Options)) (*ivs.DeleteChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteChannel")
	}

	var r0 *ivs.DeleteChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteChannelInput, ...func(*ivs.Options)) (*ivs.DeleteChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteChannelInput, ...func(*ivs.Options)) *ivs.DeleteChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.DeleteChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.DeleteChannelInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlaybackKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePlaybackKeyPair(ctx context.Context, params *ivs.DeletePlaybackKeyPairInput, optFns ...func(*ivs.Options)) (*ivs.DeletePlaybackKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePlaybackKeyPair")
	}

	var r0 *ivs.DeletePlaybackKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeletePlaybackKeyPairInput, ...func(*ivs.Options)) (*ivs.DeletePlaybackKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeletePlaybackKeyPairInput, ...func(*ivs.Options)) *ivs.DeletePlaybackKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.DeletePlaybackKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.DeletePlaybackKeyPairInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlaybackRestrictionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePlaybackRestrictionPolicy(ctx context.Context, params *ivs.DeletePlaybackRestrictionPolicyInput, optFns ...func(*ivs.Options)) (*ivs.DeletePlaybackRestrictionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePlaybackRestrictionPolicy")
	}

	var r0 *ivs.DeletePlaybackRestrictionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeletePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) (*ivs.DeletePlaybackRestrictionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeletePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) *ivs.DeletePlaybackRestrictionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.DeletePlaybackRestrictionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.DeletePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRecordingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRecordingConfiguration(ctx context.Context, params *ivs.DeleteRecordingConfigurationInput, optFns ...func(*ivs.Options)) (*ivs.DeleteRecordingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRecordingConfiguration")
	}

	var r0 *ivs.DeleteRecordingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteRecordingConfigurationInput, ...func(*ivs.Options)) (*ivs.DeleteRecordingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteRecordingConfigurationInput, ...func(*ivs.Options)) *ivs.DeleteRecordingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.DeleteRecordingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.DeleteRecordingConfigurationInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStreamKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStreamKey(ctx context.Context, params *ivs.DeleteStreamKeyInput, optFns ...func(*ivs.Options)) (*ivs.DeleteStreamKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStreamKey")
	}

	var r0 *ivs.DeleteStreamKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteStreamKeyInput, ...func(*ivs.Options)) (*ivs.DeleteStreamKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.DeleteStreamKeyInput, ...func(*ivs.Options)) *ivs.DeleteStreamKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.DeleteStreamKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.DeleteStreamKeyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChannel(ctx context.Context, params *ivs.GetChannelInput, optFns ...func(*ivs.Options)) (*ivs.GetChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChannel")
	}

	var r0 *ivs.GetChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetChannelInput, ...func(*ivs.Options)) (*ivs.GetChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetChannelInput, ...func(*ivs.Options)) *ivs.GetChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetChannelInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPlaybackKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPlaybackKeyPair(ctx context.Context, params *ivs.GetPlaybackKeyPairInput, optFns ...func(*ivs.Options)) (*ivs.GetPlaybackKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPlaybackKeyPair")
	}

	var r0 *ivs.GetPlaybackKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetPlaybackKeyPairInput, ...func(*ivs.Options)) (*ivs.GetPlaybackKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetPlaybackKeyPairInput, ...func(*ivs.Options)) *ivs.GetPlaybackKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetPlaybackKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetPlaybackKeyPairInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPlaybackRestrictionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPlaybackRestrictionPolicy(ctx context.Context, params *ivs.GetPlaybackRestrictionPolicyInput, optFns ...func(*ivs.Options)) (*ivs.GetPlaybackRestrictionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPlaybackRestrictionPolicy")
	}

	var r0 *ivs.GetPlaybackRestrictionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetPlaybackRestrictionPolicyInput, ...func(*ivs.Options)) (*ivs.GetPlaybackRestrictionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetPlaybackRestrictionPolicyInput, ...func(*ivs.Options)) *ivs.GetPlaybackRestrictionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetPlaybackRestrictionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetPlaybackRestrictionPolicyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecordingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecordingConfiguration(ctx context.Context, params *ivs.GetRecordingConfigurationInput, optFns ...func(*ivs.Options)) (*ivs.GetRecordingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecordingConfiguration")
	}

	var r0 *ivs.GetRecordingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetRecordingConfigurationInput, ...func(*ivs.Options)) (*ivs.GetRecordingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetRecordingConfigurationInput, ...func(*ivs.Options)) *ivs.GetRecordingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetRecordingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetRecordingConfigurationInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStream(ctx context.Context, params *ivs.GetStreamInput, optFns ...func(*ivs.Options)) (*ivs.GetStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStream")
	}

	var r0 *ivs.GetStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamInput, ...func(*ivs.Options)) (*ivs.GetStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamInput, ...func(*ivs.Options)) *ivs.GetStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetStreamInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStreamKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStreamKey(ctx context.Context, params *ivs.GetStreamKeyInput, optFns ...func(*ivs.Options)) (*ivs.GetStreamKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStreamKey")
	}

	var r0 *ivs.GetStreamKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamKeyInput, ...func(*ivs.Options)) (*ivs.GetStreamKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamKeyInput, ...func(*ivs.Options)) *ivs.GetStreamKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetStreamKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetStreamKeyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStreamSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStreamSession(ctx context.Context, params *ivs.GetStreamSessionInput, optFns ...func(*ivs.Options)) (*ivs.GetStreamSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStreamSession")
	}

	var r0 *ivs.GetStreamSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamSessionInput, ...func(*ivs.Options)) (*ivs.GetStreamSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.GetStreamSessionInput, ...func(*ivs.Options)) *ivs.GetStreamSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.GetStreamSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.GetStreamSessionInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPlaybackKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportPlaybackKeyPair(ctx context.Context, params *ivs.ImportPlaybackKeyPairInput, optFns ...func(*ivs.Options)) (*ivs.ImportPlaybackKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportPlaybackKeyPair")
	}

	var r0 *ivs.ImportPlaybackKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ImportPlaybackKeyPairInput, ...func(*ivs.Options)) (*ivs.ImportPlaybackKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ImportPlaybackKeyPairInput, ...func(*ivs.Options)) *ivs.ImportPlaybackKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ImportPlaybackKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ImportPlaybackKeyPairInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChannels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListChannels(ctx context.Context, params *ivs.ListChannelsInput, optFns ...func(*ivs.Options)) (*ivs.ListChannelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 *ivs.ListChannelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListChannelsInput, ...func(*ivs.Options)) (*ivs.ListChannelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListChannelsInput, ...func(*ivs.Options)) *ivs.ListChannelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListChannelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListChannelsInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPlaybackKeyPairs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPlaybackKeyPairs(ctx context.Context, params *ivs.ListPlaybackKeyPairsInput, optFns ...func(*ivs.Options)) (*ivs.ListPlaybackKeyPairsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPlaybackKeyPairs")
	}

	var r0 *ivs.ListPlaybackKeyPairsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListPlaybackKeyPairsInput, ...func(*ivs.Options)) (*ivs.ListPlaybackKeyPairsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListPlaybackKeyPairsInput, ...func(*ivs.Options)) *ivs.ListPlaybackKeyPairsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListPlaybackKeyPairsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListPlaybackKeyPairsInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPlaybackRestrictionPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPlaybackRestrictionPolicies(ctx context.Context, params *ivs.ListPlaybackRestrictionPoliciesInput, optFns ...func(*ivs.Options)) (*ivs.ListPlaybackRestrictionPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPlaybackRestrictionPolicies")
	}

	var r0 *ivs.ListPlaybackRestrictionPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListPlaybackRestrictionPoliciesInput, ...func(*ivs.Options)) (*ivs.ListPlaybackRestrictionPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListPlaybackRestrictionPoliciesInput, ...func(*ivs.Options)) *ivs.ListPlaybackRestrictionPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListPlaybackRestrictionPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListPlaybackRestrictionPoliciesInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRecordingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRecordingConfigurations(ctx context.Context, params *ivs.ListRecordingConfigurationsInput, optFns ...func(*ivs.Options)) (*ivs.ListRecordingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRecordingConfigurations")
	}

	var r0 *ivs.ListRecordingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListRecordingConfigurationsInput, ...func(*ivs.Options)) (*ivs.ListRecordingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListRecordingConfigurationsInput, ...func(*ivs.Options)) *ivs.ListRecordingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListRecordingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListRecordingConfigurationsInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreamKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreamKeys(ctx context.Context, params *ivs.ListStreamKeysInput, optFns ...func(*ivs.Options)) (*ivs.ListStreamKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreamKeys")
	}

	var r0 *ivs.ListStreamKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamKeysInput, ...func(*ivs.Options)) (*ivs.ListStreamKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamKeysInput, ...func(*ivs.Options)) *ivs.ListStreamKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListStreamKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListStreamKeysInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreamSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreamSessions(ctx context.Context, params *ivs.ListStreamSessionsInput, optFns ...func(*ivs.Options)) (*ivs.ListStreamSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreamSessions")
	}

	var r0 *ivs.ListStreamSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamSessionsInput, ...func(*ivs.Options)) (*ivs.ListStreamSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamSessionsInput, ...func(*ivs.Options)) *ivs.ListStreamSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListStreamSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListStreamSessionsInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreams provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreams(ctx context.Context, params *ivs.ListStreamsInput, optFns ...func(*ivs.Options)) (*ivs.ListStreamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreams")
	}

	var r0 *ivs.ListStreamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamsInput, ...func(*ivs.Options)) (*ivs.ListStreamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListStreamsInput, ...func(*ivs.Options)) *ivs.ListStreamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListStreamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListStreamsInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *ivs.ListTagsForResourceInput, optFns ...func(*ivs.Options)) (*ivs.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *ivs.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListTagsForResourceInput, ...func(*ivs.Options)) (*ivs.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.ListTagsForResourceInput, ...func(*ivs.Options)) *ivs.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.ListTagsForResourceInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() ivs.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 ivs.Options
	if rf, ok := ret.Get(0).(func() ivs.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ivs.Options)
	}

	return r0
}

// PutMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutMetadata(ctx context.Context, params *ivs.PutMetadataInput, optFns ...func(*ivs.Options)) (*ivs.PutMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutMetadata")
	}

	var r0 *ivs.PutMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.PutMetadataInput, ...func(*ivs.Options)) (*ivs.PutMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.PutMetadataInput, ...func(*ivs.Options)) *ivs.PutMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.PutMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.PutMetadataInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartViewerSessionRevocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartViewerSessionRevocation(ctx context.Context, params *ivs.StartViewerSessionRevocationInput, optFns ...func(*ivs.Options)) (*ivs.StartViewerSessionRevocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartViewerSessionRevocation")
	}

	var r0 *ivs.StartViewerSessionRevocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.StartViewerSessionRevocationInput, ...func(*ivs.Options)) (*ivs.StartViewerSessionRevocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.StartViewerSessionRevocationInput, ...func(*ivs.Options)) *ivs.StartViewerSessionRevocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.StartViewerSessionRevocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.StartViewerSessionRevocationInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopStream provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopStream(ctx context.Context, params *ivs.StopStreamInput, optFns ...func(*ivs.Options)) (*ivs.StopStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopStream")
	}

	var r0 *ivs.StopStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.StopStreamInput, ...func(*ivs.Options)) (*ivs.StopStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.StopStreamInput, ...func(*ivs.Options)) *ivs.StopStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.StopStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.StopStreamInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *ivs.TagResourceInput, optFns ...func(*ivs.Options)) (*ivs.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *ivs.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.TagResourceInput, ...func(*ivs.Options)) (*ivs.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.TagResourceInput, ...func(*ivs.Options)) *ivs.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.TagResourceInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *ivs.UntagResourceInput, optFns ...func(*ivs.Options)) (*ivs.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *ivs.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UntagResourceInput, ...func(*ivs.Options)) (*ivs.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UntagResourceInput, ...func(*ivs.Options)) *ivs.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.UntagResourceInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateChannel(ctx context.Context, params *ivs.UpdateChannelInput, optFns ...func(*ivs.Options)) (*ivs.UpdateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannel")
	}

	var r0 *ivs.UpdateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UpdateChannelInput, ...func(*ivs.Options)) (*ivs.UpdateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UpdateChannelInput, ...func(*ivs.Options)) *ivs.UpdateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.UpdateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.UpdateChannelInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePlaybackRestrictionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePlaybackRestrictionPolicy(ctx context.Context, params *ivs.UpdatePlaybackRestrictionPolicyInput, optFns ...func(*ivs.Options)) (*ivs.UpdatePlaybackRestrictionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePlaybackRestrictionPolicy")
	}

	var r0 *ivs.UpdatePlaybackRestrictionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UpdatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) (*ivs.UpdatePlaybackRestrictionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ivs.UpdatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) *ivs.UpdatePlaybackRestrictionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ivs.UpdatePlaybackRestrictionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ivs.UpdatePlaybackRestrictionPolicyInput, ...func(*ivs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
