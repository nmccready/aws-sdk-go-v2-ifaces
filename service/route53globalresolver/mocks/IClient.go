// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	route53globalresolver "github.com/aws/aws-sdk-go-v2/service/route53globalresolver"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateHostedZone provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateHostedZone(ctx context.Context, params *route53globalresolver.AssociateHostedZoneInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.AssociateHostedZoneOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateHostedZone")
	}

	var r0 *route53globalresolver.AssociateHostedZoneOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.AssociateHostedZoneInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.AssociateHostedZoneOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.AssociateHostedZoneInput, ...func(*route53globalresolver.Options)) *route53globalresolver.AssociateHostedZoneOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.AssociateHostedZoneOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.AssociateHostedZoneInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchCreateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreateFirewallRule(ctx context.Context, params *route53globalresolver.BatchCreateFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchCreateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreateFirewallRule")
	}

	var r0 *route53globalresolver.BatchCreateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchCreateFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchCreateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchCreateFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.BatchCreateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.BatchCreateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.BatchCreateFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteFirewallRule(ctx context.Context, params *route53globalresolver.BatchDeleteFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchDeleteFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteFirewallRule")
	}

	var r0 *route53globalresolver.BatchDeleteFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchDeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchDeleteFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchDeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.BatchDeleteFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.BatchDeleteFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.BatchDeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchUpdateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdateFirewallRule(ctx context.Context, params *route53globalresolver.BatchUpdateFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchUpdateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateFirewallRule")
	}

	var r0 *route53globalresolver.BatchUpdateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchUpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.BatchUpdateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.BatchUpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.BatchUpdateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.BatchUpdateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.BatchUpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessSource(ctx context.Context, params *route53globalresolver.CreateAccessSourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateAccessSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessSource")
	}

	var r0 *route53globalresolver.CreateAccessSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateAccessSourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateAccessSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateAccessSourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateAccessSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateAccessSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateAccessSourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessToken(ctx context.Context, params *route53globalresolver.CreateAccessTokenInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessToken")
	}

	var r0 *route53globalresolver.CreateAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateAccessTokenInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateAccessTokenInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateAccessTokenInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDNSView(ctx context.Context, params *route53globalresolver.CreateDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDNSView")
	}

	var r0 *route53globalresolver.CreateDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallDomainList(ctx context.Context, params *route53globalresolver.CreateFirewallDomainListInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallDomainList")
	}

	var r0 *route53globalresolver.CreateFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateFirewallDomainListInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateFirewallDomainListInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateFirewallDomainListInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallRule(ctx context.Context, params *route53globalresolver.CreateFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallRule")
	}

	var r0 *route53globalresolver.CreateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGlobalResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGlobalResolver(ctx context.Context, params *route53globalresolver.CreateGlobalResolverInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateGlobalResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGlobalResolver")
	}

	var r0 *route53globalresolver.CreateGlobalResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateGlobalResolverInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.CreateGlobalResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.CreateGlobalResolverInput, ...func(*route53globalresolver.Options)) *route53globalresolver.CreateGlobalResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.CreateGlobalResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.CreateGlobalResolverInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccessSource(ctx context.Context, params *route53globalresolver.DeleteAccessSourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteAccessSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessSource")
	}

	var r0 *route53globalresolver.DeleteAccessSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteAccessSourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteAccessSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteAccessSourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteAccessSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteAccessSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteAccessSourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccessToken(ctx context.Context, params *route53globalresolver.DeleteAccessTokenInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessToken")
	}

	var r0 *route53globalresolver.DeleteAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteAccessTokenInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteAccessTokenInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteAccessTokenInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDNSView(ctx context.Context, params *route53globalresolver.DeleteDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDNSView")
	}

	var r0 *route53globalresolver.DeleteDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallDomainList(ctx context.Context, params *route53globalresolver.DeleteFirewallDomainListInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallDomainList")
	}

	var r0 *route53globalresolver.DeleteFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteFirewallDomainListInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteFirewallDomainListInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteFirewallDomainListInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallRule(ctx context.Context, params *route53globalresolver.DeleteFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallRule")
	}

	var r0 *route53globalresolver.DeleteFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGlobalResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGlobalResolver(ctx context.Context, params *route53globalresolver.DeleteGlobalResolverInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteGlobalResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGlobalResolver")
	}

	var r0 *route53globalresolver.DeleteGlobalResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteGlobalResolverInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DeleteGlobalResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DeleteGlobalResolverInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DeleteGlobalResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DeleteGlobalResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DeleteGlobalResolverInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableDNSView(ctx context.Context, params *route53globalresolver.DisableDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DisableDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableDNSView")
	}

	var r0 *route53globalresolver.DisableDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DisableDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DisableDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DisableDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DisableDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DisableDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DisableDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateHostedZone provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateHostedZone(ctx context.Context, params *route53globalresolver.DisassociateHostedZoneInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.DisassociateHostedZoneOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateHostedZone")
	}

	var r0 *route53globalresolver.DisassociateHostedZoneOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DisassociateHostedZoneInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.DisassociateHostedZoneOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.DisassociateHostedZoneInput, ...func(*route53globalresolver.Options)) *route53globalresolver.DisassociateHostedZoneOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.DisassociateHostedZoneOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.DisassociateHostedZoneInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableDNSView(ctx context.Context, params *route53globalresolver.EnableDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.EnableDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableDNSView")
	}

	var r0 *route53globalresolver.EnableDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.EnableDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.EnableDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.EnableDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.EnableDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.EnableDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.EnableDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccessSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccessSource(ctx context.Context, params *route53globalresolver.GetAccessSourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetAccessSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessSource")
	}

	var r0 *route53globalresolver.GetAccessSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetAccessSourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetAccessSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetAccessSourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetAccessSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetAccessSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetAccessSourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccessToken(ctx context.Context, params *route53globalresolver.GetAccessTokenInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessToken")
	}

	var r0 *route53globalresolver.GetAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetAccessTokenInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetAccessTokenInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetAccessTokenInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDNSView(ctx context.Context, params *route53globalresolver.GetDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDNSView")
	}

	var r0 *route53globalresolver.GetDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallDomainList(ctx context.Context, params *route53globalresolver.GetFirewallDomainListInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallDomainList")
	}

	var r0 *route53globalresolver.GetFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetFirewallDomainListInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetFirewallDomainListInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetFirewallDomainListInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallRule(ctx context.Context, params *route53globalresolver.GetFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallRule")
	}

	var r0 *route53globalresolver.GetFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGlobalResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGlobalResolver(ctx context.Context, params *route53globalresolver.GetGlobalResolverInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetGlobalResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGlobalResolver")
	}

	var r0 *route53globalresolver.GetGlobalResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetGlobalResolverInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetGlobalResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetGlobalResolverInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetGlobalResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetGlobalResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetGlobalResolverInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostedZoneAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetHostedZoneAssociation(ctx context.Context, params *route53globalresolver.GetHostedZoneAssociationInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetHostedZoneAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHostedZoneAssociation")
	}

	var r0 *route53globalresolver.GetHostedZoneAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetHostedZoneAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetHostedZoneAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetHostedZoneAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetManagedFirewallDomainList(ctx context.Context, params *route53globalresolver.GetManagedFirewallDomainListInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.GetManagedFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedFirewallDomainList")
	}

	var r0 *route53globalresolver.GetManagedFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetManagedFirewallDomainListInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.GetManagedFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.GetManagedFirewallDomainListInput, ...func(*route53globalresolver.Options)) *route53globalresolver.GetManagedFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.GetManagedFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.GetManagedFirewallDomainListInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportFirewallDomains(ctx context.Context, params *route53globalresolver.ImportFirewallDomainsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ImportFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportFirewallDomains")
	}

	var r0 *route53globalresolver.ImportFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ImportFirewallDomainsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ImportFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ImportFirewallDomainsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ImportFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ImportFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ImportFirewallDomainsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessSources(ctx context.Context, params *route53globalresolver.ListAccessSourcesInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListAccessSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessSources")
	}

	var r0 *route53globalresolver.ListAccessSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListAccessSourcesInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListAccessSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListAccessSourcesInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListAccessSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListAccessSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListAccessSourcesInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessTokens provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessTokens(ctx context.Context, params *route53globalresolver.ListAccessTokensInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListAccessTokensOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessTokens")
	}

	var r0 *route53globalresolver.ListAccessTokensOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListAccessTokensInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListAccessTokensOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListAccessTokensInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListAccessTokensOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListAccessTokensOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListAccessTokensInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDNSViews provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDNSViews(ctx context.Context, params *route53globalresolver.ListDNSViewsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListDNSViewsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDNSViews")
	}

	var r0 *route53globalresolver.ListDNSViewsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListDNSViewsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListDNSViewsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListDNSViewsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListDNSViewsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListDNSViewsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListDNSViewsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallDomainLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallDomainLists(ctx context.Context, params *route53globalresolver.ListFirewallDomainListsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallDomainListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallDomainLists")
	}

	var r0 *route53globalresolver.ListFirewallDomainListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallDomainListsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallDomainListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallDomainListsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListFirewallDomainListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListFirewallDomainListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListFirewallDomainListsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallDomains(ctx context.Context, params *route53globalresolver.ListFirewallDomainsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallDomains")
	}

	var r0 *route53globalresolver.ListFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallDomainsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallDomainsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListFirewallDomainsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallRules(ctx context.Context, params *route53globalresolver.ListFirewallRulesInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallRules")
	}

	var r0 *route53globalresolver.ListFirewallRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallRulesInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListFirewallRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListFirewallRulesInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListFirewallRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListFirewallRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListFirewallRulesInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGlobalResolvers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGlobalResolvers(ctx context.Context, params *route53globalresolver.ListGlobalResolversInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListGlobalResolversOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGlobalResolvers")
	}

	var r0 *route53globalresolver.ListGlobalResolversOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListGlobalResolversInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListGlobalResolversOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListGlobalResolversInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListGlobalResolversOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListGlobalResolversOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListGlobalResolversInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHostedZoneAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListHostedZoneAssociations(ctx context.Context, params *route53globalresolver.ListHostedZoneAssociationsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListHostedZoneAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListHostedZoneAssociations")
	}

	var r0 *route53globalresolver.ListHostedZoneAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListHostedZoneAssociationsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListHostedZoneAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListHostedZoneAssociationsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListHostedZoneAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListHostedZoneAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListHostedZoneAssociationsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListManagedFirewallDomainLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListManagedFirewallDomainLists(ctx context.Context, params *route53globalresolver.ListManagedFirewallDomainListsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListManagedFirewallDomainListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListManagedFirewallDomainLists")
	}

	var r0 *route53globalresolver.ListManagedFirewallDomainListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListManagedFirewallDomainListsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListManagedFirewallDomainListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListManagedFirewallDomainListsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListManagedFirewallDomainListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListManagedFirewallDomainListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListManagedFirewallDomainListsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *route53globalresolver.ListTagsForResourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *route53globalresolver.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListTagsForResourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.ListTagsForResourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.ListTagsForResourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() route53globalresolver.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 route53globalresolver.Options
	if rf, ok := ret.Get(0).(func() route53globalresolver.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(route53globalresolver.Options)
	}

	return r0
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *route53globalresolver.TagResourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *route53globalresolver.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.TagResourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.TagResourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.TagResourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *route53globalresolver.UntagResourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *route53globalresolver.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UntagResourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UntagResourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UntagResourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccessSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAccessSource(ctx context.Context, params *route53globalresolver.UpdateAccessSourceInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateAccessSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccessSource")
	}

	var r0 *route53globalresolver.UpdateAccessSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateAccessSourceInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateAccessSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateAccessSourceInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateAccessSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateAccessSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateAccessSourceInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAccessToken(ctx context.Context, params *route53globalresolver.UpdateAccessTokenInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccessToken")
	}

	var r0 *route53globalresolver.UpdateAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateAccessTokenInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateAccessTokenInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateAccessTokenInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDNSView provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDNSView(ctx context.Context, params *route53globalresolver.UpdateDNSViewInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateDNSViewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDNSView")
	}

	var r0 *route53globalresolver.UpdateDNSViewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateDNSViewInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateDNSViewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateDNSViewInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateDNSViewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateDNSViewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateDNSViewInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallDomains(ctx context.Context, params *route53globalresolver.UpdateFirewallDomainsInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallDomains")
	}

	var r0 *route53globalresolver.UpdateFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateFirewallDomainsInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateFirewallDomainsInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateFirewallDomainsInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallRule(ctx context.Context, params *route53globalresolver.UpdateFirewallRuleInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallRule")
	}

	var r0 *route53globalresolver.UpdateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateFirewallRuleInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGlobalResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGlobalResolver(ctx context.Context, params *route53globalresolver.UpdateGlobalResolverInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateGlobalResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGlobalResolver")
	}

	var r0 *route53globalresolver.UpdateGlobalResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateGlobalResolverInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateGlobalResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateGlobalResolverInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateGlobalResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateGlobalResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateGlobalResolverInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHostedZoneAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateHostedZoneAssociation(ctx context.Context, params *route53globalresolver.UpdateHostedZoneAssociationInput, optFns ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateHostedZoneAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHostedZoneAssociation")
	}

	var r0 *route53globalresolver.UpdateHostedZoneAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) (*route53globalresolver.UpdateHostedZoneAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53globalresolver.UpdateHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) *route53globalresolver.UpdateHostedZoneAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53globalresolver.UpdateHostedZoneAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53globalresolver.UpdateHostedZoneAssociationInput, ...func(*route53globalresolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
