// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	elasticloadbalancingv2 "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.AddListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddListenerCertificates")
	}

	var r0 *elasticloadbalancingv2.AddListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.AddListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.AddListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *elasticloadbalancingv2.AddTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *elasticloadbalancingv2.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTrustStoreRevocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTrustStoreRevocations(ctx context.Context, params *elasticloadbalancingv2.AddTrustStoreRevocationsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTrustStoreRevocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTrustStoreRevocations")
	}

	var r0 *elasticloadbalancingv2.AddTrustStoreRevocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTrustStoreRevocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.AddTrustStoreRevocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.AddTrustStoreRevocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.AddTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateListener(ctx context.Context, params *elasticloadbalancingv2.CreateListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateListener")
	}

	var r0 *elasticloadbalancingv2.CreateListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLoadBalancer(ctx context.Context, params *elasticloadbalancingv2.CreateLoadBalancerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLoadBalancer")
	}

	var r0 *elasticloadbalancingv2.CreateLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRule(ctx context.Context, params *elasticloadbalancingv2.CreateRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 *elasticloadbalancingv2.CreateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTargetGroup(ctx context.Context, params *elasticloadbalancingv2.CreateTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTargetGroup")
	}

	var r0 *elasticloadbalancingv2.CreateTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrustStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrustStore(ctx context.Context, params *elasticloadbalancingv2.CreateTrustStoreInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTrustStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrustStore")
	}

	var r0 *elasticloadbalancingv2.CreateTrustStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTrustStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateTrustStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateTrustStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteListener(ctx context.Context, params *elasticloadbalancingv2.DeleteListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteListener")
	}

	var r0 *elasticloadbalancingv2.DeleteListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLoadBalancer(ctx context.Context, params *elasticloadbalancingv2.DeleteLoadBalancerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoadBalancer")
	}

	var r0 *elasticloadbalancingv2.DeleteLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRule(ctx context.Context, params *elasticloadbalancingv2.DeleteRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 *elasticloadbalancingv2.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTargetGroup(ctx context.Context, params *elasticloadbalancingv2.DeleteTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTargetGroup")
	}

	var r0 *elasticloadbalancingv2.DeleteTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrustStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrustStore(ctx context.Context, params *elasticloadbalancingv2.DeleteTrustStoreInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTrustStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrustStore")
	}

	var r0 *elasticloadbalancingv2.DeleteTrustStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTrustStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteTrustStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteTrustStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterTargets(ctx context.Context, params *elasticloadbalancingv2.DeregisterTargetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeregisterTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTargets")
	}

	var r0 *elasticloadbalancingv2.DeregisterTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeregisterTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeregisterTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeregisterTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAccountLimits(ctx context.Context, params *elasticloadbalancingv2.DescribeAccountLimitsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeAccountLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccountLimits")
	}

	var r0 *elasticloadbalancingv2.DescribeAccountLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeAccountLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeAccountLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeAccountLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.DescribeListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeListenerCertificates")
	}

	var r0 *elasticloadbalancingv2.DescribeListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeListeners provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeListeners(ctx context.Context, params *elasticloadbalancingv2.DescribeListenersInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeListeners")
	}

	var r0 *elasticloadbalancingv2.DescribeListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancerAttributes")
	}

	var r0 *elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLoadBalancers(ctx context.Context, params *elasticloadbalancingv2.DescribeLoadBalancersInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancers")
	}

	var r0 *elasticloadbalancingv2.DescribeLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRules(ctx context.Context, params *elasticloadbalancingv2.DescribeRulesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRules")
	}

	var r0 *elasticloadbalancingv2.DescribeRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSSLPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSSLPolicies(ctx context.Context, params *elasticloadbalancingv2.DescribeSSLPoliciesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeSSLPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSSLPolicies")
	}

	var r0 *elasticloadbalancingv2.DescribeSSLPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeSSLPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeSSLPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeSSLPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTags(ctx context.Context, params *elasticloadbalancingv2.DescribeTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTags")
	}

	var r0 *elasticloadbalancingv2.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetGroupAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTargetGroupAttributes(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTargetGroupAttributes")
	}

	var r0 *elasticloadbalancingv2.DescribeTargetGroupAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetGroupAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTargetGroups(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetGroupsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTargetGroups")
	}

	var r0 *elasticloadbalancingv2.DescribeTargetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetHealth provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTargetHealth(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetHealthInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTargetHealth")
	}

	var r0 *elasticloadbalancingv2.DescribeTargetHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustStoreAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrustStoreAssociations(ctx context.Context, params *elasticloadbalancingv2.DescribeTrustStoreAssociationsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoreAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustStoreAssociations")
	}

	var r0 *elasticloadbalancingv2.DescribeTrustStoreAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreAssociationsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoreAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreAssociationsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTrustStoreAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTrustStoreAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreAssociationsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustStoreRevocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrustStoreRevocations(ctx context.Context, params *elasticloadbalancingv2.DescribeTrustStoreRevocationsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoreRevocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustStoreRevocations")
	}

	var r0 *elasticloadbalancingv2.DescribeTrustStoreRevocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoreRevocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTrustStoreRevocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTrustStoreRevocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTrustStores(ctx context.Context, params *elasticloadbalancingv2.DescribeTrustStoresInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustStores")
	}

	var r0 *elasticloadbalancingv2.DescribeTrustStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoresInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTrustStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoresInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTrustStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTrustStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTrustStoresInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrustStoreCaCertificatesBundle provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTrustStoreCaCertificatesBundle(ctx context.Context, params *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTrustStoreCaCertificatesBundle")
	}

	var r0 *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreCaCertificatesBundleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrustStoreRevocationContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTrustStoreRevocationContent(ctx context.Context, params *elasticloadbalancingv2.GetTrustStoreRevocationContentInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.GetTrustStoreRevocationContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTrustStoreRevocationContent")
	}

	var r0 *elasticloadbalancingv2.GetTrustStoreRevocationContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreRevocationContentInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.GetTrustStoreRevocationContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreRevocationContentInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.GetTrustStoreRevocationContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.GetTrustStoreRevocationContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.GetTrustStoreRevocationContentInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyListener(ctx context.Context, params *elasticloadbalancingv2.ModifyListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyListener")
	}

	var r0 *elasticloadbalancingv2.ModifyListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyLoadBalancerAttributes")
	}

	var r0 *elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyRule(ctx context.Context, params *elasticloadbalancingv2.ModifyRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyRule")
	}

	var r0 *elasticloadbalancingv2.ModifyRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTargetGroup(ctx context.Context, params *elasticloadbalancingv2.ModifyTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTargetGroup")
	}

	var r0 *elasticloadbalancingv2.ModifyTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTargetGroupAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTargetGroupAttributes(ctx context.Context, params *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTargetGroupAttributes")
	}

	var r0 *elasticloadbalancingv2.ModifyTargetGroupAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyTargetGroupAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrustStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyTrustStore(ctx context.Context, params *elasticloadbalancingv2.ModifyTrustStoreInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTrustStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrustStore")
	}

	var r0 *elasticloadbalancingv2.ModifyTrustStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTrustStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyTrustStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyTrustStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyTrustStoreInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() elasticloadbalancingv2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 elasticloadbalancingv2.Options
	if rf, ok := ret.Get(0).(func() elasticloadbalancingv2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(elasticloadbalancingv2.Options)
	}

	return r0
}

// RegisterTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterTargets(ctx context.Context, params *elasticloadbalancingv2.RegisterTargetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RegisterTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTargets")
	}

	var r0 *elasticloadbalancingv2.RegisterTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RegisterTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RegisterTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RegisterTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.RemoveListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveListenerCertificates")
	}

	var r0 *elasticloadbalancingv2.RemoveListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RemoveListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RemoveListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *elasticloadbalancingv2.RemoveTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *elasticloadbalancingv2.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTrustStoreRevocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTrustStoreRevocations(ctx context.Context, params *elasticloadbalancingv2.RemoveTrustStoreRevocationsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTrustStoreRevocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTrustStoreRevocations")
	}

	var r0 *elasticloadbalancingv2.RemoveTrustStoreRevocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTrustStoreRevocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RemoveTrustStoreRevocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RemoveTrustStoreRevocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RemoveTrustStoreRevocationsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetIpAddressType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetIpAddressType(ctx context.Context, params *elasticloadbalancingv2.SetIpAddressTypeInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetIpAddressTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetIpAddressType")
	}

	var r0 *elasticloadbalancingv2.SetIpAddressTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetIpAddressTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetIpAddressTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetIpAddressTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRulePriorities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetRulePriorities(ctx context.Context, params *elasticloadbalancingv2.SetRulePrioritiesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetRulePrioritiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRulePriorities")
	}

	var r0 *elasticloadbalancingv2.SetRulePrioritiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetRulePrioritiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetRulePrioritiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetRulePrioritiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetSecurityGroups(ctx context.Context, params *elasticloadbalancingv2.SetSecurityGroupsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetSecurityGroups")
	}

	var r0 *elasticloadbalancingv2.SetSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetSubnets(ctx context.Context, params *elasticloadbalancingv2.SetSubnetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetSubnets")
	}

	var r0 *elasticloadbalancingv2.SetSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
