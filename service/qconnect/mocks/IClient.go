// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	qconnect "github.com/aws/aws-sdk-go-v2/service/qconnect"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistant(ctx context.Context, params *qconnect.CreateAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistant")
	}

	var r0 *qconnect.CreateAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) (*qconnect.CreateAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) *qconnect.CreateAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistantAssociation(ctx context.Context, params *qconnect.CreateAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistantAssociation")
	}

	var r0 *qconnect.CreateAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.CreateAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.CreateAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContent(ctx context.Context, params *qconnect.CreateContentInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContent")
	}

	var r0 *qconnect.CreateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) (*qconnect.CreateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) *qconnect.CreateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContentAssociation(ctx context.Context, params *qconnect.CreateContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContentAssociation")
	}

	var r0 *qconnect.CreateContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.CreateContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) *qconnect.CreateContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKnowledgeBase(ctx context.Context, params *qconnect.CreateKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKnowledgeBase")
	}

	var r0 *qconnect.CreateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.CreateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.CreateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateQuickResponse(ctx context.Context, params *qconnect.CreateQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateQuickResponse")
	}

	var r0 *qconnect.CreateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.CreateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) *qconnect.CreateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSession(ctx context.Context, params *qconnect.CreateSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *qconnect.CreateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) (*qconnect.CreateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) *qconnect.CreateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistant(ctx context.Context, params *qconnect.DeleteAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistant")
	}

	var r0 *qconnect.DeleteAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) (*qconnect.DeleteAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) *qconnect.DeleteAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistantAssociation(ctx context.Context, params *qconnect.DeleteAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistantAssociation")
	}

	var r0 *qconnect.DeleteAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.DeleteAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.DeleteAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContent(ctx context.Context, params *qconnect.DeleteContentInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContent")
	}

	var r0 *qconnect.DeleteContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) (*qconnect.DeleteContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) *qconnect.DeleteContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContentAssociation(ctx context.Context, params *qconnect.DeleteContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContentAssociation")
	}

	var r0 *qconnect.DeleteContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.DeleteContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) *qconnect.DeleteContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImportJob(ctx context.Context, params *qconnect.DeleteImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImportJob")
	}

	var r0 *qconnect.DeleteImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) (*qconnect.DeleteImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) *qconnect.DeleteImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKnowledgeBase(ctx context.Context, params *qconnect.DeleteKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnowledgeBase")
	}

	var r0 *qconnect.DeleteKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.DeleteKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.DeleteKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQuickResponse(ctx context.Context, params *qconnect.DeleteQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQuickResponse")
	}

	var r0 *qconnect.DeleteQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.DeleteQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) *qconnect.DeleteQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistant(ctx context.Context, params *qconnect.GetAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistant")
	}

	var r0 *qconnect.GetAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) (*qconnect.GetAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) *qconnect.GetAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistantAssociation(ctx context.Context, params *qconnect.GetAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistantAssociation")
	}

	var r0 *qconnect.GetAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.GetAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.GetAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContent(ctx context.Context, params *qconnect.GetContentInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContent")
	}

	var r0 *qconnect.GetContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) (*qconnect.GetContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) *qconnect.GetContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentAssociation(ctx context.Context, params *qconnect.GetContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentAssociation")
	}

	var r0 *qconnect.GetContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.GetContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) *qconnect.GetContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentSummary(ctx context.Context, params *qconnect.GetContentSummaryInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentSummary")
	}

	var r0 *qconnect.GetContentSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) (*qconnect.GetContentSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) *qconnect.GetContentSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImportJob(ctx context.Context, params *qconnect.GetImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.GetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImportJob")
	}

	var r0 *qconnect.GetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) (*qconnect.GetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) *qconnect.GetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKnowledgeBase(ctx context.Context, params *qconnect.GetKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.GetKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKnowledgeBase")
	}

	var r0 *qconnect.GetKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.GetKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.GetKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQuickResponse(ctx context.Context, params *qconnect.GetQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.GetQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuickResponse")
	}

	var r0 *qconnect.GetQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.GetQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) *qconnect.GetQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecommendations(ctx context.Context, params *qconnect.GetRecommendationsInput, optFns ...func(*qconnect.Options)) (*qconnect.GetRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecommendations")
	}

	var r0 *qconnect.GetRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) (*qconnect.GetRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) *qconnect.GetRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSession(ctx context.Context, params *qconnect.GetSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.GetSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *qconnect.GetSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) (*qconnect.GetSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) *qconnect.GetSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistantAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistantAssociations(ctx context.Context, params *qconnect.ListAssistantAssociationsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAssistantAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistantAssociations")
	}

	var r0 *qconnect.ListAssistantAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) (*qconnect.ListAssistantAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) *qconnect.ListAssistantAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAssistantAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistants(ctx context.Context, params *qconnect.ListAssistantsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAssistantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistants")
	}

	var r0 *qconnect.ListAssistantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) (*qconnect.ListAssistantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) *qconnect.ListAssistantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAssistantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContentAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContentAssociations(ctx context.Context, params *qconnect.ListContentAssociationsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListContentAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContentAssociations")
	}

	var r0 *qconnect.ListContentAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) (*qconnect.ListContentAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) *qconnect.ListContentAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListContentAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContents(ctx context.Context, params *qconnect.ListContentsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListContentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContents")
	}

	var r0 *qconnect.ListContentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) (*qconnect.ListContentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) *qconnect.ListContentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListContentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImportJobs(ctx context.Context, params *qconnect.ListImportJobsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImportJobs")
	}

	var r0 *qconnect.ListImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) (*qconnect.ListImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) *qconnect.ListImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKnowledgeBases(ctx context.Context, params *qconnect.ListKnowledgeBasesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKnowledgeBases")
	}

	var r0 *qconnect.ListKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) (*qconnect.ListKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) *qconnect.ListKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQuickResponses(ctx context.Context, params *qconnect.ListQuickResponsesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQuickResponses")
	}

	var r0 *qconnect.ListQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) (*qconnect.ListQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) *qconnect.ListQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *qconnect.ListTagsForResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *qconnect.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) (*qconnect.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) *qconnect.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyRecommendationsReceived provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) NotifyRecommendationsReceived(ctx context.Context, params *qconnect.NotifyRecommendationsReceivedInput, optFns ...func(*qconnect.Options)) (*qconnect.NotifyRecommendationsReceivedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotifyRecommendationsReceived")
	}

	var r0 *qconnect.NotifyRecommendationsReceivedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) (*qconnect.NotifyRecommendationsReceivedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) *qconnect.NotifyRecommendationsReceivedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.NotifyRecommendationsReceivedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() qconnect.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 qconnect.Options
	if rf, ok := ret.Get(0).(func() qconnect.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(qconnect.Options)
	}

	return r0
}

// PutFeedback provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFeedback(ctx context.Context, params *qconnect.PutFeedbackInput, optFns ...func(*qconnect.Options)) (*qconnect.PutFeedbackOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFeedback")
	}

	var r0 *qconnect.PutFeedbackOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) (*qconnect.PutFeedbackOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) *qconnect.PutFeedbackOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.PutFeedbackOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) QueryAssistant(ctx context.Context, params *qconnect.QueryAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.QueryAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryAssistant")
	}

	var r0 *qconnect.QueryAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) (*qconnect.QueryAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) *qconnect.QueryAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.QueryAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveKnowledgeBaseTemplateUri(ctx context.Context, params *qconnect.RemoveKnowledgeBaseTemplateUriInput, optFns ...func(*qconnect.Options)) (*qconnect.RemoveKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveKnowledgeBaseTemplateUri")
	}

	var r0 *qconnect.RemoveKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) (*qconnect.RemoveKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) *qconnect.RemoveKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.RemoveKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchContent(ctx context.Context, params *qconnect.SearchContentInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchContent")
	}

	var r0 *qconnect.SearchContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) (*qconnect.SearchContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) *qconnect.SearchContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchQuickResponses(ctx context.Context, params *qconnect.SearchQuickResponsesInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchQuickResponses")
	}

	var r0 *qconnect.SearchQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) (*qconnect.SearchQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) *qconnect.SearchQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchSessions(ctx context.Context, params *qconnect.SearchSessionsInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchSessions")
	}

	var r0 *qconnect.SearchSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) (*qconnect.SearchSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) *qconnect.SearchSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartContentUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartContentUpload(ctx context.Context, params *qconnect.StartContentUploadInput, optFns ...func(*qconnect.Options)) (*qconnect.StartContentUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartContentUpload")
	}

	var r0 *qconnect.StartContentUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) (*qconnect.StartContentUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) *qconnect.StartContentUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.StartContentUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImportJob(ctx context.Context, params *qconnect.StartImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.StartImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImportJob")
	}

	var r0 *qconnect.StartImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) (*qconnect.StartImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) *qconnect.StartImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.StartImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *qconnect.TagResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *qconnect.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) (*qconnect.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) *qconnect.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *qconnect.UntagResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *qconnect.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) (*qconnect.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) *qconnect.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateContent(ctx context.Context, params *qconnect.UpdateContentInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContent")
	}

	var r0 *qconnect.UpdateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) (*qconnect.UpdateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) *qconnect.UpdateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKnowledgeBaseTemplateUri(ctx context.Context, params *qconnect.UpdateKnowledgeBaseTemplateUriInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnowledgeBaseTemplateUri")
	}

	var r0 *qconnect.UpdateKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) (*qconnect.UpdateKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) *qconnect.UpdateKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQuickResponse(ctx context.Context, params *qconnect.UpdateQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQuickResponse")
	}

	var r0 *qconnect.UpdateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.UpdateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) *qconnect.UpdateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSession(ctx context.Context, params *qconnect.UpdateSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSession")
	}

	var r0 *qconnect.UpdateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) (*qconnect.UpdateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) *qconnect.UpdateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
