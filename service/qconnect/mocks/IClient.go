// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	qconnect "github.com/aws/aws-sdk-go-v2/service/qconnect"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// ActivateMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ActivateMessageTemplate(ctx context.Context, params *qconnect.ActivateMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.ActivateMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActivateMessageTemplate")
	}

	var r0 *qconnect.ActivateMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ActivateMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.ActivateMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ActivateMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.ActivateMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ActivateMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ActivateMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIAgent(ctx context.Context, params *qconnect.CreateAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIAgent")
	}

	var r0 *qconnect.CreateAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIAgentInput, ...func(*qconnect.Options)) (*qconnect.CreateAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIAgentInput, ...func(*qconnect.Options)) *qconnect.CreateAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIAgentVersion(ctx context.Context, params *qconnect.CreateAIAgentVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIAgentVersion")
	}

	var r0 *qconnect.CreateAIAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIAgentVersionInput, ...func(*qconnect.Options)) (*qconnect.CreateAIAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIAgentVersionInput, ...func(*qconnect.Options)) *qconnect.CreateAIAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIAgentVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIGuardrail(ctx context.Context, params *qconnect.CreateAIGuardrailInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIGuardrail")
	}

	var r0 *qconnect.CreateAIGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIGuardrailInput, ...func(*qconnect.Options)) (*qconnect.CreateAIGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIGuardrailInput, ...func(*qconnect.Options)) *qconnect.CreateAIGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIGuardrailInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIGuardrailVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIGuardrailVersion(ctx context.Context, params *qconnect.CreateAIGuardrailVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIGuardrailVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIGuardrailVersion")
	}

	var r0 *qconnect.CreateAIGuardrailVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIGuardrailVersionInput, ...func(*qconnect.Options)) (*qconnect.CreateAIGuardrailVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIGuardrailVersionInput, ...func(*qconnect.Options)) *qconnect.CreateAIGuardrailVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIGuardrailVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIGuardrailVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIPrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIPrompt(ctx context.Context, params *qconnect.CreateAIPromptInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIPromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIPrompt")
	}

	var r0 *qconnect.CreateAIPromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIPromptInput, ...func(*qconnect.Options)) (*qconnect.CreateAIPromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIPromptInput, ...func(*qconnect.Options)) *qconnect.CreateAIPromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIPromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIPromptInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAIPromptVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAIPromptVersion(ctx context.Context, params *qconnect.CreateAIPromptVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAIPromptVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAIPromptVersion")
	}

	var r0 *qconnect.CreateAIPromptVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIPromptVersionInput, ...func(*qconnect.Options)) (*qconnect.CreateAIPromptVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAIPromptVersionInput, ...func(*qconnect.Options)) *qconnect.CreateAIPromptVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAIPromptVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAIPromptVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistant(ctx context.Context, params *qconnect.CreateAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistant")
	}

	var r0 *qconnect.CreateAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) (*qconnect.CreateAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) *qconnect.CreateAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistantAssociation(ctx context.Context, params *qconnect.CreateAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistantAssociation")
	}

	var r0 *qconnect.CreateAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.CreateAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.CreateAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContent(ctx context.Context, params *qconnect.CreateContentInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContent")
	}

	var r0 *qconnect.CreateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) (*qconnect.CreateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) *qconnect.CreateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContentAssociation(ctx context.Context, params *qconnect.CreateContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContentAssociation")
	}

	var r0 *qconnect.CreateContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.CreateContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) *qconnect.CreateContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKnowledgeBase(ctx context.Context, params *qconnect.CreateKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKnowledgeBase")
	}

	var r0 *qconnect.CreateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.CreateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.CreateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMessageTemplate(ctx context.Context, params *qconnect.CreateMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessageTemplate")
	}

	var r0 *qconnect.CreateMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.CreateMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMessageTemplateAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMessageTemplateAttachment(ctx context.Context, params *qconnect.CreateMessageTemplateAttachmentInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessageTemplateAttachment")
	}

	var r0 *qconnect.CreateMessageTemplateAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateAttachmentInput, ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateAttachmentInput, ...func(*qconnect.Options)) *qconnect.CreateMessageTemplateAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateMessageTemplateAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateMessageTemplateAttachmentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMessageTemplateVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMessageTemplateVersion(ctx context.Context, params *qconnect.CreateMessageTemplateVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessageTemplateVersion")
	}

	var r0 *qconnect.CreateMessageTemplateVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateVersionInput, ...func(*qconnect.Options)) (*qconnect.CreateMessageTemplateVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateMessageTemplateVersionInput, ...func(*qconnect.Options)) *qconnect.CreateMessageTemplateVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateMessageTemplateVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateMessageTemplateVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateQuickResponse(ctx context.Context, params *qconnect.CreateQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateQuickResponse")
	}

	var r0 *qconnect.CreateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.CreateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) *qconnect.CreateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSession(ctx context.Context, params *qconnect.CreateSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.CreateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *qconnect.CreateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) (*qconnect.CreateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) *qconnect.CreateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.CreateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.CreateSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeactivateMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeactivateMessageTemplate(ctx context.Context, params *qconnect.DeactivateMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.DeactivateMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeactivateMessageTemplate")
	}

	var r0 *qconnect.DeactivateMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeactivateMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.DeactivateMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeactivateMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.DeactivateMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeactivateMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeactivateMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIAgent(ctx context.Context, params *qconnect.DeleteAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIAgent")
	}

	var r0 *qconnect.DeleteAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIAgentInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIAgentInput, ...func(*qconnect.Options)) *qconnect.DeleteAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIAgentVersion(ctx context.Context, params *qconnect.DeleteAIAgentVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIAgentVersion")
	}

	var r0 *qconnect.DeleteAIAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIAgentVersionInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIAgentVersionInput, ...func(*qconnect.Options)) *qconnect.DeleteAIAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIAgentVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIGuardrail(ctx context.Context, params *qconnect.DeleteAIGuardrailInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIGuardrail")
	}

	var r0 *qconnect.DeleteAIGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIGuardrailInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIGuardrailInput, ...func(*qconnect.Options)) *qconnect.DeleteAIGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIGuardrailInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIGuardrailVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIGuardrailVersion(ctx context.Context, params *qconnect.DeleteAIGuardrailVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIGuardrailVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIGuardrailVersion")
	}

	var r0 *qconnect.DeleteAIGuardrailVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIGuardrailVersionInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIGuardrailVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIGuardrailVersionInput, ...func(*qconnect.Options)) *qconnect.DeleteAIGuardrailVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIGuardrailVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIGuardrailVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIPrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIPrompt(ctx context.Context, params *qconnect.DeleteAIPromptInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIPromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIPrompt")
	}

	var r0 *qconnect.DeleteAIPromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIPromptInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIPromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIPromptInput, ...func(*qconnect.Options)) *qconnect.DeleteAIPromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIPromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIPromptInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAIPromptVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAIPromptVersion(ctx context.Context, params *qconnect.DeleteAIPromptVersionInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAIPromptVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAIPromptVersion")
	}

	var r0 *qconnect.DeleteAIPromptVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIPromptVersionInput, ...func(*qconnect.Options)) (*qconnect.DeleteAIPromptVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAIPromptVersionInput, ...func(*qconnect.Options)) *qconnect.DeleteAIPromptVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAIPromptVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAIPromptVersionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistant(ctx context.Context, params *qconnect.DeleteAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistant")
	}

	var r0 *qconnect.DeleteAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) (*qconnect.DeleteAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) *qconnect.DeleteAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistantAssociation(ctx context.Context, params *qconnect.DeleteAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistantAssociation")
	}

	var r0 *qconnect.DeleteAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.DeleteAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.DeleteAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContent(ctx context.Context, params *qconnect.DeleteContentInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContent")
	}

	var r0 *qconnect.DeleteContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) (*qconnect.DeleteContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) *qconnect.DeleteContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContentAssociation(ctx context.Context, params *qconnect.DeleteContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContentAssociation")
	}

	var r0 *qconnect.DeleteContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.DeleteContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) *qconnect.DeleteContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImportJob(ctx context.Context, params *qconnect.DeleteImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImportJob")
	}

	var r0 *qconnect.DeleteImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) (*qconnect.DeleteImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) *qconnect.DeleteImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKnowledgeBase(ctx context.Context, params *qconnect.DeleteKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnowledgeBase")
	}

	var r0 *qconnect.DeleteKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.DeleteKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.DeleteKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMessageTemplate(ctx context.Context, params *qconnect.DeleteMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessageTemplate")
	}

	var r0 *qconnect.DeleteMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.DeleteMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.DeleteMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMessageTemplateAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMessageTemplateAttachment(ctx context.Context, params *qconnect.DeleteMessageTemplateAttachmentInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteMessageTemplateAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessageTemplateAttachment")
	}

	var r0 *qconnect.DeleteMessageTemplateAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteMessageTemplateAttachmentInput, ...func(*qconnect.Options)) (*qconnect.DeleteMessageTemplateAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteMessageTemplateAttachmentInput, ...func(*qconnect.Options)) *qconnect.DeleteMessageTemplateAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteMessageTemplateAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteMessageTemplateAttachmentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQuickResponse(ctx context.Context, params *qconnect.DeleteQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.DeleteQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQuickResponse")
	}

	var r0 *qconnect.DeleteQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.DeleteQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) *qconnect.DeleteQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.DeleteQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.DeleteQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAIAgent(ctx context.Context, params *qconnect.GetAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAIAgent")
	}

	var r0 *qconnect.GetAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIAgentInput, ...func(*qconnect.Options)) (*qconnect.GetAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIAgentInput, ...func(*qconnect.Options)) *qconnect.GetAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAIGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAIGuardrail(ctx context.Context, params *qconnect.GetAIGuardrailInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAIGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAIGuardrail")
	}

	var r0 *qconnect.GetAIGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIGuardrailInput, ...func(*qconnect.Options)) (*qconnect.GetAIGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIGuardrailInput, ...func(*qconnect.Options)) *qconnect.GetAIGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAIGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAIGuardrailInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAIPrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAIPrompt(ctx context.Context, params *qconnect.GetAIPromptInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAIPromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAIPrompt")
	}

	var r0 *qconnect.GetAIPromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIPromptInput, ...func(*qconnect.Options)) (*qconnect.GetAIPromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAIPromptInput, ...func(*qconnect.Options)) *qconnect.GetAIPromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAIPromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAIPromptInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistant(ctx context.Context, params *qconnect.GetAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistant")
	}

	var r0 *qconnect.GetAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) (*qconnect.GetAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) *qconnect.GetAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistantAssociation(ctx context.Context, params *qconnect.GetAssistantAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.GetAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistantAssociation")
	}

	var r0 *qconnect.GetAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) (*qconnect.GetAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) *qconnect.GetAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetAssistantAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContent(ctx context.Context, params *qconnect.GetContentInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContent")
	}

	var r0 *qconnect.GetContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) (*qconnect.GetContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) *qconnect.GetContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentAssociation(ctx context.Context, params *qconnect.GetContentAssociationInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentAssociation")
	}

	var r0 *qconnect.GetContentAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) (*qconnect.GetContentAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) *qconnect.GetContentAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentAssociationInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentSummary(ctx context.Context, params *qconnect.GetContentSummaryInput, optFns ...func(*qconnect.Options)) (*qconnect.GetContentSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentSummary")
	}

	var r0 *qconnect.GetContentSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) (*qconnect.GetContentSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) *qconnect.GetContentSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetContentSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetContentSummaryInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImportJob(ctx context.Context, params *qconnect.GetImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.GetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImportJob")
	}

	var r0 *qconnect.GetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) (*qconnect.GetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) *qconnect.GetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKnowledgeBase(ctx context.Context, params *qconnect.GetKnowledgeBaseInput, optFns ...func(*qconnect.Options)) (*qconnect.GetKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKnowledgeBase")
	}

	var r0 *qconnect.GetKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) (*qconnect.GetKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) *qconnect.GetKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetKnowledgeBaseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMessageTemplate(ctx context.Context, params *qconnect.GetMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.GetMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMessageTemplate")
	}

	var r0 *qconnect.GetMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.GetMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.GetMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextMessage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNextMessage(ctx context.Context, params *qconnect.GetNextMessageInput, optFns ...func(*qconnect.Options)) (*qconnect.GetNextMessageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNextMessage")
	}

	var r0 *qconnect.GetNextMessageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetNextMessageInput, ...func(*qconnect.Options)) (*qconnect.GetNextMessageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetNextMessageInput, ...func(*qconnect.Options)) *qconnect.GetNextMessageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetNextMessageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetNextMessageInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQuickResponse(ctx context.Context, params *qconnect.GetQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.GetQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuickResponse")
	}

	var r0 *qconnect.GetQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.GetQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) *qconnect.GetQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecommendations(ctx context.Context, params *qconnect.GetRecommendationsInput, optFns ...func(*qconnect.Options)) (*qconnect.GetRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecommendations")
	}

	var r0 *qconnect.GetRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) (*qconnect.GetRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) *qconnect.GetRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetRecommendationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSession(ctx context.Context, params *qconnect.GetSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.GetSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *qconnect.GetSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) (*qconnect.GetSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) *qconnect.GetSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.GetSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.GetSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIAgentVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIAgentVersions(ctx context.Context, params *qconnect.ListAIAgentVersionsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIAgentVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIAgentVersions")
	}

	var r0 *qconnect.ListAIAgentVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIAgentVersionsInput, ...func(*qconnect.Options)) (*qconnect.ListAIAgentVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIAgentVersionsInput, ...func(*qconnect.Options)) *qconnect.ListAIAgentVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIAgentVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIAgentVersionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIAgents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIAgents(ctx context.Context, params *qconnect.ListAIAgentsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIAgentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIAgents")
	}

	var r0 *qconnect.ListAIAgentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIAgentsInput, ...func(*qconnect.Options)) (*qconnect.ListAIAgentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIAgentsInput, ...func(*qconnect.Options)) *qconnect.ListAIAgentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIAgentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIAgentsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIGuardrailVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIGuardrailVersions(ctx context.Context, params *qconnect.ListAIGuardrailVersionsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIGuardrailVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIGuardrailVersions")
	}

	var r0 *qconnect.ListAIGuardrailVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIGuardrailVersionsInput, ...func(*qconnect.Options)) (*qconnect.ListAIGuardrailVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIGuardrailVersionsInput, ...func(*qconnect.Options)) *qconnect.ListAIGuardrailVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIGuardrailVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIGuardrailVersionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIGuardrails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIGuardrails(ctx context.Context, params *qconnect.ListAIGuardrailsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIGuardrailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIGuardrails")
	}

	var r0 *qconnect.ListAIGuardrailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIGuardrailsInput, ...func(*qconnect.Options)) (*qconnect.ListAIGuardrailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIGuardrailsInput, ...func(*qconnect.Options)) *qconnect.ListAIGuardrailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIGuardrailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIGuardrailsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIPromptVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIPromptVersions(ctx context.Context, params *qconnect.ListAIPromptVersionsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIPromptVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIPromptVersions")
	}

	var r0 *qconnect.ListAIPromptVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIPromptVersionsInput, ...func(*qconnect.Options)) (*qconnect.ListAIPromptVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIPromptVersionsInput, ...func(*qconnect.Options)) *qconnect.ListAIPromptVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIPromptVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIPromptVersionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAIPrompts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAIPrompts(ctx context.Context, params *qconnect.ListAIPromptsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAIPromptsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAIPrompts")
	}

	var r0 *qconnect.ListAIPromptsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIPromptsInput, ...func(*qconnect.Options)) (*qconnect.ListAIPromptsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAIPromptsInput, ...func(*qconnect.Options)) *qconnect.ListAIPromptsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAIPromptsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAIPromptsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistantAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistantAssociations(ctx context.Context, params *qconnect.ListAssistantAssociationsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAssistantAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistantAssociations")
	}

	var r0 *qconnect.ListAssistantAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) (*qconnect.ListAssistantAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) *qconnect.ListAssistantAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAssistantAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAssistantAssociationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistants(ctx context.Context, params *qconnect.ListAssistantsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListAssistantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistants")
	}

	var r0 *qconnect.ListAssistantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) (*qconnect.ListAssistantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) *qconnect.ListAssistantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListAssistantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListAssistantsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContentAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContentAssociations(ctx context.Context, params *qconnect.ListContentAssociationsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListContentAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContentAssociations")
	}

	var r0 *qconnect.ListContentAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) (*qconnect.ListContentAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) *qconnect.ListContentAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListContentAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListContentAssociationsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContents(ctx context.Context, params *qconnect.ListContentsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListContentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContents")
	}

	var r0 *qconnect.ListContentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) (*qconnect.ListContentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) *qconnect.ListContentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListContentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListContentsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImportJobs(ctx context.Context, params *qconnect.ListImportJobsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImportJobs")
	}

	var r0 *qconnect.ListImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) (*qconnect.ListImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) *qconnect.ListImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListImportJobsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKnowledgeBases(ctx context.Context, params *qconnect.ListKnowledgeBasesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKnowledgeBases")
	}

	var r0 *qconnect.ListKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) (*qconnect.ListKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) *qconnect.ListKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListKnowledgeBasesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMessageTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMessageTemplateVersions(ctx context.Context, params *qconnect.ListMessageTemplateVersionsInput, optFns ...func(*qconnect.Options)) (*qconnect.ListMessageTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMessageTemplateVersions")
	}

	var r0 *qconnect.ListMessageTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessageTemplateVersionsInput, ...func(*qconnect.Options)) (*qconnect.ListMessageTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessageTemplateVersionsInput, ...func(*qconnect.Options)) *qconnect.ListMessageTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListMessageTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListMessageTemplateVersionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMessageTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMessageTemplates(ctx context.Context, params *qconnect.ListMessageTemplatesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListMessageTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMessageTemplates")
	}

	var r0 *qconnect.ListMessageTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessageTemplatesInput, ...func(*qconnect.Options)) (*qconnect.ListMessageTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessageTemplatesInput, ...func(*qconnect.Options)) *qconnect.ListMessageTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListMessageTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListMessageTemplatesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMessages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMessages(ctx context.Context, params *qconnect.ListMessagesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListMessagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMessages")
	}

	var r0 *qconnect.ListMessagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessagesInput, ...func(*qconnect.Options)) (*qconnect.ListMessagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListMessagesInput, ...func(*qconnect.Options)) *qconnect.ListMessagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListMessagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListMessagesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQuickResponses(ctx context.Context, params *qconnect.ListQuickResponsesInput, optFns ...func(*qconnect.Options)) (*qconnect.ListQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQuickResponses")
	}

	var r0 *qconnect.ListQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) (*qconnect.ListQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) *qconnect.ListQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListQuickResponsesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *qconnect.ListTagsForResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *qconnect.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) (*qconnect.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) *qconnect.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.ListTagsForResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyRecommendationsReceived provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) NotifyRecommendationsReceived(ctx context.Context, params *qconnect.NotifyRecommendationsReceivedInput, optFns ...func(*qconnect.Options)) (*qconnect.NotifyRecommendationsReceivedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotifyRecommendationsReceived")
	}

	var r0 *qconnect.NotifyRecommendationsReceivedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) (*qconnect.NotifyRecommendationsReceivedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) *qconnect.NotifyRecommendationsReceivedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.NotifyRecommendationsReceivedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.NotifyRecommendationsReceivedInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() qconnect.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 qconnect.Options
	if rf, ok := ret.Get(0).(func() qconnect.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(qconnect.Options)
	}

	return r0
}

// PutFeedback provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFeedback(ctx context.Context, params *qconnect.PutFeedbackInput, optFns ...func(*qconnect.Options)) (*qconnect.PutFeedbackOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFeedback")
	}

	var r0 *qconnect.PutFeedbackOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) (*qconnect.PutFeedbackOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) *qconnect.PutFeedbackOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.PutFeedbackOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.PutFeedbackInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) QueryAssistant(ctx context.Context, params *qconnect.QueryAssistantInput, optFns ...func(*qconnect.Options)) (*qconnect.QueryAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryAssistant")
	}

	var r0 *qconnect.QueryAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) (*qconnect.QueryAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) *qconnect.QueryAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.QueryAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.QueryAssistantInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveAssistantAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveAssistantAIAgent(ctx context.Context, params *qconnect.RemoveAssistantAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.RemoveAssistantAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAssistantAIAgent")
	}

	var r0 *qconnect.RemoveAssistantAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveAssistantAIAgentInput, ...func(*qconnect.Options)) (*qconnect.RemoveAssistantAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveAssistantAIAgentInput, ...func(*qconnect.Options)) *qconnect.RemoveAssistantAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.RemoveAssistantAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.RemoveAssistantAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveKnowledgeBaseTemplateUri(ctx context.Context, params *qconnect.RemoveKnowledgeBaseTemplateUriInput, optFns ...func(*qconnect.Options)) (*qconnect.RemoveKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveKnowledgeBaseTemplateUri")
	}

	var r0 *qconnect.RemoveKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) (*qconnect.RemoveKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) *qconnect.RemoveKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.RemoveKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.RemoveKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenderMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RenderMessageTemplate(ctx context.Context, params *qconnect.RenderMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.RenderMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RenderMessageTemplate")
	}

	var r0 *qconnect.RenderMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RenderMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.RenderMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.RenderMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.RenderMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.RenderMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.RenderMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchContent(ctx context.Context, params *qconnect.SearchContentInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchContent")
	}

	var r0 *qconnect.SearchContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) (*qconnect.SearchContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) *qconnect.SearchContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchMessageTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchMessageTemplates(ctx context.Context, params *qconnect.SearchMessageTemplatesInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchMessageTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchMessageTemplates")
	}

	var r0 *qconnect.SearchMessageTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchMessageTemplatesInput, ...func(*qconnect.Options)) (*qconnect.SearchMessageTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchMessageTemplatesInput, ...func(*qconnect.Options)) *qconnect.SearchMessageTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchMessageTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchMessageTemplatesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchQuickResponses(ctx context.Context, params *qconnect.SearchQuickResponsesInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchQuickResponses")
	}

	var r0 *qconnect.SearchQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) (*qconnect.SearchQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) *qconnect.SearchQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchQuickResponsesInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchSessions(ctx context.Context, params *qconnect.SearchSessionsInput, optFns ...func(*qconnect.Options)) (*qconnect.SearchSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchSessions")
	}

	var r0 *qconnect.SearchSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) (*qconnect.SearchSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) *qconnect.SearchSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SearchSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SearchSessionsInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendMessage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendMessage(ctx context.Context, params *qconnect.SendMessageInput, optFns ...func(*qconnect.Options)) (*qconnect.SendMessageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendMessage")
	}

	var r0 *qconnect.SendMessageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SendMessageInput, ...func(*qconnect.Options)) (*qconnect.SendMessageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.SendMessageInput, ...func(*qconnect.Options)) *qconnect.SendMessageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.SendMessageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.SendMessageInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartContentUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartContentUpload(ctx context.Context, params *qconnect.StartContentUploadInput, optFns ...func(*qconnect.Options)) (*qconnect.StartContentUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartContentUpload")
	}

	var r0 *qconnect.StartContentUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) (*qconnect.StartContentUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) *qconnect.StartContentUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.StartContentUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.StartContentUploadInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImportJob(ctx context.Context, params *qconnect.StartImportJobInput, optFns ...func(*qconnect.Options)) (*qconnect.StartImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImportJob")
	}

	var r0 *qconnect.StartImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) (*qconnect.StartImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) *qconnect.StartImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.StartImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.StartImportJobInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *qconnect.TagResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *qconnect.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) (*qconnect.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) *qconnect.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.TagResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *qconnect.UntagResourceInput, optFns ...func(*qconnect.Options)) (*qconnect.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *qconnect.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) (*qconnect.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) *qconnect.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UntagResourceInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAIAgent(ctx context.Context, params *qconnect.UpdateAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAIAgent")
	}

	var r0 *qconnect.UpdateAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIAgentInput, ...func(*qconnect.Options)) (*qconnect.UpdateAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIAgentInput, ...func(*qconnect.Options)) *qconnect.UpdateAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAIGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAIGuardrail(ctx context.Context, params *qconnect.UpdateAIGuardrailInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateAIGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAIGuardrail")
	}

	var r0 *qconnect.UpdateAIGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIGuardrailInput, ...func(*qconnect.Options)) (*qconnect.UpdateAIGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIGuardrailInput, ...func(*qconnect.Options)) *qconnect.UpdateAIGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateAIGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateAIGuardrailInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAIPrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAIPrompt(ctx context.Context, params *qconnect.UpdateAIPromptInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateAIPromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAIPrompt")
	}

	var r0 *qconnect.UpdateAIPromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIPromptInput, ...func(*qconnect.Options)) (*qconnect.UpdateAIPromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAIPromptInput, ...func(*qconnect.Options)) *qconnect.UpdateAIPromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateAIPromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateAIPromptInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssistantAIAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssistantAIAgent(ctx context.Context, params *qconnect.UpdateAssistantAIAgentInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateAssistantAIAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssistantAIAgent")
	}

	var r0 *qconnect.UpdateAssistantAIAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAssistantAIAgentInput, ...func(*qconnect.Options)) (*qconnect.UpdateAssistantAIAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateAssistantAIAgentInput, ...func(*qconnect.Options)) *qconnect.UpdateAssistantAIAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateAssistantAIAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateAssistantAIAgentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateContent(ctx context.Context, params *qconnect.UpdateContentInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContent")
	}

	var r0 *qconnect.UpdateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) (*qconnect.UpdateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) *qconnect.UpdateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateContentInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKnowledgeBaseTemplateUri(ctx context.Context, params *qconnect.UpdateKnowledgeBaseTemplateUriInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnowledgeBaseTemplateUri")
	}

	var r0 *qconnect.UpdateKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) (*qconnect.UpdateKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) *qconnect.UpdateKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateKnowledgeBaseTemplateUriInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMessageTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMessageTemplate(ctx context.Context, params *qconnect.UpdateMessageTemplateInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateMessageTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageTemplate")
	}

	var r0 *qconnect.UpdateMessageTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateMessageTemplateInput, ...func(*qconnect.Options)) (*qconnect.UpdateMessageTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateMessageTemplateInput, ...func(*qconnect.Options)) *qconnect.UpdateMessageTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateMessageTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateMessageTemplateInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMessageTemplateMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMessageTemplateMetadata(ctx context.Context, params *qconnect.UpdateMessageTemplateMetadataInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateMessageTemplateMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageTemplateMetadata")
	}

	var r0 *qconnect.UpdateMessageTemplateMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateMessageTemplateMetadataInput, ...func(*qconnect.Options)) (*qconnect.UpdateMessageTemplateMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateMessageTemplateMetadataInput, ...func(*qconnect.Options)) *qconnect.UpdateMessageTemplateMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateMessageTemplateMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateMessageTemplateMetadataInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQuickResponse(ctx context.Context, params *qconnect.UpdateQuickResponseInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQuickResponse")
	}

	var r0 *qconnect.UpdateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) (*qconnect.UpdateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) *qconnect.UpdateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateQuickResponseInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSession(ctx context.Context, params *qconnect.UpdateSessionInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSession")
	}

	var r0 *qconnect.UpdateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) (*qconnect.UpdateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) *qconnect.UpdateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateSessionInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSessionData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSessionData(ctx context.Context, params *qconnect.UpdateSessionDataInput, optFns ...func(*qconnect.Options)) (*qconnect.UpdateSessionDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSessionData")
	}

	var r0 *qconnect.UpdateSessionDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionDataInput, ...func(*qconnect.Options)) (*qconnect.UpdateSessionDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *qconnect.UpdateSessionDataInput, ...func(*qconnect.Options)) *qconnect.UpdateSessionDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qconnect.UpdateSessionDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *qconnect.UpdateSessionDataInput, ...func(*qconnect.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
