// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	codeartifact "github.com/aws/aws-sdk-go-v2/service/codeartifact"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateExternalConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateExternalConnection(ctx context.Context, params *codeartifact.AssociateExternalConnectionInput, optFns ...func(*codeartifact.Options)) (*codeartifact.AssociateExternalConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateExternalConnection")
	}

	var r0 *codeartifact.AssociateExternalConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.AssociateExternalConnectionInput, ...func(*codeartifact.Options)) (*codeartifact.AssociateExternalConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.AssociateExternalConnectionInput, ...func(*codeartifact.Options)) *codeartifact.AssociateExternalConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.AssociateExternalConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.AssociateExternalConnectionInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyPackageVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyPackageVersions(ctx context.Context, params *codeartifact.CopyPackageVersionsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.CopyPackageVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyPackageVersions")
	}

	var r0 *codeartifact.CopyPackageVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CopyPackageVersionsInput, ...func(*codeartifact.Options)) (*codeartifact.CopyPackageVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CopyPackageVersionsInput, ...func(*codeartifact.Options)) *codeartifact.CopyPackageVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.CopyPackageVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.CopyPackageVersionsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDomain(ctx context.Context, params *codeartifact.CreateDomainInput, optFns ...func(*codeartifact.Options)) (*codeartifact.CreateDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDomain")
	}

	var r0 *codeartifact.CreateDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreateDomainInput, ...func(*codeartifact.Options)) (*codeartifact.CreateDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreateDomainInput, ...func(*codeartifact.Options)) *codeartifact.CreateDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.CreateDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.CreateDomainInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePackageGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePackageGroup(ctx context.Context, params *codeartifact.CreatePackageGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.CreatePackageGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackageGroup")
	}

	var r0 *codeartifact.CreatePackageGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreatePackageGroupInput, ...func(*codeartifact.Options)) (*codeartifact.CreatePackageGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreatePackageGroupInput, ...func(*codeartifact.Options)) *codeartifact.CreatePackageGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.CreatePackageGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.CreatePackageGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRepository(ctx context.Context, params *codeartifact.CreateRepositoryInput, optFns ...func(*codeartifact.Options)) (*codeartifact.CreateRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepository")
	}

	var r0 *codeartifact.CreateRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreateRepositoryInput, ...func(*codeartifact.Options)) (*codeartifact.CreateRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.CreateRepositoryInput, ...func(*codeartifact.Options)) *codeartifact.CreateRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.CreateRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.CreateRepositoryInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDomain(ctx context.Context, params *codeartifact.DeleteDomainInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeleteDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomain")
	}

	var r0 *codeartifact.DeleteDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteDomainInput, ...func(*codeartifact.Options)) (*codeartifact.DeleteDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteDomainInput, ...func(*codeartifact.Options)) *codeartifact.DeleteDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeleteDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeleteDomainInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDomainPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDomainPermissionsPolicy(ctx context.Context, params *codeartifact.DeleteDomainPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeleteDomainPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomainPermissionsPolicy")
	}

	var r0 *codeartifact.DeleteDomainPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.DeleteDomainPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.DeleteDomainPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeleteDomainPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeleteDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePackage(ctx context.Context, params *codeartifact.DeletePackageInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeletePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 *codeartifact.DeletePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageInput, ...func(*codeartifact.Options)) (*codeartifact.DeletePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageInput, ...func(*codeartifact.Options)) *codeartifact.DeletePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeletePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeletePackageInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePackageGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePackageGroup(ctx context.Context, params *codeartifact.DeletePackageGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeletePackageGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackageGroup")
	}

	var r0 *codeartifact.DeletePackageGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageGroupInput, ...func(*codeartifact.Options)) (*codeartifact.DeletePackageGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageGroupInput, ...func(*codeartifact.Options)) *codeartifact.DeletePackageGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeletePackageGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeletePackageGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePackageVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePackageVersions(ctx context.Context, params *codeartifact.DeletePackageVersionsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeletePackageVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackageVersions")
	}

	var r0 *codeartifact.DeletePackageVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageVersionsInput, ...func(*codeartifact.Options)) (*codeartifact.DeletePackageVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeletePackageVersionsInput, ...func(*codeartifact.Options)) *codeartifact.DeletePackageVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeletePackageVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeletePackageVersionsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRepository(ctx context.Context, params *codeartifact.DeleteRepositoryInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeleteRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepository")
	}

	var r0 *codeartifact.DeleteRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteRepositoryInput, ...func(*codeartifact.Options)) (*codeartifact.DeleteRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteRepositoryInput, ...func(*codeartifact.Options)) *codeartifact.DeleteRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeleteRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeleteRepositoryInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRepositoryPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRepositoryPermissionsPolicy(ctx context.Context, params *codeartifact.DeleteRepositoryPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DeleteRepositoryPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepositoryPermissionsPolicy")
	}

	var r0 *codeartifact.DeleteRepositoryPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.DeleteRepositoryPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DeleteRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.DeleteRepositoryPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DeleteRepositoryPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DeleteRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomain(ctx context.Context, params *codeartifact.DescribeDomainInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DescribeDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomain")
	}

	var r0 *codeartifact.DescribeDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribeDomainInput, ...func(*codeartifact.Options)) (*codeartifact.DescribeDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribeDomainInput, ...func(*codeartifact.Options)) *codeartifact.DescribeDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DescribeDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DescribeDomainInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePackage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePackage(ctx context.Context, params *codeartifact.DescribePackageInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DescribePackageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePackage")
	}

	var r0 *codeartifact.DescribePackageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageInput, ...func(*codeartifact.Options)) (*codeartifact.DescribePackageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageInput, ...func(*codeartifact.Options)) *codeartifact.DescribePackageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DescribePackageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DescribePackageInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePackageGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePackageGroup(ctx context.Context, params *codeartifact.DescribePackageGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DescribePackageGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePackageGroup")
	}

	var r0 *codeartifact.DescribePackageGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageGroupInput, ...func(*codeartifact.Options)) (*codeartifact.DescribePackageGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageGroupInput, ...func(*codeartifact.Options)) *codeartifact.DescribePackageGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DescribePackageGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DescribePackageGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePackageVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePackageVersion(ctx context.Context, params *codeartifact.DescribePackageVersionInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DescribePackageVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePackageVersion")
	}

	var r0 *codeartifact.DescribePackageVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageVersionInput, ...func(*codeartifact.Options)) (*codeartifact.DescribePackageVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribePackageVersionInput, ...func(*codeartifact.Options)) *codeartifact.DescribePackageVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DescribePackageVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DescribePackageVersionInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRepository(ctx context.Context, params *codeartifact.DescribeRepositoryInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DescribeRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRepository")
	}

	var r0 *codeartifact.DescribeRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribeRepositoryInput, ...func(*codeartifact.Options)) (*codeartifact.DescribeRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DescribeRepositoryInput, ...func(*codeartifact.Options)) *codeartifact.DescribeRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DescribeRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DescribeRepositoryInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateExternalConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateExternalConnection(ctx context.Context, params *codeartifact.DisassociateExternalConnectionInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DisassociateExternalConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateExternalConnection")
	}

	var r0 *codeartifact.DisassociateExternalConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DisassociateExternalConnectionInput, ...func(*codeartifact.Options)) (*codeartifact.DisassociateExternalConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DisassociateExternalConnectionInput, ...func(*codeartifact.Options)) *codeartifact.DisassociateExternalConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DisassociateExternalConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DisassociateExternalConnectionInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisposePackageVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisposePackageVersions(ctx context.Context, params *codeartifact.DisposePackageVersionsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.DisposePackageVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisposePackageVersions")
	}

	var r0 *codeartifact.DisposePackageVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DisposePackageVersionsInput, ...func(*codeartifact.Options)) (*codeartifact.DisposePackageVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.DisposePackageVersionsInput, ...func(*codeartifact.Options)) *codeartifact.DisposePackageVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.DisposePackageVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.DisposePackageVersionsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedPackageGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssociatedPackageGroup(ctx context.Context, params *codeartifact.GetAssociatedPackageGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetAssociatedPackageGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssociatedPackageGroup")
	}

	var r0 *codeartifact.GetAssociatedPackageGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetAssociatedPackageGroupInput, ...func(*codeartifact.Options)) (*codeartifact.GetAssociatedPackageGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetAssociatedPackageGroupInput, ...func(*codeartifact.Options)) *codeartifact.GetAssociatedPackageGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetAssociatedPackageGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetAssociatedPackageGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthorizationToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAuthorizationToken(ctx context.Context, params *codeartifact.GetAuthorizationTokenInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetAuthorizationTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAuthorizationToken")
	}

	var r0 *codeartifact.GetAuthorizationTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetAuthorizationTokenInput, ...func(*codeartifact.Options)) (*codeartifact.GetAuthorizationTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetAuthorizationTokenInput, ...func(*codeartifact.Options)) *codeartifact.GetAuthorizationTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetAuthorizationTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetAuthorizationTokenInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDomainPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDomainPermissionsPolicy(ctx context.Context, params *codeartifact.GetDomainPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetDomainPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDomainPermissionsPolicy")
	}

	var r0 *codeartifact.GetDomainPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.GetDomainPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.GetDomainPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetDomainPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPackageVersionAsset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPackageVersionAsset(ctx context.Context, params *codeartifact.GetPackageVersionAssetInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionAssetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageVersionAsset")
	}

	var r0 *codeartifact.GetPackageVersionAssetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetPackageVersionAssetInput, ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionAssetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetPackageVersionAssetInput, ...func(*codeartifact.Options)) *codeartifact.GetPackageVersionAssetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetPackageVersionAssetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetPackageVersionAssetInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPackageVersionReadme provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPackageVersionReadme(ctx context.Context, params *codeartifact.GetPackageVersionReadmeInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionReadmeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageVersionReadme")
	}

	var r0 *codeartifact.GetPackageVersionReadmeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetPackageVersionReadmeInput, ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionReadmeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetPackageVersionReadmeInput, ...func(*codeartifact.Options)) *codeartifact.GetPackageVersionReadmeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetPackageVersionReadmeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetPackageVersionReadmeInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoryEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRepositoryEndpoint(ctx context.Context, params *codeartifact.GetRepositoryEndpointInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryEndpoint")
	}

	var r0 *codeartifact.GetRepositoryEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetRepositoryEndpointInput, ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetRepositoryEndpointInput, ...func(*codeartifact.Options)) *codeartifact.GetRepositoryEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetRepositoryEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetRepositoryEndpointInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoryPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRepositoryPermissionsPolicy(ctx context.Context, params *codeartifact.GetRepositoryPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryPermissionsPolicy")
	}

	var r0 *codeartifact.GetRepositoryPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.GetRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.GetRepositoryPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.GetRepositoryPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.GetRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAllowedRepositoriesForGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAllowedRepositoriesForGroup(ctx context.Context, params *codeartifact.ListAllowedRepositoriesForGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListAllowedRepositoriesForGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllowedRepositoriesForGroup")
	}

	var r0 *codeartifact.ListAllowedRepositoriesForGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListAllowedRepositoriesForGroupInput, ...func(*codeartifact.Options)) (*codeartifact.ListAllowedRepositoriesForGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListAllowedRepositoriesForGroupInput, ...func(*codeartifact.Options)) *codeartifact.ListAllowedRepositoriesForGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListAllowedRepositoriesForGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListAllowedRepositoriesForGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssociatedPackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssociatedPackages(ctx context.Context, params *codeartifact.ListAssociatedPackagesInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListAssociatedPackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssociatedPackages")
	}

	var r0 *codeartifact.ListAssociatedPackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListAssociatedPackagesInput, ...func(*codeartifact.Options)) (*codeartifact.ListAssociatedPackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListAssociatedPackagesInput, ...func(*codeartifact.Options)) *codeartifact.ListAssociatedPackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListAssociatedPackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListAssociatedPackagesInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomains(ctx context.Context, params *codeartifact.ListDomainsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomains")
	}

	var r0 *codeartifact.ListDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListDomainsInput, ...func(*codeartifact.Options)) (*codeartifact.ListDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListDomainsInput, ...func(*codeartifact.Options)) *codeartifact.ListDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListDomainsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackageGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackageGroups(ctx context.Context, params *codeartifact.ListPackageGroupsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListPackageGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageGroups")
	}

	var r0 *codeartifact.ListPackageGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageGroupsInput, ...func(*codeartifact.Options)) (*codeartifact.ListPackageGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageGroupsInput, ...func(*codeartifact.Options)) *codeartifact.ListPackageGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListPackageGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListPackageGroupsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackageVersionAssets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackageVersionAssets(ctx context.Context, params *codeartifact.ListPackageVersionAssetsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionAssetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageVersionAssets")
	}

	var r0 *codeartifact.ListPackageVersionAssetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionAssetsInput, ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionAssetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionAssetsInput, ...func(*codeartifact.Options)) *codeartifact.ListPackageVersionAssetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListPackageVersionAssetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListPackageVersionAssetsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackageVersionDependencies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackageVersionDependencies(ctx context.Context, params *codeartifact.ListPackageVersionDependenciesInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionDependenciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageVersionDependencies")
	}

	var r0 *codeartifact.ListPackageVersionDependenciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionDependenciesInput, ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionDependenciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionDependenciesInput, ...func(*codeartifact.Options)) *codeartifact.ListPackageVersionDependenciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListPackageVersionDependenciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListPackageVersionDependenciesInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackageVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackageVersions(ctx context.Context, params *codeartifact.ListPackageVersionsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageVersions")
	}

	var r0 *codeartifact.ListPackageVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionsInput, ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackageVersionsInput, ...func(*codeartifact.Options)) *codeartifact.ListPackageVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListPackageVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListPackageVersionsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPackages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPackages(ctx context.Context, params *codeartifact.ListPackagesInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListPackagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPackages")
	}

	var r0 *codeartifact.ListPackagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackagesInput, ...func(*codeartifact.Options)) (*codeartifact.ListPackagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListPackagesInput, ...func(*codeartifact.Options)) *codeartifact.ListPackagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListPackagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListPackagesInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRepositories(ctx context.Context, params *codeartifact.ListRepositoriesInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositories")
	}

	var r0 *codeartifact.ListRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListRepositoriesInput, ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListRepositoriesInput, ...func(*codeartifact.Options)) *codeartifact.ListRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListRepositoriesInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRepositoriesInDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRepositoriesInDomain(ctx context.Context, params *codeartifact.ListRepositoriesInDomainInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesInDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositoriesInDomain")
	}

	var r0 *codeartifact.ListRepositoriesInDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListRepositoriesInDomainInput, ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesInDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListRepositoriesInDomainInput, ...func(*codeartifact.Options)) *codeartifact.ListRepositoriesInDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListRepositoriesInDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListRepositoriesInDomainInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSubPackageGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSubPackageGroups(ctx context.Context, params *codeartifact.ListSubPackageGroupsInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListSubPackageGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubPackageGroups")
	}

	var r0 *codeartifact.ListSubPackageGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListSubPackageGroupsInput, ...func(*codeartifact.Options)) (*codeartifact.ListSubPackageGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListSubPackageGroupsInput, ...func(*codeartifact.Options)) *codeartifact.ListSubPackageGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListSubPackageGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListSubPackageGroupsInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *codeartifact.ListTagsForResourceInput, optFns ...func(*codeartifact.Options)) (*codeartifact.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *codeartifact.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListTagsForResourceInput, ...func(*codeartifact.Options)) (*codeartifact.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.ListTagsForResourceInput, ...func(*codeartifact.Options)) *codeartifact.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.ListTagsForResourceInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() codeartifact.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 codeartifact.Options
	if rf, ok := ret.Get(0).(func() codeartifact.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(codeartifact.Options)
	}

	return r0
}

// PublishPackageVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PublishPackageVersion(ctx context.Context, params *codeartifact.PublishPackageVersionInput, optFns ...func(*codeartifact.Options)) (*codeartifact.PublishPackageVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishPackageVersion")
	}

	var r0 *codeartifact.PublishPackageVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PublishPackageVersionInput, ...func(*codeartifact.Options)) (*codeartifact.PublishPackageVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PublishPackageVersionInput, ...func(*codeartifact.Options)) *codeartifact.PublishPackageVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.PublishPackageVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.PublishPackageVersionInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutDomainPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutDomainPermissionsPolicy(ctx context.Context, params *codeartifact.PutDomainPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.PutDomainPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutDomainPermissionsPolicy")
	}

	var r0 *codeartifact.PutDomainPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.PutDomainPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.PutDomainPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.PutDomainPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.PutDomainPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPackageOriginConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPackageOriginConfiguration(ctx context.Context, params *codeartifact.PutPackageOriginConfigurationInput, optFns ...func(*codeartifact.Options)) (*codeartifact.PutPackageOriginConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPackageOriginConfiguration")
	}

	var r0 *codeartifact.PutPackageOriginConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutPackageOriginConfigurationInput, ...func(*codeartifact.Options)) (*codeartifact.PutPackageOriginConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutPackageOriginConfigurationInput, ...func(*codeartifact.Options)) *codeartifact.PutPackageOriginConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.PutPackageOriginConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.PutPackageOriginConfigurationInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRepositoryPermissionsPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRepositoryPermissionsPolicy(ctx context.Context, params *codeartifact.PutRepositoryPermissionsPolicyInput, optFns ...func(*codeartifact.Options)) (*codeartifact.PutRepositoryPermissionsPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRepositoryPermissionsPolicy")
	}

	var r0 *codeartifact.PutRepositoryPermissionsPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) (*codeartifact.PutRepositoryPermissionsPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.PutRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) *codeartifact.PutRepositoryPermissionsPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.PutRepositoryPermissionsPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.PutRepositoryPermissionsPolicyInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *codeartifact.TagResourceInput, optFns ...func(*codeartifact.Options)) (*codeartifact.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *codeartifact.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.TagResourceInput, ...func(*codeartifact.Options)) (*codeartifact.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.TagResourceInput, ...func(*codeartifact.Options)) *codeartifact.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.TagResourceInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *codeartifact.UntagResourceInput, optFns ...func(*codeartifact.Options)) (*codeartifact.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *codeartifact.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UntagResourceInput, ...func(*codeartifact.Options)) (*codeartifact.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UntagResourceInput, ...func(*codeartifact.Options)) *codeartifact.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.UntagResourceInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackageGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackageGroup(ctx context.Context, params *codeartifact.UpdatePackageGroupInput, optFns ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageGroup")
	}

	var r0 *codeartifact.UpdatePackageGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageGroupInput, ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageGroupInput, ...func(*codeartifact.Options)) *codeartifact.UpdatePackageGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.UpdatePackageGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.UpdatePackageGroupInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackageGroupOriginConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackageGroupOriginConfiguration(ctx context.Context, params *codeartifact.UpdatePackageGroupOriginConfigurationInput, optFns ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageGroupOriginConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageGroupOriginConfiguration")
	}

	var r0 *codeartifact.UpdatePackageGroupOriginConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageGroupOriginConfigurationInput, ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageGroupOriginConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageGroupOriginConfigurationInput, ...func(*codeartifact.Options)) *codeartifact.UpdatePackageGroupOriginConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.UpdatePackageGroupOriginConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.UpdatePackageGroupOriginConfigurationInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePackageVersionsStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePackageVersionsStatus(ctx context.Context, params *codeartifact.UpdatePackageVersionsStatusInput, optFns ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageVersionsStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageVersionsStatus")
	}

	var r0 *codeartifact.UpdatePackageVersionsStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageVersionsStatusInput, ...func(*codeartifact.Options)) (*codeartifact.UpdatePackageVersionsStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdatePackageVersionsStatusInput, ...func(*codeartifact.Options)) *codeartifact.UpdatePackageVersionsStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.UpdatePackageVersionsStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.UpdatePackageVersionsStatusInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRepository(ctx context.Context, params *codeartifact.UpdateRepositoryInput, optFns ...func(*codeartifact.Options)) (*codeartifact.UpdateRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepository")
	}

	var r0 *codeartifact.UpdateRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdateRepositoryInput, ...func(*codeartifact.Options)) (*codeartifact.UpdateRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codeartifact.UpdateRepositoryInput, ...func(*codeartifact.Options)) *codeartifact.UpdateRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codeartifact.UpdateRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codeartifact.UpdateRepositoryInput, ...func(*codeartifact.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
