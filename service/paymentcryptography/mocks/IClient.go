// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	paymentcryptography "github.com/aws/aws-sdk-go-v2/service/paymentcryptography"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddKeyReplicationRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddKeyReplicationRegions(ctx context.Context, params *paymentcryptography.AddKeyReplicationRegionsInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.AddKeyReplicationRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddKeyReplicationRegions")
	}

	var r0 *paymentcryptography.AddKeyReplicationRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.AddKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.AddKeyReplicationRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.AddKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) *paymentcryptography.AddKeyReplicationRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.AddKeyReplicationRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.AddKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAlias(ctx context.Context, params *paymentcryptography.CreateAliasInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.CreateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 *paymentcryptography.CreateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.CreateAliasInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.CreateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.CreateAliasInput, ...func(*paymentcryptography.Options)) *paymentcryptography.CreateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.CreateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.CreateAliasInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKey(ctx context.Context, params *paymentcryptography.CreateKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.CreateKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKey")
	}

	var r0 *paymentcryptography.CreateKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.CreateKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.CreateKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.CreateKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.CreateKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.CreateKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.CreateKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAlias(ctx context.Context, params *paymentcryptography.DeleteAliasInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.DeleteAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAlias")
	}

	var r0 *paymentcryptography.DeleteAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DeleteAliasInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.DeleteAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DeleteAliasInput, ...func(*paymentcryptography.Options)) *paymentcryptography.DeleteAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.DeleteAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.DeleteAliasInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKey(ctx context.Context, params *paymentcryptography.DeleteKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.DeleteKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKey")
	}

	var r0 *paymentcryptography.DeleteKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DeleteKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.DeleteKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DeleteKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.DeleteKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.DeleteKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.DeleteKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableDefaultKeyReplicationRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableDefaultKeyReplicationRegions(ctx context.Context, params *paymentcryptography.DisableDefaultKeyReplicationRegionsInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.DisableDefaultKeyReplicationRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableDefaultKeyReplicationRegions")
	}

	var r0 *paymentcryptography.DisableDefaultKeyReplicationRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DisableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.DisableDefaultKeyReplicationRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.DisableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) *paymentcryptography.DisableDefaultKeyReplicationRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.DisableDefaultKeyReplicationRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.DisableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableDefaultKeyReplicationRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableDefaultKeyReplicationRegions(ctx context.Context, params *paymentcryptography.EnableDefaultKeyReplicationRegionsInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.EnableDefaultKeyReplicationRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableDefaultKeyReplicationRegions")
	}

	var r0 *paymentcryptography.EnableDefaultKeyReplicationRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.EnableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.EnableDefaultKeyReplicationRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.EnableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) *paymentcryptography.EnableDefaultKeyReplicationRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.EnableDefaultKeyReplicationRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.EnableDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportKey(ctx context.Context, params *paymentcryptography.ExportKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.ExportKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportKey")
	}

	var r0 *paymentcryptography.ExportKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ExportKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.ExportKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ExportKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.ExportKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.ExportKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.ExportKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAlias(ctx context.Context, params *paymentcryptography.GetAliasInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAlias")
	}

	var r0 *paymentcryptography.GetAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetAliasInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetAliasInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetAliasInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCertificateSigningRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCertificateSigningRequest(ctx context.Context, params *paymentcryptography.GetCertificateSigningRequestInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetCertificateSigningRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCertificateSigningRequest")
	}

	var r0 *paymentcryptography.GetCertificateSigningRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetCertificateSigningRequestInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetCertificateSigningRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetCertificateSigningRequestInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetCertificateSigningRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetCertificateSigningRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetCertificateSigningRequestInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultKeyReplicationRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDefaultKeyReplicationRegions(ctx context.Context, params *paymentcryptography.GetDefaultKeyReplicationRegionsInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetDefaultKeyReplicationRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDefaultKeyReplicationRegions")
	}

	var r0 *paymentcryptography.GetDefaultKeyReplicationRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetDefaultKeyReplicationRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetDefaultKeyReplicationRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetDefaultKeyReplicationRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetDefaultKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKey(ctx context.Context, params *paymentcryptography.GetKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKey")
	}

	var r0 *paymentcryptography.GetKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParametersForExport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetParametersForExport(ctx context.Context, params *paymentcryptography.GetParametersForExportInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetParametersForExportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParametersForExport")
	}

	var r0 *paymentcryptography.GetParametersForExportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetParametersForExportInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetParametersForExportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetParametersForExportInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetParametersForExportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetParametersForExportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetParametersForExportInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParametersForImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetParametersForImport(ctx context.Context, params *paymentcryptography.GetParametersForImportInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetParametersForImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParametersForImport")
	}

	var r0 *paymentcryptography.GetParametersForImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetParametersForImportInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetParametersForImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetParametersForImportInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetParametersForImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetParametersForImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetParametersForImportInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicKeyCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPublicKeyCertificate(ctx context.Context, params *paymentcryptography.GetPublicKeyCertificateInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.GetPublicKeyCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKeyCertificate")
	}

	var r0 *paymentcryptography.GetPublicKeyCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetPublicKeyCertificateInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.GetPublicKeyCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.GetPublicKeyCertificateInput, ...func(*paymentcryptography.Options)) *paymentcryptography.GetPublicKeyCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.GetPublicKeyCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.GetPublicKeyCertificateInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportKey(ctx context.Context, params *paymentcryptography.ImportKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.ImportKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportKey")
	}

	var r0 *paymentcryptography.ImportKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ImportKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.ImportKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ImportKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.ImportKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.ImportKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.ImportKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAliases(ctx context.Context, params *paymentcryptography.ListAliasesInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.ListAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAliases")
	}

	var r0 *paymentcryptography.ListAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListAliasesInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.ListAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListAliasesInput, ...func(*paymentcryptography.Options)) *paymentcryptography.ListAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.ListAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.ListAliasesInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeys(ctx context.Context, params *paymentcryptography.ListKeysInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.ListKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeys")
	}

	var r0 *paymentcryptography.ListKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListKeysInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.ListKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListKeysInput, ...func(*paymentcryptography.Options)) *paymentcryptography.ListKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.ListKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.ListKeysInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *paymentcryptography.ListTagsForResourceInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *paymentcryptography.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListTagsForResourceInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.ListTagsForResourceInput, ...func(*paymentcryptography.Options)) *paymentcryptography.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.ListTagsForResourceInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() paymentcryptography.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 paymentcryptography.Options
	if rf, ok := ret.Get(0).(func() paymentcryptography.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(paymentcryptography.Options)
	}

	return r0
}

// RemoveKeyReplicationRegions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveKeyReplicationRegions(ctx context.Context, params *paymentcryptography.RemoveKeyReplicationRegionsInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.RemoveKeyReplicationRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveKeyReplicationRegions")
	}

	var r0 *paymentcryptography.RemoveKeyReplicationRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.RemoveKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.RemoveKeyReplicationRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.RemoveKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) *paymentcryptography.RemoveKeyReplicationRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.RemoveKeyReplicationRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.RemoveKeyReplicationRegionsInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreKey(ctx context.Context, params *paymentcryptography.RestoreKeyInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.RestoreKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreKey")
	}

	var r0 *paymentcryptography.RestoreKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.RestoreKeyInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.RestoreKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.RestoreKeyInput, ...func(*paymentcryptography.Options)) *paymentcryptography.RestoreKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.RestoreKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.RestoreKeyInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartKeyUsage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartKeyUsage(ctx context.Context, params *paymentcryptography.StartKeyUsageInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.StartKeyUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartKeyUsage")
	}

	var r0 *paymentcryptography.StartKeyUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.StartKeyUsageInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.StartKeyUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.StartKeyUsageInput, ...func(*paymentcryptography.Options)) *paymentcryptography.StartKeyUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.StartKeyUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.StartKeyUsageInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopKeyUsage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopKeyUsage(ctx context.Context, params *paymentcryptography.StopKeyUsageInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.StopKeyUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopKeyUsage")
	}

	var r0 *paymentcryptography.StopKeyUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.StopKeyUsageInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.StopKeyUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.StopKeyUsageInput, ...func(*paymentcryptography.Options)) *paymentcryptography.StopKeyUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.StopKeyUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.StopKeyUsageInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *paymentcryptography.TagResourceInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *paymentcryptography.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.TagResourceInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.TagResourceInput, ...func(*paymentcryptography.Options)) *paymentcryptography.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.TagResourceInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *paymentcryptography.UntagResourceInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *paymentcryptography.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.UntagResourceInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.UntagResourceInput, ...func(*paymentcryptography.Options)) *paymentcryptography.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.UntagResourceInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAlias(ctx context.Context, params *paymentcryptography.UpdateAliasInput, optFns ...func(*paymentcryptography.Options)) (*paymentcryptography.UpdateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAlias")
	}

	var r0 *paymentcryptography.UpdateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.UpdateAliasInput, ...func(*paymentcryptography.Options)) (*paymentcryptography.UpdateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *paymentcryptography.UpdateAliasInput, ...func(*paymentcryptography.Options)) *paymentcryptography.UpdateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paymentcryptography.UpdateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *paymentcryptography.UpdateAliasInput, ...func(*paymentcryptography.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
