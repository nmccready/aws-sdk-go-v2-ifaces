// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	notifications "github.com/aws/aws-sdk-go-v2/service/notifications"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateChannel(ctx context.Context, params *notifications.AssociateChannelInput, optFns ...func(*notifications.Options)) (*notifications.AssociateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateChannel")
	}

	var r0 *notifications.AssociateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.AssociateChannelInput, ...func(*notifications.Options)) (*notifications.AssociateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.AssociateChannelInput, ...func(*notifications.Options)) *notifications.AssociateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.AssociateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.AssociateChannelInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventRule(ctx context.Context, params *notifications.CreateEventRuleInput, optFns ...func(*notifications.Options)) (*notifications.CreateEventRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventRule")
	}

	var r0 *notifications.CreateEventRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.CreateEventRuleInput, ...func(*notifications.Options)) (*notifications.CreateEventRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.CreateEventRuleInput, ...func(*notifications.Options)) *notifications.CreateEventRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.CreateEventRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.CreateEventRuleInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNotificationConfiguration(ctx context.Context, params *notifications.CreateNotificationConfigurationInput, optFns ...func(*notifications.Options)) (*notifications.CreateNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNotificationConfiguration")
	}

	var r0 *notifications.CreateNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.CreateNotificationConfigurationInput, ...func(*notifications.Options)) (*notifications.CreateNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.CreateNotificationConfigurationInput, ...func(*notifications.Options)) *notifications.CreateNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.CreateNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.CreateNotificationConfigurationInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventRule(ctx context.Context, params *notifications.DeleteEventRuleInput, optFns ...func(*notifications.Options)) (*notifications.DeleteEventRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventRule")
	}

	var r0 *notifications.DeleteEventRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeleteEventRuleInput, ...func(*notifications.Options)) (*notifications.DeleteEventRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeleteEventRuleInput, ...func(*notifications.Options)) *notifications.DeleteEventRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.DeleteEventRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.DeleteEventRuleInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNotificationConfiguration(ctx context.Context, params *notifications.DeleteNotificationConfigurationInput, optFns ...func(*notifications.Options)) (*notifications.DeleteNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNotificationConfiguration")
	}

	var r0 *notifications.DeleteNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeleteNotificationConfigurationInput, ...func(*notifications.Options)) (*notifications.DeleteNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeleteNotificationConfigurationInput, ...func(*notifications.Options)) *notifications.DeleteNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.DeleteNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.DeleteNotificationConfigurationInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterNotificationHub provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterNotificationHub(ctx context.Context, params *notifications.DeregisterNotificationHubInput, optFns ...func(*notifications.Options)) (*notifications.DeregisterNotificationHubOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterNotificationHub")
	}

	var r0 *notifications.DeregisterNotificationHubOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeregisterNotificationHubInput, ...func(*notifications.Options)) (*notifications.DeregisterNotificationHubOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DeregisterNotificationHubInput, ...func(*notifications.Options)) *notifications.DeregisterNotificationHubOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.DeregisterNotificationHubOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.DeregisterNotificationHubInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateChannel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateChannel(ctx context.Context, params *notifications.DisassociateChannelInput, optFns ...func(*notifications.Options)) (*notifications.DisassociateChannelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateChannel")
	}

	var r0 *notifications.DisassociateChannelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DisassociateChannelInput, ...func(*notifications.Options)) (*notifications.DisassociateChannelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.DisassociateChannelInput, ...func(*notifications.Options)) *notifications.DisassociateChannelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.DisassociateChannelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.DisassociateChannelInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventRule(ctx context.Context, params *notifications.GetEventRuleInput, optFns ...func(*notifications.Options)) (*notifications.GetEventRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventRule")
	}

	var r0 *notifications.GetEventRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetEventRuleInput, ...func(*notifications.Options)) (*notifications.GetEventRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetEventRuleInput, ...func(*notifications.Options)) *notifications.GetEventRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.GetEventRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.GetEventRuleInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNotificationConfiguration(ctx context.Context, params *notifications.GetNotificationConfigurationInput, optFns ...func(*notifications.Options)) (*notifications.GetNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNotificationConfiguration")
	}

	var r0 *notifications.GetNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetNotificationConfigurationInput, ...func(*notifications.Options)) (*notifications.GetNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetNotificationConfigurationInput, ...func(*notifications.Options)) *notifications.GetNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.GetNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.GetNotificationConfigurationInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNotificationEvent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNotificationEvent(ctx context.Context, params *notifications.GetNotificationEventInput, optFns ...func(*notifications.Options)) (*notifications.GetNotificationEventOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNotificationEvent")
	}

	var r0 *notifications.GetNotificationEventOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetNotificationEventInput, ...func(*notifications.Options)) (*notifications.GetNotificationEventOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.GetNotificationEventInput, ...func(*notifications.Options)) *notifications.GetNotificationEventOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.GetNotificationEventOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.GetNotificationEventInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChannels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListChannels(ctx context.Context, params *notifications.ListChannelsInput, optFns ...func(*notifications.Options)) (*notifications.ListChannelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 *notifications.ListChannelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListChannelsInput, ...func(*notifications.Options)) (*notifications.ListChannelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListChannelsInput, ...func(*notifications.Options)) *notifications.ListChannelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListChannelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListChannelsInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventRules(ctx context.Context, params *notifications.ListEventRulesInput, optFns ...func(*notifications.Options)) (*notifications.ListEventRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventRules")
	}

	var r0 *notifications.ListEventRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListEventRulesInput, ...func(*notifications.Options)) (*notifications.ListEventRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListEventRulesInput, ...func(*notifications.Options)) *notifications.ListEventRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListEventRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListEventRulesInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNotificationConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNotificationConfigurations(ctx context.Context, params *notifications.ListNotificationConfigurationsInput, optFns ...func(*notifications.Options)) (*notifications.ListNotificationConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNotificationConfigurations")
	}

	var r0 *notifications.ListNotificationConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationConfigurationsInput, ...func(*notifications.Options)) (*notifications.ListNotificationConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationConfigurationsInput, ...func(*notifications.Options)) *notifications.ListNotificationConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListNotificationConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListNotificationConfigurationsInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNotificationEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNotificationEvents(ctx context.Context, params *notifications.ListNotificationEventsInput, optFns ...func(*notifications.Options)) (*notifications.ListNotificationEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNotificationEvents")
	}

	var r0 *notifications.ListNotificationEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationEventsInput, ...func(*notifications.Options)) (*notifications.ListNotificationEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationEventsInput, ...func(*notifications.Options)) *notifications.ListNotificationEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListNotificationEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListNotificationEventsInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNotificationHubs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNotificationHubs(ctx context.Context, params *notifications.ListNotificationHubsInput, optFns ...func(*notifications.Options)) (*notifications.ListNotificationHubsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNotificationHubs")
	}

	var r0 *notifications.ListNotificationHubsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationHubsInput, ...func(*notifications.Options)) (*notifications.ListNotificationHubsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListNotificationHubsInput, ...func(*notifications.Options)) *notifications.ListNotificationHubsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListNotificationHubsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListNotificationHubsInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *notifications.ListTagsForResourceInput, optFns ...func(*notifications.Options)) (*notifications.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *notifications.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListTagsForResourceInput, ...func(*notifications.Options)) (*notifications.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.ListTagsForResourceInput, ...func(*notifications.Options)) *notifications.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.ListTagsForResourceInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() notifications.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 notifications.Options
	if rf, ok := ret.Get(0).(func() notifications.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(notifications.Options)
	}

	return r0
}

// RegisterNotificationHub provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterNotificationHub(ctx context.Context, params *notifications.RegisterNotificationHubInput, optFns ...func(*notifications.Options)) (*notifications.RegisterNotificationHubOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterNotificationHub")
	}

	var r0 *notifications.RegisterNotificationHubOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.RegisterNotificationHubInput, ...func(*notifications.Options)) (*notifications.RegisterNotificationHubOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.RegisterNotificationHubInput, ...func(*notifications.Options)) *notifications.RegisterNotificationHubOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.RegisterNotificationHubOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.RegisterNotificationHubInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *notifications.TagResourceInput, optFns ...func(*notifications.Options)) (*notifications.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *notifications.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.TagResourceInput, ...func(*notifications.Options)) (*notifications.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.TagResourceInput, ...func(*notifications.Options)) *notifications.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.TagResourceInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *notifications.UntagResourceInput, optFns ...func(*notifications.Options)) (*notifications.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *notifications.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UntagResourceInput, ...func(*notifications.Options)) (*notifications.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UntagResourceInput, ...func(*notifications.Options)) *notifications.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.UntagResourceInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventRule(ctx context.Context, params *notifications.UpdateEventRuleInput, optFns ...func(*notifications.Options)) (*notifications.UpdateEventRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventRule")
	}

	var r0 *notifications.UpdateEventRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UpdateEventRuleInput, ...func(*notifications.Options)) (*notifications.UpdateEventRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UpdateEventRuleInput, ...func(*notifications.Options)) *notifications.UpdateEventRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.UpdateEventRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.UpdateEventRuleInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateNotificationConfiguration(ctx context.Context, params *notifications.UpdateNotificationConfigurationInput, optFns ...func(*notifications.Options)) (*notifications.UpdateNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNotificationConfiguration")
	}

	var r0 *notifications.UpdateNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UpdateNotificationConfigurationInput, ...func(*notifications.Options)) (*notifications.UpdateNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *notifications.UpdateNotificationConfigurationInput, ...func(*notifications.Options)) *notifications.UpdateNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*notifications.UpdateNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *notifications.UpdateNotificationConfigurationInput, ...func(*notifications.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
