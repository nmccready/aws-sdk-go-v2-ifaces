// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	waf "github.com/aws/aws-sdk-go-v2/service/waf"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateByteMatchSet(ctx context.Context, params *waf.CreateByteMatchSetInput, optFns ...func(*waf.Options)) (*waf.CreateByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateByteMatchSet")
	}

	var r0 *waf.CreateByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateByteMatchSetInput, ...func(*waf.Options)) (*waf.CreateByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateByteMatchSetInput, ...func(*waf.Options)) *waf.CreateByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateByteMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGeoMatchSet(ctx context.Context, params *waf.CreateGeoMatchSetInput, optFns ...func(*waf.Options)) (*waf.CreateGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGeoMatchSet")
	}

	var r0 *waf.CreateGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateGeoMatchSetInput, ...func(*waf.Options)) (*waf.CreateGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateGeoMatchSetInput, ...func(*waf.Options)) *waf.CreateGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateGeoMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIPSet(ctx context.Context, params *waf.CreateIPSetInput, optFns ...func(*waf.Options)) (*waf.CreateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIPSet")
	}

	var r0 *waf.CreateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateIPSetInput, ...func(*waf.Options)) (*waf.CreateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateIPSetInput, ...func(*waf.Options)) *waf.CreateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateIPSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRateBasedRule(ctx context.Context, params *waf.CreateRateBasedRuleInput, optFns ...func(*waf.Options)) (*waf.CreateRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRateBasedRule")
	}

	var r0 *waf.CreateRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRateBasedRuleInput, ...func(*waf.Options)) (*waf.CreateRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRateBasedRuleInput, ...func(*waf.Options)) *waf.CreateRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateRateBasedRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegexMatchSet(ctx context.Context, params *waf.CreateRegexMatchSetInput, optFns ...func(*waf.Options)) (*waf.CreateRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegexMatchSet")
	}

	var r0 *waf.CreateRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRegexMatchSetInput, ...func(*waf.Options)) (*waf.CreateRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRegexMatchSetInput, ...func(*waf.Options)) *waf.CreateRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateRegexMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegexPatternSet(ctx context.Context, params *waf.CreateRegexPatternSetInput, optFns ...func(*waf.Options)) (*waf.CreateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegexPatternSet")
	}

	var r0 *waf.CreateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRegexPatternSetInput, ...func(*waf.Options)) (*waf.CreateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRegexPatternSetInput, ...func(*waf.Options)) *waf.CreateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateRegexPatternSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRule(ctx context.Context, params *waf.CreateRuleInput, optFns ...func(*waf.Options)) (*waf.CreateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 *waf.CreateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRuleInput, ...func(*waf.Options)) (*waf.CreateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRuleInput, ...func(*waf.Options)) *waf.CreateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRuleGroup(ctx context.Context, params *waf.CreateRuleGroupInput, optFns ...func(*waf.Options)) (*waf.CreateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRuleGroup")
	}

	var r0 *waf.CreateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRuleGroupInput, ...func(*waf.Options)) (*waf.CreateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateRuleGroupInput, ...func(*waf.Options)) *waf.CreateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateRuleGroupInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSizeConstraintSet(ctx context.Context, params *waf.CreateSizeConstraintSetInput, optFns ...func(*waf.Options)) (*waf.CreateSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSizeConstraintSet")
	}

	var r0 *waf.CreateSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateSizeConstraintSetInput, ...func(*waf.Options)) (*waf.CreateSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateSizeConstraintSetInput, ...func(*waf.Options)) *waf.CreateSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateSizeConstraintSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSqlInjectionMatchSet(ctx context.Context, params *waf.CreateSqlInjectionMatchSetInput, optFns ...func(*waf.Options)) (*waf.CreateSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSqlInjectionMatchSet")
	}

	var r0 *waf.CreateSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateSqlInjectionMatchSetInput, ...func(*waf.Options)) (*waf.CreateSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateSqlInjectionMatchSetInput, ...func(*waf.Options)) *waf.CreateSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateSqlInjectionMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebACL(ctx context.Context, params *waf.CreateWebACLInput, optFns ...func(*waf.Options)) (*waf.CreateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebACL")
	}

	var r0 *waf.CreateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateWebACLInput, ...func(*waf.Options)) (*waf.CreateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateWebACLInput, ...func(*waf.Options)) *waf.CreateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateWebACLInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebACLMigrationStack provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebACLMigrationStack(ctx context.Context, params *waf.CreateWebACLMigrationStackInput, optFns ...func(*waf.Options)) (*waf.CreateWebACLMigrationStackOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebACLMigrationStack")
	}

	var r0 *waf.CreateWebACLMigrationStackOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateWebACLMigrationStackInput, ...func(*waf.Options)) (*waf.CreateWebACLMigrationStackOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateWebACLMigrationStackInput, ...func(*waf.Options)) *waf.CreateWebACLMigrationStackOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateWebACLMigrationStackOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateWebACLMigrationStackInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateXssMatchSet(ctx context.Context, params *waf.CreateXssMatchSetInput, optFns ...func(*waf.Options)) (*waf.CreateXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateXssMatchSet")
	}

	var r0 *waf.CreateXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateXssMatchSetInput, ...func(*waf.Options)) (*waf.CreateXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.CreateXssMatchSetInput, ...func(*waf.Options)) *waf.CreateXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.CreateXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.CreateXssMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteByteMatchSet(ctx context.Context, params *waf.DeleteByteMatchSetInput, optFns ...func(*waf.Options)) (*waf.DeleteByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByteMatchSet")
	}

	var r0 *waf.DeleteByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteByteMatchSetInput, ...func(*waf.Options)) (*waf.DeleteByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteByteMatchSetInput, ...func(*waf.Options)) *waf.DeleteByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteByteMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGeoMatchSet(ctx context.Context, params *waf.DeleteGeoMatchSetInput, optFns ...func(*waf.Options)) (*waf.DeleteGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGeoMatchSet")
	}

	var r0 *waf.DeleteGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteGeoMatchSetInput, ...func(*waf.Options)) (*waf.DeleteGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteGeoMatchSetInput, ...func(*waf.Options)) *waf.DeleteGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteGeoMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIPSet(ctx context.Context, params *waf.DeleteIPSetInput, optFns ...func(*waf.Options)) (*waf.DeleteIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIPSet")
	}

	var r0 *waf.DeleteIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteIPSetInput, ...func(*waf.Options)) (*waf.DeleteIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteIPSetInput, ...func(*waf.Options)) *waf.DeleteIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteIPSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLoggingConfiguration(ctx context.Context, params *waf.DeleteLoggingConfigurationInput, optFns ...func(*waf.Options)) (*waf.DeleteLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoggingConfiguration")
	}

	var r0 *waf.DeleteLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteLoggingConfigurationInput, ...func(*waf.Options)) (*waf.DeleteLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteLoggingConfigurationInput, ...func(*waf.Options)) *waf.DeleteLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteLoggingConfigurationInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePermissionPolicy(ctx context.Context, params *waf.DeletePermissionPolicyInput, optFns ...func(*waf.Options)) (*waf.DeletePermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionPolicy")
	}

	var r0 *waf.DeletePermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeletePermissionPolicyInput, ...func(*waf.Options)) (*waf.DeletePermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeletePermissionPolicyInput, ...func(*waf.Options)) *waf.DeletePermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeletePermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeletePermissionPolicyInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRateBasedRule(ctx context.Context, params *waf.DeleteRateBasedRuleInput, optFns ...func(*waf.Options)) (*waf.DeleteRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRateBasedRule")
	}

	var r0 *waf.DeleteRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRateBasedRuleInput, ...func(*waf.Options)) (*waf.DeleteRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRateBasedRuleInput, ...func(*waf.Options)) *waf.DeleteRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteRateBasedRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegexMatchSet(ctx context.Context, params *waf.DeleteRegexMatchSetInput, optFns ...func(*waf.Options)) (*waf.DeleteRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegexMatchSet")
	}

	var r0 *waf.DeleteRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRegexMatchSetInput, ...func(*waf.Options)) (*waf.DeleteRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRegexMatchSetInput, ...func(*waf.Options)) *waf.DeleteRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteRegexMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegexPatternSet(ctx context.Context, params *waf.DeleteRegexPatternSetInput, optFns ...func(*waf.Options)) (*waf.DeleteRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegexPatternSet")
	}

	var r0 *waf.DeleteRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRegexPatternSetInput, ...func(*waf.Options)) (*waf.DeleteRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRegexPatternSetInput, ...func(*waf.Options)) *waf.DeleteRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteRegexPatternSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRule(ctx context.Context, params *waf.DeleteRuleInput, optFns ...func(*waf.Options)) (*waf.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 *waf.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRuleInput, ...func(*waf.Options)) (*waf.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRuleInput, ...func(*waf.Options)) *waf.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRuleGroup(ctx context.Context, params *waf.DeleteRuleGroupInput, optFns ...func(*waf.Options)) (*waf.DeleteRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRuleGroup")
	}

	var r0 *waf.DeleteRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRuleGroupInput, ...func(*waf.Options)) (*waf.DeleteRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteRuleGroupInput, ...func(*waf.Options)) *waf.DeleteRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteRuleGroupInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSizeConstraintSet(ctx context.Context, params *waf.DeleteSizeConstraintSetInput, optFns ...func(*waf.Options)) (*waf.DeleteSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSizeConstraintSet")
	}

	var r0 *waf.DeleteSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteSizeConstraintSetInput, ...func(*waf.Options)) (*waf.DeleteSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteSizeConstraintSetInput, ...func(*waf.Options)) *waf.DeleteSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteSizeConstraintSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSqlInjectionMatchSet(ctx context.Context, params *waf.DeleteSqlInjectionMatchSetInput, optFns ...func(*waf.Options)) (*waf.DeleteSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSqlInjectionMatchSet")
	}

	var r0 *waf.DeleteSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteSqlInjectionMatchSetInput, ...func(*waf.Options)) (*waf.DeleteSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteSqlInjectionMatchSetInput, ...func(*waf.Options)) *waf.DeleteSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteSqlInjectionMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWebACL(ctx context.Context, params *waf.DeleteWebACLInput, optFns ...func(*waf.Options)) (*waf.DeleteWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWebACL")
	}

	var r0 *waf.DeleteWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteWebACLInput, ...func(*waf.Options)) (*waf.DeleteWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteWebACLInput, ...func(*waf.Options)) *waf.DeleteWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteWebACLInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteXssMatchSet(ctx context.Context, params *waf.DeleteXssMatchSetInput, optFns ...func(*waf.Options)) (*waf.DeleteXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteXssMatchSet")
	}

	var r0 *waf.DeleteXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteXssMatchSetInput, ...func(*waf.Options)) (*waf.DeleteXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.DeleteXssMatchSetInput, ...func(*waf.Options)) *waf.DeleteXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.DeleteXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.DeleteXssMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetByteMatchSet(ctx context.Context, params *waf.GetByteMatchSetInput, optFns ...func(*waf.Options)) (*waf.GetByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetByteMatchSet")
	}

	var r0 *waf.GetByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetByteMatchSetInput, ...func(*waf.Options)) (*waf.GetByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetByteMatchSetInput, ...func(*waf.Options)) *waf.GetByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetByteMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChangeToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChangeToken(ctx context.Context, params *waf.GetChangeTokenInput, optFns ...func(*waf.Options)) (*waf.GetChangeTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChangeToken")
	}

	var r0 *waf.GetChangeTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetChangeTokenInput, ...func(*waf.Options)) (*waf.GetChangeTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetChangeTokenInput, ...func(*waf.Options)) *waf.GetChangeTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetChangeTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetChangeTokenInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChangeTokenStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChangeTokenStatus(ctx context.Context, params *waf.GetChangeTokenStatusInput, optFns ...func(*waf.Options)) (*waf.GetChangeTokenStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChangeTokenStatus")
	}

	var r0 *waf.GetChangeTokenStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetChangeTokenStatusInput, ...func(*waf.Options)) (*waf.GetChangeTokenStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetChangeTokenStatusInput, ...func(*waf.Options)) *waf.GetChangeTokenStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetChangeTokenStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetChangeTokenStatusInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGeoMatchSet(ctx context.Context, params *waf.GetGeoMatchSetInput, optFns ...func(*waf.Options)) (*waf.GetGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGeoMatchSet")
	}

	var r0 *waf.GetGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetGeoMatchSetInput, ...func(*waf.Options)) (*waf.GetGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetGeoMatchSetInput, ...func(*waf.Options)) *waf.GetGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetGeoMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIPSet(ctx context.Context, params *waf.GetIPSetInput, optFns ...func(*waf.Options)) (*waf.GetIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIPSet")
	}

	var r0 *waf.GetIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetIPSetInput, ...func(*waf.Options)) (*waf.GetIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetIPSetInput, ...func(*waf.Options)) *waf.GetIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetIPSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLoggingConfiguration(ctx context.Context, params *waf.GetLoggingConfigurationInput, optFns ...func(*waf.Options)) (*waf.GetLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLoggingConfiguration")
	}

	var r0 *waf.GetLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetLoggingConfigurationInput, ...func(*waf.Options)) (*waf.GetLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetLoggingConfigurationInput, ...func(*waf.Options)) *waf.GetLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetLoggingConfigurationInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPermissionPolicy(ctx context.Context, params *waf.GetPermissionPolicyInput, optFns ...func(*waf.Options)) (*waf.GetPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionPolicy")
	}

	var r0 *waf.GetPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetPermissionPolicyInput, ...func(*waf.Options)) (*waf.GetPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetPermissionPolicyInput, ...func(*waf.Options)) *waf.GetPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetPermissionPolicyInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRateBasedRule(ctx context.Context, params *waf.GetRateBasedRuleInput, optFns ...func(*waf.Options)) (*waf.GetRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRateBasedRule")
	}

	var r0 *waf.GetRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRateBasedRuleInput, ...func(*waf.Options)) (*waf.GetRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRateBasedRuleInput, ...func(*waf.Options)) *waf.GetRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRateBasedRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateBasedRuleManagedKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRateBasedRuleManagedKeys(ctx context.Context, params *waf.GetRateBasedRuleManagedKeysInput, optFns ...func(*waf.Options)) (*waf.GetRateBasedRuleManagedKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRateBasedRuleManagedKeys")
	}

	var r0 *waf.GetRateBasedRuleManagedKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRateBasedRuleManagedKeysInput, ...func(*waf.Options)) (*waf.GetRateBasedRuleManagedKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRateBasedRuleManagedKeysInput, ...func(*waf.Options)) *waf.GetRateBasedRuleManagedKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRateBasedRuleManagedKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRateBasedRuleManagedKeysInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegexMatchSet(ctx context.Context, params *waf.GetRegexMatchSetInput, optFns ...func(*waf.Options)) (*waf.GetRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegexMatchSet")
	}

	var r0 *waf.GetRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRegexMatchSetInput, ...func(*waf.Options)) (*waf.GetRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRegexMatchSetInput, ...func(*waf.Options)) *waf.GetRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRegexMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegexPatternSet(ctx context.Context, params *waf.GetRegexPatternSetInput, optFns ...func(*waf.Options)) (*waf.GetRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegexPatternSet")
	}

	var r0 *waf.GetRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRegexPatternSetInput, ...func(*waf.Options)) (*waf.GetRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRegexPatternSetInput, ...func(*waf.Options)) *waf.GetRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRegexPatternSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRule(ctx context.Context, params *waf.GetRuleInput, optFns ...func(*waf.Options)) (*waf.GetRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 *waf.GetRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRuleInput, ...func(*waf.Options)) (*waf.GetRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRuleInput, ...func(*waf.Options)) *waf.GetRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRuleGroup(ctx context.Context, params *waf.GetRuleGroupInput, optFns ...func(*waf.Options)) (*waf.GetRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRuleGroup")
	}

	var r0 *waf.GetRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRuleGroupInput, ...func(*waf.Options)) (*waf.GetRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetRuleGroupInput, ...func(*waf.Options)) *waf.GetRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetRuleGroupInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSampledRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSampledRequests(ctx context.Context, params *waf.GetSampledRequestsInput, optFns ...func(*waf.Options)) (*waf.GetSampledRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSampledRequests")
	}

	var r0 *waf.GetSampledRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSampledRequestsInput, ...func(*waf.Options)) (*waf.GetSampledRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSampledRequestsInput, ...func(*waf.Options)) *waf.GetSampledRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetSampledRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetSampledRequestsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSizeConstraintSet(ctx context.Context, params *waf.GetSizeConstraintSetInput, optFns ...func(*waf.Options)) (*waf.GetSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSizeConstraintSet")
	}

	var r0 *waf.GetSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSizeConstraintSetInput, ...func(*waf.Options)) (*waf.GetSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSizeConstraintSetInput, ...func(*waf.Options)) *waf.GetSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetSizeConstraintSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSqlInjectionMatchSet(ctx context.Context, params *waf.GetSqlInjectionMatchSetInput, optFns ...func(*waf.Options)) (*waf.GetSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSqlInjectionMatchSet")
	}

	var r0 *waf.GetSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSqlInjectionMatchSetInput, ...func(*waf.Options)) (*waf.GetSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetSqlInjectionMatchSetInput, ...func(*waf.Options)) *waf.GetSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetSqlInjectionMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWebACL(ctx context.Context, params *waf.GetWebACLInput, optFns ...func(*waf.Options)) (*waf.GetWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWebACL")
	}

	var r0 *waf.GetWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetWebACLInput, ...func(*waf.Options)) (*waf.GetWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetWebACLInput, ...func(*waf.Options)) *waf.GetWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetWebACLInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetXssMatchSet(ctx context.Context, params *waf.GetXssMatchSetInput, optFns ...func(*waf.Options)) (*waf.GetXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetXssMatchSet")
	}

	var r0 *waf.GetXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetXssMatchSetInput, ...func(*waf.Options)) (*waf.GetXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.GetXssMatchSetInput, ...func(*waf.Options)) *waf.GetXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.GetXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.GetXssMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActivatedRulesInRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActivatedRulesInRuleGroup(ctx context.Context, params *waf.ListActivatedRulesInRuleGroupInput, optFns ...func(*waf.Options)) (*waf.ListActivatedRulesInRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActivatedRulesInRuleGroup")
	}

	var r0 *waf.ListActivatedRulesInRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListActivatedRulesInRuleGroupInput, ...func(*waf.Options)) (*waf.ListActivatedRulesInRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListActivatedRulesInRuleGroupInput, ...func(*waf.Options)) *waf.ListActivatedRulesInRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListActivatedRulesInRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListActivatedRulesInRuleGroupInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListByteMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListByteMatchSets(ctx context.Context, params *waf.ListByteMatchSetsInput, optFns ...func(*waf.Options)) (*waf.ListByteMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListByteMatchSets")
	}

	var r0 *waf.ListByteMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListByteMatchSetsInput, ...func(*waf.Options)) (*waf.ListByteMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListByteMatchSetsInput, ...func(*waf.Options)) *waf.ListByteMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListByteMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListByteMatchSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGeoMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGeoMatchSets(ctx context.Context, params *waf.ListGeoMatchSetsInput, optFns ...func(*waf.Options)) (*waf.ListGeoMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGeoMatchSets")
	}

	var r0 *waf.ListGeoMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListGeoMatchSetsInput, ...func(*waf.Options)) (*waf.ListGeoMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListGeoMatchSetsInput, ...func(*waf.Options)) *waf.ListGeoMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListGeoMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListGeoMatchSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIPSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIPSets(ctx context.Context, params *waf.ListIPSetsInput, optFns ...func(*waf.Options)) (*waf.ListIPSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIPSets")
	}

	var r0 *waf.ListIPSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListIPSetsInput, ...func(*waf.Options)) (*waf.ListIPSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListIPSetsInput, ...func(*waf.Options)) *waf.ListIPSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListIPSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListIPSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLoggingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLoggingConfigurations(ctx context.Context, params *waf.ListLoggingConfigurationsInput, optFns ...func(*waf.Options)) (*waf.ListLoggingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLoggingConfigurations")
	}

	var r0 *waf.ListLoggingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListLoggingConfigurationsInput, ...func(*waf.Options)) (*waf.ListLoggingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListLoggingConfigurationsInput, ...func(*waf.Options)) *waf.ListLoggingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListLoggingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListLoggingConfigurationsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRateBasedRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRateBasedRules(ctx context.Context, params *waf.ListRateBasedRulesInput, optFns ...func(*waf.Options)) (*waf.ListRateBasedRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRateBasedRules")
	}

	var r0 *waf.ListRateBasedRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRateBasedRulesInput, ...func(*waf.Options)) (*waf.ListRateBasedRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRateBasedRulesInput, ...func(*waf.Options)) *waf.ListRateBasedRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListRateBasedRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListRateBasedRulesInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegexMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegexMatchSets(ctx context.Context, params *waf.ListRegexMatchSetsInput, optFns ...func(*waf.Options)) (*waf.ListRegexMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegexMatchSets")
	}

	var r0 *waf.ListRegexMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRegexMatchSetsInput, ...func(*waf.Options)) (*waf.ListRegexMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRegexMatchSetsInput, ...func(*waf.Options)) *waf.ListRegexMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListRegexMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListRegexMatchSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegexPatternSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegexPatternSets(ctx context.Context, params *waf.ListRegexPatternSetsInput, optFns ...func(*waf.Options)) (*waf.ListRegexPatternSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegexPatternSets")
	}

	var r0 *waf.ListRegexPatternSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRegexPatternSetsInput, ...func(*waf.Options)) (*waf.ListRegexPatternSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRegexPatternSetsInput, ...func(*waf.Options)) *waf.ListRegexPatternSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListRegexPatternSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListRegexPatternSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuleGroups(ctx context.Context, params *waf.ListRuleGroupsInput, optFns ...func(*waf.Options)) (*waf.ListRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuleGroups")
	}

	var r0 *waf.ListRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRuleGroupsInput, ...func(*waf.Options)) (*waf.ListRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRuleGroupsInput, ...func(*waf.Options)) *waf.ListRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListRuleGroupsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRules(ctx context.Context, params *waf.ListRulesInput, optFns ...func(*waf.Options)) (*waf.ListRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 *waf.ListRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRulesInput, ...func(*waf.Options)) (*waf.ListRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListRulesInput, ...func(*waf.Options)) *waf.ListRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListRulesInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSizeConstraintSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSizeConstraintSets(ctx context.Context, params *waf.ListSizeConstraintSetsInput, optFns ...func(*waf.Options)) (*waf.ListSizeConstraintSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSizeConstraintSets")
	}

	var r0 *waf.ListSizeConstraintSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSizeConstraintSetsInput, ...func(*waf.Options)) (*waf.ListSizeConstraintSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSizeConstraintSetsInput, ...func(*waf.Options)) *waf.ListSizeConstraintSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListSizeConstraintSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListSizeConstraintSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSqlInjectionMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSqlInjectionMatchSets(ctx context.Context, params *waf.ListSqlInjectionMatchSetsInput, optFns ...func(*waf.Options)) (*waf.ListSqlInjectionMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSqlInjectionMatchSets")
	}

	var r0 *waf.ListSqlInjectionMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSqlInjectionMatchSetsInput, ...func(*waf.Options)) (*waf.ListSqlInjectionMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSqlInjectionMatchSetsInput, ...func(*waf.Options)) *waf.ListSqlInjectionMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListSqlInjectionMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListSqlInjectionMatchSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSubscribedRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSubscribedRuleGroups(ctx context.Context, params *waf.ListSubscribedRuleGroupsInput, optFns ...func(*waf.Options)) (*waf.ListSubscribedRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubscribedRuleGroups")
	}

	var r0 *waf.ListSubscribedRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSubscribedRuleGroupsInput, ...func(*waf.Options)) (*waf.ListSubscribedRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListSubscribedRuleGroupsInput, ...func(*waf.Options)) *waf.ListSubscribedRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListSubscribedRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListSubscribedRuleGroupsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *waf.ListTagsForResourceInput, optFns ...func(*waf.Options)) (*waf.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *waf.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListTagsForResourceInput, ...func(*waf.Options)) (*waf.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListTagsForResourceInput, ...func(*waf.Options)) *waf.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListTagsForResourceInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWebACLs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWebACLs(ctx context.Context, params *waf.ListWebACLsInput, optFns ...func(*waf.Options)) (*waf.ListWebACLsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWebACLs")
	}

	var r0 *waf.ListWebACLsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListWebACLsInput, ...func(*waf.Options)) (*waf.ListWebACLsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListWebACLsInput, ...func(*waf.Options)) *waf.ListWebACLsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListWebACLsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListWebACLsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListXssMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListXssMatchSets(ctx context.Context, params *waf.ListXssMatchSetsInput, optFns ...func(*waf.Options)) (*waf.ListXssMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListXssMatchSets")
	}

	var r0 *waf.ListXssMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListXssMatchSetsInput, ...func(*waf.Options)) (*waf.ListXssMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.ListXssMatchSetsInput, ...func(*waf.Options)) *waf.ListXssMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.ListXssMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.ListXssMatchSetsInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() waf.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 waf.Options
	if rf, ok := ret.Get(0).(func() waf.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(waf.Options)
	}

	return r0
}

// PutLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLoggingConfiguration(ctx context.Context, params *waf.PutLoggingConfigurationInput, optFns ...func(*waf.Options)) (*waf.PutLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLoggingConfiguration")
	}

	var r0 *waf.PutLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.PutLoggingConfigurationInput, ...func(*waf.Options)) (*waf.PutLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.PutLoggingConfigurationInput, ...func(*waf.Options)) *waf.PutLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.PutLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.PutLoggingConfigurationInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPermissionPolicy(ctx context.Context, params *waf.PutPermissionPolicyInput, optFns ...func(*waf.Options)) (*waf.PutPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPermissionPolicy")
	}

	var r0 *waf.PutPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.PutPermissionPolicyInput, ...func(*waf.Options)) (*waf.PutPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.PutPermissionPolicyInput, ...func(*waf.Options)) *waf.PutPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.PutPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.PutPermissionPolicyInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *waf.TagResourceInput, optFns ...func(*waf.Options)) (*waf.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *waf.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.TagResourceInput, ...func(*waf.Options)) (*waf.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.TagResourceInput, ...func(*waf.Options)) *waf.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.TagResourceInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *waf.UntagResourceInput, optFns ...func(*waf.Options)) (*waf.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *waf.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UntagResourceInput, ...func(*waf.Options)) (*waf.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UntagResourceInput, ...func(*waf.Options)) *waf.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UntagResourceInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateByteMatchSet(ctx context.Context, params *waf.UpdateByteMatchSetInput, optFns ...func(*waf.Options)) (*waf.UpdateByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByteMatchSet")
	}

	var r0 *waf.UpdateByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateByteMatchSetInput, ...func(*waf.Options)) (*waf.UpdateByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateByteMatchSetInput, ...func(*waf.Options)) *waf.UpdateByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateByteMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGeoMatchSet(ctx context.Context, params *waf.UpdateGeoMatchSetInput, optFns ...func(*waf.Options)) (*waf.UpdateGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGeoMatchSet")
	}

	var r0 *waf.UpdateGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateGeoMatchSetInput, ...func(*waf.Options)) (*waf.UpdateGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateGeoMatchSetInput, ...func(*waf.Options)) *waf.UpdateGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateGeoMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIPSet(ctx context.Context, params *waf.UpdateIPSetInput, optFns ...func(*waf.Options)) (*waf.UpdateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIPSet")
	}

	var r0 *waf.UpdateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateIPSetInput, ...func(*waf.Options)) (*waf.UpdateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateIPSetInput, ...func(*waf.Options)) *waf.UpdateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateIPSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRateBasedRule(ctx context.Context, params *waf.UpdateRateBasedRuleInput, optFns ...func(*waf.Options)) (*waf.UpdateRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRateBasedRule")
	}

	var r0 *waf.UpdateRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRateBasedRuleInput, ...func(*waf.Options)) (*waf.UpdateRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRateBasedRuleInput, ...func(*waf.Options)) *waf.UpdateRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateRateBasedRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegexMatchSet(ctx context.Context, params *waf.UpdateRegexMatchSetInput, optFns ...func(*waf.Options)) (*waf.UpdateRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegexMatchSet")
	}

	var r0 *waf.UpdateRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRegexMatchSetInput, ...func(*waf.Options)) (*waf.UpdateRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRegexMatchSetInput, ...func(*waf.Options)) *waf.UpdateRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateRegexMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegexPatternSet(ctx context.Context, params *waf.UpdateRegexPatternSetInput, optFns ...func(*waf.Options)) (*waf.UpdateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegexPatternSet")
	}

	var r0 *waf.UpdateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRegexPatternSetInput, ...func(*waf.Options)) (*waf.UpdateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRegexPatternSetInput, ...func(*waf.Options)) *waf.UpdateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateRegexPatternSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRule(ctx context.Context, params *waf.UpdateRuleInput, optFns ...func(*waf.Options)) (*waf.UpdateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 *waf.UpdateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRuleInput, ...func(*waf.Options)) (*waf.UpdateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRuleInput, ...func(*waf.Options)) *waf.UpdateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateRuleInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleGroup(ctx context.Context, params *waf.UpdateRuleGroupInput, optFns ...func(*waf.Options)) (*waf.UpdateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleGroup")
	}

	var r0 *waf.UpdateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRuleGroupInput, ...func(*waf.Options)) (*waf.UpdateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateRuleGroupInput, ...func(*waf.Options)) *waf.UpdateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateRuleGroupInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSizeConstraintSet(ctx context.Context, params *waf.UpdateSizeConstraintSetInput, optFns ...func(*waf.Options)) (*waf.UpdateSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSizeConstraintSet")
	}

	var r0 *waf.UpdateSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateSizeConstraintSetInput, ...func(*waf.Options)) (*waf.UpdateSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateSizeConstraintSetInput, ...func(*waf.Options)) *waf.UpdateSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateSizeConstraintSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSqlInjectionMatchSet(ctx context.Context, params *waf.UpdateSqlInjectionMatchSetInput, optFns ...func(*waf.Options)) (*waf.UpdateSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSqlInjectionMatchSet")
	}

	var r0 *waf.UpdateSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateSqlInjectionMatchSetInput, ...func(*waf.Options)) (*waf.UpdateSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateSqlInjectionMatchSetInput, ...func(*waf.Options)) *waf.UpdateSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateSqlInjectionMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWebACL(ctx context.Context, params *waf.UpdateWebACLInput, optFns ...func(*waf.Options)) (*waf.UpdateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWebACL")
	}

	var r0 *waf.UpdateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateWebACLInput, ...func(*waf.Options)) (*waf.UpdateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateWebACLInput, ...func(*waf.Options)) *waf.UpdateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateWebACLInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateXssMatchSet(ctx context.Context, params *waf.UpdateXssMatchSetInput, optFns ...func(*waf.Options)) (*waf.UpdateXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateXssMatchSet")
	}

	var r0 *waf.UpdateXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateXssMatchSetInput, ...func(*waf.Options)) (*waf.UpdateXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *waf.UpdateXssMatchSetInput, ...func(*waf.Options)) *waf.UpdateXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*waf.UpdateXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *waf.UpdateXssMatchSetInput, ...func(*waf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
