// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	glacier "github.com/aws/aws-sdk-go-v2/service/glacier"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AbortMultipartUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AbortMultipartUpload(ctx context.Context, params *glacier.AbortMultipartUploadInput, optFns ...func(*glacier.Options)) (*glacier.AbortMultipartUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AbortMultipartUpload")
	}

	var r0 *glacier.AbortMultipartUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AbortMultipartUploadInput, ...func(*glacier.Options)) (*glacier.AbortMultipartUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AbortMultipartUploadInput, ...func(*glacier.Options)) *glacier.AbortMultipartUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.AbortMultipartUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.AbortMultipartUploadInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AbortVaultLock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AbortVaultLock(ctx context.Context, params *glacier.AbortVaultLockInput, optFns ...func(*glacier.Options)) (*glacier.AbortVaultLockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AbortVaultLock")
	}

	var r0 *glacier.AbortVaultLockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AbortVaultLockInput, ...func(*glacier.Options)) (*glacier.AbortVaultLockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AbortVaultLockInput, ...func(*glacier.Options)) *glacier.AbortVaultLockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.AbortVaultLockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.AbortVaultLockInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTagsToVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTagsToVault(ctx context.Context, params *glacier.AddTagsToVaultInput, optFns ...func(*glacier.Options)) (*glacier.AddTagsToVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToVault")
	}

	var r0 *glacier.AddTagsToVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AddTagsToVaultInput, ...func(*glacier.Options)) (*glacier.AddTagsToVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.AddTagsToVaultInput, ...func(*glacier.Options)) *glacier.AddTagsToVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.AddTagsToVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.AddTagsToVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteMultipartUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompleteMultipartUpload(ctx context.Context, params *glacier.CompleteMultipartUploadInput, optFns ...func(*glacier.Options)) (*glacier.CompleteMultipartUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompleteMultipartUpload")
	}

	var r0 *glacier.CompleteMultipartUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CompleteMultipartUploadInput, ...func(*glacier.Options)) (*glacier.CompleteMultipartUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CompleteMultipartUploadInput, ...func(*glacier.Options)) *glacier.CompleteMultipartUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.CompleteMultipartUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.CompleteMultipartUploadInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteVaultLock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompleteVaultLock(ctx context.Context, params *glacier.CompleteVaultLockInput, optFns ...func(*glacier.Options)) (*glacier.CompleteVaultLockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompleteVaultLock")
	}

	var r0 *glacier.CompleteVaultLockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CompleteVaultLockInput, ...func(*glacier.Options)) (*glacier.CompleteVaultLockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CompleteVaultLockInput, ...func(*glacier.Options)) *glacier.CompleteVaultLockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.CompleteVaultLockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.CompleteVaultLockInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVault(ctx context.Context, params *glacier.CreateVaultInput, optFns ...func(*glacier.Options)) (*glacier.CreateVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVault")
	}

	var r0 *glacier.CreateVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CreateVaultInput, ...func(*glacier.Options)) (*glacier.CreateVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.CreateVaultInput, ...func(*glacier.Options)) *glacier.CreateVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.CreateVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.CreateVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteArchive(ctx context.Context, params *glacier.DeleteArchiveInput, optFns ...func(*glacier.Options)) (*glacier.DeleteArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteArchive")
	}

	var r0 *glacier.DeleteArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteArchiveInput, ...func(*glacier.Options)) (*glacier.DeleteArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteArchiveInput, ...func(*glacier.Options)) *glacier.DeleteArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DeleteArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DeleteArchiveInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVault(ctx context.Context, params *glacier.DeleteVaultInput, optFns ...func(*glacier.Options)) (*glacier.DeleteVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVault")
	}

	var r0 *glacier.DeleteVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultInput, ...func(*glacier.Options)) (*glacier.DeleteVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultInput, ...func(*glacier.Options)) *glacier.DeleteVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DeleteVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DeleteVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVaultAccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVaultAccessPolicy(ctx context.Context, params *glacier.DeleteVaultAccessPolicyInput, optFns ...func(*glacier.Options)) (*glacier.DeleteVaultAccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVaultAccessPolicy")
	}

	var r0 *glacier.DeleteVaultAccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultAccessPolicyInput, ...func(*glacier.Options)) (*glacier.DeleteVaultAccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultAccessPolicyInput, ...func(*glacier.Options)) *glacier.DeleteVaultAccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DeleteVaultAccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DeleteVaultAccessPolicyInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVaultNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVaultNotifications(ctx context.Context, params *glacier.DeleteVaultNotificationsInput, optFns ...func(*glacier.Options)) (*glacier.DeleteVaultNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVaultNotifications")
	}

	var r0 *glacier.DeleteVaultNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultNotificationsInput, ...func(*glacier.Options)) (*glacier.DeleteVaultNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DeleteVaultNotificationsInput, ...func(*glacier.Options)) *glacier.DeleteVaultNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DeleteVaultNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DeleteVaultNotificationsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJob(ctx context.Context, params *glacier.DescribeJobInput, optFns ...func(*glacier.Options)) (*glacier.DescribeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJob")
	}

	var r0 *glacier.DescribeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DescribeJobInput, ...func(*glacier.Options)) (*glacier.DescribeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DescribeJobInput, ...func(*glacier.Options)) *glacier.DescribeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DescribeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DescribeJobInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVault(ctx context.Context, params *glacier.DescribeVaultInput, optFns ...func(*glacier.Options)) (*glacier.DescribeVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVault")
	}

	var r0 *glacier.DescribeVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DescribeVaultInput, ...func(*glacier.Options)) (*glacier.DescribeVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.DescribeVaultInput, ...func(*glacier.Options)) *glacier.DescribeVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.DescribeVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.DescribeVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRetrievalPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataRetrievalPolicy(ctx context.Context, params *glacier.GetDataRetrievalPolicyInput, optFns ...func(*glacier.Options)) (*glacier.GetDataRetrievalPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataRetrievalPolicy")
	}

	var r0 *glacier.GetDataRetrievalPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetDataRetrievalPolicyInput, ...func(*glacier.Options)) (*glacier.GetDataRetrievalPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetDataRetrievalPolicyInput, ...func(*glacier.Options)) *glacier.GetDataRetrievalPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.GetDataRetrievalPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.GetDataRetrievalPolicyInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobOutput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobOutput(ctx context.Context, params *glacier.GetJobOutputInput, optFns ...func(*glacier.Options)) (*glacier.GetJobOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobOutput")
	}

	var r0 *glacier.GetJobOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetJobOutputInput, ...func(*glacier.Options)) (*glacier.GetJobOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetJobOutputInput, ...func(*glacier.Options)) *glacier.GetJobOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.GetJobOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.GetJobOutputInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVaultAccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVaultAccessPolicy(ctx context.Context, params *glacier.GetVaultAccessPolicyInput, optFns ...func(*glacier.Options)) (*glacier.GetVaultAccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVaultAccessPolicy")
	}

	var r0 *glacier.GetVaultAccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultAccessPolicyInput, ...func(*glacier.Options)) (*glacier.GetVaultAccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultAccessPolicyInput, ...func(*glacier.Options)) *glacier.GetVaultAccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.GetVaultAccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.GetVaultAccessPolicyInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVaultLock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVaultLock(ctx context.Context, params *glacier.GetVaultLockInput, optFns ...func(*glacier.Options)) (*glacier.GetVaultLockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVaultLock")
	}

	var r0 *glacier.GetVaultLockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultLockInput, ...func(*glacier.Options)) (*glacier.GetVaultLockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultLockInput, ...func(*glacier.Options)) *glacier.GetVaultLockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.GetVaultLockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.GetVaultLockInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVaultNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVaultNotifications(ctx context.Context, params *glacier.GetVaultNotificationsInput, optFns ...func(*glacier.Options)) (*glacier.GetVaultNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVaultNotifications")
	}

	var r0 *glacier.GetVaultNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultNotificationsInput, ...func(*glacier.Options)) (*glacier.GetVaultNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.GetVaultNotificationsInput, ...func(*glacier.Options)) *glacier.GetVaultNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.GetVaultNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.GetVaultNotificationsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitiateJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InitiateJob(ctx context.Context, params *glacier.InitiateJobInput, optFns ...func(*glacier.Options)) (*glacier.InitiateJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InitiateJob")
	}

	var r0 *glacier.InitiateJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateJobInput, ...func(*glacier.Options)) (*glacier.InitiateJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateJobInput, ...func(*glacier.Options)) *glacier.InitiateJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.InitiateJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.InitiateJobInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitiateMultipartUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InitiateMultipartUpload(ctx context.Context, params *glacier.InitiateMultipartUploadInput, optFns ...func(*glacier.Options)) (*glacier.InitiateMultipartUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InitiateMultipartUpload")
	}

	var r0 *glacier.InitiateMultipartUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateMultipartUploadInput, ...func(*glacier.Options)) (*glacier.InitiateMultipartUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateMultipartUploadInput, ...func(*glacier.Options)) *glacier.InitiateMultipartUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.InitiateMultipartUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.InitiateMultipartUploadInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitiateVaultLock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) InitiateVaultLock(ctx context.Context, params *glacier.InitiateVaultLockInput, optFns ...func(*glacier.Options)) (*glacier.InitiateVaultLockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InitiateVaultLock")
	}

	var r0 *glacier.InitiateVaultLockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateVaultLockInput, ...func(*glacier.Options)) (*glacier.InitiateVaultLockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.InitiateVaultLockInput, ...func(*glacier.Options)) *glacier.InitiateVaultLockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.InitiateVaultLockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.InitiateVaultLockInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobs(ctx context.Context, params *glacier.ListJobsInput, optFns ...func(*glacier.Options)) (*glacier.ListJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 *glacier.ListJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListJobsInput, ...func(*glacier.Options)) (*glacier.ListJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListJobsInput, ...func(*glacier.Options)) *glacier.ListJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListJobsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMultipartUploads provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMultipartUploads(ctx context.Context, params *glacier.ListMultipartUploadsInput, optFns ...func(*glacier.Options)) (*glacier.ListMultipartUploadsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMultipartUploads")
	}

	var r0 *glacier.ListMultipartUploadsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListMultipartUploadsInput, ...func(*glacier.Options)) (*glacier.ListMultipartUploadsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListMultipartUploadsInput, ...func(*glacier.Options)) *glacier.ListMultipartUploadsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListMultipartUploadsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListMultipartUploadsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListParts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListParts(ctx context.Context, params *glacier.ListPartsInput, optFns ...func(*glacier.Options)) (*glacier.ListPartsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParts")
	}

	var r0 *glacier.ListPartsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListPartsInput, ...func(*glacier.Options)) (*glacier.ListPartsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListPartsInput, ...func(*glacier.Options)) *glacier.ListPartsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListPartsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListPartsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProvisionedCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProvisionedCapacity(ctx context.Context, params *glacier.ListProvisionedCapacityInput, optFns ...func(*glacier.Options)) (*glacier.ListProvisionedCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProvisionedCapacity")
	}

	var r0 *glacier.ListProvisionedCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListProvisionedCapacityInput, ...func(*glacier.Options)) (*glacier.ListProvisionedCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListProvisionedCapacityInput, ...func(*glacier.Options)) *glacier.ListProvisionedCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListProvisionedCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListProvisionedCapacityInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForVault(ctx context.Context, params *glacier.ListTagsForVaultInput, optFns ...func(*glacier.Options)) (*glacier.ListTagsForVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForVault")
	}

	var r0 *glacier.ListTagsForVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListTagsForVaultInput, ...func(*glacier.Options)) (*glacier.ListTagsForVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListTagsForVaultInput, ...func(*glacier.Options)) *glacier.ListTagsForVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListTagsForVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListTagsForVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVaults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVaults(ctx context.Context, params *glacier.ListVaultsInput, optFns ...func(*glacier.Options)) (*glacier.ListVaultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVaults")
	}

	var r0 *glacier.ListVaultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListVaultsInput, ...func(*glacier.Options)) (*glacier.ListVaultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.ListVaultsInput, ...func(*glacier.Options)) *glacier.ListVaultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.ListVaultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.ListVaultsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() glacier.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 glacier.Options
	if rf, ok := ret.Get(0).(func() glacier.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(glacier.Options)
	}

	return r0
}

// PurchaseProvisionedCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseProvisionedCapacity(ctx context.Context, params *glacier.PurchaseProvisionedCapacityInput, optFns ...func(*glacier.Options)) (*glacier.PurchaseProvisionedCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseProvisionedCapacity")
	}

	var r0 *glacier.PurchaseProvisionedCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.PurchaseProvisionedCapacityInput, ...func(*glacier.Options)) (*glacier.PurchaseProvisionedCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.PurchaseProvisionedCapacityInput, ...func(*glacier.Options)) *glacier.PurchaseProvisionedCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.PurchaseProvisionedCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.PurchaseProvisionedCapacityInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTagsFromVault provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTagsFromVault(ctx context.Context, params *glacier.RemoveTagsFromVaultInput, optFns ...func(*glacier.Options)) (*glacier.RemoveTagsFromVaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTagsFromVault")
	}

	var r0 *glacier.RemoveTagsFromVaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.RemoveTagsFromVaultInput, ...func(*glacier.Options)) (*glacier.RemoveTagsFromVaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.RemoveTagsFromVaultInput, ...func(*glacier.Options)) *glacier.RemoveTagsFromVaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.RemoveTagsFromVaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.RemoveTagsFromVaultInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetDataRetrievalPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetDataRetrievalPolicy(ctx context.Context, params *glacier.SetDataRetrievalPolicyInput, optFns ...func(*glacier.Options)) (*glacier.SetDataRetrievalPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetDataRetrievalPolicy")
	}

	var r0 *glacier.SetDataRetrievalPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetDataRetrievalPolicyInput, ...func(*glacier.Options)) (*glacier.SetDataRetrievalPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetDataRetrievalPolicyInput, ...func(*glacier.Options)) *glacier.SetDataRetrievalPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.SetDataRetrievalPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.SetDataRetrievalPolicyInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetVaultAccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetVaultAccessPolicy(ctx context.Context, params *glacier.SetVaultAccessPolicyInput, optFns ...func(*glacier.Options)) (*glacier.SetVaultAccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetVaultAccessPolicy")
	}

	var r0 *glacier.SetVaultAccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetVaultAccessPolicyInput, ...func(*glacier.Options)) (*glacier.SetVaultAccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetVaultAccessPolicyInput, ...func(*glacier.Options)) *glacier.SetVaultAccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.SetVaultAccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.SetVaultAccessPolicyInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetVaultNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetVaultNotifications(ctx context.Context, params *glacier.SetVaultNotificationsInput, optFns ...func(*glacier.Options)) (*glacier.SetVaultNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetVaultNotifications")
	}

	var r0 *glacier.SetVaultNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetVaultNotificationsInput, ...func(*glacier.Options)) (*glacier.SetVaultNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.SetVaultNotificationsInput, ...func(*glacier.Options)) *glacier.SetVaultNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.SetVaultNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.SetVaultNotificationsInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UploadArchive(ctx context.Context, params *glacier.UploadArchiveInput, optFns ...func(*glacier.Options)) (*glacier.UploadArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadArchive")
	}

	var r0 *glacier.UploadArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.UploadArchiveInput, ...func(*glacier.Options)) (*glacier.UploadArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.UploadArchiveInput, ...func(*glacier.Options)) *glacier.UploadArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.UploadArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.UploadArchiveInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadMultipartPart provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UploadMultipartPart(ctx context.Context, params *glacier.UploadMultipartPartInput, optFns ...func(*glacier.Options)) (*glacier.UploadMultipartPartOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadMultipartPart")
	}

	var r0 *glacier.UploadMultipartPartOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.UploadMultipartPartInput, ...func(*glacier.Options)) (*glacier.UploadMultipartPartOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glacier.UploadMultipartPartInput, ...func(*glacier.Options)) *glacier.UploadMultipartPartOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glacier.UploadMultipartPartOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glacier.UploadMultipartPartInput, ...func(*glacier.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
