// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	wisdom "github.com/aws/aws-sdk-go-v2/service/wisdom"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistant(ctx context.Context, params *wisdom.CreateAssistantInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistant")
	}

	var r0 *wisdom.CreateAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateAssistantInput, ...func(*wisdom.Options)) (*wisdom.CreateAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateAssistantInput, ...func(*wisdom.Options)) *wisdom.CreateAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateAssistantInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssistantAssociation(ctx context.Context, params *wisdom.CreateAssistantAssociationInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssistantAssociation")
	}

	var r0 *wisdom.CreateAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateAssistantAssociationInput, ...func(*wisdom.Options)) (*wisdom.CreateAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateAssistantAssociationInput, ...func(*wisdom.Options)) *wisdom.CreateAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateAssistantAssociationInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContent(ctx context.Context, params *wisdom.CreateContentInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContent")
	}

	var r0 *wisdom.CreateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateContentInput, ...func(*wisdom.Options)) (*wisdom.CreateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateContentInput, ...func(*wisdom.Options)) *wisdom.CreateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateContentInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKnowledgeBase(ctx context.Context, params *wisdom.CreateKnowledgeBaseInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKnowledgeBase")
	}

	var r0 *wisdom.CreateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateKnowledgeBaseInput, ...func(*wisdom.Options)) (*wisdom.CreateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateKnowledgeBaseInput, ...func(*wisdom.Options)) *wisdom.CreateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateKnowledgeBaseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateQuickResponse(ctx context.Context, params *wisdom.CreateQuickResponseInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateQuickResponse")
	}

	var r0 *wisdom.CreateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateQuickResponseInput, ...func(*wisdom.Options)) (*wisdom.CreateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateQuickResponseInput, ...func(*wisdom.Options)) *wisdom.CreateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateQuickResponseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSession(ctx context.Context, params *wisdom.CreateSessionInput, optFns ...func(*wisdom.Options)) (*wisdom.CreateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *wisdom.CreateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateSessionInput, ...func(*wisdom.Options)) (*wisdom.CreateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.CreateSessionInput, ...func(*wisdom.Options)) *wisdom.CreateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.CreateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.CreateSessionInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistant(ctx context.Context, params *wisdom.DeleteAssistantInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistant")
	}

	var r0 *wisdom.DeleteAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteAssistantInput, ...func(*wisdom.Options)) (*wisdom.DeleteAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteAssistantInput, ...func(*wisdom.Options)) *wisdom.DeleteAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteAssistantInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssistantAssociation(ctx context.Context, params *wisdom.DeleteAssistantAssociationInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssistantAssociation")
	}

	var r0 *wisdom.DeleteAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteAssistantAssociationInput, ...func(*wisdom.Options)) (*wisdom.DeleteAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteAssistantAssociationInput, ...func(*wisdom.Options)) *wisdom.DeleteAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteAssistantAssociationInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContent(ctx context.Context, params *wisdom.DeleteContentInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContent")
	}

	var r0 *wisdom.DeleteContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteContentInput, ...func(*wisdom.Options)) (*wisdom.DeleteContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteContentInput, ...func(*wisdom.Options)) *wisdom.DeleteContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteContentInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImportJob(ctx context.Context, params *wisdom.DeleteImportJobInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImportJob")
	}

	var r0 *wisdom.DeleteImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteImportJobInput, ...func(*wisdom.Options)) (*wisdom.DeleteImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteImportJobInput, ...func(*wisdom.Options)) *wisdom.DeleteImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteImportJobInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKnowledgeBase(ctx context.Context, params *wisdom.DeleteKnowledgeBaseInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnowledgeBase")
	}

	var r0 *wisdom.DeleteKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteKnowledgeBaseInput, ...func(*wisdom.Options)) (*wisdom.DeleteKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteKnowledgeBaseInput, ...func(*wisdom.Options)) *wisdom.DeleteKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteKnowledgeBaseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQuickResponse(ctx context.Context, params *wisdom.DeleteQuickResponseInput, optFns ...func(*wisdom.Options)) (*wisdom.DeleteQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQuickResponse")
	}

	var r0 *wisdom.DeleteQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteQuickResponseInput, ...func(*wisdom.Options)) (*wisdom.DeleteQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.DeleteQuickResponseInput, ...func(*wisdom.Options)) *wisdom.DeleteQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.DeleteQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.DeleteQuickResponseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistant(ctx context.Context, params *wisdom.GetAssistantInput, optFns ...func(*wisdom.Options)) (*wisdom.GetAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistant")
	}

	var r0 *wisdom.GetAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetAssistantInput, ...func(*wisdom.Options)) (*wisdom.GetAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetAssistantInput, ...func(*wisdom.Options)) *wisdom.GetAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetAssistantInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssistantAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssistantAssociation(ctx context.Context, params *wisdom.GetAssistantAssociationInput, optFns ...func(*wisdom.Options)) (*wisdom.GetAssistantAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssistantAssociation")
	}

	var r0 *wisdom.GetAssistantAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetAssistantAssociationInput, ...func(*wisdom.Options)) (*wisdom.GetAssistantAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetAssistantAssociationInput, ...func(*wisdom.Options)) *wisdom.GetAssistantAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetAssistantAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetAssistantAssociationInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContent(ctx context.Context, params *wisdom.GetContentInput, optFns ...func(*wisdom.Options)) (*wisdom.GetContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContent")
	}

	var r0 *wisdom.GetContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetContentInput, ...func(*wisdom.Options)) (*wisdom.GetContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetContentInput, ...func(*wisdom.Options)) *wisdom.GetContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetContentInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentSummary(ctx context.Context, params *wisdom.GetContentSummaryInput, optFns ...func(*wisdom.Options)) (*wisdom.GetContentSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentSummary")
	}

	var r0 *wisdom.GetContentSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetContentSummaryInput, ...func(*wisdom.Options)) (*wisdom.GetContentSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetContentSummaryInput, ...func(*wisdom.Options)) *wisdom.GetContentSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetContentSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetContentSummaryInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetImportJob(ctx context.Context, params *wisdom.GetImportJobInput, optFns ...func(*wisdom.Options)) (*wisdom.GetImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImportJob")
	}

	var r0 *wisdom.GetImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetImportJobInput, ...func(*wisdom.Options)) (*wisdom.GetImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetImportJobInput, ...func(*wisdom.Options)) *wisdom.GetImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetImportJobInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKnowledgeBase(ctx context.Context, params *wisdom.GetKnowledgeBaseInput, optFns ...func(*wisdom.Options)) (*wisdom.GetKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKnowledgeBase")
	}

	var r0 *wisdom.GetKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetKnowledgeBaseInput, ...func(*wisdom.Options)) (*wisdom.GetKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetKnowledgeBaseInput, ...func(*wisdom.Options)) *wisdom.GetKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetKnowledgeBaseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQuickResponse(ctx context.Context, params *wisdom.GetQuickResponseInput, optFns ...func(*wisdom.Options)) (*wisdom.GetQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuickResponse")
	}

	var r0 *wisdom.GetQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetQuickResponseInput, ...func(*wisdom.Options)) (*wisdom.GetQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetQuickResponseInput, ...func(*wisdom.Options)) *wisdom.GetQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetQuickResponseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecommendations(ctx context.Context, params *wisdom.GetRecommendationsInput, optFns ...func(*wisdom.Options)) (*wisdom.GetRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecommendations")
	}

	var r0 *wisdom.GetRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetRecommendationsInput, ...func(*wisdom.Options)) (*wisdom.GetRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetRecommendationsInput, ...func(*wisdom.Options)) *wisdom.GetRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetRecommendationsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSession(ctx context.Context, params *wisdom.GetSessionInput, optFns ...func(*wisdom.Options)) (*wisdom.GetSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *wisdom.GetSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetSessionInput, ...func(*wisdom.Options)) (*wisdom.GetSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.GetSessionInput, ...func(*wisdom.Options)) *wisdom.GetSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.GetSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.GetSessionInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistantAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistantAssociations(ctx context.Context, params *wisdom.ListAssistantAssociationsInput, optFns ...func(*wisdom.Options)) (*wisdom.ListAssistantAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistantAssociations")
	}

	var r0 *wisdom.ListAssistantAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListAssistantAssociationsInput, ...func(*wisdom.Options)) (*wisdom.ListAssistantAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListAssistantAssociationsInput, ...func(*wisdom.Options)) *wisdom.ListAssistantAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListAssistantAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListAssistantAssociationsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssistants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssistants(ctx context.Context, params *wisdom.ListAssistantsInput, optFns ...func(*wisdom.Options)) (*wisdom.ListAssistantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistants")
	}

	var r0 *wisdom.ListAssistantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListAssistantsInput, ...func(*wisdom.Options)) (*wisdom.ListAssistantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListAssistantsInput, ...func(*wisdom.Options)) *wisdom.ListAssistantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListAssistantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListAssistantsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContents(ctx context.Context, params *wisdom.ListContentsInput, optFns ...func(*wisdom.Options)) (*wisdom.ListContentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContents")
	}

	var r0 *wisdom.ListContentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListContentsInput, ...func(*wisdom.Options)) (*wisdom.ListContentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListContentsInput, ...func(*wisdom.Options)) *wisdom.ListContentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListContentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListContentsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListImportJobs(ctx context.Context, params *wisdom.ListImportJobsInput, optFns ...func(*wisdom.Options)) (*wisdom.ListImportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImportJobs")
	}

	var r0 *wisdom.ListImportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListImportJobsInput, ...func(*wisdom.Options)) (*wisdom.ListImportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListImportJobsInput, ...func(*wisdom.Options)) *wisdom.ListImportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListImportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListImportJobsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKnowledgeBases(ctx context.Context, params *wisdom.ListKnowledgeBasesInput, optFns ...func(*wisdom.Options)) (*wisdom.ListKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKnowledgeBases")
	}

	var r0 *wisdom.ListKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListKnowledgeBasesInput, ...func(*wisdom.Options)) (*wisdom.ListKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListKnowledgeBasesInput, ...func(*wisdom.Options)) *wisdom.ListKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListKnowledgeBasesInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQuickResponses(ctx context.Context, params *wisdom.ListQuickResponsesInput, optFns ...func(*wisdom.Options)) (*wisdom.ListQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQuickResponses")
	}

	var r0 *wisdom.ListQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListQuickResponsesInput, ...func(*wisdom.Options)) (*wisdom.ListQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListQuickResponsesInput, ...func(*wisdom.Options)) *wisdom.ListQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListQuickResponsesInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *wisdom.ListTagsForResourceInput, optFns ...func(*wisdom.Options)) (*wisdom.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *wisdom.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListTagsForResourceInput, ...func(*wisdom.Options)) (*wisdom.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.ListTagsForResourceInput, ...func(*wisdom.Options)) *wisdom.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.ListTagsForResourceInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyRecommendationsReceived provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) NotifyRecommendationsReceived(ctx context.Context, params *wisdom.NotifyRecommendationsReceivedInput, optFns ...func(*wisdom.Options)) (*wisdom.NotifyRecommendationsReceivedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotifyRecommendationsReceived")
	}

	var r0 *wisdom.NotifyRecommendationsReceivedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.NotifyRecommendationsReceivedInput, ...func(*wisdom.Options)) (*wisdom.NotifyRecommendationsReceivedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.NotifyRecommendationsReceivedInput, ...func(*wisdom.Options)) *wisdom.NotifyRecommendationsReceivedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.NotifyRecommendationsReceivedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.NotifyRecommendationsReceivedInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() wisdom.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 wisdom.Options
	if rf, ok := ret.Get(0).(func() wisdom.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wisdom.Options)
	}

	return r0
}

// QueryAssistant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) QueryAssistant(ctx context.Context, params *wisdom.QueryAssistantInput, optFns ...func(*wisdom.Options)) (*wisdom.QueryAssistantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryAssistant")
	}

	var r0 *wisdom.QueryAssistantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.QueryAssistantInput, ...func(*wisdom.Options)) (*wisdom.QueryAssistantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.QueryAssistantInput, ...func(*wisdom.Options)) *wisdom.QueryAssistantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.QueryAssistantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.QueryAssistantInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveKnowledgeBaseTemplateUri(ctx context.Context, params *wisdom.RemoveKnowledgeBaseTemplateUriInput, optFns ...func(*wisdom.Options)) (*wisdom.RemoveKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveKnowledgeBaseTemplateUri")
	}

	var r0 *wisdom.RemoveKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.RemoveKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) (*wisdom.RemoveKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.RemoveKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) *wisdom.RemoveKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.RemoveKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.RemoveKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchContent(ctx context.Context, params *wisdom.SearchContentInput, optFns ...func(*wisdom.Options)) (*wisdom.SearchContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchContent")
	}

	var r0 *wisdom.SearchContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchContentInput, ...func(*wisdom.Options)) (*wisdom.SearchContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchContentInput, ...func(*wisdom.Options)) *wisdom.SearchContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.SearchContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.SearchContentInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchQuickResponses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchQuickResponses(ctx context.Context, params *wisdom.SearchQuickResponsesInput, optFns ...func(*wisdom.Options)) (*wisdom.SearchQuickResponsesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchQuickResponses")
	}

	var r0 *wisdom.SearchQuickResponsesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchQuickResponsesInput, ...func(*wisdom.Options)) (*wisdom.SearchQuickResponsesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchQuickResponsesInput, ...func(*wisdom.Options)) *wisdom.SearchQuickResponsesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.SearchQuickResponsesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.SearchQuickResponsesInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchSessions(ctx context.Context, params *wisdom.SearchSessionsInput, optFns ...func(*wisdom.Options)) (*wisdom.SearchSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchSessions")
	}

	var r0 *wisdom.SearchSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchSessionsInput, ...func(*wisdom.Options)) (*wisdom.SearchSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.SearchSessionsInput, ...func(*wisdom.Options)) *wisdom.SearchSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.SearchSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.SearchSessionsInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartContentUpload provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartContentUpload(ctx context.Context, params *wisdom.StartContentUploadInput, optFns ...func(*wisdom.Options)) (*wisdom.StartContentUploadOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartContentUpload")
	}

	var r0 *wisdom.StartContentUploadOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.StartContentUploadInput, ...func(*wisdom.Options)) (*wisdom.StartContentUploadOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.StartContentUploadInput, ...func(*wisdom.Options)) *wisdom.StartContentUploadOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.StartContentUploadOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.StartContentUploadInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImportJob(ctx context.Context, params *wisdom.StartImportJobInput, optFns ...func(*wisdom.Options)) (*wisdom.StartImportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImportJob")
	}

	var r0 *wisdom.StartImportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.StartImportJobInput, ...func(*wisdom.Options)) (*wisdom.StartImportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.StartImportJobInput, ...func(*wisdom.Options)) *wisdom.StartImportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.StartImportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.StartImportJobInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *wisdom.TagResourceInput, optFns ...func(*wisdom.Options)) (*wisdom.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *wisdom.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.TagResourceInput, ...func(*wisdom.Options)) (*wisdom.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.TagResourceInput, ...func(*wisdom.Options)) *wisdom.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.TagResourceInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *wisdom.UntagResourceInput, optFns ...func(*wisdom.Options)) (*wisdom.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *wisdom.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UntagResourceInput, ...func(*wisdom.Options)) (*wisdom.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UntagResourceInput, ...func(*wisdom.Options)) *wisdom.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.UntagResourceInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateContent(ctx context.Context, params *wisdom.UpdateContentInput, optFns ...func(*wisdom.Options)) (*wisdom.UpdateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContent")
	}

	var r0 *wisdom.UpdateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateContentInput, ...func(*wisdom.Options)) (*wisdom.UpdateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateContentInput, ...func(*wisdom.Options)) *wisdom.UpdateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.UpdateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.UpdateContentInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKnowledgeBaseTemplateUri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKnowledgeBaseTemplateUri(ctx context.Context, params *wisdom.UpdateKnowledgeBaseTemplateUriInput, optFns ...func(*wisdom.Options)) (*wisdom.UpdateKnowledgeBaseTemplateUriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnowledgeBaseTemplateUri")
	}

	var r0 *wisdom.UpdateKnowledgeBaseTemplateUriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) (*wisdom.UpdateKnowledgeBaseTemplateUriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) *wisdom.UpdateKnowledgeBaseTemplateUriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.UpdateKnowledgeBaseTemplateUriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.UpdateKnowledgeBaseTemplateUriInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuickResponse provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQuickResponse(ctx context.Context, params *wisdom.UpdateQuickResponseInput, optFns ...func(*wisdom.Options)) (*wisdom.UpdateQuickResponseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQuickResponse")
	}

	var r0 *wisdom.UpdateQuickResponseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateQuickResponseInput, ...func(*wisdom.Options)) (*wisdom.UpdateQuickResponseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wisdom.UpdateQuickResponseInput, ...func(*wisdom.Options)) *wisdom.UpdateQuickResponseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wisdom.UpdateQuickResponseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wisdom.UpdateQuickResponseInput, ...func(*wisdom.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
