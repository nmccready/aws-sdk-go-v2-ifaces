// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	lookoutequipment "github.com/aws/aws-sdk-go-v2/service/lookoutequipment"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataset(ctx context.Context, params *lookoutequipment.CreateDatasetInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataset")
	}

	var r0 *lookoutequipment.CreateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateDatasetInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateDatasetInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateDatasetInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateInferenceScheduler(ctx context.Context, params *lookoutequipment.CreateInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInferenceScheduler")
	}

	var r0 *lookoutequipment.CreateInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLabel(ctx context.Context, params *lookoutequipment.CreateLabelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLabel")
	}

	var r0 *lookoutequipment.CreateLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateLabelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateLabelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateLabelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLabelGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLabelGroup(ctx context.Context, params *lookoutequipment.CreateLabelGroupInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateLabelGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLabelGroup")
	}

	var r0 *lookoutequipment.CreateLabelGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateLabelGroupInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateLabelGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateLabelGroupInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateLabelGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateLabelGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateLabelGroupInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateModel(ctx context.Context, params *lookoutequipment.CreateModelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateModel")
	}

	var r0 *lookoutequipment.CreateModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateModelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateModelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateModelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRetrainingScheduler(ctx context.Context, params *lookoutequipment.CreateRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRetrainingScheduler")
	}

	var r0 *lookoutequipment.CreateRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.CreateRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.CreateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.CreateRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.CreateRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.CreateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataset(ctx context.Context, params *lookoutequipment.DeleteDatasetInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataset")
	}

	var r0 *lookoutequipment.DeleteDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteDatasetInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteDatasetInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteDatasetInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteInferenceScheduler(ctx context.Context, params *lookoutequipment.DeleteInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInferenceScheduler")
	}

	var r0 *lookoutequipment.DeleteInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLabel(ctx context.Context, params *lookoutequipment.DeleteLabelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLabel")
	}

	var r0 *lookoutequipment.DeleteLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteLabelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteLabelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteLabelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLabelGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLabelGroup(ctx context.Context, params *lookoutequipment.DeleteLabelGroupInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteLabelGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLabelGroup")
	}

	var r0 *lookoutequipment.DeleteLabelGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteLabelGroupInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteLabelGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteLabelGroupInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteLabelGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteLabelGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteLabelGroupInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteModel(ctx context.Context, params *lookoutequipment.DeleteModelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteModel")
	}

	var r0 *lookoutequipment.DeleteModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteModelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteModelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteModelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *lookoutequipment.DeleteResourcePolicyInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *lookoutequipment.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteResourcePolicyInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteResourcePolicyInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteResourcePolicyInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRetrainingScheduler(ctx context.Context, params *lookoutequipment.DeleteRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRetrainingScheduler")
	}

	var r0 *lookoutequipment.DeleteRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DeleteRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DeleteRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DeleteRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DeleteRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DeleteRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataIngestionJob(ctx context.Context, params *lookoutequipment.DescribeDataIngestionJobInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeDataIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataIngestionJob")
	}

	var r0 *lookoutequipment.DescribeDataIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeDataIngestionJobInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeDataIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeDataIngestionJobInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeDataIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeDataIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeDataIngestionJobInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataset(ctx context.Context, params *lookoutequipment.DescribeDatasetInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataset")
	}

	var r0 *lookoutequipment.DescribeDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeDatasetInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeDatasetInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeDatasetInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInferenceScheduler(ctx context.Context, params *lookoutequipment.DescribeInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInferenceScheduler")
	}

	var r0 *lookoutequipment.DescribeInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLabel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLabel(ctx context.Context, params *lookoutequipment.DescribeLabelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeLabelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLabel")
	}

	var r0 *lookoutequipment.DescribeLabelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeLabelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeLabelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeLabelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeLabelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeLabelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeLabelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLabelGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLabelGroup(ctx context.Context, params *lookoutequipment.DescribeLabelGroupInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeLabelGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLabelGroup")
	}

	var r0 *lookoutequipment.DescribeLabelGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeLabelGroupInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeLabelGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeLabelGroupInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeLabelGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeLabelGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeLabelGroupInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeModel(ctx context.Context, params *lookoutequipment.DescribeModelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeModel")
	}

	var r0 *lookoutequipment.DescribeModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeModelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeModelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeModelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeModelVersion(ctx context.Context, params *lookoutequipment.DescribeModelVersionInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeModelVersion")
	}

	var r0 *lookoutequipment.DescribeModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeModelVersionInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeModelVersionInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeModelVersionInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResourcePolicy(ctx context.Context, params *lookoutequipment.DescribeResourcePolicyInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourcePolicy")
	}

	var r0 *lookoutequipment.DescribeResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeResourcePolicyInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeResourcePolicyInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeResourcePolicyInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRetrainingScheduler(ctx context.Context, params *lookoutequipment.DescribeRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRetrainingScheduler")
	}

	var r0 *lookoutequipment.DescribeRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.DescribeRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.DescribeRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.DescribeRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.DescribeRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.DescribeRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportDataset(ctx context.Context, params *lookoutequipment.ImportDatasetInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ImportDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportDataset")
	}

	var r0 *lookoutequipment.ImportDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ImportDatasetInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ImportDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ImportDatasetInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ImportDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ImportDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ImportDatasetInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportModelVersion(ctx context.Context, params *lookoutequipment.ImportModelVersionInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ImportModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportModelVersion")
	}

	var r0 *lookoutequipment.ImportModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ImportModelVersionInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ImportModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ImportModelVersionInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ImportModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ImportModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ImportModelVersionInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataIngestionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataIngestionJobs(ctx context.Context, params *lookoutequipment.ListDataIngestionJobsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListDataIngestionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataIngestionJobs")
	}

	var r0 *lookoutequipment.ListDataIngestionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListDataIngestionJobsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListDataIngestionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListDataIngestionJobsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListDataIngestionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListDataIngestionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListDataIngestionJobsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasets(ctx context.Context, params *lookoutequipment.ListDatasetsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListDatasetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasets")
	}

	var r0 *lookoutequipment.ListDatasetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListDatasetsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListDatasetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListDatasetsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListDatasetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListDatasetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListDatasetsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInferenceEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInferenceEvents(ctx context.Context, params *lookoutequipment.ListInferenceEventsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInferenceEvents")
	}

	var r0 *lookoutequipment.ListInferenceEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceEventsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceEventsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListInferenceEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListInferenceEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListInferenceEventsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInferenceExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInferenceExecutions(ctx context.Context, params *lookoutequipment.ListInferenceExecutionsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInferenceExecutions")
	}

	var r0 *lookoutequipment.ListInferenceExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceExecutionsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceExecutionsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListInferenceExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListInferenceExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListInferenceExecutionsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInferenceSchedulers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInferenceSchedulers(ctx context.Context, params *lookoutequipment.ListInferenceSchedulersInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceSchedulersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInferenceSchedulers")
	}

	var r0 *lookoutequipment.ListInferenceSchedulersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceSchedulersInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListInferenceSchedulersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListInferenceSchedulersInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListInferenceSchedulersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListInferenceSchedulersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListInferenceSchedulersInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLabelGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLabelGroups(ctx context.Context, params *lookoutequipment.ListLabelGroupsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListLabelGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLabelGroups")
	}

	var r0 *lookoutequipment.ListLabelGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListLabelGroupsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListLabelGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListLabelGroupsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListLabelGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListLabelGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListLabelGroupsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLabels(ctx context.Context, params *lookoutequipment.ListLabelsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLabels")
	}

	var r0 *lookoutequipment.ListLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListLabelsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListLabelsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListLabelsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListModelVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListModelVersions(ctx context.Context, params *lookoutequipment.ListModelVersionsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListModelVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListModelVersions")
	}

	var r0 *lookoutequipment.ListModelVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListModelVersionsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListModelVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListModelVersionsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListModelVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListModelVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListModelVersionsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListModels(ctx context.Context, params *lookoutequipment.ListModelsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListModels")
	}

	var r0 *lookoutequipment.ListModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListModelsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListModelsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListModelsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRetrainingSchedulers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRetrainingSchedulers(ctx context.Context, params *lookoutequipment.ListRetrainingSchedulersInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListRetrainingSchedulersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRetrainingSchedulers")
	}

	var r0 *lookoutequipment.ListRetrainingSchedulersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListRetrainingSchedulersInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListRetrainingSchedulersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListRetrainingSchedulersInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListRetrainingSchedulersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListRetrainingSchedulersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListRetrainingSchedulersInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSensorStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSensorStatistics(ctx context.Context, params *lookoutequipment.ListSensorStatisticsInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListSensorStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSensorStatistics")
	}

	var r0 *lookoutequipment.ListSensorStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListSensorStatisticsInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListSensorStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListSensorStatisticsInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListSensorStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListSensorStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListSensorStatisticsInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *lookoutequipment.ListTagsForResourceInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *lookoutequipment.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListTagsForResourceInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.ListTagsForResourceInput, ...func(*lookoutequipment.Options)) *lookoutequipment.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.ListTagsForResourceInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() lookoutequipment.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 lookoutequipment.Options
	if rf, ok := ret.Get(0).(func() lookoutequipment.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(lookoutequipment.Options)
	}

	return r0
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *lookoutequipment.PutResourcePolicyInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *lookoutequipment.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.PutResourcePolicyInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.PutResourcePolicyInput, ...func(*lookoutequipment.Options)) *lookoutequipment.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.PutResourcePolicyInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDataIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDataIngestionJob(ctx context.Context, params *lookoutequipment.StartDataIngestionJobInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.StartDataIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDataIngestionJob")
	}

	var r0 *lookoutequipment.StartDataIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartDataIngestionJobInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.StartDataIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartDataIngestionJobInput, ...func(*lookoutequipment.Options)) *lookoutequipment.StartDataIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.StartDataIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.StartDataIngestionJobInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartInferenceScheduler(ctx context.Context, params *lookoutequipment.StartInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.StartInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartInferenceScheduler")
	}

	var r0 *lookoutequipment.StartInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.StartInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.StartInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.StartInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.StartInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartRetrainingScheduler(ctx context.Context, params *lookoutequipment.StartRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.StartRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartRetrainingScheduler")
	}

	var r0 *lookoutequipment.StartRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.StartRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StartRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.StartRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.StartRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.StartRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopInferenceScheduler(ctx context.Context, params *lookoutequipment.StopInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.StopInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopInferenceScheduler")
	}

	var r0 *lookoutequipment.StopInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StopInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.StopInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StopInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.StopInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.StopInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.StopInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopRetrainingScheduler(ctx context.Context, params *lookoutequipment.StopRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.StopRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopRetrainingScheduler")
	}

	var r0 *lookoutequipment.StopRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StopRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.StopRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.StopRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.StopRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.StopRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.StopRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *lookoutequipment.TagResourceInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *lookoutequipment.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.TagResourceInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.TagResourceInput, ...func(*lookoutequipment.Options)) *lookoutequipment.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.TagResourceInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *lookoutequipment.UntagResourceInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *lookoutequipment.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UntagResourceInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UntagResourceInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UntagResourceInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateActiveModelVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateActiveModelVersion(ctx context.Context, params *lookoutequipment.UpdateActiveModelVersionInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateActiveModelVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateActiveModelVersion")
	}

	var r0 *lookoutequipment.UpdateActiveModelVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateActiveModelVersionInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateActiveModelVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateActiveModelVersionInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UpdateActiveModelVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UpdateActiveModelVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UpdateActiveModelVersionInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateInferenceScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateInferenceScheduler(ctx context.Context, params *lookoutequipment.UpdateInferenceSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateInferenceSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInferenceScheduler")
	}

	var r0 *lookoutequipment.UpdateInferenceSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateInferenceSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UpdateInferenceSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UpdateInferenceSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UpdateInferenceSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLabelGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLabelGroup(ctx context.Context, params *lookoutequipment.UpdateLabelGroupInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateLabelGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLabelGroup")
	}

	var r0 *lookoutequipment.UpdateLabelGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateLabelGroupInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateLabelGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateLabelGroupInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UpdateLabelGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UpdateLabelGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UpdateLabelGroupInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateModel(ctx context.Context, params *lookoutequipment.UpdateModelInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateModel")
	}

	var r0 *lookoutequipment.UpdateModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateModelInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateModelInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UpdateModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UpdateModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UpdateModelInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRetrainingScheduler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRetrainingScheduler(ctx context.Context, params *lookoutequipment.UpdateRetrainingSchedulerInput, optFns ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateRetrainingSchedulerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRetrainingScheduler")
	}

	var r0 *lookoutequipment.UpdateRetrainingSchedulerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) (*lookoutequipment.UpdateRetrainingSchedulerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lookoutequipment.UpdateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) *lookoutequipment.UpdateRetrainingSchedulerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lookoutequipment.UpdateRetrainingSchedulerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lookoutequipment.UpdateRetrainingSchedulerInput, ...func(*lookoutequipment.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
