// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	bedrockagent "github.com/aws/aws-sdk-go-v2/service/bedrockagent"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.AssociateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.AssociateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.AssociateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.AssociateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.AssociateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.AssociateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAgent(ctx context.Context, params *bedrockagent.CreateAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgent")
	}

	var r0 *bedrockagent.CreateAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAgentActionGroup(ctx context.Context, params *bedrockagent.CreateAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgentActionGroup")
	}

	var r0 *bedrockagent.CreateAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAgentAlias(ctx context.Context, params *bedrockagent.CreateAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgentAlias")
	}

	var r0 *bedrockagent.CreateAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataSource(ctx context.Context, params *bedrockagent.CreateDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataSource")
	}

	var r0 *bedrockagent.CreateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFlow(ctx context.Context, params *bedrockagent.CreateFlowInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlow")
	}

	var r0 *bedrockagent.CreateFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateFlowInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlowAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFlowAlias(ctx context.Context, params *bedrockagent.CreateFlowAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlowAlias")
	}

	var r0 *bedrockagent.CreateFlowAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateFlowAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateFlowAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateFlowAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlowVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFlowVersion(ctx context.Context, params *bedrockagent.CreateFlowVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlowVersion")
	}

	var r0 *bedrockagent.CreateFlowVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateFlowVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateFlowVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateFlowVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateFlowVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateFlowVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKnowledgeBase(ctx context.Context, params *bedrockagent.CreateKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKnowledgeBase")
	}

	var r0 *bedrockagent.CreateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePrompt(ctx context.Context, params *bedrockagent.CreatePromptInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreatePromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePrompt")
	}

	var r0 *bedrockagent.CreatePromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreatePromptInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreatePromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreatePromptInput, ...func(*bedrockagent.Options)) *bedrockagent.CreatePromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreatePromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreatePromptInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePromptVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePromptVersion(ctx context.Context, params *bedrockagent.CreatePromptVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreatePromptVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePromptVersion")
	}

	var r0 *bedrockagent.CreatePromptVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreatePromptVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreatePromptVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreatePromptVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.CreatePromptVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreatePromptVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreatePromptVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAgent(ctx context.Context, params *bedrockagent.DeleteAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgent")
	}

	var r0 *bedrockagent.DeleteAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAgentActionGroup(ctx context.Context, params *bedrockagent.DeleteAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentActionGroup")
	}

	var r0 *bedrockagent.DeleteAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAgentAlias(ctx context.Context, params *bedrockagent.DeleteAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentAlias")
	}

	var r0 *bedrockagent.DeleteAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAgentVersion(ctx context.Context, params *bedrockagent.DeleteAgentVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentVersion")
	}

	var r0 *bedrockagent.DeleteAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataSource(ctx context.Context, params *bedrockagent.DeleteDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataSource")
	}

	var r0 *bedrockagent.DeleteDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFlow(ctx context.Context, params *bedrockagent.DeleteFlowInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlow")
	}

	var r0 *bedrockagent.DeleteFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteFlowInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlowAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFlowAlias(ctx context.Context, params *bedrockagent.DeleteFlowAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlowAlias")
	}

	var r0 *bedrockagent.DeleteFlowAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteFlowAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteFlowAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteFlowAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlowVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFlowVersion(ctx context.Context, params *bedrockagent.DeleteFlowVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlowVersion")
	}

	var r0 *bedrockagent.DeleteFlowVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteFlowVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteFlowVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteFlowVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteFlowVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteFlowVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKnowledgeBase(ctx context.Context, params *bedrockagent.DeleteKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnowledgeBase")
	}

	var r0 *bedrockagent.DeleteKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePrompt(ctx context.Context, params *bedrockagent.DeletePromptInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeletePromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePrompt")
	}

	var r0 *bedrockagent.DeletePromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeletePromptInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeletePromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeletePromptInput, ...func(*bedrockagent.Options)) *bedrockagent.DeletePromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeletePromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeletePromptInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.DisassociateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DisassociateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.DisassociateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.DisassociateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.DisassociateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DisassociateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAgent(ctx context.Context, params *bedrockagent.GetAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgent")
	}

	var r0 *bedrockagent.GetAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAgentActionGroup(ctx context.Context, params *bedrockagent.GetAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentActionGroup")
	}

	var r0 *bedrockagent.GetAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAgentAlias(ctx context.Context, params *bedrockagent.GetAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentAlias")
	}

	var r0 *bedrockagent.GetAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAgentKnowledgeBase(ctx context.Context, params *bedrockagent.GetAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentKnowledgeBase")
	}

	var r0 *bedrockagent.GetAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAgentVersion(ctx context.Context, params *bedrockagent.GetAgentVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentVersion")
	}

	var r0 *bedrockagent.GetAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataSource(ctx context.Context, params *bedrockagent.GetDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSource")
	}

	var r0 *bedrockagent.GetDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.GetDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFlow(ctx context.Context, params *bedrockagent.GetFlowInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFlow")
	}

	var r0 *bedrockagent.GetFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowInput, ...func(*bedrockagent.Options)) *bedrockagent.GetFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetFlowInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlowAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFlowAlias(ctx context.Context, params *bedrockagent.GetFlowAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowAlias")
	}

	var r0 *bedrockagent.GetFlowAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.GetFlowAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetFlowAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetFlowAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlowVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFlowVersion(ctx context.Context, params *bedrockagent.GetFlowVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowVersion")
	}

	var r0 *bedrockagent.GetFlowVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetFlowVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetFlowVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.GetFlowVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetFlowVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetFlowVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIngestionJob(ctx context.Context, params *bedrockagent.GetIngestionJobInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIngestionJob")
	}

	var r0 *bedrockagent.GetIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) *bedrockagent.GetIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKnowledgeBase(ctx context.Context, params *bedrockagent.GetKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKnowledgeBase")
	}

	var r0 *bedrockagent.GetKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.GetKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPrompt(ctx context.Context, params *bedrockagent.GetPromptInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetPromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPrompt")
	}

	var r0 *bedrockagent.GetPromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetPromptInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetPromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetPromptInput, ...func(*bedrockagent.Options)) *bedrockagent.GetPromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetPromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetPromptInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentActionGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAgentActionGroups(ctx context.Context, params *bedrockagent.ListAgentActionGroupsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentActionGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentActionGroups")
	}

	var r0 *bedrockagent.ListAgentActionGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentActionGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentActionGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentActionGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAgentAliases(ctx context.Context, params *bedrockagent.ListAgentAliasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentAliases")
	}

	var r0 *bedrockagent.ListAgentAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAgentKnowledgeBases(ctx context.Context, params *bedrockagent.ListAgentKnowledgeBasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentKnowledgeBases")
	}

	var r0 *bedrockagent.ListAgentKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAgentVersions(ctx context.Context, params *bedrockagent.ListAgentVersionsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentVersions")
	}

	var r0 *bedrockagent.ListAgentVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAgents(ctx context.Context, params *bedrockagent.ListAgentsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgents")
	}

	var r0 *bedrockagent.ListAgentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSources(ctx context.Context, params *bedrockagent.ListDataSourcesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListDataSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSources")
	}

	var r0 *bedrockagent.ListDataSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListDataSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListDataSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListDataSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlowAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlowAliases(ctx context.Context, params *bedrockagent.ListFlowAliasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlowAliases")
	}

	var r0 *bedrockagent.ListFlowAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowAliasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowAliasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListFlowAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListFlowAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListFlowAliasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlowVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlowVersions(ctx context.Context, params *bedrockagent.ListFlowVersionsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlowVersions")
	}

	var r0 *bedrockagent.ListFlowVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowVersionsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowVersionsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListFlowVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListFlowVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListFlowVersionsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlows(ctx context.Context, params *bedrockagent.ListFlowsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlows")
	}

	var r0 *bedrockagent.ListFlowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListFlowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListFlowsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListFlowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListFlowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListFlowsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIngestionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIngestionJobs(ctx context.Context, params *bedrockagent.ListIngestionJobsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListIngestionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIngestionJobs")
	}

	var r0 *bedrockagent.ListIngestionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListIngestionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListIngestionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListIngestionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKnowledgeBases(ctx context.Context, params *bedrockagent.ListKnowledgeBasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKnowledgeBases")
	}

	var r0 *bedrockagent.ListKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPrompts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPrompts(ctx context.Context, params *bedrockagent.ListPromptsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListPromptsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPrompts")
	}

	var r0 *bedrockagent.ListPromptsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListPromptsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListPromptsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListPromptsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListPromptsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListPromptsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListPromptsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *bedrockagent.ListTagsForResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *bedrockagent.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() bedrockagent.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 bedrockagent.Options
	if rf, ok := ret.Get(0).(func() bedrockagent.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bedrockagent.Options)
	}

	return r0
}

// PrepareAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PrepareAgent(ctx context.Context, params *bedrockagent.PrepareAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.PrepareAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PrepareAgent")
	}

	var r0 *bedrockagent.PrepareAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.PrepareAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.PrepareAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.PrepareAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrepareFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PrepareFlow(ctx context.Context, params *bedrockagent.PrepareFlowInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.PrepareFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PrepareFlow")
	}

	var r0 *bedrockagent.PrepareFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareFlowInput, ...func(*bedrockagent.Options)) (*bedrockagent.PrepareFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareFlowInput, ...func(*bedrockagent.Options)) *bedrockagent.PrepareFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.PrepareFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.PrepareFlowInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartIngestionJob(ctx context.Context, params *bedrockagent.StartIngestionJobInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.StartIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartIngestionJob")
	}

	var r0 *bedrockagent.StartIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) (*bedrockagent.StartIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) *bedrockagent.StartIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.StartIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *bedrockagent.TagResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *bedrockagent.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *bedrockagent.UntagResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *bedrockagent.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAgent(ctx context.Context, params *bedrockagent.UpdateAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgent")
	}

	var r0 *bedrockagent.UpdateAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAgentActionGroup(ctx context.Context, params *bedrockagent.UpdateAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentActionGroup")
	}

	var r0 *bedrockagent.UpdateAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAgentAlias(ctx context.Context, params *bedrockagent.UpdateAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentAlias")
	}

	var r0 *bedrockagent.UpdateAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.UpdateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.UpdateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataSource(ctx context.Context, params *bedrockagent.UpdateDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataSource")
	}

	var r0 *bedrockagent.UpdateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFlow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFlow(ctx context.Context, params *bedrockagent.UpdateFlowInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateFlowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFlow")
	}

	var r0 *bedrockagent.UpdateFlowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateFlowInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateFlowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateFlowInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateFlowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateFlowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateFlowInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFlowAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFlowAlias(ctx context.Context, params *bedrockagent.UpdateFlowAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateFlowAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFlowAlias")
	}

	var r0 *bedrockagent.UpdateFlowAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateFlowAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateFlowAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateFlowAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateFlowAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateFlowAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateFlowAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKnowledgeBase(ctx context.Context, params *bedrockagent.UpdateKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnowledgeBase")
	}

	var r0 *bedrockagent.UpdateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrompt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePrompt(ctx context.Context, params *bedrockagent.UpdatePromptInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdatePromptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrompt")
	}

	var r0 *bedrockagent.UpdatePromptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdatePromptInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdatePromptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdatePromptInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdatePromptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdatePromptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdatePromptInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
