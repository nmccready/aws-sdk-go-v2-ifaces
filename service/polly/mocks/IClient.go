// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	polly "github.com/aws/aws-sdk-go-v2/service/polly"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// DeleteLexicon provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLexicon(ctx context.Context, params *polly.DeleteLexiconInput, optFns ...func(*polly.Options)) (*polly.DeleteLexiconOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLexicon")
	}

	var r0 *polly.DeleteLexiconOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.DeleteLexiconInput, ...func(*polly.Options)) (*polly.DeleteLexiconOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.DeleteLexiconInput, ...func(*polly.Options)) *polly.DeleteLexiconOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.DeleteLexiconOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.DeleteLexiconInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVoices provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVoices(ctx context.Context, params *polly.DescribeVoicesInput, optFns ...func(*polly.Options)) (*polly.DescribeVoicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVoices")
	}

	var r0 *polly.DescribeVoicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.DescribeVoicesInput, ...func(*polly.Options)) (*polly.DescribeVoicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.DescribeVoicesInput, ...func(*polly.Options)) *polly.DescribeVoicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.DescribeVoicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.DescribeVoicesInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLexicon provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLexicon(ctx context.Context, params *polly.GetLexiconInput, optFns ...func(*polly.Options)) (*polly.GetLexiconOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLexicon")
	}

	var r0 *polly.GetLexiconOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.GetLexiconInput, ...func(*polly.Options)) (*polly.GetLexiconOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.GetLexiconInput, ...func(*polly.Options)) *polly.GetLexiconOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.GetLexiconOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.GetLexiconInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSpeechSynthesisTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSpeechSynthesisTask(ctx context.Context, params *polly.GetSpeechSynthesisTaskInput, optFns ...func(*polly.Options)) (*polly.GetSpeechSynthesisTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSpeechSynthesisTask")
	}

	var r0 *polly.GetSpeechSynthesisTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.GetSpeechSynthesisTaskInput, ...func(*polly.Options)) (*polly.GetSpeechSynthesisTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.GetSpeechSynthesisTaskInput, ...func(*polly.Options)) *polly.GetSpeechSynthesisTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.GetSpeechSynthesisTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.GetSpeechSynthesisTaskInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLexicons provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLexicons(ctx context.Context, params *polly.ListLexiconsInput, optFns ...func(*polly.Options)) (*polly.ListLexiconsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLexicons")
	}

	var r0 *polly.ListLexiconsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.ListLexiconsInput, ...func(*polly.Options)) (*polly.ListLexiconsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.ListLexiconsInput, ...func(*polly.Options)) *polly.ListLexiconsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.ListLexiconsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.ListLexiconsInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSpeechSynthesisTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSpeechSynthesisTasks(ctx context.Context, params *polly.ListSpeechSynthesisTasksInput, optFns ...func(*polly.Options)) (*polly.ListSpeechSynthesisTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSpeechSynthesisTasks")
	}

	var r0 *polly.ListSpeechSynthesisTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.ListSpeechSynthesisTasksInput, ...func(*polly.Options)) (*polly.ListSpeechSynthesisTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.ListSpeechSynthesisTasksInput, ...func(*polly.Options)) *polly.ListSpeechSynthesisTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.ListSpeechSynthesisTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.ListSpeechSynthesisTasksInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() polly.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 polly.Options
	if rf, ok := ret.Get(0).(func() polly.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(polly.Options)
	}

	return r0
}

// PutLexicon provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLexicon(ctx context.Context, params *polly.PutLexiconInput, optFns ...func(*polly.Options)) (*polly.PutLexiconOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLexicon")
	}

	var r0 *polly.PutLexiconOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.PutLexiconInput, ...func(*polly.Options)) (*polly.PutLexiconOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.PutLexiconInput, ...func(*polly.Options)) *polly.PutLexiconOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.PutLexiconOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.PutLexiconInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartSpeechSynthesisTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartSpeechSynthesisTask(ctx context.Context, params *polly.StartSpeechSynthesisTaskInput, optFns ...func(*polly.Options)) (*polly.StartSpeechSynthesisTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartSpeechSynthesisTask")
	}

	var r0 *polly.StartSpeechSynthesisTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.StartSpeechSynthesisTaskInput, ...func(*polly.Options)) (*polly.StartSpeechSynthesisTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.StartSpeechSynthesisTaskInput, ...func(*polly.Options)) *polly.StartSpeechSynthesisTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.StartSpeechSynthesisTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.StartSpeechSynthesisTaskInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SynthesizeSpeech provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SynthesizeSpeech(ctx context.Context, params *polly.SynthesizeSpeechInput, optFns ...func(*polly.Options)) (*polly.SynthesizeSpeechOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SynthesizeSpeech")
	}

	var r0 *polly.SynthesizeSpeechOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *polly.SynthesizeSpeechInput, ...func(*polly.Options)) (*polly.SynthesizeSpeechOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *polly.SynthesizeSpeechInput, ...func(*polly.Options)) *polly.SynthesizeSpeechOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*polly.SynthesizeSpeechOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *polly.SynthesizeSpeechInput, ...func(*polly.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
