// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	kinesisanalytics "github.com/aws/aws-sdk-go-v2/service/kinesisanalytics"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddApplicationCloudWatchLoggingOption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddApplicationCloudWatchLoggingOption(ctx context.Context, params *kinesisanalytics.AddApplicationCloudWatchLoggingOptionInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationCloudWatchLoggingOptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddApplicationCloudWatchLoggingOption")
	}

	var r0 *kinesisanalytics.AddApplicationCloudWatchLoggingOptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationCloudWatchLoggingOptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.AddApplicationCloudWatchLoggingOptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.AddApplicationCloudWatchLoggingOptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.AddApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddApplicationInput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddApplicationInput(ctx context.Context, params *kinesisanalytics.AddApplicationInputInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationInputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddApplicationInput")
	}

	var r0 *kinesisanalytics.AddApplicationInputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationInputInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationInputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationInputInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.AddApplicationInputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.AddApplicationInputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.AddApplicationInputInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddApplicationInputProcessingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddApplicationInputProcessingConfiguration(ctx context.Context, params *kinesisanalytics.AddApplicationInputProcessingConfigurationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationInputProcessingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddApplicationInputProcessingConfiguration")
	}

	var r0 *kinesisanalytics.AddApplicationInputProcessingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationInputProcessingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.AddApplicationInputProcessingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.AddApplicationInputProcessingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.AddApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddApplicationOutput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddApplicationOutput(ctx context.Context, params *kinesisanalytics.AddApplicationOutputInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddApplicationOutput")
	}

	var r0 *kinesisanalytics.AddApplicationOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationOutputInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationOutputInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.AddApplicationOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.AddApplicationOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.AddApplicationOutputInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddApplicationReferenceDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddApplicationReferenceDataSource(ctx context.Context, params *kinesisanalytics.AddApplicationReferenceDataSourceInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationReferenceDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddApplicationReferenceDataSource")
	}

	var r0 *kinesisanalytics.AddApplicationReferenceDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.AddApplicationReferenceDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.AddApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.AddApplicationReferenceDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.AddApplicationReferenceDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.AddApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApplication(ctx context.Context, params *kinesisanalytics.CreateApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.CreateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApplication")
	}

	var r0 *kinesisanalytics.CreateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.CreateApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.CreateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.CreateApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.CreateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.CreateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.CreateApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplication(ctx context.Context, params *kinesisanalytics.DeleteApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplication")
	}

	var r0 *kinesisanalytics.DeleteApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DeleteApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DeleteApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DeleteApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplicationCloudWatchLoggingOption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplicationCloudWatchLoggingOption(ctx context.Context, params *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplicationCloudWatchLoggingOption")
	}

	var r0 *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplicationInputProcessingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplicationInputProcessingConfiguration(ctx context.Context, params *kinesisanalytics.DeleteApplicationInputProcessingConfigurationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationInputProcessingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplicationInputProcessingConfiguration")
	}

	var r0 *kinesisanalytics.DeleteApplicationInputProcessingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationInputProcessingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DeleteApplicationInputProcessingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DeleteApplicationInputProcessingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DeleteApplicationInputProcessingConfigurationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplicationOutput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplicationOutput(ctx context.Context, params *kinesisanalytics.DeleteApplicationOutputInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplicationOutput")
	}

	var r0 *kinesisanalytics.DeleteApplicationOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationOutputInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationOutputInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DeleteApplicationOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DeleteApplicationOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DeleteApplicationOutputInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplicationReferenceDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplicationReferenceDataSource(ctx context.Context, params *kinesisanalytics.DeleteApplicationReferenceDataSourceInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationReferenceDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplicationReferenceDataSource")
	}

	var r0 *kinesisanalytics.DeleteApplicationReferenceDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DeleteApplicationReferenceDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DeleteApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DeleteApplicationReferenceDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DeleteApplicationReferenceDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DeleteApplicationReferenceDataSourceInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeApplication(ctx context.Context, params *kinesisanalytics.DescribeApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DescribeApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeApplication")
	}

	var r0 *kinesisanalytics.DescribeApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DescribeApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DescribeApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DescribeApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DescribeApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DescribeApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DescribeApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscoverInputSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DiscoverInputSchema(ctx context.Context, params *kinesisanalytics.DiscoverInputSchemaInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DiscoverInputSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DiscoverInputSchema")
	}

	var r0 *kinesisanalytics.DiscoverInputSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DiscoverInputSchemaInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.DiscoverInputSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.DiscoverInputSchemaInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.DiscoverInputSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.DiscoverInputSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.DiscoverInputSchemaInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplications(ctx context.Context, params *kinesisanalytics.ListApplicationsInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.ListApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplications")
	}

	var r0 *kinesisanalytics.ListApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.ListApplicationsInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.ListApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.ListApplicationsInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.ListApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.ListApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.ListApplicationsInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *kinesisanalytics.ListTagsForResourceInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *kinesisanalytics.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.ListTagsForResourceInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.ListTagsForResourceInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.ListTagsForResourceInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() kinesisanalytics.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 kinesisanalytics.Options
	if rf, ok := ret.Get(0).(func() kinesisanalytics.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kinesisanalytics.Options)
	}

	return r0
}

// StartApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartApplication(ctx context.Context, params *kinesisanalytics.StartApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.StartApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartApplication")
	}

	var r0 *kinesisanalytics.StartApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.StartApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.StartApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.StartApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.StartApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.StartApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.StartApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopApplication(ctx context.Context, params *kinesisanalytics.StopApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.StopApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopApplication")
	}

	var r0 *kinesisanalytics.StopApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.StopApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.StopApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.StopApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.StopApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.StopApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.StopApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *kinesisanalytics.TagResourceInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *kinesisanalytics.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.TagResourceInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.TagResourceInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.TagResourceInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *kinesisanalytics.UntagResourceInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *kinesisanalytics.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.UntagResourceInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.UntagResourceInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.UntagResourceInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApplication(ctx context.Context, params *kinesisanalytics.UpdateApplicationInput, optFns ...func(*kinesisanalytics.Options)) (*kinesisanalytics.UpdateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApplication")
	}

	var r0 *kinesisanalytics.UpdateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.UpdateApplicationInput, ...func(*kinesisanalytics.Options)) (*kinesisanalytics.UpdateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesisanalytics.UpdateApplicationInput, ...func(*kinesisanalytics.Options)) *kinesisanalytics.UpdateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesisanalytics.UpdateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesisanalytics.UpdateApplicationInput, ...func(*kinesisanalytics.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
