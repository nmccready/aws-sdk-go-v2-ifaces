// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	eventbridge "github.com/aws/aws-sdk-go-v2/service/eventbridge"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// ActivateEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ActivateEventSource(ctx context.Context, params *eventbridge.ActivateEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ActivateEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActivateEventSource")
	}

	var r0 *eventbridge.ActivateEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ActivateEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.ActivateEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ActivateEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.ActivateEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ActivateEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ActivateEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelReplay provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelReplay(ctx context.Context, params *eventbridge.CancelReplayInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CancelReplayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelReplay")
	}

	var r0 *eventbridge.CancelReplayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CancelReplayInput, ...func(*eventbridge.Options)) (*eventbridge.CancelReplayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CancelReplayInput, ...func(*eventbridge.Options)) *eventbridge.CancelReplayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CancelReplayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CancelReplayInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateApiDestination provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApiDestination(ctx context.Context, params *eventbridge.CreateApiDestinationInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreateApiDestinationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApiDestination")
	}

	var r0 *eventbridge.CreateApiDestinationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateApiDestinationInput, ...func(*eventbridge.Options)) (*eventbridge.CreateApiDestinationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateApiDestinationInput, ...func(*eventbridge.Options)) *eventbridge.CreateApiDestinationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreateApiDestinationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreateApiDestinationInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateArchive(ctx context.Context, params *eventbridge.CreateArchiveInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreateArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateArchive")
	}

	var r0 *eventbridge.CreateArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateArchiveInput, ...func(*eventbridge.Options)) (*eventbridge.CreateArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateArchiveInput, ...func(*eventbridge.Options)) *eventbridge.CreateArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreateArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreateArchiveInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConnection(ctx context.Context, params *eventbridge.CreateConnectionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreateConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConnection")
	}

	var r0 *eventbridge.CreateConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateConnectionInput, ...func(*eventbridge.Options)) (*eventbridge.CreateConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateConnectionInput, ...func(*eventbridge.Options)) *eventbridge.CreateConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreateConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreateConnectionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEndpoint(ctx context.Context, params *eventbridge.CreateEndpointInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreateEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEndpoint")
	}

	var r0 *eventbridge.CreateEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateEndpointInput, ...func(*eventbridge.Options)) (*eventbridge.CreateEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateEndpointInput, ...func(*eventbridge.Options)) *eventbridge.CreateEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreateEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreateEndpointInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventBus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventBus(ctx context.Context, params *eventbridge.CreateEventBusInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreateEventBusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventBus")
	}

	var r0 *eventbridge.CreateEventBusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateEventBusInput, ...func(*eventbridge.Options)) (*eventbridge.CreateEventBusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreateEventBusInput, ...func(*eventbridge.Options)) *eventbridge.CreateEventBusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreateEventBusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreateEventBusInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePartnerEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePartnerEventSource(ctx context.Context, params *eventbridge.CreatePartnerEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.CreatePartnerEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartnerEventSource")
	}

	var r0 *eventbridge.CreatePartnerEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreatePartnerEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.CreatePartnerEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.CreatePartnerEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.CreatePartnerEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.CreatePartnerEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.CreatePartnerEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeactivateEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeactivateEventSource(ctx context.Context, params *eventbridge.DeactivateEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeactivateEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeactivateEventSource")
	}

	var r0 *eventbridge.DeactivateEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeactivateEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.DeactivateEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeactivateEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.DeactivateEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeactivateEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeactivateEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeauthorizeConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeauthorizeConnection(ctx context.Context, params *eventbridge.DeauthorizeConnectionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeauthorizeConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeauthorizeConnection")
	}

	var r0 *eventbridge.DeauthorizeConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeauthorizeConnectionInput, ...func(*eventbridge.Options)) (*eventbridge.DeauthorizeConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeauthorizeConnectionInput, ...func(*eventbridge.Options)) *eventbridge.DeauthorizeConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeauthorizeConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeauthorizeConnectionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApiDestination provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApiDestination(ctx context.Context, params *eventbridge.DeleteApiDestinationInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteApiDestinationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApiDestination")
	}

	var r0 *eventbridge.DeleteApiDestinationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteApiDestinationInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteApiDestinationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteApiDestinationInput, ...func(*eventbridge.Options)) *eventbridge.DeleteApiDestinationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteApiDestinationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteApiDestinationInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteArchive(ctx context.Context, params *eventbridge.DeleteArchiveInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteArchive")
	}

	var r0 *eventbridge.DeleteArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteArchiveInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteArchiveInput, ...func(*eventbridge.Options)) *eventbridge.DeleteArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteArchiveInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConnection(ctx context.Context, params *eventbridge.DeleteConnectionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConnection")
	}

	var r0 *eventbridge.DeleteConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteConnectionInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteConnectionInput, ...func(*eventbridge.Options)) *eventbridge.DeleteConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteConnectionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEndpoint(ctx context.Context, params *eventbridge.DeleteEndpointInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEndpoint")
	}

	var r0 *eventbridge.DeleteEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteEndpointInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteEndpointInput, ...func(*eventbridge.Options)) *eventbridge.DeleteEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteEndpointInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventBus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventBus(ctx context.Context, params *eventbridge.DeleteEventBusInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteEventBusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventBus")
	}

	var r0 *eventbridge.DeleteEventBusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteEventBusInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteEventBusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteEventBusInput, ...func(*eventbridge.Options)) *eventbridge.DeleteEventBusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteEventBusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteEventBusInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePartnerEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePartnerEventSource(ctx context.Context, params *eventbridge.DeletePartnerEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeletePartnerEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePartnerEventSource")
	}

	var r0 *eventbridge.DeletePartnerEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeletePartnerEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.DeletePartnerEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeletePartnerEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.DeletePartnerEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeletePartnerEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeletePartnerEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRule(ctx context.Context, params *eventbridge.DeleteRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 *eventbridge.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteRuleInput, ...func(*eventbridge.Options)) (*eventbridge.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DeleteRuleInput, ...func(*eventbridge.Options)) *eventbridge.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DeleteRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeApiDestination provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeApiDestination(ctx context.Context, params *eventbridge.DescribeApiDestinationInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeApiDestinationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeApiDestination")
	}

	var r0 *eventbridge.DescribeApiDestinationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeApiDestinationInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeApiDestinationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeApiDestinationInput, ...func(*eventbridge.Options)) *eventbridge.DescribeApiDestinationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeApiDestinationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeApiDestinationInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeArchive(ctx context.Context, params *eventbridge.DescribeArchiveInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeArchive")
	}

	var r0 *eventbridge.DescribeArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeArchiveInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeArchiveInput, ...func(*eventbridge.Options)) *eventbridge.DescribeArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeArchiveInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConnection(ctx context.Context, params *eventbridge.DescribeConnectionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConnection")
	}

	var r0 *eventbridge.DescribeConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeConnectionInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeConnectionInput, ...func(*eventbridge.Options)) *eventbridge.DescribeConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeConnectionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEndpoint(ctx context.Context, params *eventbridge.DescribeEndpointInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEndpoint")
	}

	var r0 *eventbridge.DescribeEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEndpointInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEndpointInput, ...func(*eventbridge.Options)) *eventbridge.DescribeEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeEndpointInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEventBus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEventBus(ctx context.Context, params *eventbridge.DescribeEventBusInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeEventBusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEventBus")
	}

	var r0 *eventbridge.DescribeEventBusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEventBusInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeEventBusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEventBusInput, ...func(*eventbridge.Options)) *eventbridge.DescribeEventBusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeEventBusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeEventBusInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEventSource(ctx context.Context, params *eventbridge.DescribeEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEventSource")
	}

	var r0 *eventbridge.DescribeEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.DescribeEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePartnerEventSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePartnerEventSource(ctx context.Context, params *eventbridge.DescribePartnerEventSourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribePartnerEventSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePartnerEventSource")
	}

	var r0 *eventbridge.DescribePartnerEventSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribePartnerEventSourceInput, ...func(*eventbridge.Options)) (*eventbridge.DescribePartnerEventSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribePartnerEventSourceInput, ...func(*eventbridge.Options)) *eventbridge.DescribePartnerEventSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribePartnerEventSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribePartnerEventSourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReplay provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReplay(ctx context.Context, params *eventbridge.DescribeReplayInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeReplayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReplay")
	}

	var r0 *eventbridge.DescribeReplayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeReplayInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeReplayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeReplayInput, ...func(*eventbridge.Options)) *eventbridge.DescribeReplayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeReplayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeReplayInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRule(ctx context.Context, params *eventbridge.DescribeRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DescribeRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRule")
	}

	var r0 *eventbridge.DescribeRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeRuleInput, ...func(*eventbridge.Options)) (*eventbridge.DescribeRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DescribeRuleInput, ...func(*eventbridge.Options)) *eventbridge.DescribeRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DescribeRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DescribeRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableRule(ctx context.Context, params *eventbridge.DisableRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.DisableRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableRule")
	}

	var r0 *eventbridge.DisableRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DisableRuleInput, ...func(*eventbridge.Options)) (*eventbridge.DisableRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.DisableRuleInput, ...func(*eventbridge.Options)) *eventbridge.DisableRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.DisableRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.DisableRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableRule(ctx context.Context, params *eventbridge.EnableRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.EnableRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableRule")
	}

	var r0 *eventbridge.EnableRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.EnableRuleInput, ...func(*eventbridge.Options)) (*eventbridge.EnableRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.EnableRuleInput, ...func(*eventbridge.Options)) *eventbridge.EnableRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.EnableRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.EnableRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApiDestinations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApiDestinations(ctx context.Context, params *eventbridge.ListApiDestinationsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListApiDestinationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApiDestinations")
	}

	var r0 *eventbridge.ListApiDestinationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListApiDestinationsInput, ...func(*eventbridge.Options)) (*eventbridge.ListApiDestinationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListApiDestinationsInput, ...func(*eventbridge.Options)) *eventbridge.ListApiDestinationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListApiDestinationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListApiDestinationsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListArchives provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListArchives(ctx context.Context, params *eventbridge.ListArchivesInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListArchivesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListArchives")
	}

	var r0 *eventbridge.ListArchivesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListArchivesInput, ...func(*eventbridge.Options)) (*eventbridge.ListArchivesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListArchivesInput, ...func(*eventbridge.Options)) *eventbridge.ListArchivesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListArchivesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListArchivesInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConnections(ctx context.Context, params *eventbridge.ListConnectionsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConnections")
	}

	var r0 *eventbridge.ListConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListConnectionsInput, ...func(*eventbridge.Options)) (*eventbridge.ListConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListConnectionsInput, ...func(*eventbridge.Options)) *eventbridge.ListConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListConnectionsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEndpoints(ctx context.Context, params *eventbridge.ListEndpointsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEndpoints")
	}

	var r0 *eventbridge.ListEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEndpointsInput, ...func(*eventbridge.Options)) (*eventbridge.ListEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEndpointsInput, ...func(*eventbridge.Options)) *eventbridge.ListEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListEndpointsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventBuses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventBuses(ctx context.Context, params *eventbridge.ListEventBusesInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListEventBusesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventBuses")
	}

	var r0 *eventbridge.ListEventBusesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEventBusesInput, ...func(*eventbridge.Options)) (*eventbridge.ListEventBusesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEventBusesInput, ...func(*eventbridge.Options)) *eventbridge.ListEventBusesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListEventBusesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListEventBusesInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventSources(ctx context.Context, params *eventbridge.ListEventSourcesInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListEventSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventSources")
	}

	var r0 *eventbridge.ListEventSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEventSourcesInput, ...func(*eventbridge.Options)) (*eventbridge.ListEventSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListEventSourcesInput, ...func(*eventbridge.Options)) *eventbridge.ListEventSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListEventSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListEventSourcesInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPartnerEventSourceAccounts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPartnerEventSourceAccounts(ctx context.Context, params *eventbridge.ListPartnerEventSourceAccountsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListPartnerEventSourceAccountsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPartnerEventSourceAccounts")
	}

	var r0 *eventbridge.ListPartnerEventSourceAccountsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListPartnerEventSourceAccountsInput, ...func(*eventbridge.Options)) (*eventbridge.ListPartnerEventSourceAccountsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListPartnerEventSourceAccountsInput, ...func(*eventbridge.Options)) *eventbridge.ListPartnerEventSourceAccountsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListPartnerEventSourceAccountsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListPartnerEventSourceAccountsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPartnerEventSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPartnerEventSources(ctx context.Context, params *eventbridge.ListPartnerEventSourcesInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListPartnerEventSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPartnerEventSources")
	}

	var r0 *eventbridge.ListPartnerEventSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListPartnerEventSourcesInput, ...func(*eventbridge.Options)) (*eventbridge.ListPartnerEventSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListPartnerEventSourcesInput, ...func(*eventbridge.Options)) *eventbridge.ListPartnerEventSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListPartnerEventSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListPartnerEventSourcesInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReplays provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReplays(ctx context.Context, params *eventbridge.ListReplaysInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListReplaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReplays")
	}

	var r0 *eventbridge.ListReplaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListReplaysInput, ...func(*eventbridge.Options)) (*eventbridge.ListReplaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListReplaysInput, ...func(*eventbridge.Options)) *eventbridge.ListReplaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListReplaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListReplaysInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuleNamesByTarget provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuleNamesByTarget(ctx context.Context, params *eventbridge.ListRuleNamesByTargetInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListRuleNamesByTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuleNamesByTarget")
	}

	var r0 *eventbridge.ListRuleNamesByTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListRuleNamesByTargetInput, ...func(*eventbridge.Options)) (*eventbridge.ListRuleNamesByTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListRuleNamesByTargetInput, ...func(*eventbridge.Options)) *eventbridge.ListRuleNamesByTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListRuleNamesByTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListRuleNamesByTargetInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRules(ctx context.Context, params *eventbridge.ListRulesInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 *eventbridge.ListRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListRulesInput, ...func(*eventbridge.Options)) (*eventbridge.ListRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListRulesInput, ...func(*eventbridge.Options)) *eventbridge.ListRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListRulesInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *eventbridge.ListTagsForResourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *eventbridge.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListTagsForResourceInput, ...func(*eventbridge.Options)) (*eventbridge.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListTagsForResourceInput, ...func(*eventbridge.Options)) *eventbridge.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListTagsForResourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTargetsByRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTargetsByRule(ctx context.Context, params *eventbridge.ListTargetsByRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.ListTargetsByRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTargetsByRule")
	}

	var r0 *eventbridge.ListTargetsByRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListTargetsByRuleInput, ...func(*eventbridge.Options)) (*eventbridge.ListTargetsByRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.ListTargetsByRuleInput, ...func(*eventbridge.Options)) *eventbridge.ListTargetsByRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.ListTargetsByRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.ListTargetsByRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() eventbridge.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 eventbridge.Options
	if rf, ok := ret.Get(0).(func() eventbridge.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(eventbridge.Options)
	}

	return r0
}

// PutEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutEvents(ctx context.Context, params *eventbridge.PutEventsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.PutEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEvents")
	}

	var r0 *eventbridge.PutEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutEventsInput, ...func(*eventbridge.Options)) (*eventbridge.PutEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutEventsInput, ...func(*eventbridge.Options)) *eventbridge.PutEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.PutEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.PutEventsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPartnerEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPartnerEvents(ctx context.Context, params *eventbridge.PutPartnerEventsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.PutPartnerEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPartnerEvents")
	}

	var r0 *eventbridge.PutPartnerEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutPartnerEventsInput, ...func(*eventbridge.Options)) (*eventbridge.PutPartnerEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutPartnerEventsInput, ...func(*eventbridge.Options)) *eventbridge.PutPartnerEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.PutPartnerEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.PutPartnerEventsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPermission(ctx context.Context, params *eventbridge.PutPermissionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.PutPermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPermission")
	}

	var r0 *eventbridge.PutPermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutPermissionInput, ...func(*eventbridge.Options)) (*eventbridge.PutPermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutPermissionInput, ...func(*eventbridge.Options)) *eventbridge.PutPermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.PutPermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.PutPermissionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRule(ctx context.Context, params *eventbridge.PutRuleInput, optFns ...func(*eventbridge.Options)) (*eventbridge.PutRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRule")
	}

	var r0 *eventbridge.PutRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutRuleInput, ...func(*eventbridge.Options)) (*eventbridge.PutRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutRuleInput, ...func(*eventbridge.Options)) *eventbridge.PutRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.PutRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.PutRuleInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTargets(ctx context.Context, params *eventbridge.PutTargetsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.PutTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTargets")
	}

	var r0 *eventbridge.PutTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutTargetsInput, ...func(*eventbridge.Options)) (*eventbridge.PutTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.PutTargetsInput, ...func(*eventbridge.Options)) *eventbridge.PutTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.PutTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.PutTargetsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemovePermission provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemovePermission(ctx context.Context, params *eventbridge.RemovePermissionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.RemovePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePermission")
	}

	var r0 *eventbridge.RemovePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.RemovePermissionInput, ...func(*eventbridge.Options)) (*eventbridge.RemovePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.RemovePermissionInput, ...func(*eventbridge.Options)) *eventbridge.RemovePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.RemovePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.RemovePermissionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTargets(ctx context.Context, params *eventbridge.RemoveTargetsInput, optFns ...func(*eventbridge.Options)) (*eventbridge.RemoveTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTargets")
	}

	var r0 *eventbridge.RemoveTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.RemoveTargetsInput, ...func(*eventbridge.Options)) (*eventbridge.RemoveTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.RemoveTargetsInput, ...func(*eventbridge.Options)) *eventbridge.RemoveTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.RemoveTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.RemoveTargetsInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartReplay provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartReplay(ctx context.Context, params *eventbridge.StartReplayInput, optFns ...func(*eventbridge.Options)) (*eventbridge.StartReplayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartReplay")
	}

	var r0 *eventbridge.StartReplayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.StartReplayInput, ...func(*eventbridge.Options)) (*eventbridge.StartReplayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.StartReplayInput, ...func(*eventbridge.Options)) *eventbridge.StartReplayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.StartReplayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.StartReplayInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *eventbridge.TagResourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *eventbridge.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.TagResourceInput, ...func(*eventbridge.Options)) (*eventbridge.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.TagResourceInput, ...func(*eventbridge.Options)) *eventbridge.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.TagResourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestEventPattern provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestEventPattern(ctx context.Context, params *eventbridge.TestEventPatternInput, optFns ...func(*eventbridge.Options)) (*eventbridge.TestEventPatternOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestEventPattern")
	}

	var r0 *eventbridge.TestEventPatternOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.TestEventPatternInput, ...func(*eventbridge.Options)) (*eventbridge.TestEventPatternOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.TestEventPatternInput, ...func(*eventbridge.Options)) *eventbridge.TestEventPatternOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.TestEventPatternOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.TestEventPatternInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *eventbridge.UntagResourceInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *eventbridge.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UntagResourceInput, ...func(*eventbridge.Options)) (*eventbridge.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UntagResourceInput, ...func(*eventbridge.Options)) *eventbridge.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UntagResourceInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApiDestination provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApiDestination(ctx context.Context, params *eventbridge.UpdateApiDestinationInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UpdateApiDestinationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApiDestination")
	}

	var r0 *eventbridge.UpdateApiDestinationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateApiDestinationInput, ...func(*eventbridge.Options)) (*eventbridge.UpdateApiDestinationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateApiDestinationInput, ...func(*eventbridge.Options)) *eventbridge.UpdateApiDestinationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UpdateApiDestinationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UpdateApiDestinationInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateArchive provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateArchive(ctx context.Context, params *eventbridge.UpdateArchiveInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UpdateArchiveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateArchive")
	}

	var r0 *eventbridge.UpdateArchiveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateArchiveInput, ...func(*eventbridge.Options)) (*eventbridge.UpdateArchiveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateArchiveInput, ...func(*eventbridge.Options)) *eventbridge.UpdateArchiveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UpdateArchiveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UpdateArchiveInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConnection(ctx context.Context, params *eventbridge.UpdateConnectionInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UpdateConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnection")
	}

	var r0 *eventbridge.UpdateConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateConnectionInput, ...func(*eventbridge.Options)) (*eventbridge.UpdateConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateConnectionInput, ...func(*eventbridge.Options)) *eventbridge.UpdateConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UpdateConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UpdateConnectionInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEndpoint(ctx context.Context, params *eventbridge.UpdateEndpointInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UpdateEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEndpoint")
	}

	var r0 *eventbridge.UpdateEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateEndpointInput, ...func(*eventbridge.Options)) (*eventbridge.UpdateEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateEndpointInput, ...func(*eventbridge.Options)) *eventbridge.UpdateEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UpdateEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UpdateEndpointInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventBus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventBus(ctx context.Context, params *eventbridge.UpdateEventBusInput, optFns ...func(*eventbridge.Options)) (*eventbridge.UpdateEventBusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventBus")
	}

	var r0 *eventbridge.UpdateEventBusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateEventBusInput, ...func(*eventbridge.Options)) (*eventbridge.UpdateEventBusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eventbridge.UpdateEventBusInput, ...func(*eventbridge.Options)) *eventbridge.UpdateEventBusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eventbridge.UpdateEventBusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eventbridge.UpdateEventBusInput, ...func(*eventbridge.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
