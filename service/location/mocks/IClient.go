// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	location "github.com/aws/aws-sdk-go-v2/service/location"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateTrackerConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateTrackerConsumer(ctx context.Context, params *location.AssociateTrackerConsumerInput, optFns ...func(*location.Options)) (*location.AssociateTrackerConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTrackerConsumer")
	}

	var r0 *location.AssociateTrackerConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.AssociateTrackerConsumerInput, ...func(*location.Options)) (*location.AssociateTrackerConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.AssociateTrackerConsumerInput, ...func(*location.Options)) *location.AssociateTrackerConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.AssociateTrackerConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.AssociateTrackerConsumerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteDevicePositionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteDevicePositionHistory(ctx context.Context, params *location.BatchDeleteDevicePositionHistoryInput, optFns ...func(*location.Options)) (*location.BatchDeleteDevicePositionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteDevicePositionHistory")
	}

	var r0 *location.BatchDeleteDevicePositionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchDeleteDevicePositionHistoryInput, ...func(*location.Options)) (*location.BatchDeleteDevicePositionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchDeleteDevicePositionHistoryInput, ...func(*location.Options)) *location.BatchDeleteDevicePositionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchDeleteDevicePositionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchDeleteDevicePositionHistoryInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteGeofence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteGeofence(ctx context.Context, params *location.BatchDeleteGeofenceInput, optFns ...func(*location.Options)) (*location.BatchDeleteGeofenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteGeofence")
	}

	var r0 *location.BatchDeleteGeofenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchDeleteGeofenceInput, ...func(*location.Options)) (*location.BatchDeleteGeofenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchDeleteGeofenceInput, ...func(*location.Options)) *location.BatchDeleteGeofenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchDeleteGeofenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchDeleteGeofenceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchEvaluateGeofences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchEvaluateGeofences(ctx context.Context, params *location.BatchEvaluateGeofencesInput, optFns ...func(*location.Options)) (*location.BatchEvaluateGeofencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchEvaluateGeofences")
	}

	var r0 *location.BatchEvaluateGeofencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchEvaluateGeofencesInput, ...func(*location.Options)) (*location.BatchEvaluateGeofencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchEvaluateGeofencesInput, ...func(*location.Options)) *location.BatchEvaluateGeofencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchEvaluateGeofencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchEvaluateGeofencesInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetDevicePosition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetDevicePosition(ctx context.Context, params *location.BatchGetDevicePositionInput, optFns ...func(*location.Options)) (*location.BatchGetDevicePositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetDevicePosition")
	}

	var r0 *location.BatchGetDevicePositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchGetDevicePositionInput, ...func(*location.Options)) (*location.BatchGetDevicePositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchGetDevicePositionInput, ...func(*location.Options)) *location.BatchGetDevicePositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchGetDevicePositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchGetDevicePositionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchPutGeofence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchPutGeofence(ctx context.Context, params *location.BatchPutGeofenceInput, optFns ...func(*location.Options)) (*location.BatchPutGeofenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchPutGeofence")
	}

	var r0 *location.BatchPutGeofenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchPutGeofenceInput, ...func(*location.Options)) (*location.BatchPutGeofenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchPutGeofenceInput, ...func(*location.Options)) *location.BatchPutGeofenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchPutGeofenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchPutGeofenceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchUpdateDevicePosition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdateDevicePosition(ctx context.Context, params *location.BatchUpdateDevicePositionInput, optFns ...func(*location.Options)) (*location.BatchUpdateDevicePositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateDevicePosition")
	}

	var r0 *location.BatchUpdateDevicePositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchUpdateDevicePositionInput, ...func(*location.Options)) (*location.BatchUpdateDevicePositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.BatchUpdateDevicePositionInput, ...func(*location.Options)) *location.BatchUpdateDevicePositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.BatchUpdateDevicePositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.BatchUpdateDevicePositionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateRoute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CalculateRoute(ctx context.Context, params *location.CalculateRouteInput, optFns ...func(*location.Options)) (*location.CalculateRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CalculateRoute")
	}

	var r0 *location.CalculateRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CalculateRouteInput, ...func(*location.Options)) (*location.CalculateRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CalculateRouteInput, ...func(*location.Options)) *location.CalculateRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CalculateRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CalculateRouteInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateRouteMatrix provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CalculateRouteMatrix(ctx context.Context, params *location.CalculateRouteMatrixInput, optFns ...func(*location.Options)) (*location.CalculateRouteMatrixOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CalculateRouteMatrix")
	}

	var r0 *location.CalculateRouteMatrixOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CalculateRouteMatrixInput, ...func(*location.Options)) (*location.CalculateRouteMatrixOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CalculateRouteMatrixInput, ...func(*location.Options)) *location.CalculateRouteMatrixOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CalculateRouteMatrixOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CalculateRouteMatrixInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGeofenceCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGeofenceCollection(ctx context.Context, params *location.CreateGeofenceCollectionInput, optFns ...func(*location.Options)) (*location.CreateGeofenceCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGeofenceCollection")
	}

	var r0 *location.CreateGeofenceCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateGeofenceCollectionInput, ...func(*location.Options)) (*location.CreateGeofenceCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateGeofenceCollectionInput, ...func(*location.Options)) *location.CreateGeofenceCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreateGeofenceCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreateGeofenceCollectionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKey(ctx context.Context, params *location.CreateKeyInput, optFns ...func(*location.Options)) (*location.CreateKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKey")
	}

	var r0 *location.CreateKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateKeyInput, ...func(*location.Options)) (*location.CreateKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateKeyInput, ...func(*location.Options)) *location.CreateKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreateKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreateKeyInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMap provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMap(ctx context.Context, params *location.CreateMapInput, optFns ...func(*location.Options)) (*location.CreateMapOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMap")
	}

	var r0 *location.CreateMapOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateMapInput, ...func(*location.Options)) (*location.CreateMapOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateMapInput, ...func(*location.Options)) *location.CreateMapOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreateMapOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreateMapInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlaceIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePlaceIndex(ctx context.Context, params *location.CreatePlaceIndexInput, optFns ...func(*location.Options)) (*location.CreatePlaceIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlaceIndex")
	}

	var r0 *location.CreatePlaceIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreatePlaceIndexInput, ...func(*location.Options)) (*location.CreatePlaceIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreatePlaceIndexInput, ...func(*location.Options)) *location.CreatePlaceIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreatePlaceIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreatePlaceIndexInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteCalculator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRouteCalculator(ctx context.Context, params *location.CreateRouteCalculatorInput, optFns ...func(*location.Options)) (*location.CreateRouteCalculatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteCalculator")
	}

	var r0 *location.CreateRouteCalculatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateRouteCalculatorInput, ...func(*location.Options)) (*location.CreateRouteCalculatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateRouteCalculatorInput, ...func(*location.Options)) *location.CreateRouteCalculatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreateRouteCalculatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreateRouteCalculatorInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTracker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTracker(ctx context.Context, params *location.CreateTrackerInput, optFns ...func(*location.Options)) (*location.CreateTrackerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTracker")
	}

	var r0 *location.CreateTrackerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateTrackerInput, ...func(*location.Options)) (*location.CreateTrackerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.CreateTrackerInput, ...func(*location.Options)) *location.CreateTrackerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.CreateTrackerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.CreateTrackerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGeofenceCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGeofenceCollection(ctx context.Context, params *location.DeleteGeofenceCollectionInput, optFns ...func(*location.Options)) (*location.DeleteGeofenceCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGeofenceCollection")
	}

	var r0 *location.DeleteGeofenceCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteGeofenceCollectionInput, ...func(*location.Options)) (*location.DeleteGeofenceCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteGeofenceCollectionInput, ...func(*location.Options)) *location.DeleteGeofenceCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeleteGeofenceCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeleteGeofenceCollectionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteKey(ctx context.Context, params *location.DeleteKeyInput, optFns ...func(*location.Options)) (*location.DeleteKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKey")
	}

	var r0 *location.DeleteKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteKeyInput, ...func(*location.Options)) (*location.DeleteKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteKeyInput, ...func(*location.Options)) *location.DeleteKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeleteKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeleteKeyInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMap provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMap(ctx context.Context, params *location.DeleteMapInput, optFns ...func(*location.Options)) (*location.DeleteMapOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMap")
	}

	var r0 *location.DeleteMapOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteMapInput, ...func(*location.Options)) (*location.DeleteMapOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteMapInput, ...func(*location.Options)) *location.DeleteMapOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeleteMapOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeleteMapInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlaceIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePlaceIndex(ctx context.Context, params *location.DeletePlaceIndexInput, optFns ...func(*location.Options)) (*location.DeletePlaceIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePlaceIndex")
	}

	var r0 *location.DeletePlaceIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeletePlaceIndexInput, ...func(*location.Options)) (*location.DeletePlaceIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeletePlaceIndexInput, ...func(*location.Options)) *location.DeletePlaceIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeletePlaceIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeletePlaceIndexInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteCalculator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRouteCalculator(ctx context.Context, params *location.DeleteRouteCalculatorInput, optFns ...func(*location.Options)) (*location.DeleteRouteCalculatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteCalculator")
	}

	var r0 *location.DeleteRouteCalculatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteRouteCalculatorInput, ...func(*location.Options)) (*location.DeleteRouteCalculatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteRouteCalculatorInput, ...func(*location.Options)) *location.DeleteRouteCalculatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeleteRouteCalculatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeleteRouteCalculatorInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTracker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTracker(ctx context.Context, params *location.DeleteTrackerInput, optFns ...func(*location.Options)) (*location.DeleteTrackerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTracker")
	}

	var r0 *location.DeleteTrackerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteTrackerInput, ...func(*location.Options)) (*location.DeleteTrackerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DeleteTrackerInput, ...func(*location.Options)) *location.DeleteTrackerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DeleteTrackerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DeleteTrackerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGeofenceCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGeofenceCollection(ctx context.Context, params *location.DescribeGeofenceCollectionInput, optFns ...func(*location.Options)) (*location.DescribeGeofenceCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGeofenceCollection")
	}

	var r0 *location.DescribeGeofenceCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeGeofenceCollectionInput, ...func(*location.Options)) (*location.DescribeGeofenceCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeGeofenceCollectionInput, ...func(*location.Options)) *location.DescribeGeofenceCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribeGeofenceCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribeGeofenceCollectionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeKey(ctx context.Context, params *location.DescribeKeyInput, optFns ...func(*location.Options)) (*location.DescribeKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeKey")
	}

	var r0 *location.DescribeKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeKeyInput, ...func(*location.Options)) (*location.DescribeKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeKeyInput, ...func(*location.Options)) *location.DescribeKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribeKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribeKeyInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMap provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMap(ctx context.Context, params *location.DescribeMapInput, optFns ...func(*location.Options)) (*location.DescribeMapOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMap")
	}

	var r0 *location.DescribeMapOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeMapInput, ...func(*location.Options)) (*location.DescribeMapOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeMapInput, ...func(*location.Options)) *location.DescribeMapOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribeMapOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribeMapInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePlaceIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePlaceIndex(ctx context.Context, params *location.DescribePlaceIndexInput, optFns ...func(*location.Options)) (*location.DescribePlaceIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePlaceIndex")
	}

	var r0 *location.DescribePlaceIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribePlaceIndexInput, ...func(*location.Options)) (*location.DescribePlaceIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribePlaceIndexInput, ...func(*location.Options)) *location.DescribePlaceIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribePlaceIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribePlaceIndexInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteCalculator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRouteCalculator(ctx context.Context, params *location.DescribeRouteCalculatorInput, optFns ...func(*location.Options)) (*location.DescribeRouteCalculatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteCalculator")
	}

	var r0 *location.DescribeRouteCalculatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeRouteCalculatorInput, ...func(*location.Options)) (*location.DescribeRouteCalculatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeRouteCalculatorInput, ...func(*location.Options)) *location.DescribeRouteCalculatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribeRouteCalculatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribeRouteCalculatorInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTracker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTracker(ctx context.Context, params *location.DescribeTrackerInput, optFns ...func(*location.Options)) (*location.DescribeTrackerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTracker")
	}

	var r0 *location.DescribeTrackerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeTrackerInput, ...func(*location.Options)) (*location.DescribeTrackerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DescribeTrackerInput, ...func(*location.Options)) *location.DescribeTrackerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DescribeTrackerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DescribeTrackerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTrackerConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateTrackerConsumer(ctx context.Context, params *location.DisassociateTrackerConsumerInput, optFns ...func(*location.Options)) (*location.DisassociateTrackerConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTrackerConsumer")
	}

	var r0 *location.DisassociateTrackerConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.DisassociateTrackerConsumerInput, ...func(*location.Options)) (*location.DisassociateTrackerConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.DisassociateTrackerConsumerInput, ...func(*location.Options)) *location.DisassociateTrackerConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.DisassociateTrackerConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.DisassociateTrackerConsumerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForecastGeofenceEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ForecastGeofenceEvents(ctx context.Context, params *location.ForecastGeofenceEventsInput, optFns ...func(*location.Options)) (*location.ForecastGeofenceEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForecastGeofenceEvents")
	}

	var r0 *location.ForecastGeofenceEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ForecastGeofenceEventsInput, ...func(*location.Options)) (*location.ForecastGeofenceEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ForecastGeofenceEventsInput, ...func(*location.Options)) *location.ForecastGeofenceEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ForecastGeofenceEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ForecastGeofenceEventsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDevicePosition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDevicePosition(ctx context.Context, params *location.GetDevicePositionInput, optFns ...func(*location.Options)) (*location.GetDevicePositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDevicePosition")
	}

	var r0 *location.GetDevicePositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetDevicePositionInput, ...func(*location.Options)) (*location.GetDevicePositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetDevicePositionInput, ...func(*location.Options)) *location.GetDevicePositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetDevicePositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetDevicePositionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDevicePositionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDevicePositionHistory(ctx context.Context, params *location.GetDevicePositionHistoryInput, optFns ...func(*location.Options)) (*location.GetDevicePositionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDevicePositionHistory")
	}

	var r0 *location.GetDevicePositionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetDevicePositionHistoryInput, ...func(*location.Options)) (*location.GetDevicePositionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetDevicePositionHistoryInput, ...func(*location.Options)) *location.GetDevicePositionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetDevicePositionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetDevicePositionHistoryInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGeofence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGeofence(ctx context.Context, params *location.GetGeofenceInput, optFns ...func(*location.Options)) (*location.GetGeofenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGeofence")
	}

	var r0 *location.GetGeofenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetGeofenceInput, ...func(*location.Options)) (*location.GetGeofenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetGeofenceInput, ...func(*location.Options)) *location.GetGeofenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetGeofenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetGeofenceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapGlyphs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMapGlyphs(ctx context.Context, params *location.GetMapGlyphsInput, optFns ...func(*location.Options)) (*location.GetMapGlyphsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMapGlyphs")
	}

	var r0 *location.GetMapGlyphsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapGlyphsInput, ...func(*location.Options)) (*location.GetMapGlyphsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapGlyphsInput, ...func(*location.Options)) *location.GetMapGlyphsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetMapGlyphsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetMapGlyphsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapSprites provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMapSprites(ctx context.Context, params *location.GetMapSpritesInput, optFns ...func(*location.Options)) (*location.GetMapSpritesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMapSprites")
	}

	var r0 *location.GetMapSpritesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapSpritesInput, ...func(*location.Options)) (*location.GetMapSpritesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapSpritesInput, ...func(*location.Options)) *location.GetMapSpritesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetMapSpritesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetMapSpritesInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapStyleDescriptor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMapStyleDescriptor(ctx context.Context, params *location.GetMapStyleDescriptorInput, optFns ...func(*location.Options)) (*location.GetMapStyleDescriptorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMapStyleDescriptor")
	}

	var r0 *location.GetMapStyleDescriptorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapStyleDescriptorInput, ...func(*location.Options)) (*location.GetMapStyleDescriptorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapStyleDescriptorInput, ...func(*location.Options)) *location.GetMapStyleDescriptorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetMapStyleDescriptorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetMapStyleDescriptorInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapTile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMapTile(ctx context.Context, params *location.GetMapTileInput, optFns ...func(*location.Options)) (*location.GetMapTileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMapTile")
	}

	var r0 *location.GetMapTileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapTileInput, ...func(*location.Options)) (*location.GetMapTileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetMapTileInput, ...func(*location.Options)) *location.GetMapTileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetMapTileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetMapTileInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPlace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPlace(ctx context.Context, params *location.GetPlaceInput, optFns ...func(*location.Options)) (*location.GetPlaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPlace")
	}

	var r0 *location.GetPlaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetPlaceInput, ...func(*location.Options)) (*location.GetPlaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.GetPlaceInput, ...func(*location.Options)) *location.GetPlaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.GetPlaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.GetPlaceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDevicePositions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDevicePositions(ctx context.Context, params *location.ListDevicePositionsInput, optFns ...func(*location.Options)) (*location.ListDevicePositionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevicePositions")
	}

	var r0 *location.ListDevicePositionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListDevicePositionsInput, ...func(*location.Options)) (*location.ListDevicePositionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListDevicePositionsInput, ...func(*location.Options)) *location.ListDevicePositionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListDevicePositionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListDevicePositionsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGeofenceCollections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGeofenceCollections(ctx context.Context, params *location.ListGeofenceCollectionsInput, optFns ...func(*location.Options)) (*location.ListGeofenceCollectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGeofenceCollections")
	}

	var r0 *location.ListGeofenceCollectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListGeofenceCollectionsInput, ...func(*location.Options)) (*location.ListGeofenceCollectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListGeofenceCollectionsInput, ...func(*location.Options)) *location.ListGeofenceCollectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListGeofenceCollectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListGeofenceCollectionsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGeofences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGeofences(ctx context.Context, params *location.ListGeofencesInput, optFns ...func(*location.Options)) (*location.ListGeofencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGeofences")
	}

	var r0 *location.ListGeofencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListGeofencesInput, ...func(*location.Options)) (*location.ListGeofencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListGeofencesInput, ...func(*location.Options)) *location.ListGeofencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListGeofencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListGeofencesInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeys(ctx context.Context, params *location.ListKeysInput, optFns ...func(*location.Options)) (*location.ListKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeys")
	}

	var r0 *location.ListKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListKeysInput, ...func(*location.Options)) (*location.ListKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListKeysInput, ...func(*location.Options)) *location.ListKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListKeysInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMaps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMaps(ctx context.Context, params *location.ListMapsInput, optFns ...func(*location.Options)) (*location.ListMapsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMaps")
	}

	var r0 *location.ListMapsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListMapsInput, ...func(*location.Options)) (*location.ListMapsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListMapsInput, ...func(*location.Options)) *location.ListMapsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListMapsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListMapsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPlaceIndexes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPlaceIndexes(ctx context.Context, params *location.ListPlaceIndexesInput, optFns ...func(*location.Options)) (*location.ListPlaceIndexesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPlaceIndexes")
	}

	var r0 *location.ListPlaceIndexesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListPlaceIndexesInput, ...func(*location.Options)) (*location.ListPlaceIndexesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListPlaceIndexesInput, ...func(*location.Options)) *location.ListPlaceIndexesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListPlaceIndexesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListPlaceIndexesInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRouteCalculators provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRouteCalculators(ctx context.Context, params *location.ListRouteCalculatorsInput, optFns ...func(*location.Options)) (*location.ListRouteCalculatorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRouteCalculators")
	}

	var r0 *location.ListRouteCalculatorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListRouteCalculatorsInput, ...func(*location.Options)) (*location.ListRouteCalculatorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListRouteCalculatorsInput, ...func(*location.Options)) *location.ListRouteCalculatorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListRouteCalculatorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListRouteCalculatorsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *location.ListTagsForResourceInput, optFns ...func(*location.Options)) (*location.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *location.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTagsForResourceInput, ...func(*location.Options)) (*location.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTagsForResourceInput, ...func(*location.Options)) *location.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListTagsForResourceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTrackerConsumers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTrackerConsumers(ctx context.Context, params *location.ListTrackerConsumersInput, optFns ...func(*location.Options)) (*location.ListTrackerConsumersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTrackerConsumers")
	}

	var r0 *location.ListTrackerConsumersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTrackerConsumersInput, ...func(*location.Options)) (*location.ListTrackerConsumersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTrackerConsumersInput, ...func(*location.Options)) *location.ListTrackerConsumersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListTrackerConsumersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListTrackerConsumersInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTrackers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTrackers(ctx context.Context, params *location.ListTrackersInput, optFns ...func(*location.Options)) (*location.ListTrackersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTrackers")
	}

	var r0 *location.ListTrackersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTrackersInput, ...func(*location.Options)) (*location.ListTrackersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.ListTrackersInput, ...func(*location.Options)) *location.ListTrackersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.ListTrackersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.ListTrackersInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() location.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 location.Options
	if rf, ok := ret.Get(0).(func() location.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(location.Options)
	}

	return r0
}

// PutGeofence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutGeofence(ctx context.Context, params *location.PutGeofenceInput, optFns ...func(*location.Options)) (*location.PutGeofenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutGeofence")
	}

	var r0 *location.PutGeofenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.PutGeofenceInput, ...func(*location.Options)) (*location.PutGeofenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.PutGeofenceInput, ...func(*location.Options)) *location.PutGeofenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.PutGeofenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.PutGeofenceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchPlaceIndexForPosition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchPlaceIndexForPosition(ctx context.Context, params *location.SearchPlaceIndexForPositionInput, optFns ...func(*location.Options)) (*location.SearchPlaceIndexForPositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchPlaceIndexForPosition")
	}

	var r0 *location.SearchPlaceIndexForPositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForPositionInput, ...func(*location.Options)) (*location.SearchPlaceIndexForPositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForPositionInput, ...func(*location.Options)) *location.SearchPlaceIndexForPositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.SearchPlaceIndexForPositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.SearchPlaceIndexForPositionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchPlaceIndexForSuggestions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchPlaceIndexForSuggestions(ctx context.Context, params *location.SearchPlaceIndexForSuggestionsInput, optFns ...func(*location.Options)) (*location.SearchPlaceIndexForSuggestionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchPlaceIndexForSuggestions")
	}

	var r0 *location.SearchPlaceIndexForSuggestionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForSuggestionsInput, ...func(*location.Options)) (*location.SearchPlaceIndexForSuggestionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForSuggestionsInput, ...func(*location.Options)) *location.SearchPlaceIndexForSuggestionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.SearchPlaceIndexForSuggestionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.SearchPlaceIndexForSuggestionsInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchPlaceIndexForText provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchPlaceIndexForText(ctx context.Context, params *location.SearchPlaceIndexForTextInput, optFns ...func(*location.Options)) (*location.SearchPlaceIndexForTextOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchPlaceIndexForText")
	}

	var r0 *location.SearchPlaceIndexForTextOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForTextInput, ...func(*location.Options)) (*location.SearchPlaceIndexForTextOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.SearchPlaceIndexForTextInput, ...func(*location.Options)) *location.SearchPlaceIndexForTextOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.SearchPlaceIndexForTextOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.SearchPlaceIndexForTextInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *location.TagResourceInput, optFns ...func(*location.Options)) (*location.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *location.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.TagResourceInput, ...func(*location.Options)) (*location.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.TagResourceInput, ...func(*location.Options)) *location.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.TagResourceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *location.UntagResourceInput, optFns ...func(*location.Options)) (*location.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *location.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UntagResourceInput, ...func(*location.Options)) (*location.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UntagResourceInput, ...func(*location.Options)) *location.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UntagResourceInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGeofenceCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGeofenceCollection(ctx context.Context, params *location.UpdateGeofenceCollectionInput, optFns ...func(*location.Options)) (*location.UpdateGeofenceCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGeofenceCollection")
	}

	var r0 *location.UpdateGeofenceCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateGeofenceCollectionInput, ...func(*location.Options)) (*location.UpdateGeofenceCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateGeofenceCollectionInput, ...func(*location.Options)) *location.UpdateGeofenceCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdateGeofenceCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdateGeofenceCollectionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKey(ctx context.Context, params *location.UpdateKeyInput, optFns ...func(*location.Options)) (*location.UpdateKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKey")
	}

	var r0 *location.UpdateKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateKeyInput, ...func(*location.Options)) (*location.UpdateKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateKeyInput, ...func(*location.Options)) *location.UpdateKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdateKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdateKeyInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMap provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMap(ctx context.Context, params *location.UpdateMapInput, optFns ...func(*location.Options)) (*location.UpdateMapOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMap")
	}

	var r0 *location.UpdateMapOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateMapInput, ...func(*location.Options)) (*location.UpdateMapOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateMapInput, ...func(*location.Options)) *location.UpdateMapOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdateMapOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdateMapInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePlaceIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePlaceIndex(ctx context.Context, params *location.UpdatePlaceIndexInput, optFns ...func(*location.Options)) (*location.UpdatePlaceIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePlaceIndex")
	}

	var r0 *location.UpdatePlaceIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdatePlaceIndexInput, ...func(*location.Options)) (*location.UpdatePlaceIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdatePlaceIndexInput, ...func(*location.Options)) *location.UpdatePlaceIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdatePlaceIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdatePlaceIndexInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRouteCalculator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRouteCalculator(ctx context.Context, params *location.UpdateRouteCalculatorInput, optFns ...func(*location.Options)) (*location.UpdateRouteCalculatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRouteCalculator")
	}

	var r0 *location.UpdateRouteCalculatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateRouteCalculatorInput, ...func(*location.Options)) (*location.UpdateRouteCalculatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateRouteCalculatorInput, ...func(*location.Options)) *location.UpdateRouteCalculatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdateRouteCalculatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdateRouteCalculatorInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTracker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTracker(ctx context.Context, params *location.UpdateTrackerInput, optFns ...func(*location.Options)) (*location.UpdateTrackerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTracker")
	}

	var r0 *location.UpdateTrackerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateTrackerInput, ...func(*location.Options)) (*location.UpdateTrackerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.UpdateTrackerInput, ...func(*location.Options)) *location.UpdateTrackerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.UpdateTrackerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.UpdateTrackerInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyDevicePosition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) VerifyDevicePosition(ctx context.Context, params *location.VerifyDevicePositionInput, optFns ...func(*location.Options)) (*location.VerifyDevicePositionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifyDevicePosition")
	}

	var r0 *location.VerifyDevicePositionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *location.VerifyDevicePositionInput, ...func(*location.Options)) (*location.VerifyDevicePositionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *location.VerifyDevicePositionInput, ...func(*location.Options)) *location.VerifyDevicePositionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*location.VerifyDevicePositionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *location.VerifyDevicePositionInput, ...func(*location.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
