// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	gamelift "github.com/aws/aws-sdk-go-v2/service/gamelift"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptMatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptMatch(ctx context.Context, params *gamelift.AcceptMatchInput, optFns ...func(*gamelift.Options)) (*gamelift.AcceptMatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptMatch")
	}

	var r0 *gamelift.AcceptMatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.AcceptMatchInput, ...func(*gamelift.Options)) (*gamelift.AcceptMatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.AcceptMatchInput, ...func(*gamelift.Options)) *gamelift.AcceptMatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.AcceptMatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.AcceptMatchInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClaimGameServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ClaimGameServer(ctx context.Context, params *gamelift.ClaimGameServerInput, optFns ...func(*gamelift.Options)) (*gamelift.ClaimGameServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClaimGameServer")
	}

	var r0 *gamelift.ClaimGameServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ClaimGameServerInput, ...func(*gamelift.Options)) (*gamelift.ClaimGameServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ClaimGameServerInput, ...func(*gamelift.Options)) *gamelift.ClaimGameServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ClaimGameServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ClaimGameServerInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAlias(ctx context.Context, params *gamelift.CreateAliasInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 *gamelift.CreateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateAliasInput, ...func(*gamelift.Options)) (*gamelift.CreateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateAliasInput, ...func(*gamelift.Options)) *gamelift.CreateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateAliasInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBuild(ctx context.Context, params *gamelift.CreateBuildInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuild")
	}

	var r0 *gamelift.CreateBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateBuildInput, ...func(*gamelift.Options)) (*gamelift.CreateBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateBuildInput, ...func(*gamelift.Options)) *gamelift.CreateBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateBuildInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContainerFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContainerFleet(ctx context.Context, params *gamelift.CreateContainerFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateContainerFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContainerFleet")
	}

	var r0 *gamelift.CreateContainerFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateContainerFleetInput, ...func(*gamelift.Options)) (*gamelift.CreateContainerFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateContainerFleetInput, ...func(*gamelift.Options)) *gamelift.CreateContainerFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateContainerFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateContainerFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateContainerGroupDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateContainerGroupDefinition(ctx context.Context, params *gamelift.CreateContainerGroupDefinitionInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateContainerGroupDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContainerGroupDefinition")
	}

	var r0 *gamelift.CreateContainerGroupDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateContainerGroupDefinitionInput, ...func(*gamelift.Options)) (*gamelift.CreateContainerGroupDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateContainerGroupDefinitionInput, ...func(*gamelift.Options)) *gamelift.CreateContainerGroupDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateContainerGroupDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateContainerGroupDefinitionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFleet(ctx context.Context, params *gamelift.CreateFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleet")
	}

	var r0 *gamelift.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateFleetInput, ...func(*gamelift.Options)) (*gamelift.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateFleetInput, ...func(*gamelift.Options)) *gamelift.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleetLocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFleetLocations(ctx context.Context, params *gamelift.CreateFleetLocationsInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateFleetLocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleetLocations")
	}

	var r0 *gamelift.CreateFleetLocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateFleetLocationsInput, ...func(*gamelift.Options)) (*gamelift.CreateFleetLocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateFleetLocationsInput, ...func(*gamelift.Options)) *gamelift.CreateFleetLocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateFleetLocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateFleetLocationsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGameServerGroup(ctx context.Context, params *gamelift.CreateGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGameServerGroup")
	}

	var r0 *gamelift.CreateGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.CreateGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.CreateGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGameSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGameSession(ctx context.Context, params *gamelift.CreateGameSessionInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateGameSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGameSession")
	}

	var r0 *gamelift.CreateGameSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameSessionInput, ...func(*gamelift.Options)) (*gamelift.CreateGameSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameSessionInput, ...func(*gamelift.Options)) *gamelift.CreateGameSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateGameSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateGameSessionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGameSessionQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGameSessionQueue(ctx context.Context, params *gamelift.CreateGameSessionQueueInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateGameSessionQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGameSessionQueue")
	}

	var r0 *gamelift.CreateGameSessionQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameSessionQueueInput, ...func(*gamelift.Options)) (*gamelift.CreateGameSessionQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateGameSessionQueueInput, ...func(*gamelift.Options)) *gamelift.CreateGameSessionQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateGameSessionQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateGameSessionQueueInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLocation(ctx context.Context, params *gamelift.CreateLocationInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocation")
	}

	var r0 *gamelift.CreateLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateLocationInput, ...func(*gamelift.Options)) (*gamelift.CreateLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateLocationInput, ...func(*gamelift.Options)) *gamelift.CreateLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateLocationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMatchmakingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMatchmakingConfiguration(ctx context.Context, params *gamelift.CreateMatchmakingConfigurationInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateMatchmakingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMatchmakingConfiguration")
	}

	var r0 *gamelift.CreateMatchmakingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateMatchmakingConfigurationInput, ...func(*gamelift.Options)) (*gamelift.CreateMatchmakingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateMatchmakingConfigurationInput, ...func(*gamelift.Options)) *gamelift.CreateMatchmakingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateMatchmakingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateMatchmakingConfigurationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMatchmakingRuleSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMatchmakingRuleSet(ctx context.Context, params *gamelift.CreateMatchmakingRuleSetInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateMatchmakingRuleSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMatchmakingRuleSet")
	}

	var r0 *gamelift.CreateMatchmakingRuleSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateMatchmakingRuleSetInput, ...func(*gamelift.Options)) (*gamelift.CreateMatchmakingRuleSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateMatchmakingRuleSetInput, ...func(*gamelift.Options)) *gamelift.CreateMatchmakingRuleSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateMatchmakingRuleSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateMatchmakingRuleSetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlayerSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePlayerSession(ctx context.Context, params *gamelift.CreatePlayerSessionInput, optFns ...func(*gamelift.Options)) (*gamelift.CreatePlayerSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlayerSession")
	}

	var r0 *gamelift.CreatePlayerSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreatePlayerSessionInput, ...func(*gamelift.Options)) (*gamelift.CreatePlayerSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreatePlayerSessionInput, ...func(*gamelift.Options)) *gamelift.CreatePlayerSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreatePlayerSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreatePlayerSessionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlayerSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePlayerSessions(ctx context.Context, params *gamelift.CreatePlayerSessionsInput, optFns ...func(*gamelift.Options)) (*gamelift.CreatePlayerSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlayerSessions")
	}

	var r0 *gamelift.CreatePlayerSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreatePlayerSessionsInput, ...func(*gamelift.Options)) (*gamelift.CreatePlayerSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreatePlayerSessionsInput, ...func(*gamelift.Options)) *gamelift.CreatePlayerSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreatePlayerSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreatePlayerSessionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateScript provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateScript(ctx context.Context, params *gamelift.CreateScriptInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateScriptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateScript")
	}

	var r0 *gamelift.CreateScriptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateScriptInput, ...func(*gamelift.Options)) (*gamelift.CreateScriptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateScriptInput, ...func(*gamelift.Options)) *gamelift.CreateScriptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateScriptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateScriptInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcPeeringAuthorization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcPeeringAuthorization(ctx context.Context, params *gamelift.CreateVpcPeeringAuthorizationInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateVpcPeeringAuthorizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcPeeringAuthorization")
	}

	var r0 *gamelift.CreateVpcPeeringAuthorizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) (*gamelift.CreateVpcPeeringAuthorizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) *gamelift.CreateVpcPeeringAuthorizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateVpcPeeringAuthorizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcPeeringConnection(ctx context.Context, params *gamelift.CreateVpcPeeringConnectionInput, optFns ...func(*gamelift.Options)) (*gamelift.CreateVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcPeeringConnection")
	}

	var r0 *gamelift.CreateVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateVpcPeeringConnectionInput, ...func(*gamelift.Options)) (*gamelift.CreateVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.CreateVpcPeeringConnectionInput, ...func(*gamelift.Options)) *gamelift.CreateVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.CreateVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.CreateVpcPeeringConnectionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAlias(ctx context.Context, params *gamelift.DeleteAliasInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAlias")
	}

	var r0 *gamelift.DeleteAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteAliasInput, ...func(*gamelift.Options)) (*gamelift.DeleteAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteAliasInput, ...func(*gamelift.Options)) *gamelift.DeleteAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteAliasInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBuild(ctx context.Context, params *gamelift.DeleteBuildInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBuild")
	}

	var r0 *gamelift.DeleteBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteBuildInput, ...func(*gamelift.Options)) (*gamelift.DeleteBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteBuildInput, ...func(*gamelift.Options)) *gamelift.DeleteBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteBuildInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContainerFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContainerFleet(ctx context.Context, params *gamelift.DeleteContainerFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteContainerFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContainerFleet")
	}

	var r0 *gamelift.DeleteContainerFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteContainerFleetInput, ...func(*gamelift.Options)) (*gamelift.DeleteContainerFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteContainerFleetInput, ...func(*gamelift.Options)) *gamelift.DeleteContainerFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteContainerFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteContainerFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteContainerGroupDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteContainerGroupDefinition(ctx context.Context, params *gamelift.DeleteContainerGroupDefinitionInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteContainerGroupDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContainerGroupDefinition")
	}

	var r0 *gamelift.DeleteContainerGroupDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteContainerGroupDefinitionInput, ...func(*gamelift.Options)) (*gamelift.DeleteContainerGroupDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteContainerGroupDefinitionInput, ...func(*gamelift.Options)) *gamelift.DeleteContainerGroupDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteContainerGroupDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteContainerGroupDefinitionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFleet(ctx context.Context, params *gamelift.DeleteFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleet")
	}

	var r0 *gamelift.DeleteFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteFleetInput, ...func(*gamelift.Options)) (*gamelift.DeleteFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteFleetInput, ...func(*gamelift.Options)) *gamelift.DeleteFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleetLocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFleetLocations(ctx context.Context, params *gamelift.DeleteFleetLocationsInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteFleetLocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleetLocations")
	}

	var r0 *gamelift.DeleteFleetLocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteFleetLocationsInput, ...func(*gamelift.Options)) (*gamelift.DeleteFleetLocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteFleetLocationsInput, ...func(*gamelift.Options)) *gamelift.DeleteFleetLocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteFleetLocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteFleetLocationsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGameServerGroup(ctx context.Context, params *gamelift.DeleteGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGameServerGroup")
	}

	var r0 *gamelift.DeleteGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.DeleteGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.DeleteGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGameSessionQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGameSessionQueue(ctx context.Context, params *gamelift.DeleteGameSessionQueueInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteGameSessionQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGameSessionQueue")
	}

	var r0 *gamelift.DeleteGameSessionQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteGameSessionQueueInput, ...func(*gamelift.Options)) (*gamelift.DeleteGameSessionQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteGameSessionQueueInput, ...func(*gamelift.Options)) *gamelift.DeleteGameSessionQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteGameSessionQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteGameSessionQueueInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLocation(ctx context.Context, params *gamelift.DeleteLocationInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocation")
	}

	var r0 *gamelift.DeleteLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteLocationInput, ...func(*gamelift.Options)) (*gamelift.DeleteLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteLocationInput, ...func(*gamelift.Options)) *gamelift.DeleteLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteLocationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMatchmakingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMatchmakingConfiguration(ctx context.Context, params *gamelift.DeleteMatchmakingConfigurationInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteMatchmakingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMatchmakingConfiguration")
	}

	var r0 *gamelift.DeleteMatchmakingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteMatchmakingConfigurationInput, ...func(*gamelift.Options)) (*gamelift.DeleteMatchmakingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteMatchmakingConfigurationInput, ...func(*gamelift.Options)) *gamelift.DeleteMatchmakingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteMatchmakingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteMatchmakingConfigurationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMatchmakingRuleSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMatchmakingRuleSet(ctx context.Context, params *gamelift.DeleteMatchmakingRuleSetInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteMatchmakingRuleSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMatchmakingRuleSet")
	}

	var r0 *gamelift.DeleteMatchmakingRuleSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteMatchmakingRuleSetInput, ...func(*gamelift.Options)) (*gamelift.DeleteMatchmakingRuleSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteMatchmakingRuleSetInput, ...func(*gamelift.Options)) *gamelift.DeleteMatchmakingRuleSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteMatchmakingRuleSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteMatchmakingRuleSetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteScalingPolicy(ctx context.Context, params *gamelift.DeleteScalingPolicyInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteScalingPolicy")
	}

	var r0 *gamelift.DeleteScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteScalingPolicyInput, ...func(*gamelift.Options)) (*gamelift.DeleteScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteScalingPolicyInput, ...func(*gamelift.Options)) *gamelift.DeleteScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteScalingPolicyInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteScript provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteScript(ctx context.Context, params *gamelift.DeleteScriptInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteScriptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteScript")
	}

	var r0 *gamelift.DeleteScriptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteScriptInput, ...func(*gamelift.Options)) (*gamelift.DeleteScriptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteScriptInput, ...func(*gamelift.Options)) *gamelift.DeleteScriptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteScriptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteScriptInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcPeeringAuthorization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcPeeringAuthorization(ctx context.Context, params *gamelift.DeleteVpcPeeringAuthorizationInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteVpcPeeringAuthorizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcPeeringAuthorization")
	}

	var r0 *gamelift.DeleteVpcPeeringAuthorizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) (*gamelift.DeleteVpcPeeringAuthorizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) *gamelift.DeleteVpcPeeringAuthorizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteVpcPeeringAuthorizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteVpcPeeringAuthorizationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcPeeringConnection(ctx context.Context, params *gamelift.DeleteVpcPeeringConnectionInput, optFns ...func(*gamelift.Options)) (*gamelift.DeleteVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcPeeringConnection")
	}

	var r0 *gamelift.DeleteVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteVpcPeeringConnectionInput, ...func(*gamelift.Options)) (*gamelift.DeleteVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeleteVpcPeeringConnectionInput, ...func(*gamelift.Options)) *gamelift.DeleteVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeleteVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeleteVpcPeeringConnectionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterCompute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterCompute(ctx context.Context, params *gamelift.DeregisterComputeInput, optFns ...func(*gamelift.Options)) (*gamelift.DeregisterComputeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterCompute")
	}

	var r0 *gamelift.DeregisterComputeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeregisterComputeInput, ...func(*gamelift.Options)) (*gamelift.DeregisterComputeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeregisterComputeInput, ...func(*gamelift.Options)) *gamelift.DeregisterComputeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeregisterComputeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeregisterComputeInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterGameServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterGameServer(ctx context.Context, params *gamelift.DeregisterGameServerInput, optFns ...func(*gamelift.Options)) (*gamelift.DeregisterGameServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterGameServer")
	}

	var r0 *gamelift.DeregisterGameServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeregisterGameServerInput, ...func(*gamelift.Options)) (*gamelift.DeregisterGameServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DeregisterGameServerInput, ...func(*gamelift.Options)) *gamelift.DeregisterGameServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DeregisterGameServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DeregisterGameServerInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAlias(ctx context.Context, params *gamelift.DescribeAliasInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAlias")
	}

	var r0 *gamelift.DescribeAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeAliasInput, ...func(*gamelift.Options)) (*gamelift.DescribeAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeAliasInput, ...func(*gamelift.Options)) *gamelift.DescribeAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeAliasInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBuild(ctx context.Context, params *gamelift.DescribeBuildInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBuild")
	}

	var r0 *gamelift.DescribeBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeBuildInput, ...func(*gamelift.Options)) (*gamelift.DescribeBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeBuildInput, ...func(*gamelift.Options)) *gamelift.DescribeBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeBuildInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCompute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCompute(ctx context.Context, params *gamelift.DescribeComputeInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeComputeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCompute")
	}

	var r0 *gamelift.DescribeComputeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeComputeInput, ...func(*gamelift.Options)) (*gamelift.DescribeComputeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeComputeInput, ...func(*gamelift.Options)) *gamelift.DescribeComputeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeComputeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeComputeInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeContainerFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeContainerFleet(ctx context.Context, params *gamelift.DescribeContainerFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeContainerFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeContainerFleet")
	}

	var r0 *gamelift.DescribeContainerFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeContainerFleetInput, ...func(*gamelift.Options)) (*gamelift.DescribeContainerFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeContainerFleetInput, ...func(*gamelift.Options)) *gamelift.DescribeContainerFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeContainerFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeContainerFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeContainerGroupDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeContainerGroupDefinition(ctx context.Context, params *gamelift.DescribeContainerGroupDefinitionInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeContainerGroupDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeContainerGroupDefinition")
	}

	var r0 *gamelift.DescribeContainerGroupDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeContainerGroupDefinitionInput, ...func(*gamelift.Options)) (*gamelift.DescribeContainerGroupDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeContainerGroupDefinitionInput, ...func(*gamelift.Options)) *gamelift.DescribeContainerGroupDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeContainerGroupDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeContainerGroupDefinitionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEC2InstanceLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEC2InstanceLimits(ctx context.Context, params *gamelift.DescribeEC2InstanceLimitsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeEC2InstanceLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEC2InstanceLimits")
	}

	var r0 *gamelift.DescribeEC2InstanceLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeEC2InstanceLimitsInput, ...func(*gamelift.Options)) (*gamelift.DescribeEC2InstanceLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeEC2InstanceLimitsInput, ...func(*gamelift.Options)) *gamelift.DescribeEC2InstanceLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeEC2InstanceLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeEC2InstanceLimitsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetAttributes(ctx context.Context, params *gamelift.DescribeFleetAttributesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetAttributes")
	}

	var r0 *gamelift.DescribeFleetAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetAttributesInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetAttributesInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetAttributesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetCapacity(ctx context.Context, params *gamelift.DescribeFleetCapacityInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetCapacity")
	}

	var r0 *gamelift.DescribeFleetCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetCapacityInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetCapacityInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetCapacityInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetDeployment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetDeployment(ctx context.Context, params *gamelift.DescribeFleetDeploymentInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetDeploymentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetDeployment")
	}

	var r0 *gamelift.DescribeFleetDeploymentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetDeploymentInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetDeploymentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetDeploymentInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetDeploymentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetDeploymentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetDeploymentInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetEvents(ctx context.Context, params *gamelift.DescribeFleetEventsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetEvents")
	}

	var r0 *gamelift.DescribeFleetEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetEventsInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetEventsInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetEventsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetLocationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetLocationAttributes(ctx context.Context, params *gamelift.DescribeFleetLocationAttributesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetLocationAttributes")
	}

	var r0 *gamelift.DescribeFleetLocationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationAttributesInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationAttributesInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetLocationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetLocationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetLocationAttributesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetLocationCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetLocationCapacity(ctx context.Context, params *gamelift.DescribeFleetLocationCapacityInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetLocationCapacity")
	}

	var r0 *gamelift.DescribeFleetLocationCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationCapacityInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationCapacityInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetLocationCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetLocationCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetLocationCapacityInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetLocationUtilization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetLocationUtilization(ctx context.Context, params *gamelift.DescribeFleetLocationUtilizationInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationUtilizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetLocationUtilization")
	}

	var r0 *gamelift.DescribeFleetLocationUtilizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationUtilizationInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetLocationUtilizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetLocationUtilizationInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetLocationUtilizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetLocationUtilizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetLocationUtilizationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetPortSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetPortSettings(ctx context.Context, params *gamelift.DescribeFleetPortSettingsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetPortSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetPortSettings")
	}

	var r0 *gamelift.DescribeFleetPortSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetPortSettingsInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetPortSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetPortSettingsInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetPortSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetPortSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetPortSettingsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetUtilization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleetUtilization(ctx context.Context, params *gamelift.DescribeFleetUtilizationInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeFleetUtilizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetUtilization")
	}

	var r0 *gamelift.DescribeFleetUtilizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetUtilizationInput, ...func(*gamelift.Options)) (*gamelift.DescribeFleetUtilizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeFleetUtilizationInput, ...func(*gamelift.Options)) *gamelift.DescribeFleetUtilizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeFleetUtilizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeFleetUtilizationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameServer(ctx context.Context, params *gamelift.DescribeGameServerInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameServer")
	}

	var r0 *gamelift.DescribeGameServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerInput, ...func(*gamelift.Options)) *gamelift.DescribeGameServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameServerInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameServerGroup(ctx context.Context, params *gamelift.DescribeGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameServerGroup")
	}

	var r0 *gamelift.DescribeGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.DescribeGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameServerInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameServerInstances(ctx context.Context, params *gamelift.DescribeGameServerInstancesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameServerInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameServerInstances")
	}

	var r0 *gamelift.DescribeGameServerInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerInstancesInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameServerInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameServerInstancesInput, ...func(*gamelift.Options)) *gamelift.DescribeGameServerInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameServerInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameServerInstancesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameSessionDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameSessionDetails(ctx context.Context, params *gamelift.DescribeGameSessionDetailsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameSessionDetails")
	}

	var r0 *gamelift.DescribeGameSessionDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionDetailsInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionDetailsInput, ...func(*gamelift.Options)) *gamelift.DescribeGameSessionDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameSessionDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameSessionDetailsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameSessionPlacement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameSessionPlacement(ctx context.Context, params *gamelift.DescribeGameSessionPlacementInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionPlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameSessionPlacement")
	}

	var r0 *gamelift.DescribeGameSessionPlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionPlacementInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionPlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionPlacementInput, ...func(*gamelift.Options)) *gamelift.DescribeGameSessionPlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameSessionPlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameSessionPlacementInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameSessionQueues provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameSessionQueues(ctx context.Context, params *gamelift.DescribeGameSessionQueuesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionQueuesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameSessionQueues")
	}

	var r0 *gamelift.DescribeGameSessionQueuesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionQueuesInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionQueuesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionQueuesInput, ...func(*gamelift.Options)) *gamelift.DescribeGameSessionQueuesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameSessionQueuesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameSessionQueuesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGameSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeGameSessions(ctx context.Context, params *gamelift.DescribeGameSessionsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeGameSessions")
	}

	var r0 *gamelift.DescribeGameSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionsInput, ...func(*gamelift.Options)) (*gamelift.DescribeGameSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeGameSessionsInput, ...func(*gamelift.Options)) *gamelift.DescribeGameSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeGameSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeGameSessionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstances provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInstances(ctx context.Context, params *gamelift.DescribeInstancesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstances")
	}

	var r0 *gamelift.DescribeInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeInstancesInput, ...func(*gamelift.Options)) (*gamelift.DescribeInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeInstancesInput, ...func(*gamelift.Options)) *gamelift.DescribeInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeInstancesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMatchmaking provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMatchmaking(ctx context.Context, params *gamelift.DescribeMatchmakingInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMatchmaking")
	}

	var r0 *gamelift.DescribeMatchmakingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingInput, ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingInput, ...func(*gamelift.Options)) *gamelift.DescribeMatchmakingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeMatchmakingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeMatchmakingInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMatchmakingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMatchmakingConfigurations(ctx context.Context, params *gamelift.DescribeMatchmakingConfigurationsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMatchmakingConfigurations")
	}

	var r0 *gamelift.DescribeMatchmakingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingConfigurationsInput, ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingConfigurationsInput, ...func(*gamelift.Options)) *gamelift.DescribeMatchmakingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeMatchmakingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeMatchmakingConfigurationsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMatchmakingRuleSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMatchmakingRuleSets(ctx context.Context, params *gamelift.DescribeMatchmakingRuleSetsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingRuleSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMatchmakingRuleSets")
	}

	var r0 *gamelift.DescribeMatchmakingRuleSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingRuleSetsInput, ...func(*gamelift.Options)) (*gamelift.DescribeMatchmakingRuleSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeMatchmakingRuleSetsInput, ...func(*gamelift.Options)) *gamelift.DescribeMatchmakingRuleSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeMatchmakingRuleSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeMatchmakingRuleSetsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePlayerSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePlayerSessions(ctx context.Context, params *gamelift.DescribePlayerSessionsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribePlayerSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePlayerSessions")
	}

	var r0 *gamelift.DescribePlayerSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribePlayerSessionsInput, ...func(*gamelift.Options)) (*gamelift.DescribePlayerSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribePlayerSessionsInput, ...func(*gamelift.Options)) *gamelift.DescribePlayerSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribePlayerSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribePlayerSessionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRuntimeConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRuntimeConfiguration(ctx context.Context, params *gamelift.DescribeRuntimeConfigurationInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeRuntimeConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRuntimeConfiguration")
	}

	var r0 *gamelift.DescribeRuntimeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeRuntimeConfigurationInput, ...func(*gamelift.Options)) (*gamelift.DescribeRuntimeConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeRuntimeConfigurationInput, ...func(*gamelift.Options)) *gamelift.DescribeRuntimeConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeRuntimeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeRuntimeConfigurationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScalingPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeScalingPolicies(ctx context.Context, params *gamelift.DescribeScalingPoliciesInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeScalingPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScalingPolicies")
	}

	var r0 *gamelift.DescribeScalingPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeScalingPoliciesInput, ...func(*gamelift.Options)) (*gamelift.DescribeScalingPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeScalingPoliciesInput, ...func(*gamelift.Options)) *gamelift.DescribeScalingPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeScalingPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeScalingPoliciesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScript provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeScript(ctx context.Context, params *gamelift.DescribeScriptInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeScriptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScript")
	}

	var r0 *gamelift.DescribeScriptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeScriptInput, ...func(*gamelift.Options)) (*gamelift.DescribeScriptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeScriptInput, ...func(*gamelift.Options)) *gamelift.DescribeScriptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeScriptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeScriptInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcPeeringAuthorizations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcPeeringAuthorizations(ctx context.Context, params *gamelift.DescribeVpcPeeringAuthorizationsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeVpcPeeringAuthorizationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcPeeringAuthorizations")
	}

	var r0 *gamelift.DescribeVpcPeeringAuthorizationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeVpcPeeringAuthorizationsInput, ...func(*gamelift.Options)) (*gamelift.DescribeVpcPeeringAuthorizationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeVpcPeeringAuthorizationsInput, ...func(*gamelift.Options)) *gamelift.DescribeVpcPeeringAuthorizationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeVpcPeeringAuthorizationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeVpcPeeringAuthorizationsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcPeeringConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcPeeringConnections(ctx context.Context, params *gamelift.DescribeVpcPeeringConnectionsInput, optFns ...func(*gamelift.Options)) (*gamelift.DescribeVpcPeeringConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcPeeringConnections")
	}

	var r0 *gamelift.DescribeVpcPeeringConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeVpcPeeringConnectionsInput, ...func(*gamelift.Options)) (*gamelift.DescribeVpcPeeringConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.DescribeVpcPeeringConnectionsInput, ...func(*gamelift.Options)) *gamelift.DescribeVpcPeeringConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.DescribeVpcPeeringConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.DescribeVpcPeeringConnectionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComputeAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetComputeAccess(ctx context.Context, params *gamelift.GetComputeAccessInput, optFns ...func(*gamelift.Options)) (*gamelift.GetComputeAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetComputeAccess")
	}

	var r0 *gamelift.GetComputeAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetComputeAccessInput, ...func(*gamelift.Options)) (*gamelift.GetComputeAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetComputeAccessInput, ...func(*gamelift.Options)) *gamelift.GetComputeAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.GetComputeAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.GetComputeAccessInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComputeAuthToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetComputeAuthToken(ctx context.Context, params *gamelift.GetComputeAuthTokenInput, optFns ...func(*gamelift.Options)) (*gamelift.GetComputeAuthTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetComputeAuthToken")
	}

	var r0 *gamelift.GetComputeAuthTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetComputeAuthTokenInput, ...func(*gamelift.Options)) (*gamelift.GetComputeAuthTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetComputeAuthTokenInput, ...func(*gamelift.Options)) *gamelift.GetComputeAuthTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.GetComputeAuthTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.GetComputeAuthTokenInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGameSessionLogUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGameSessionLogUrl(ctx context.Context, params *gamelift.GetGameSessionLogUrlInput, optFns ...func(*gamelift.Options)) (*gamelift.GetGameSessionLogUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGameSessionLogUrl")
	}

	var r0 *gamelift.GetGameSessionLogUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetGameSessionLogUrlInput, ...func(*gamelift.Options)) (*gamelift.GetGameSessionLogUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetGameSessionLogUrlInput, ...func(*gamelift.Options)) *gamelift.GetGameSessionLogUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.GetGameSessionLogUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.GetGameSessionLogUrlInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInstanceAccess(ctx context.Context, params *gamelift.GetInstanceAccessInput, optFns ...func(*gamelift.Options)) (*gamelift.GetInstanceAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceAccess")
	}

	var r0 *gamelift.GetInstanceAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetInstanceAccessInput, ...func(*gamelift.Options)) (*gamelift.GetInstanceAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.GetInstanceAccessInput, ...func(*gamelift.Options)) *gamelift.GetInstanceAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.GetInstanceAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.GetInstanceAccessInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAliases(ctx context.Context, params *gamelift.ListAliasesInput, optFns ...func(*gamelift.Options)) (*gamelift.ListAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAliases")
	}

	var r0 *gamelift.ListAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListAliasesInput, ...func(*gamelift.Options)) (*gamelift.ListAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListAliasesInput, ...func(*gamelift.Options)) *gamelift.ListAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListAliasesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuilds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBuilds(ctx context.Context, params *gamelift.ListBuildsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListBuildsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuilds")
	}

	var r0 *gamelift.ListBuildsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListBuildsInput, ...func(*gamelift.Options)) (*gamelift.ListBuildsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListBuildsInput, ...func(*gamelift.Options)) *gamelift.ListBuildsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListBuildsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListBuildsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCompute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCompute(ctx context.Context, params *gamelift.ListComputeInput, optFns ...func(*gamelift.Options)) (*gamelift.ListComputeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCompute")
	}

	var r0 *gamelift.ListComputeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListComputeInput, ...func(*gamelift.Options)) (*gamelift.ListComputeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListComputeInput, ...func(*gamelift.Options)) *gamelift.ListComputeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListComputeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListComputeInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContainerFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContainerFleets(ctx context.Context, params *gamelift.ListContainerFleetsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListContainerFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContainerFleets")
	}

	var r0 *gamelift.ListContainerFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerFleetsInput, ...func(*gamelift.Options)) (*gamelift.ListContainerFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerFleetsInput, ...func(*gamelift.Options)) *gamelift.ListContainerFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListContainerFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListContainerFleetsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContainerGroupDefinitionVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContainerGroupDefinitionVersions(ctx context.Context, params *gamelift.ListContainerGroupDefinitionVersionsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListContainerGroupDefinitionVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContainerGroupDefinitionVersions")
	}

	var r0 *gamelift.ListContainerGroupDefinitionVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerGroupDefinitionVersionsInput, ...func(*gamelift.Options)) (*gamelift.ListContainerGroupDefinitionVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerGroupDefinitionVersionsInput, ...func(*gamelift.Options)) *gamelift.ListContainerGroupDefinitionVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListContainerGroupDefinitionVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListContainerGroupDefinitionVersionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContainerGroupDefinitions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListContainerGroupDefinitions(ctx context.Context, params *gamelift.ListContainerGroupDefinitionsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListContainerGroupDefinitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContainerGroupDefinitions")
	}

	var r0 *gamelift.ListContainerGroupDefinitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerGroupDefinitionsInput, ...func(*gamelift.Options)) (*gamelift.ListContainerGroupDefinitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListContainerGroupDefinitionsInput, ...func(*gamelift.Options)) *gamelift.ListContainerGroupDefinitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListContainerGroupDefinitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListContainerGroupDefinitionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFleetDeployments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFleetDeployments(ctx context.Context, params *gamelift.ListFleetDeploymentsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListFleetDeploymentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFleetDeployments")
	}

	var r0 *gamelift.ListFleetDeploymentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListFleetDeploymentsInput, ...func(*gamelift.Options)) (*gamelift.ListFleetDeploymentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListFleetDeploymentsInput, ...func(*gamelift.Options)) *gamelift.ListFleetDeploymentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListFleetDeploymentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListFleetDeploymentsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFleets(ctx context.Context, params *gamelift.ListFleetsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFleets")
	}

	var r0 *gamelift.ListFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListFleetsInput, ...func(*gamelift.Options)) (*gamelift.ListFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListFleetsInput, ...func(*gamelift.Options)) *gamelift.ListFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListFleetsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGameServerGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGameServerGroups(ctx context.Context, params *gamelift.ListGameServerGroupsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListGameServerGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGameServerGroups")
	}

	var r0 *gamelift.ListGameServerGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListGameServerGroupsInput, ...func(*gamelift.Options)) (*gamelift.ListGameServerGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListGameServerGroupsInput, ...func(*gamelift.Options)) *gamelift.ListGameServerGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListGameServerGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListGameServerGroupsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGameServers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGameServers(ctx context.Context, params *gamelift.ListGameServersInput, optFns ...func(*gamelift.Options)) (*gamelift.ListGameServersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGameServers")
	}

	var r0 *gamelift.ListGameServersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListGameServersInput, ...func(*gamelift.Options)) (*gamelift.ListGameServersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListGameServersInput, ...func(*gamelift.Options)) *gamelift.ListGameServersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListGameServersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListGameServersInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLocations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLocations(ctx context.Context, params *gamelift.ListLocationsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListLocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLocations")
	}

	var r0 *gamelift.ListLocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListLocationsInput, ...func(*gamelift.Options)) (*gamelift.ListLocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListLocationsInput, ...func(*gamelift.Options)) *gamelift.ListLocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListLocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListLocationsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListScripts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListScripts(ctx context.Context, params *gamelift.ListScriptsInput, optFns ...func(*gamelift.Options)) (*gamelift.ListScriptsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListScripts")
	}

	var r0 *gamelift.ListScriptsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListScriptsInput, ...func(*gamelift.Options)) (*gamelift.ListScriptsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListScriptsInput, ...func(*gamelift.Options)) *gamelift.ListScriptsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListScriptsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListScriptsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *gamelift.ListTagsForResourceInput, optFns ...func(*gamelift.Options)) (*gamelift.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *gamelift.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListTagsForResourceInput, ...func(*gamelift.Options)) (*gamelift.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ListTagsForResourceInput, ...func(*gamelift.Options)) *gamelift.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ListTagsForResourceInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() gamelift.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 gamelift.Options
	if rf, ok := ret.Get(0).(func() gamelift.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(gamelift.Options)
	}

	return r0
}

// PutScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutScalingPolicy(ctx context.Context, params *gamelift.PutScalingPolicyInput, optFns ...func(*gamelift.Options)) (*gamelift.PutScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutScalingPolicy")
	}

	var r0 *gamelift.PutScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.PutScalingPolicyInput, ...func(*gamelift.Options)) (*gamelift.PutScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.PutScalingPolicyInput, ...func(*gamelift.Options)) *gamelift.PutScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.PutScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.PutScalingPolicyInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterCompute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterCompute(ctx context.Context, params *gamelift.RegisterComputeInput, optFns ...func(*gamelift.Options)) (*gamelift.RegisterComputeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterCompute")
	}

	var r0 *gamelift.RegisterComputeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RegisterComputeInput, ...func(*gamelift.Options)) (*gamelift.RegisterComputeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RegisterComputeInput, ...func(*gamelift.Options)) *gamelift.RegisterComputeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.RegisterComputeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.RegisterComputeInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterGameServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterGameServer(ctx context.Context, params *gamelift.RegisterGameServerInput, optFns ...func(*gamelift.Options)) (*gamelift.RegisterGameServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterGameServer")
	}

	var r0 *gamelift.RegisterGameServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RegisterGameServerInput, ...func(*gamelift.Options)) (*gamelift.RegisterGameServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RegisterGameServerInput, ...func(*gamelift.Options)) *gamelift.RegisterGameServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.RegisterGameServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.RegisterGameServerInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestUploadCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RequestUploadCredentials(ctx context.Context, params *gamelift.RequestUploadCredentialsInput, optFns ...func(*gamelift.Options)) (*gamelift.RequestUploadCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestUploadCredentials")
	}

	var r0 *gamelift.RequestUploadCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RequestUploadCredentialsInput, ...func(*gamelift.Options)) (*gamelift.RequestUploadCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.RequestUploadCredentialsInput, ...func(*gamelift.Options)) *gamelift.RequestUploadCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.RequestUploadCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.RequestUploadCredentialsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolveAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResolveAlias(ctx context.Context, params *gamelift.ResolveAliasInput, optFns ...func(*gamelift.Options)) (*gamelift.ResolveAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResolveAlias")
	}

	var r0 *gamelift.ResolveAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ResolveAliasInput, ...func(*gamelift.Options)) (*gamelift.ResolveAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ResolveAliasInput, ...func(*gamelift.Options)) *gamelift.ResolveAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ResolveAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ResolveAliasInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResumeGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResumeGameServerGroup(ctx context.Context, params *gamelift.ResumeGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.ResumeGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeGameServerGroup")
	}

	var r0 *gamelift.ResumeGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ResumeGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.ResumeGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ResumeGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.ResumeGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ResumeGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ResumeGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchGameSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchGameSessions(ctx context.Context, params *gamelift.SearchGameSessionsInput, optFns ...func(*gamelift.Options)) (*gamelift.SearchGameSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchGameSessions")
	}

	var r0 *gamelift.SearchGameSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.SearchGameSessionsInput, ...func(*gamelift.Options)) (*gamelift.SearchGameSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.SearchGameSessionsInput, ...func(*gamelift.Options)) *gamelift.SearchGameSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.SearchGameSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.SearchGameSessionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFleetActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFleetActions(ctx context.Context, params *gamelift.StartFleetActionsInput, optFns ...func(*gamelift.Options)) (*gamelift.StartFleetActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFleetActions")
	}

	var r0 *gamelift.StartFleetActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartFleetActionsInput, ...func(*gamelift.Options)) (*gamelift.StartFleetActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartFleetActionsInput, ...func(*gamelift.Options)) *gamelift.StartFleetActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StartFleetActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StartFleetActionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartGameSessionPlacement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartGameSessionPlacement(ctx context.Context, params *gamelift.StartGameSessionPlacementInput, optFns ...func(*gamelift.Options)) (*gamelift.StartGameSessionPlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartGameSessionPlacement")
	}

	var r0 *gamelift.StartGameSessionPlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartGameSessionPlacementInput, ...func(*gamelift.Options)) (*gamelift.StartGameSessionPlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartGameSessionPlacementInput, ...func(*gamelift.Options)) *gamelift.StartGameSessionPlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StartGameSessionPlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StartGameSessionPlacementInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMatchBackfill provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMatchBackfill(ctx context.Context, params *gamelift.StartMatchBackfillInput, optFns ...func(*gamelift.Options)) (*gamelift.StartMatchBackfillOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMatchBackfill")
	}

	var r0 *gamelift.StartMatchBackfillOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartMatchBackfillInput, ...func(*gamelift.Options)) (*gamelift.StartMatchBackfillOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartMatchBackfillInput, ...func(*gamelift.Options)) *gamelift.StartMatchBackfillOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StartMatchBackfillOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StartMatchBackfillInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMatchmaking provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMatchmaking(ctx context.Context, params *gamelift.StartMatchmakingInput, optFns ...func(*gamelift.Options)) (*gamelift.StartMatchmakingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMatchmaking")
	}

	var r0 *gamelift.StartMatchmakingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartMatchmakingInput, ...func(*gamelift.Options)) (*gamelift.StartMatchmakingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StartMatchmakingInput, ...func(*gamelift.Options)) *gamelift.StartMatchmakingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StartMatchmakingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StartMatchmakingInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopFleetActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopFleetActions(ctx context.Context, params *gamelift.StopFleetActionsInput, optFns ...func(*gamelift.Options)) (*gamelift.StopFleetActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopFleetActions")
	}

	var r0 *gamelift.StopFleetActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopFleetActionsInput, ...func(*gamelift.Options)) (*gamelift.StopFleetActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopFleetActionsInput, ...func(*gamelift.Options)) *gamelift.StopFleetActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StopFleetActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StopFleetActionsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopGameSessionPlacement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopGameSessionPlacement(ctx context.Context, params *gamelift.StopGameSessionPlacementInput, optFns ...func(*gamelift.Options)) (*gamelift.StopGameSessionPlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopGameSessionPlacement")
	}

	var r0 *gamelift.StopGameSessionPlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopGameSessionPlacementInput, ...func(*gamelift.Options)) (*gamelift.StopGameSessionPlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopGameSessionPlacementInput, ...func(*gamelift.Options)) *gamelift.StopGameSessionPlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StopGameSessionPlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StopGameSessionPlacementInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopMatchmaking provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopMatchmaking(ctx context.Context, params *gamelift.StopMatchmakingInput, optFns ...func(*gamelift.Options)) (*gamelift.StopMatchmakingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopMatchmaking")
	}

	var r0 *gamelift.StopMatchmakingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopMatchmakingInput, ...func(*gamelift.Options)) (*gamelift.StopMatchmakingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.StopMatchmakingInput, ...func(*gamelift.Options)) *gamelift.StopMatchmakingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.StopMatchmakingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.StopMatchmakingInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuspendGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SuspendGameServerGroup(ctx context.Context, params *gamelift.SuspendGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.SuspendGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SuspendGameServerGroup")
	}

	var r0 *gamelift.SuspendGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.SuspendGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.SuspendGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.SuspendGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.SuspendGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.SuspendGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.SuspendGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *gamelift.TagResourceInput, optFns ...func(*gamelift.Options)) (*gamelift.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *gamelift.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.TagResourceInput, ...func(*gamelift.Options)) (*gamelift.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.TagResourceInput, ...func(*gamelift.Options)) *gamelift.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.TagResourceInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateGameSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateGameSession(ctx context.Context, params *gamelift.TerminateGameSessionInput, optFns ...func(*gamelift.Options)) (*gamelift.TerminateGameSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateGameSession")
	}

	var r0 *gamelift.TerminateGameSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.TerminateGameSessionInput, ...func(*gamelift.Options)) (*gamelift.TerminateGameSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.TerminateGameSessionInput, ...func(*gamelift.Options)) *gamelift.TerminateGameSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.TerminateGameSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.TerminateGameSessionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *gamelift.UntagResourceInput, optFns ...func(*gamelift.Options)) (*gamelift.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *gamelift.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UntagResourceInput, ...func(*gamelift.Options)) (*gamelift.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UntagResourceInput, ...func(*gamelift.Options)) *gamelift.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UntagResourceInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAlias(ctx context.Context, params *gamelift.UpdateAliasInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAlias")
	}

	var r0 *gamelift.UpdateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateAliasInput, ...func(*gamelift.Options)) (*gamelift.UpdateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateAliasInput, ...func(*gamelift.Options)) *gamelift.UpdateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateAliasInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBuild provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBuild(ctx context.Context, params *gamelift.UpdateBuildInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateBuildOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBuild")
	}

	var r0 *gamelift.UpdateBuildOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateBuildInput, ...func(*gamelift.Options)) (*gamelift.UpdateBuildOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateBuildInput, ...func(*gamelift.Options)) *gamelift.UpdateBuildOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateBuildOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateBuildInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateContainerFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateContainerFleet(ctx context.Context, params *gamelift.UpdateContainerFleetInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateContainerFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContainerFleet")
	}

	var r0 *gamelift.UpdateContainerFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateContainerFleetInput, ...func(*gamelift.Options)) (*gamelift.UpdateContainerFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateContainerFleetInput, ...func(*gamelift.Options)) *gamelift.UpdateContainerFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateContainerFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateContainerFleetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateContainerGroupDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateContainerGroupDefinition(ctx context.Context, params *gamelift.UpdateContainerGroupDefinitionInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateContainerGroupDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContainerGroupDefinition")
	}

	var r0 *gamelift.UpdateContainerGroupDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateContainerGroupDefinitionInput, ...func(*gamelift.Options)) (*gamelift.UpdateContainerGroupDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateContainerGroupDefinitionInput, ...func(*gamelift.Options)) *gamelift.UpdateContainerGroupDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateContainerGroupDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateContainerGroupDefinitionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFleetAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFleetAttributes(ctx context.Context, params *gamelift.UpdateFleetAttributesInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateFleetAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFleetAttributes")
	}

	var r0 *gamelift.UpdateFleetAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetAttributesInput, ...func(*gamelift.Options)) (*gamelift.UpdateFleetAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetAttributesInput, ...func(*gamelift.Options)) *gamelift.UpdateFleetAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateFleetAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateFleetAttributesInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFleetCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFleetCapacity(ctx context.Context, params *gamelift.UpdateFleetCapacityInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateFleetCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFleetCapacity")
	}

	var r0 *gamelift.UpdateFleetCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetCapacityInput, ...func(*gamelift.Options)) (*gamelift.UpdateFleetCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetCapacityInput, ...func(*gamelift.Options)) *gamelift.UpdateFleetCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateFleetCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateFleetCapacityInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFleetPortSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFleetPortSettings(ctx context.Context, params *gamelift.UpdateFleetPortSettingsInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateFleetPortSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFleetPortSettings")
	}

	var r0 *gamelift.UpdateFleetPortSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetPortSettingsInput, ...func(*gamelift.Options)) (*gamelift.UpdateFleetPortSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateFleetPortSettingsInput, ...func(*gamelift.Options)) *gamelift.UpdateFleetPortSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateFleetPortSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateFleetPortSettingsInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGameServer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGameServer(ctx context.Context, params *gamelift.UpdateGameServerInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateGameServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGameServer")
	}

	var r0 *gamelift.UpdateGameServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameServerInput, ...func(*gamelift.Options)) (*gamelift.UpdateGameServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameServerInput, ...func(*gamelift.Options)) *gamelift.UpdateGameServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateGameServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateGameServerInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGameServerGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGameServerGroup(ctx context.Context, params *gamelift.UpdateGameServerGroupInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateGameServerGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGameServerGroup")
	}

	var r0 *gamelift.UpdateGameServerGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameServerGroupInput, ...func(*gamelift.Options)) (*gamelift.UpdateGameServerGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameServerGroupInput, ...func(*gamelift.Options)) *gamelift.UpdateGameServerGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateGameServerGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateGameServerGroupInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGameSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGameSession(ctx context.Context, params *gamelift.UpdateGameSessionInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateGameSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGameSession")
	}

	var r0 *gamelift.UpdateGameSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameSessionInput, ...func(*gamelift.Options)) (*gamelift.UpdateGameSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameSessionInput, ...func(*gamelift.Options)) *gamelift.UpdateGameSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateGameSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateGameSessionInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGameSessionQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGameSessionQueue(ctx context.Context, params *gamelift.UpdateGameSessionQueueInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateGameSessionQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGameSessionQueue")
	}

	var r0 *gamelift.UpdateGameSessionQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameSessionQueueInput, ...func(*gamelift.Options)) (*gamelift.UpdateGameSessionQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateGameSessionQueueInput, ...func(*gamelift.Options)) *gamelift.UpdateGameSessionQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateGameSessionQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateGameSessionQueueInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMatchmakingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMatchmakingConfiguration(ctx context.Context, params *gamelift.UpdateMatchmakingConfigurationInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateMatchmakingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMatchmakingConfiguration")
	}

	var r0 *gamelift.UpdateMatchmakingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateMatchmakingConfigurationInput, ...func(*gamelift.Options)) (*gamelift.UpdateMatchmakingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateMatchmakingConfigurationInput, ...func(*gamelift.Options)) *gamelift.UpdateMatchmakingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateMatchmakingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateMatchmakingConfigurationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuntimeConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuntimeConfiguration(ctx context.Context, params *gamelift.UpdateRuntimeConfigurationInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateRuntimeConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuntimeConfiguration")
	}

	var r0 *gamelift.UpdateRuntimeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateRuntimeConfigurationInput, ...func(*gamelift.Options)) (*gamelift.UpdateRuntimeConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateRuntimeConfigurationInput, ...func(*gamelift.Options)) *gamelift.UpdateRuntimeConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateRuntimeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateRuntimeConfigurationInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateScript provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateScript(ctx context.Context, params *gamelift.UpdateScriptInput, optFns ...func(*gamelift.Options)) (*gamelift.UpdateScriptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScript")
	}

	var r0 *gamelift.UpdateScriptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateScriptInput, ...func(*gamelift.Options)) (*gamelift.UpdateScriptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.UpdateScriptInput, ...func(*gamelift.Options)) *gamelift.UpdateScriptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.UpdateScriptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.UpdateScriptInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateMatchmakingRuleSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidateMatchmakingRuleSet(ctx context.Context, params *gamelift.ValidateMatchmakingRuleSetInput, optFns ...func(*gamelift.Options)) (*gamelift.ValidateMatchmakingRuleSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateMatchmakingRuleSet")
	}

	var r0 *gamelift.ValidateMatchmakingRuleSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ValidateMatchmakingRuleSetInput, ...func(*gamelift.Options)) (*gamelift.ValidateMatchmakingRuleSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gamelift.ValidateMatchmakingRuleSetInput, ...func(*gamelift.Options)) *gamelift.ValidateMatchmakingRuleSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gamelift.ValidateMatchmakingRuleSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gamelift.ValidateMatchmakingRuleSetInput, ...func(*gamelift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
