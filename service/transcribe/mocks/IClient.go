// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	transcribe "github.com/aws/aws-sdk-go-v2/service/transcribe"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateCallAnalyticsCategory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCallAnalyticsCategory(ctx context.Context, params *transcribe.CreateCallAnalyticsCategoryInput, optFns ...func(*transcribe.Options)) (*transcribe.CreateCallAnalyticsCategoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCallAnalyticsCategory")
	}

	var r0 *transcribe.CreateCallAnalyticsCategoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) (*transcribe.CreateCallAnalyticsCategoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) *transcribe.CreateCallAnalyticsCategoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.CreateCallAnalyticsCategoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.CreateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLanguageModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLanguageModel(ctx context.Context, params *transcribe.CreateLanguageModelInput, optFns ...func(*transcribe.Options)) (*transcribe.CreateLanguageModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLanguageModel")
	}

	var r0 *transcribe.CreateLanguageModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateLanguageModelInput, ...func(*transcribe.Options)) (*transcribe.CreateLanguageModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateLanguageModelInput, ...func(*transcribe.Options)) *transcribe.CreateLanguageModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.CreateLanguageModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.CreateLanguageModelInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMedicalVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMedicalVocabulary(ctx context.Context, params *transcribe.CreateMedicalVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.CreateMedicalVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMedicalVocabulary")
	}

	var r0 *transcribe.CreateMedicalVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateMedicalVocabularyInput, ...func(*transcribe.Options)) (*transcribe.CreateMedicalVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateMedicalVocabularyInput, ...func(*transcribe.Options)) *transcribe.CreateMedicalVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.CreateMedicalVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.CreateMedicalVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVocabulary(ctx context.Context, params *transcribe.CreateVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.CreateVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVocabulary")
	}

	var r0 *transcribe.CreateVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateVocabularyInput, ...func(*transcribe.Options)) (*transcribe.CreateVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateVocabularyInput, ...func(*transcribe.Options)) *transcribe.CreateVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.CreateVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.CreateVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVocabularyFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVocabularyFilter(ctx context.Context, params *transcribe.CreateVocabularyFilterInput, optFns ...func(*transcribe.Options)) (*transcribe.CreateVocabularyFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVocabularyFilter")
	}

	var r0 *transcribe.CreateVocabularyFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateVocabularyFilterInput, ...func(*transcribe.Options)) (*transcribe.CreateVocabularyFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.CreateVocabularyFilterInput, ...func(*transcribe.Options)) *transcribe.CreateVocabularyFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.CreateVocabularyFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.CreateVocabularyFilterInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCallAnalyticsCategory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCallAnalyticsCategory(ctx context.Context, params *transcribe.DeleteCallAnalyticsCategoryInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteCallAnalyticsCategoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCallAnalyticsCategory")
	}

	var r0 *transcribe.DeleteCallAnalyticsCategoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteCallAnalyticsCategoryInput, ...func(*transcribe.Options)) (*transcribe.DeleteCallAnalyticsCategoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteCallAnalyticsCategoryInput, ...func(*transcribe.Options)) *transcribe.DeleteCallAnalyticsCategoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteCallAnalyticsCategoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteCallAnalyticsCategoryInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCallAnalyticsJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCallAnalyticsJob(ctx context.Context, params *transcribe.DeleteCallAnalyticsJobInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteCallAnalyticsJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCallAnalyticsJob")
	}

	var r0 *transcribe.DeleteCallAnalyticsJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteCallAnalyticsJobInput, ...func(*transcribe.Options)) (*transcribe.DeleteCallAnalyticsJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteCallAnalyticsJobInput, ...func(*transcribe.Options)) *transcribe.DeleteCallAnalyticsJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteCallAnalyticsJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteCallAnalyticsJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLanguageModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLanguageModel(ctx context.Context, params *transcribe.DeleteLanguageModelInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteLanguageModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLanguageModel")
	}

	var r0 *transcribe.DeleteLanguageModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteLanguageModelInput, ...func(*transcribe.Options)) (*transcribe.DeleteLanguageModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteLanguageModelInput, ...func(*transcribe.Options)) *transcribe.DeleteLanguageModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteLanguageModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteLanguageModelInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMedicalScribeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMedicalScribeJob(ctx context.Context, params *transcribe.DeleteMedicalScribeJobInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteMedicalScribeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMedicalScribeJob")
	}

	var r0 *transcribe.DeleteMedicalScribeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalScribeJobInput, ...func(*transcribe.Options)) (*transcribe.DeleteMedicalScribeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalScribeJobInput, ...func(*transcribe.Options)) *transcribe.DeleteMedicalScribeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteMedicalScribeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteMedicalScribeJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMedicalTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMedicalTranscriptionJob(ctx context.Context, params *transcribe.DeleteMedicalTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteMedicalTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMedicalTranscriptionJob")
	}

	var r0 *transcribe.DeleteMedicalTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.DeleteMedicalTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.DeleteMedicalTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteMedicalTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteMedicalTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMedicalVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMedicalVocabulary(ctx context.Context, params *transcribe.DeleteMedicalVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteMedicalVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMedicalVocabulary")
	}

	var r0 *transcribe.DeleteMedicalVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalVocabularyInput, ...func(*transcribe.Options)) (*transcribe.DeleteMedicalVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteMedicalVocabularyInput, ...func(*transcribe.Options)) *transcribe.DeleteMedicalVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteMedicalVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteMedicalVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTranscriptionJob(ctx context.Context, params *transcribe.DeleteTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTranscriptionJob")
	}

	var r0 *transcribe.DeleteTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.DeleteTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.DeleteTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVocabulary(ctx context.Context, params *transcribe.DeleteVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVocabulary")
	}

	var r0 *transcribe.DeleteVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteVocabularyInput, ...func(*transcribe.Options)) (*transcribe.DeleteVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteVocabularyInput, ...func(*transcribe.Options)) *transcribe.DeleteVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVocabularyFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVocabularyFilter(ctx context.Context, params *transcribe.DeleteVocabularyFilterInput, optFns ...func(*transcribe.Options)) (*transcribe.DeleteVocabularyFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVocabularyFilter")
	}

	var r0 *transcribe.DeleteVocabularyFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteVocabularyFilterInput, ...func(*transcribe.Options)) (*transcribe.DeleteVocabularyFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DeleteVocabularyFilterInput, ...func(*transcribe.Options)) *transcribe.DeleteVocabularyFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DeleteVocabularyFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DeleteVocabularyFilterInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLanguageModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLanguageModel(ctx context.Context, params *transcribe.DescribeLanguageModelInput, optFns ...func(*transcribe.Options)) (*transcribe.DescribeLanguageModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLanguageModel")
	}

	var r0 *transcribe.DescribeLanguageModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DescribeLanguageModelInput, ...func(*transcribe.Options)) (*transcribe.DescribeLanguageModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.DescribeLanguageModelInput, ...func(*transcribe.Options)) *transcribe.DescribeLanguageModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.DescribeLanguageModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.DescribeLanguageModelInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCallAnalyticsCategory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCallAnalyticsCategory(ctx context.Context, params *transcribe.GetCallAnalyticsCategoryInput, optFns ...func(*transcribe.Options)) (*transcribe.GetCallAnalyticsCategoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCallAnalyticsCategory")
	}

	var r0 *transcribe.GetCallAnalyticsCategoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetCallAnalyticsCategoryInput, ...func(*transcribe.Options)) (*transcribe.GetCallAnalyticsCategoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetCallAnalyticsCategoryInput, ...func(*transcribe.Options)) *transcribe.GetCallAnalyticsCategoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetCallAnalyticsCategoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetCallAnalyticsCategoryInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCallAnalyticsJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCallAnalyticsJob(ctx context.Context, params *transcribe.GetCallAnalyticsJobInput, optFns ...func(*transcribe.Options)) (*transcribe.GetCallAnalyticsJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCallAnalyticsJob")
	}

	var r0 *transcribe.GetCallAnalyticsJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetCallAnalyticsJobInput, ...func(*transcribe.Options)) (*transcribe.GetCallAnalyticsJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetCallAnalyticsJobInput, ...func(*transcribe.Options)) *transcribe.GetCallAnalyticsJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetCallAnalyticsJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetCallAnalyticsJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMedicalScribeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMedicalScribeJob(ctx context.Context, params *transcribe.GetMedicalScribeJobInput, optFns ...func(*transcribe.Options)) (*transcribe.GetMedicalScribeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMedicalScribeJob")
	}

	var r0 *transcribe.GetMedicalScribeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalScribeJobInput, ...func(*transcribe.Options)) (*transcribe.GetMedicalScribeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalScribeJobInput, ...func(*transcribe.Options)) *transcribe.GetMedicalScribeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetMedicalScribeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetMedicalScribeJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMedicalTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMedicalTranscriptionJob(ctx context.Context, params *transcribe.GetMedicalTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.GetMedicalTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMedicalTranscriptionJob")
	}

	var r0 *transcribe.GetMedicalTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.GetMedicalTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.GetMedicalTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetMedicalTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetMedicalTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMedicalVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMedicalVocabulary(ctx context.Context, params *transcribe.GetMedicalVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.GetMedicalVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMedicalVocabulary")
	}

	var r0 *transcribe.GetMedicalVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalVocabularyInput, ...func(*transcribe.Options)) (*transcribe.GetMedicalVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetMedicalVocabularyInput, ...func(*transcribe.Options)) *transcribe.GetMedicalVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetMedicalVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetMedicalVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTranscriptionJob(ctx context.Context, params *transcribe.GetTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.GetTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTranscriptionJob")
	}

	var r0 *transcribe.GetTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.GetTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.GetTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVocabulary(ctx context.Context, params *transcribe.GetVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.GetVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVocabulary")
	}

	var r0 *transcribe.GetVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetVocabularyInput, ...func(*transcribe.Options)) (*transcribe.GetVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetVocabularyInput, ...func(*transcribe.Options)) *transcribe.GetVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVocabularyFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetVocabularyFilter(ctx context.Context, params *transcribe.GetVocabularyFilterInput, optFns ...func(*transcribe.Options)) (*transcribe.GetVocabularyFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVocabularyFilter")
	}

	var r0 *transcribe.GetVocabularyFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetVocabularyFilterInput, ...func(*transcribe.Options)) (*transcribe.GetVocabularyFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.GetVocabularyFilterInput, ...func(*transcribe.Options)) *transcribe.GetVocabularyFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.GetVocabularyFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.GetVocabularyFilterInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCallAnalyticsCategories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCallAnalyticsCategories(ctx context.Context, params *transcribe.ListCallAnalyticsCategoriesInput, optFns ...func(*transcribe.Options)) (*transcribe.ListCallAnalyticsCategoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCallAnalyticsCategories")
	}

	var r0 *transcribe.ListCallAnalyticsCategoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListCallAnalyticsCategoriesInput, ...func(*transcribe.Options)) (*transcribe.ListCallAnalyticsCategoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListCallAnalyticsCategoriesInput, ...func(*transcribe.Options)) *transcribe.ListCallAnalyticsCategoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListCallAnalyticsCategoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListCallAnalyticsCategoriesInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCallAnalyticsJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCallAnalyticsJobs(ctx context.Context, params *transcribe.ListCallAnalyticsJobsInput, optFns ...func(*transcribe.Options)) (*transcribe.ListCallAnalyticsJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCallAnalyticsJobs")
	}

	var r0 *transcribe.ListCallAnalyticsJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListCallAnalyticsJobsInput, ...func(*transcribe.Options)) (*transcribe.ListCallAnalyticsJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListCallAnalyticsJobsInput, ...func(*transcribe.Options)) *transcribe.ListCallAnalyticsJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListCallAnalyticsJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListCallAnalyticsJobsInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLanguageModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLanguageModels(ctx context.Context, params *transcribe.ListLanguageModelsInput, optFns ...func(*transcribe.Options)) (*transcribe.ListLanguageModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLanguageModels")
	}

	var r0 *transcribe.ListLanguageModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListLanguageModelsInput, ...func(*transcribe.Options)) (*transcribe.ListLanguageModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListLanguageModelsInput, ...func(*transcribe.Options)) *transcribe.ListLanguageModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListLanguageModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListLanguageModelsInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMedicalScribeJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMedicalScribeJobs(ctx context.Context, params *transcribe.ListMedicalScribeJobsInput, optFns ...func(*transcribe.Options)) (*transcribe.ListMedicalScribeJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMedicalScribeJobs")
	}

	var r0 *transcribe.ListMedicalScribeJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalScribeJobsInput, ...func(*transcribe.Options)) (*transcribe.ListMedicalScribeJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalScribeJobsInput, ...func(*transcribe.Options)) *transcribe.ListMedicalScribeJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListMedicalScribeJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListMedicalScribeJobsInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMedicalTranscriptionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMedicalTranscriptionJobs(ctx context.Context, params *transcribe.ListMedicalTranscriptionJobsInput, optFns ...func(*transcribe.Options)) (*transcribe.ListMedicalTranscriptionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMedicalTranscriptionJobs")
	}

	var r0 *transcribe.ListMedicalTranscriptionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalTranscriptionJobsInput, ...func(*transcribe.Options)) (*transcribe.ListMedicalTranscriptionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalTranscriptionJobsInput, ...func(*transcribe.Options)) *transcribe.ListMedicalTranscriptionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListMedicalTranscriptionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListMedicalTranscriptionJobsInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMedicalVocabularies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMedicalVocabularies(ctx context.Context, params *transcribe.ListMedicalVocabulariesInput, optFns ...func(*transcribe.Options)) (*transcribe.ListMedicalVocabulariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMedicalVocabularies")
	}

	var r0 *transcribe.ListMedicalVocabulariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalVocabulariesInput, ...func(*transcribe.Options)) (*transcribe.ListMedicalVocabulariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListMedicalVocabulariesInput, ...func(*transcribe.Options)) *transcribe.ListMedicalVocabulariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListMedicalVocabulariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListMedicalVocabulariesInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *transcribe.ListTagsForResourceInput, optFns ...func(*transcribe.Options)) (*transcribe.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *transcribe.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListTagsForResourceInput, ...func(*transcribe.Options)) (*transcribe.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListTagsForResourceInput, ...func(*transcribe.Options)) *transcribe.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListTagsForResourceInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTranscriptionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTranscriptionJobs(ctx context.Context, params *transcribe.ListTranscriptionJobsInput, optFns ...func(*transcribe.Options)) (*transcribe.ListTranscriptionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTranscriptionJobs")
	}

	var r0 *transcribe.ListTranscriptionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListTranscriptionJobsInput, ...func(*transcribe.Options)) (*transcribe.ListTranscriptionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListTranscriptionJobsInput, ...func(*transcribe.Options)) *transcribe.ListTranscriptionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListTranscriptionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListTranscriptionJobsInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVocabularies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVocabularies(ctx context.Context, params *transcribe.ListVocabulariesInput, optFns ...func(*transcribe.Options)) (*transcribe.ListVocabulariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVocabularies")
	}

	var r0 *transcribe.ListVocabulariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListVocabulariesInput, ...func(*transcribe.Options)) (*transcribe.ListVocabulariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListVocabulariesInput, ...func(*transcribe.Options)) *transcribe.ListVocabulariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListVocabulariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListVocabulariesInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVocabularyFilters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVocabularyFilters(ctx context.Context, params *transcribe.ListVocabularyFiltersInput, optFns ...func(*transcribe.Options)) (*transcribe.ListVocabularyFiltersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVocabularyFilters")
	}

	var r0 *transcribe.ListVocabularyFiltersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListVocabularyFiltersInput, ...func(*transcribe.Options)) (*transcribe.ListVocabularyFiltersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.ListVocabularyFiltersInput, ...func(*transcribe.Options)) *transcribe.ListVocabularyFiltersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.ListVocabularyFiltersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.ListVocabularyFiltersInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() transcribe.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 transcribe.Options
	if rf, ok := ret.Get(0).(func() transcribe.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(transcribe.Options)
	}

	return r0
}

// StartCallAnalyticsJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCallAnalyticsJob(ctx context.Context, params *transcribe.StartCallAnalyticsJobInput, optFns ...func(*transcribe.Options)) (*transcribe.StartCallAnalyticsJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCallAnalyticsJob")
	}

	var r0 *transcribe.StartCallAnalyticsJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartCallAnalyticsJobInput, ...func(*transcribe.Options)) (*transcribe.StartCallAnalyticsJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartCallAnalyticsJobInput, ...func(*transcribe.Options)) *transcribe.StartCallAnalyticsJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.StartCallAnalyticsJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.StartCallAnalyticsJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMedicalScribeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMedicalScribeJob(ctx context.Context, params *transcribe.StartMedicalScribeJobInput, optFns ...func(*transcribe.Options)) (*transcribe.StartMedicalScribeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMedicalScribeJob")
	}

	var r0 *transcribe.StartMedicalScribeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartMedicalScribeJobInput, ...func(*transcribe.Options)) (*transcribe.StartMedicalScribeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartMedicalScribeJobInput, ...func(*transcribe.Options)) *transcribe.StartMedicalScribeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.StartMedicalScribeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.StartMedicalScribeJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMedicalTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMedicalTranscriptionJob(ctx context.Context, params *transcribe.StartMedicalTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.StartMedicalTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMedicalTranscriptionJob")
	}

	var r0 *transcribe.StartMedicalTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartMedicalTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.StartMedicalTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartMedicalTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.StartMedicalTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.StartMedicalTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.StartMedicalTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTranscriptionJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTranscriptionJob(ctx context.Context, params *transcribe.StartTranscriptionJobInput, optFns ...func(*transcribe.Options)) (*transcribe.StartTranscriptionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTranscriptionJob")
	}

	var r0 *transcribe.StartTranscriptionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartTranscriptionJobInput, ...func(*transcribe.Options)) (*transcribe.StartTranscriptionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.StartTranscriptionJobInput, ...func(*transcribe.Options)) *transcribe.StartTranscriptionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.StartTranscriptionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.StartTranscriptionJobInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *transcribe.TagResourceInput, optFns ...func(*transcribe.Options)) (*transcribe.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *transcribe.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.TagResourceInput, ...func(*transcribe.Options)) (*transcribe.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.TagResourceInput, ...func(*transcribe.Options)) *transcribe.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.TagResourceInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *transcribe.UntagResourceInput, optFns ...func(*transcribe.Options)) (*transcribe.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *transcribe.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UntagResourceInput, ...func(*transcribe.Options)) (*transcribe.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UntagResourceInput, ...func(*transcribe.Options)) *transcribe.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.UntagResourceInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCallAnalyticsCategory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCallAnalyticsCategory(ctx context.Context, params *transcribe.UpdateCallAnalyticsCategoryInput, optFns ...func(*transcribe.Options)) (*transcribe.UpdateCallAnalyticsCategoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCallAnalyticsCategory")
	}

	var r0 *transcribe.UpdateCallAnalyticsCategoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) (*transcribe.UpdateCallAnalyticsCategoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) *transcribe.UpdateCallAnalyticsCategoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.UpdateCallAnalyticsCategoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.UpdateCallAnalyticsCategoryInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMedicalVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMedicalVocabulary(ctx context.Context, params *transcribe.UpdateMedicalVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.UpdateMedicalVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMedicalVocabulary")
	}

	var r0 *transcribe.UpdateMedicalVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateMedicalVocabularyInput, ...func(*transcribe.Options)) (*transcribe.UpdateMedicalVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateMedicalVocabularyInput, ...func(*transcribe.Options)) *transcribe.UpdateMedicalVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.UpdateMedicalVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.UpdateMedicalVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVocabulary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVocabulary(ctx context.Context, params *transcribe.UpdateVocabularyInput, optFns ...func(*transcribe.Options)) (*transcribe.UpdateVocabularyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVocabulary")
	}

	var r0 *transcribe.UpdateVocabularyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateVocabularyInput, ...func(*transcribe.Options)) (*transcribe.UpdateVocabularyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateVocabularyInput, ...func(*transcribe.Options)) *transcribe.UpdateVocabularyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.UpdateVocabularyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.UpdateVocabularyInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVocabularyFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateVocabularyFilter(ctx context.Context, params *transcribe.UpdateVocabularyFilterInput, optFns ...func(*transcribe.Options)) (*transcribe.UpdateVocabularyFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVocabularyFilter")
	}

	var r0 *transcribe.UpdateVocabularyFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateVocabularyFilterInput, ...func(*transcribe.Options)) (*transcribe.UpdateVocabularyFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *transcribe.UpdateVocabularyFilterInput, ...func(*transcribe.Options)) *transcribe.UpdateVocabularyFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transcribe.UpdateVocabularyFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *transcribe.UpdateVocabularyFilterInput, ...func(*transcribe.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
