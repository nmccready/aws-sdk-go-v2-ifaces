// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	globalaccelerator "github.com/aws/aws-sdk-go-v2/service/globalaccelerator"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddCustomRoutingEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddCustomRoutingEndpoints(ctx context.Context, params *globalaccelerator.AddCustomRoutingEndpointsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.AddCustomRoutingEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCustomRoutingEndpoints")
	}

	var r0 *globalaccelerator.AddCustomRoutingEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AddCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.AddCustomRoutingEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AddCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.AddCustomRoutingEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.AddCustomRoutingEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.AddCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddEndpoints(ctx context.Context, params *globalaccelerator.AddEndpointsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.AddEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddEndpoints")
	}

	var r0 *globalaccelerator.AddEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AddEndpointsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.AddEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AddEndpointsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.AddEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.AddEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.AddEndpointsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AdvertiseByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AdvertiseByoipCidr(ctx context.Context, params *globalaccelerator.AdvertiseByoipCidrInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.AdvertiseByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AdvertiseByoipCidr")
	}

	var r0 *globalaccelerator.AdvertiseByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AdvertiseByoipCidrInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.AdvertiseByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AdvertiseByoipCidrInput, ...func(*globalaccelerator.Options)) *globalaccelerator.AdvertiseByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.AdvertiseByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.AdvertiseByoipCidrInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllowCustomRoutingTraffic provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AllowCustomRoutingTraffic(ctx context.Context, params *globalaccelerator.AllowCustomRoutingTrafficInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.AllowCustomRoutingTrafficOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllowCustomRoutingTraffic")
	}

	var r0 *globalaccelerator.AllowCustomRoutingTrafficOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AllowCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.AllowCustomRoutingTrafficOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.AllowCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) *globalaccelerator.AllowCustomRoutingTrafficOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.AllowCustomRoutingTrafficOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.AllowCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccelerator(ctx context.Context, params *globalaccelerator.CreateAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccelerator")
	}

	var r0 *globalaccelerator.CreateAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCrossAccountAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCrossAccountAttachment(ctx context.Context, params *globalaccelerator.CreateCrossAccountAttachmentInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCrossAccountAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCrossAccountAttachment")
	}

	var r0 *globalaccelerator.CreateCrossAccountAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCrossAccountAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateCrossAccountAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateCrossAccountAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomRoutingAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomRoutingAccelerator(ctx context.Context, params *globalaccelerator.CreateCustomRoutingAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomRoutingAccelerator")
	}

	var r0 *globalaccelerator.CreateCustomRoutingAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateCustomRoutingAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateCustomRoutingAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomRoutingEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomRoutingEndpointGroup(ctx context.Context, params *globalaccelerator.CreateCustomRoutingEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomRoutingEndpointGroup")
	}

	var r0 *globalaccelerator.CreateCustomRoutingEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateCustomRoutingEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateCustomRoutingEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomRoutingListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomRoutingListener(ctx context.Context, params *globalaccelerator.CreateCustomRoutingListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomRoutingListener")
	}

	var r0 *globalaccelerator.CreateCustomRoutingListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateCustomRoutingListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateCustomRoutingListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateCustomRoutingListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEndpointGroup(ctx context.Context, params *globalaccelerator.CreateEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEndpointGroup")
	}

	var r0 *globalaccelerator.CreateEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateListener(ctx context.Context, params *globalaccelerator.CreateListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateListener")
	}

	var r0 *globalaccelerator.CreateListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.CreateListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.CreateListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.CreateListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.CreateListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.CreateListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccelerator(ctx context.Context, params *globalaccelerator.DeleteAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccelerator")
	}

	var r0 *globalaccelerator.DeleteAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCrossAccountAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCrossAccountAttachment(ctx context.Context, params *globalaccelerator.DeleteCrossAccountAttachmentInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCrossAccountAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCrossAccountAttachment")
	}

	var r0 *globalaccelerator.DeleteCrossAccountAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCrossAccountAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteCrossAccountAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteCrossAccountAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomRoutingAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomRoutingAccelerator(ctx context.Context, params *globalaccelerator.DeleteCustomRoutingAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomRoutingAccelerator")
	}

	var r0 *globalaccelerator.DeleteCustomRoutingAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteCustomRoutingAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteCustomRoutingAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomRoutingEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomRoutingEndpointGroup(ctx context.Context, params *globalaccelerator.DeleteCustomRoutingEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomRoutingEndpointGroup")
	}

	var r0 *globalaccelerator.DeleteCustomRoutingEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteCustomRoutingEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteCustomRoutingEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomRoutingListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomRoutingListener(ctx context.Context, params *globalaccelerator.DeleteCustomRoutingListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomRoutingListener")
	}

	var r0 *globalaccelerator.DeleteCustomRoutingListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteCustomRoutingListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteCustomRoutingListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteCustomRoutingListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEndpointGroup(ctx context.Context, params *globalaccelerator.DeleteEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEndpointGroup")
	}

	var r0 *globalaccelerator.DeleteEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteListener(ctx context.Context, params *globalaccelerator.DeleteListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteListener")
	}

	var r0 *globalaccelerator.DeleteListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeleteListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeleteListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeleteListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeleteListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeleteListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DenyCustomRoutingTraffic provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DenyCustomRoutingTraffic(ctx context.Context, params *globalaccelerator.DenyCustomRoutingTrafficInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DenyCustomRoutingTrafficOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DenyCustomRoutingTraffic")
	}

	var r0 *globalaccelerator.DenyCustomRoutingTrafficOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DenyCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DenyCustomRoutingTrafficOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DenyCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DenyCustomRoutingTrafficOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DenyCustomRoutingTrafficOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DenyCustomRoutingTrafficInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprovisionByoipCidr(ctx context.Context, params *globalaccelerator.DeprovisionByoipCidrInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DeprovisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionByoipCidr")
	}

	var r0 *globalaccelerator.DeprovisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeprovisionByoipCidrInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DeprovisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DeprovisionByoipCidrInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DeprovisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DeprovisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DeprovisionByoipCidrInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAccelerator(ctx context.Context, params *globalaccelerator.DescribeAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccelerator")
	}

	var r0 *globalaccelerator.DescribeAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAcceleratorAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAcceleratorAttributes(ctx context.Context, params *globalaccelerator.DescribeAcceleratorAttributesInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeAcceleratorAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAcceleratorAttributes")
	}

	var r0 *globalaccelerator.DescribeAcceleratorAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeAcceleratorAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeAcceleratorAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeAcceleratorAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCrossAccountAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCrossAccountAttachment(ctx context.Context, params *globalaccelerator.DescribeCrossAccountAttachmentInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCrossAccountAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCrossAccountAttachment")
	}

	var r0 *globalaccelerator.DescribeCrossAccountAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCrossAccountAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeCrossAccountAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeCrossAccountAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomRoutingAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomRoutingAccelerator(ctx context.Context, params *globalaccelerator.DescribeCustomRoutingAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomRoutingAccelerator")
	}

	var r0 *globalaccelerator.DescribeCustomRoutingAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeCustomRoutingAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeCustomRoutingAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomRoutingAcceleratorAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomRoutingAcceleratorAttributes(ctx context.Context, params *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingAcceleratorAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomRoutingAcceleratorAttributes")
	}

	var r0 *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingAcceleratorAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeCustomRoutingAcceleratorAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomRoutingEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomRoutingEndpointGroup(ctx context.Context, params *globalaccelerator.DescribeCustomRoutingEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomRoutingEndpointGroup")
	}

	var r0 *globalaccelerator.DescribeCustomRoutingEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeCustomRoutingEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeCustomRoutingEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeCustomRoutingEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomRoutingListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomRoutingListener(ctx context.Context, params *globalaccelerator.DescribeCustomRoutingListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomRoutingListener")
	}

	var r0 *globalaccelerator.DescribeCustomRoutingListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeCustomRoutingListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeCustomRoutingListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeCustomRoutingListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEndpointGroup(ctx context.Context, params *globalaccelerator.DescribeEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEndpointGroup")
	}

	var r0 *globalaccelerator.DescribeEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeListener(ctx context.Context, params *globalaccelerator.DescribeListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeListener")
	}

	var r0 *globalaccelerator.DescribeListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.DescribeListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.DescribeListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.DescribeListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.DescribeListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.DescribeListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccelerators provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccelerators(ctx context.Context, params *globalaccelerator.ListAcceleratorsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListAcceleratorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccelerators")
	}

	var r0 *globalaccelerator.ListAcceleratorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListAcceleratorsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListAcceleratorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListAcceleratorsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListAcceleratorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListAcceleratorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListAcceleratorsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListByoipCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListByoipCidrs(ctx context.Context, params *globalaccelerator.ListByoipCidrsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListByoipCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListByoipCidrs")
	}

	var r0 *globalaccelerator.ListByoipCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListByoipCidrsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListByoipCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListByoipCidrsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListByoipCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListByoipCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListByoipCidrsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCrossAccountAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCrossAccountAttachments(ctx context.Context, params *globalaccelerator.ListCrossAccountAttachmentsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCrossAccountAttachments")
	}

	var r0 *globalaccelerator.ListCrossAccountAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountAttachmentsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountAttachmentsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCrossAccountAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCrossAccountAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCrossAccountAttachmentsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCrossAccountResourceAccounts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCrossAccountResourceAccounts(ctx context.Context, params *globalaccelerator.ListCrossAccountResourceAccountsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountResourceAccountsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCrossAccountResourceAccounts")
	}

	var r0 *globalaccelerator.ListCrossAccountResourceAccountsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountResourceAccountsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountResourceAccountsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountResourceAccountsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCrossAccountResourceAccountsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCrossAccountResourceAccountsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCrossAccountResourceAccountsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCrossAccountResources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCrossAccountResources(ctx context.Context, params *globalaccelerator.ListCrossAccountResourcesInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountResourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCrossAccountResources")
	}

	var r0 *globalaccelerator.ListCrossAccountResourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountResourcesInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCrossAccountResourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCrossAccountResourcesInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCrossAccountResourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCrossAccountResourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCrossAccountResourcesInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomRoutingAccelerators provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomRoutingAccelerators(ctx context.Context, params *globalaccelerator.ListCustomRoutingAcceleratorsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingAcceleratorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomRoutingAccelerators")
	}

	var r0 *globalaccelerator.ListCustomRoutingAcceleratorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingAcceleratorsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingAcceleratorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingAcceleratorsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCustomRoutingAcceleratorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCustomRoutingAcceleratorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCustomRoutingAcceleratorsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomRoutingEndpointGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomRoutingEndpointGroups(ctx context.Context, params *globalaccelerator.ListCustomRoutingEndpointGroupsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingEndpointGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomRoutingEndpointGroups")
	}

	var r0 *globalaccelerator.ListCustomRoutingEndpointGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingEndpointGroupsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingEndpointGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingEndpointGroupsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCustomRoutingEndpointGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCustomRoutingEndpointGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCustomRoutingEndpointGroupsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomRoutingListeners provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomRoutingListeners(ctx context.Context, params *globalaccelerator.ListCustomRoutingListenersInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomRoutingListeners")
	}

	var r0 *globalaccelerator.ListCustomRoutingListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingListenersInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingListenersInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCustomRoutingListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCustomRoutingListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCustomRoutingListenersInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomRoutingPortMappings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomRoutingPortMappings(ctx context.Context, params *globalaccelerator.ListCustomRoutingPortMappingsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingPortMappingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomRoutingPortMappings")
	}

	var r0 *globalaccelerator.ListCustomRoutingPortMappingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingPortMappingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCustomRoutingPortMappingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCustomRoutingPortMappingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomRoutingPortMappingsByDestination provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomRoutingPortMappingsByDestination(ctx context.Context, params *globalaccelerator.ListCustomRoutingPortMappingsByDestinationInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingPortMappingsByDestinationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomRoutingPortMappingsByDestination")
	}

	var r0 *globalaccelerator.ListCustomRoutingPortMappingsByDestinationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsByDestinationInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListCustomRoutingPortMappingsByDestinationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsByDestinationInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListCustomRoutingPortMappingsByDestinationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListCustomRoutingPortMappingsByDestinationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListCustomRoutingPortMappingsByDestinationInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEndpointGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEndpointGroups(ctx context.Context, params *globalaccelerator.ListEndpointGroupsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListEndpointGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEndpointGroups")
	}

	var r0 *globalaccelerator.ListEndpointGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListEndpointGroupsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListEndpointGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListEndpointGroupsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListEndpointGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListEndpointGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListEndpointGroupsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListListeners provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListListeners(ctx context.Context, params *globalaccelerator.ListListenersInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListListeners")
	}

	var r0 *globalaccelerator.ListListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListListenersInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListListenersInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListListenersInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *globalaccelerator.ListTagsForResourceInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *globalaccelerator.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListTagsForResourceInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ListTagsForResourceInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ListTagsForResourceInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() globalaccelerator.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 globalaccelerator.Options
	if rf, ok := ret.Get(0).(func() globalaccelerator.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(globalaccelerator.Options)
	}

	return r0
}

// ProvisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ProvisionByoipCidr(ctx context.Context, params *globalaccelerator.ProvisionByoipCidrInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.ProvisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionByoipCidr")
	}

	var r0 *globalaccelerator.ProvisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ProvisionByoipCidrInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.ProvisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.ProvisionByoipCidrInput, ...func(*globalaccelerator.Options)) *globalaccelerator.ProvisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.ProvisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.ProvisionByoipCidrInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveCustomRoutingEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveCustomRoutingEndpoints(ctx context.Context, params *globalaccelerator.RemoveCustomRoutingEndpointsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.RemoveCustomRoutingEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveCustomRoutingEndpoints")
	}

	var r0 *globalaccelerator.RemoveCustomRoutingEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.RemoveCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.RemoveCustomRoutingEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.RemoveCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.RemoveCustomRoutingEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.RemoveCustomRoutingEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.RemoveCustomRoutingEndpointsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveEndpoints(ctx context.Context, params *globalaccelerator.RemoveEndpointsInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.RemoveEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveEndpoints")
	}

	var r0 *globalaccelerator.RemoveEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.RemoveEndpointsInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.RemoveEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.RemoveEndpointsInput, ...func(*globalaccelerator.Options)) *globalaccelerator.RemoveEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.RemoveEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.RemoveEndpointsInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *globalaccelerator.TagResourceInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *globalaccelerator.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.TagResourceInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.TagResourceInput, ...func(*globalaccelerator.Options)) *globalaccelerator.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.TagResourceInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *globalaccelerator.UntagResourceInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *globalaccelerator.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UntagResourceInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UntagResourceInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UntagResourceInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAccelerator(ctx context.Context, params *globalaccelerator.UpdateAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccelerator")
	}

	var r0 *globalaccelerator.UpdateAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAcceleratorAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAcceleratorAttributes(ctx context.Context, params *globalaccelerator.UpdateAcceleratorAttributesInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateAcceleratorAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAcceleratorAttributes")
	}

	var r0 *globalaccelerator.UpdateAcceleratorAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateAcceleratorAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateAcceleratorAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateAcceleratorAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCrossAccountAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCrossAccountAttachment(ctx context.Context, params *globalaccelerator.UpdateCrossAccountAttachmentInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCrossAccountAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCrossAccountAttachment")
	}

	var r0 *globalaccelerator.UpdateCrossAccountAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCrossAccountAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateCrossAccountAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateCrossAccountAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateCrossAccountAttachmentInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCustomRoutingAccelerator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCustomRoutingAccelerator(ctx context.Context, params *globalaccelerator.UpdateCustomRoutingAcceleratorInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingAcceleratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomRoutingAccelerator")
	}

	var r0 *globalaccelerator.UpdateCustomRoutingAcceleratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingAcceleratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateCustomRoutingAcceleratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateCustomRoutingAcceleratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCustomRoutingAcceleratorAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCustomRoutingAcceleratorAttributes(ctx context.Context, params *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingAcceleratorAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomRoutingAcceleratorAttributes")
	}

	var r0 *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingAcceleratorAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateCustomRoutingAcceleratorAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateCustomRoutingAcceleratorAttributesInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCustomRoutingListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCustomRoutingListener(ctx context.Context, params *globalaccelerator.UpdateCustomRoutingListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomRoutingListener")
	}

	var r0 *globalaccelerator.UpdateCustomRoutingListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateCustomRoutingListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateCustomRoutingListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateCustomRoutingListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateCustomRoutingListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEndpointGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEndpointGroup(ctx context.Context, params *globalaccelerator.UpdateEndpointGroupInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateEndpointGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEndpointGroup")
	}

	var r0 *globalaccelerator.UpdateEndpointGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateEndpointGroupInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateEndpointGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateEndpointGroupInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateEndpointGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateEndpointGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateEndpointGroupInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateListener provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateListener(ctx context.Context, params *globalaccelerator.UpdateListenerInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateListener")
	}

	var r0 *globalaccelerator.UpdateListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateListenerInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.UpdateListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.UpdateListenerInput, ...func(*globalaccelerator.Options)) *globalaccelerator.UpdateListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.UpdateListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.UpdateListenerInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) WithdrawByoipCidr(ctx context.Context, params *globalaccelerator.WithdrawByoipCidrInput, optFns ...func(*globalaccelerator.Options)) (*globalaccelerator.WithdrawByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawByoipCidr")
	}

	var r0 *globalaccelerator.WithdrawByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.WithdrawByoipCidrInput, ...func(*globalaccelerator.Options)) (*globalaccelerator.WithdrawByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *globalaccelerator.WithdrawByoipCidrInput, ...func(*globalaccelerator.Options)) *globalaccelerator.WithdrawByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*globalaccelerator.WithdrawByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *globalaccelerator.WithdrawByoipCidrInput, ...func(*globalaccelerator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
