// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	codepipeline "github.com/aws/aws-sdk-go-v2/service/codepipeline"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcknowledgeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcknowledgeJob(ctx context.Context, params *codepipeline.AcknowledgeJobInput, optFns ...func(*codepipeline.Options)) (*codepipeline.AcknowledgeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcknowledgeJob")
	}

	var r0 *codepipeline.AcknowledgeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.AcknowledgeJobInput, ...func(*codepipeline.Options)) (*codepipeline.AcknowledgeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.AcknowledgeJobInput, ...func(*codepipeline.Options)) *codepipeline.AcknowledgeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.AcknowledgeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.AcknowledgeJobInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcknowledgeThirdPartyJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcknowledgeThirdPartyJob(ctx context.Context, params *codepipeline.AcknowledgeThirdPartyJobInput, optFns ...func(*codepipeline.Options)) (*codepipeline.AcknowledgeThirdPartyJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcknowledgeThirdPartyJob")
	}

	var r0 *codepipeline.AcknowledgeThirdPartyJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.AcknowledgeThirdPartyJobInput, ...func(*codepipeline.Options)) (*codepipeline.AcknowledgeThirdPartyJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.AcknowledgeThirdPartyJobInput, ...func(*codepipeline.Options)) *codepipeline.AcknowledgeThirdPartyJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.AcknowledgeThirdPartyJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.AcknowledgeThirdPartyJobInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomActionType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomActionType(ctx context.Context, params *codepipeline.CreateCustomActionTypeInput, optFns ...func(*codepipeline.Options)) (*codepipeline.CreateCustomActionTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomActionType")
	}

	var r0 *codepipeline.CreateCustomActionTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.CreateCustomActionTypeInput, ...func(*codepipeline.Options)) (*codepipeline.CreateCustomActionTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.CreateCustomActionTypeInput, ...func(*codepipeline.Options)) *codepipeline.CreateCustomActionTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.CreateCustomActionTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.CreateCustomActionTypeInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePipeline(ctx context.Context, params *codepipeline.CreatePipelineInput, optFns ...func(*codepipeline.Options)) (*codepipeline.CreatePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePipeline")
	}

	var r0 *codepipeline.CreatePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.CreatePipelineInput, ...func(*codepipeline.Options)) (*codepipeline.CreatePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.CreatePipelineInput, ...func(*codepipeline.Options)) *codepipeline.CreatePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.CreatePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.CreatePipelineInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomActionType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomActionType(ctx context.Context, params *codepipeline.DeleteCustomActionTypeInput, optFns ...func(*codepipeline.Options)) (*codepipeline.DeleteCustomActionTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomActionType")
	}

	var r0 *codepipeline.DeleteCustomActionTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeleteCustomActionTypeInput, ...func(*codepipeline.Options)) (*codepipeline.DeleteCustomActionTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeleteCustomActionTypeInput, ...func(*codepipeline.Options)) *codepipeline.DeleteCustomActionTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.DeleteCustomActionTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.DeleteCustomActionTypeInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePipeline(ctx context.Context, params *codepipeline.DeletePipelineInput, optFns ...func(*codepipeline.Options)) (*codepipeline.DeletePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipeline")
	}

	var r0 *codepipeline.DeletePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeletePipelineInput, ...func(*codepipeline.Options)) (*codepipeline.DeletePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeletePipelineInput, ...func(*codepipeline.Options)) *codepipeline.DeletePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.DeletePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.DeletePipelineInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebhook provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWebhook(ctx context.Context, params *codepipeline.DeleteWebhookInput, optFns ...func(*codepipeline.Options)) (*codepipeline.DeleteWebhookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWebhook")
	}

	var r0 *codepipeline.DeleteWebhookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeleteWebhookInput, ...func(*codepipeline.Options)) (*codepipeline.DeleteWebhookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeleteWebhookInput, ...func(*codepipeline.Options)) *codepipeline.DeleteWebhookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.DeleteWebhookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.DeleteWebhookInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterWebhookWithThirdParty provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterWebhookWithThirdParty(ctx context.Context, params *codepipeline.DeregisterWebhookWithThirdPartyInput, optFns ...func(*codepipeline.Options)) (*codepipeline.DeregisterWebhookWithThirdPartyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterWebhookWithThirdParty")
	}

	var r0 *codepipeline.DeregisterWebhookWithThirdPartyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeregisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) (*codepipeline.DeregisterWebhookWithThirdPartyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DeregisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) *codepipeline.DeregisterWebhookWithThirdPartyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.DeregisterWebhookWithThirdPartyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.DeregisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableStageTransition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableStageTransition(ctx context.Context, params *codepipeline.DisableStageTransitionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.DisableStageTransitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableStageTransition")
	}

	var r0 *codepipeline.DisableStageTransitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DisableStageTransitionInput, ...func(*codepipeline.Options)) (*codepipeline.DisableStageTransitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.DisableStageTransitionInput, ...func(*codepipeline.Options)) *codepipeline.DisableStageTransitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.DisableStageTransitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.DisableStageTransitionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableStageTransition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableStageTransition(ctx context.Context, params *codepipeline.EnableStageTransitionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.EnableStageTransitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableStageTransition")
	}

	var r0 *codepipeline.EnableStageTransitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.EnableStageTransitionInput, ...func(*codepipeline.Options)) (*codepipeline.EnableStageTransitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.EnableStageTransitionInput, ...func(*codepipeline.Options)) *codepipeline.EnableStageTransitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.EnableStageTransitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.EnableStageTransitionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActionType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetActionType(ctx context.Context, params *codepipeline.GetActionTypeInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetActionTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetActionType")
	}

	var r0 *codepipeline.GetActionTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetActionTypeInput, ...func(*codepipeline.Options)) (*codepipeline.GetActionTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetActionTypeInput, ...func(*codepipeline.Options)) *codepipeline.GetActionTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetActionTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetActionTypeInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobDetails(ctx context.Context, params *codepipeline.GetJobDetailsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetJobDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobDetails")
	}

	var r0 *codepipeline.GetJobDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetJobDetailsInput, ...func(*codepipeline.Options)) (*codepipeline.GetJobDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetJobDetailsInput, ...func(*codepipeline.Options)) *codepipeline.GetJobDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetJobDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetJobDetailsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPipeline(ctx context.Context, params *codepipeline.GetPipelineInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetPipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipeline")
	}

	var r0 *codepipeline.GetPipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineInput, ...func(*codepipeline.Options)) (*codepipeline.GetPipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineInput, ...func(*codepipeline.Options)) *codepipeline.GetPipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetPipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetPipelineInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipelineExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPipelineExecution(ctx context.Context, params *codepipeline.GetPipelineExecutionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetPipelineExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineExecution")
	}

	var r0 *codepipeline.GetPipelineExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineExecutionInput, ...func(*codepipeline.Options)) (*codepipeline.GetPipelineExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineExecutionInput, ...func(*codepipeline.Options)) *codepipeline.GetPipelineExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetPipelineExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetPipelineExecutionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipelineState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPipelineState(ctx context.Context, params *codepipeline.GetPipelineStateInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetPipelineStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineState")
	}

	var r0 *codepipeline.GetPipelineStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineStateInput, ...func(*codepipeline.Options)) (*codepipeline.GetPipelineStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetPipelineStateInput, ...func(*codepipeline.Options)) *codepipeline.GetPipelineStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetPipelineStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetPipelineStateInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThirdPartyJobDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetThirdPartyJobDetails(ctx context.Context, params *codepipeline.GetThirdPartyJobDetailsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.GetThirdPartyJobDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetThirdPartyJobDetails")
	}

	var r0 *codepipeline.GetThirdPartyJobDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetThirdPartyJobDetailsInput, ...func(*codepipeline.Options)) (*codepipeline.GetThirdPartyJobDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.GetThirdPartyJobDetailsInput, ...func(*codepipeline.Options)) *codepipeline.GetThirdPartyJobDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.GetThirdPartyJobDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.GetThirdPartyJobDetailsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActionExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActionExecutions(ctx context.Context, params *codepipeline.ListActionExecutionsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListActionExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActionExecutions")
	}

	var r0 *codepipeline.ListActionExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListActionExecutionsInput, ...func(*codepipeline.Options)) (*codepipeline.ListActionExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListActionExecutionsInput, ...func(*codepipeline.Options)) *codepipeline.ListActionExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListActionExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListActionExecutionsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActionTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActionTypes(ctx context.Context, params *codepipeline.ListActionTypesInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListActionTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActionTypes")
	}

	var r0 *codepipeline.ListActionTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListActionTypesInput, ...func(*codepipeline.Options)) (*codepipeline.ListActionTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListActionTypesInput, ...func(*codepipeline.Options)) *codepipeline.ListActionTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListActionTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListActionTypesInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPipelineExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPipelineExecutions(ctx context.Context, params *codepipeline.ListPipelineExecutionsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListPipelineExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPipelineExecutions")
	}

	var r0 *codepipeline.ListPipelineExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListPipelineExecutionsInput, ...func(*codepipeline.Options)) (*codepipeline.ListPipelineExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListPipelineExecutionsInput, ...func(*codepipeline.Options)) *codepipeline.ListPipelineExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListPipelineExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListPipelineExecutionsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPipelines provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPipelines(ctx context.Context, params *codepipeline.ListPipelinesInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListPipelinesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPipelines")
	}

	var r0 *codepipeline.ListPipelinesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListPipelinesInput, ...func(*codepipeline.Options)) (*codepipeline.ListPipelinesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListPipelinesInput, ...func(*codepipeline.Options)) *codepipeline.ListPipelinesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListPipelinesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListPipelinesInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *codepipeline.ListTagsForResourceInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *codepipeline.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListTagsForResourceInput, ...func(*codepipeline.Options)) (*codepipeline.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListTagsForResourceInput, ...func(*codepipeline.Options)) *codepipeline.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListTagsForResourceInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWebhooks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWebhooks(ctx context.Context, params *codepipeline.ListWebhooksInput, optFns ...func(*codepipeline.Options)) (*codepipeline.ListWebhooksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWebhooks")
	}

	var r0 *codepipeline.ListWebhooksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListWebhooksInput, ...func(*codepipeline.Options)) (*codepipeline.ListWebhooksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.ListWebhooksInput, ...func(*codepipeline.Options)) *codepipeline.ListWebhooksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.ListWebhooksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.ListWebhooksInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() codepipeline.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 codepipeline.Options
	if rf, ok := ret.Get(0).(func() codepipeline.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(codepipeline.Options)
	}

	return r0
}

// PollForJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PollForJobs(ctx context.Context, params *codepipeline.PollForJobsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PollForJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForJobs")
	}

	var r0 *codepipeline.PollForJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PollForJobsInput, ...func(*codepipeline.Options)) (*codepipeline.PollForJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PollForJobsInput, ...func(*codepipeline.Options)) *codepipeline.PollForJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PollForJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PollForJobsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PollForThirdPartyJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PollForThirdPartyJobs(ctx context.Context, params *codepipeline.PollForThirdPartyJobsInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PollForThirdPartyJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForThirdPartyJobs")
	}

	var r0 *codepipeline.PollForThirdPartyJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PollForThirdPartyJobsInput, ...func(*codepipeline.Options)) (*codepipeline.PollForThirdPartyJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PollForThirdPartyJobsInput, ...func(*codepipeline.Options)) *codepipeline.PollForThirdPartyJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PollForThirdPartyJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PollForThirdPartyJobsInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutActionRevision provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutActionRevision(ctx context.Context, params *codepipeline.PutActionRevisionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutActionRevisionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutActionRevision")
	}

	var r0 *codepipeline.PutActionRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutActionRevisionInput, ...func(*codepipeline.Options)) (*codepipeline.PutActionRevisionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutActionRevisionInput, ...func(*codepipeline.Options)) *codepipeline.PutActionRevisionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutActionRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutActionRevisionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutApprovalResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutApprovalResult(ctx context.Context, params *codepipeline.PutApprovalResultInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutApprovalResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutApprovalResult")
	}

	var r0 *codepipeline.PutApprovalResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutApprovalResultInput, ...func(*codepipeline.Options)) (*codepipeline.PutApprovalResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutApprovalResultInput, ...func(*codepipeline.Options)) *codepipeline.PutApprovalResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutApprovalResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutApprovalResultInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutJobFailureResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutJobFailureResult(ctx context.Context, params *codepipeline.PutJobFailureResultInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutJobFailureResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutJobFailureResult")
	}

	var r0 *codepipeline.PutJobFailureResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutJobFailureResultInput, ...func(*codepipeline.Options)) (*codepipeline.PutJobFailureResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutJobFailureResultInput, ...func(*codepipeline.Options)) *codepipeline.PutJobFailureResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutJobFailureResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutJobFailureResultInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutJobSuccessResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutJobSuccessResult(ctx context.Context, params *codepipeline.PutJobSuccessResultInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutJobSuccessResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutJobSuccessResult")
	}

	var r0 *codepipeline.PutJobSuccessResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutJobSuccessResultInput, ...func(*codepipeline.Options)) (*codepipeline.PutJobSuccessResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutJobSuccessResultInput, ...func(*codepipeline.Options)) *codepipeline.PutJobSuccessResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutJobSuccessResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutJobSuccessResultInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutThirdPartyJobFailureResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutThirdPartyJobFailureResult(ctx context.Context, params *codepipeline.PutThirdPartyJobFailureResultInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutThirdPartyJobFailureResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutThirdPartyJobFailureResult")
	}

	var r0 *codepipeline.PutThirdPartyJobFailureResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutThirdPartyJobFailureResultInput, ...func(*codepipeline.Options)) (*codepipeline.PutThirdPartyJobFailureResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutThirdPartyJobFailureResultInput, ...func(*codepipeline.Options)) *codepipeline.PutThirdPartyJobFailureResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutThirdPartyJobFailureResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutThirdPartyJobFailureResultInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutThirdPartyJobSuccessResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutThirdPartyJobSuccessResult(ctx context.Context, params *codepipeline.PutThirdPartyJobSuccessResultInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutThirdPartyJobSuccessResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutThirdPartyJobSuccessResult")
	}

	var r0 *codepipeline.PutThirdPartyJobSuccessResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutThirdPartyJobSuccessResultInput, ...func(*codepipeline.Options)) (*codepipeline.PutThirdPartyJobSuccessResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutThirdPartyJobSuccessResultInput, ...func(*codepipeline.Options)) *codepipeline.PutThirdPartyJobSuccessResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutThirdPartyJobSuccessResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutThirdPartyJobSuccessResultInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutWebhook provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutWebhook(ctx context.Context, params *codepipeline.PutWebhookInput, optFns ...func(*codepipeline.Options)) (*codepipeline.PutWebhookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutWebhook")
	}

	var r0 *codepipeline.PutWebhookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutWebhookInput, ...func(*codepipeline.Options)) (*codepipeline.PutWebhookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.PutWebhookInput, ...func(*codepipeline.Options)) *codepipeline.PutWebhookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.PutWebhookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.PutWebhookInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterWebhookWithThirdParty provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterWebhookWithThirdParty(ctx context.Context, params *codepipeline.RegisterWebhookWithThirdPartyInput, optFns ...func(*codepipeline.Options)) (*codepipeline.RegisterWebhookWithThirdPartyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterWebhookWithThirdParty")
	}

	var r0 *codepipeline.RegisterWebhookWithThirdPartyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RegisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) (*codepipeline.RegisterWebhookWithThirdPartyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RegisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) *codepipeline.RegisterWebhookWithThirdPartyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.RegisterWebhookWithThirdPartyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.RegisterWebhookWithThirdPartyInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetryStageExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetryStageExecution(ctx context.Context, params *codepipeline.RetryStageExecutionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.RetryStageExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryStageExecution")
	}

	var r0 *codepipeline.RetryStageExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RetryStageExecutionInput, ...func(*codepipeline.Options)) (*codepipeline.RetryStageExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RetryStageExecutionInput, ...func(*codepipeline.Options)) *codepipeline.RetryStageExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.RetryStageExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.RetryStageExecutionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RollbackStage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RollbackStage(ctx context.Context, params *codepipeline.RollbackStageInput, optFns ...func(*codepipeline.Options)) (*codepipeline.RollbackStageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RollbackStage")
	}

	var r0 *codepipeline.RollbackStageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RollbackStageInput, ...func(*codepipeline.Options)) (*codepipeline.RollbackStageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.RollbackStageInput, ...func(*codepipeline.Options)) *codepipeline.RollbackStageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.RollbackStageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.RollbackStageInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartPipelineExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartPipelineExecution(ctx context.Context, params *codepipeline.StartPipelineExecutionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.StartPipelineExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartPipelineExecution")
	}

	var r0 *codepipeline.StartPipelineExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.StartPipelineExecutionInput, ...func(*codepipeline.Options)) (*codepipeline.StartPipelineExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.StartPipelineExecutionInput, ...func(*codepipeline.Options)) *codepipeline.StartPipelineExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.StartPipelineExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.StartPipelineExecutionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopPipelineExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopPipelineExecution(ctx context.Context, params *codepipeline.StopPipelineExecutionInput, optFns ...func(*codepipeline.Options)) (*codepipeline.StopPipelineExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopPipelineExecution")
	}

	var r0 *codepipeline.StopPipelineExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.StopPipelineExecutionInput, ...func(*codepipeline.Options)) (*codepipeline.StopPipelineExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.StopPipelineExecutionInput, ...func(*codepipeline.Options)) *codepipeline.StopPipelineExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.StopPipelineExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.StopPipelineExecutionInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *codepipeline.TagResourceInput, optFns ...func(*codepipeline.Options)) (*codepipeline.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *codepipeline.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.TagResourceInput, ...func(*codepipeline.Options)) (*codepipeline.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.TagResourceInput, ...func(*codepipeline.Options)) *codepipeline.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.TagResourceInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *codepipeline.UntagResourceInput, optFns ...func(*codepipeline.Options)) (*codepipeline.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *codepipeline.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UntagResourceInput, ...func(*codepipeline.Options)) (*codepipeline.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UntagResourceInput, ...func(*codepipeline.Options)) *codepipeline.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.UntagResourceInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateActionType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateActionType(ctx context.Context, params *codepipeline.UpdateActionTypeInput, optFns ...func(*codepipeline.Options)) (*codepipeline.UpdateActionTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateActionType")
	}

	var r0 *codepipeline.UpdateActionTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UpdateActionTypeInput, ...func(*codepipeline.Options)) (*codepipeline.UpdateActionTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UpdateActionTypeInput, ...func(*codepipeline.Options)) *codepipeline.UpdateActionTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.UpdateActionTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.UpdateActionTypeInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePipeline(ctx context.Context, params *codepipeline.UpdatePipelineInput, optFns ...func(*codepipeline.Options)) (*codepipeline.UpdatePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePipeline")
	}

	var r0 *codepipeline.UpdatePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UpdatePipelineInput, ...func(*codepipeline.Options)) (*codepipeline.UpdatePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codepipeline.UpdatePipelineInput, ...func(*codepipeline.Options)) *codepipeline.UpdatePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codepipeline.UpdatePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codepipeline.UpdatePipelineInput, ...func(*codepipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
