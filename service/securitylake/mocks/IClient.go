// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	securitylake "github.com/aws/aws-sdk-go-v2/service/securitylake"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAwsLogSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAwsLogSource(ctx context.Context, params *securitylake.CreateAwsLogSourceInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateAwsLogSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAwsLogSource")
	}

	var r0 *securitylake.CreateAwsLogSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateAwsLogSourceInput, ...func(*securitylake.Options)) (*securitylake.CreateAwsLogSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateAwsLogSourceInput, ...func(*securitylake.Options)) *securitylake.CreateAwsLogSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateAwsLogSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateAwsLogSourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomLogSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomLogSource(ctx context.Context, params *securitylake.CreateCustomLogSourceInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateCustomLogSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomLogSource")
	}

	var r0 *securitylake.CreateCustomLogSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateCustomLogSourceInput, ...func(*securitylake.Options)) (*securitylake.CreateCustomLogSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateCustomLogSourceInput, ...func(*securitylake.Options)) *securitylake.CreateCustomLogSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateCustomLogSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateCustomLogSourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataLake provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataLake(ctx context.Context, params *securitylake.CreateDataLakeInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateDataLakeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataLake")
	}

	var r0 *securitylake.CreateDataLakeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeInput, ...func(*securitylake.Options)) (*securitylake.CreateDataLakeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeInput, ...func(*securitylake.Options)) *securitylake.CreateDataLakeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateDataLakeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateDataLakeInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataLakeExceptionSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataLakeExceptionSubscription(ctx context.Context, params *securitylake.CreateDataLakeExceptionSubscriptionInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateDataLakeExceptionSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataLakeExceptionSubscription")
	}

	var r0 *securitylake.CreateDataLakeExceptionSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) (*securitylake.CreateDataLakeExceptionSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) *securitylake.CreateDataLakeExceptionSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateDataLakeExceptionSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataLakeOrganizationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataLakeOrganizationConfiguration(ctx context.Context, params *securitylake.CreateDataLakeOrganizationConfigurationInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateDataLakeOrganizationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataLakeOrganizationConfiguration")
	}

	var r0 *securitylake.CreateDataLakeOrganizationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) (*securitylake.CreateDataLakeOrganizationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) *securitylake.CreateDataLakeOrganizationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateDataLakeOrganizationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubscriber provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubscriber(ctx context.Context, params *securitylake.CreateSubscriberInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateSubscriberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubscriber")
	}

	var r0 *securitylake.CreateSubscriberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateSubscriberInput, ...func(*securitylake.Options)) (*securitylake.CreateSubscriberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateSubscriberInput, ...func(*securitylake.Options)) *securitylake.CreateSubscriberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateSubscriberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateSubscriberInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubscriberNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubscriberNotification(ctx context.Context, params *securitylake.CreateSubscriberNotificationInput, optFns ...func(*securitylake.Options)) (*securitylake.CreateSubscriberNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubscriberNotification")
	}

	var r0 *securitylake.CreateSubscriberNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateSubscriberNotificationInput, ...func(*securitylake.Options)) (*securitylake.CreateSubscriberNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.CreateSubscriberNotificationInput, ...func(*securitylake.Options)) *securitylake.CreateSubscriberNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.CreateSubscriberNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.CreateSubscriberNotificationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAwsLogSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAwsLogSource(ctx context.Context, params *securitylake.DeleteAwsLogSourceInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteAwsLogSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAwsLogSource")
	}

	var r0 *securitylake.DeleteAwsLogSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteAwsLogSourceInput, ...func(*securitylake.Options)) (*securitylake.DeleteAwsLogSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteAwsLogSourceInput, ...func(*securitylake.Options)) *securitylake.DeleteAwsLogSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteAwsLogSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteAwsLogSourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomLogSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomLogSource(ctx context.Context, params *securitylake.DeleteCustomLogSourceInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteCustomLogSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomLogSource")
	}

	var r0 *securitylake.DeleteCustomLogSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteCustomLogSourceInput, ...func(*securitylake.Options)) (*securitylake.DeleteCustomLogSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteCustomLogSourceInput, ...func(*securitylake.Options)) *securitylake.DeleteCustomLogSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteCustomLogSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteCustomLogSourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataLake provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataLake(ctx context.Context, params *securitylake.DeleteDataLakeInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataLake")
	}

	var r0 *securitylake.DeleteDataLakeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeInput, ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeInput, ...func(*securitylake.Options)) *securitylake.DeleteDataLakeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteDataLakeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteDataLakeInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataLakeExceptionSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataLakeExceptionSubscription(ctx context.Context, params *securitylake.DeleteDataLakeExceptionSubscriptionInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeExceptionSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataLakeExceptionSubscription")
	}

	var r0 *securitylake.DeleteDataLakeExceptionSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeExceptionSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) *securitylake.DeleteDataLakeExceptionSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteDataLakeExceptionSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataLakeOrganizationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataLakeOrganizationConfiguration(ctx context.Context, params *securitylake.DeleteDataLakeOrganizationConfigurationInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeOrganizationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataLakeOrganizationConfiguration")
	}

	var r0 *securitylake.DeleteDataLakeOrganizationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) (*securitylake.DeleteDataLakeOrganizationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) *securitylake.DeleteDataLakeOrganizationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteDataLakeOrganizationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubscriber provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubscriber(ctx context.Context, params *securitylake.DeleteSubscriberInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteSubscriberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubscriber")
	}

	var r0 *securitylake.DeleteSubscriberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteSubscriberInput, ...func(*securitylake.Options)) (*securitylake.DeleteSubscriberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteSubscriberInput, ...func(*securitylake.Options)) *securitylake.DeleteSubscriberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteSubscriberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteSubscriberInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubscriberNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubscriberNotification(ctx context.Context, params *securitylake.DeleteSubscriberNotificationInput, optFns ...func(*securitylake.Options)) (*securitylake.DeleteSubscriberNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubscriberNotification")
	}

	var r0 *securitylake.DeleteSubscriberNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteSubscriberNotificationInput, ...func(*securitylake.Options)) (*securitylake.DeleteSubscriberNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeleteSubscriberNotificationInput, ...func(*securitylake.Options)) *securitylake.DeleteSubscriberNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeleteSubscriberNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeleteSubscriberNotificationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterDataLakeDelegatedAdministrator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterDataLakeDelegatedAdministrator(ctx context.Context, params *securitylake.DeregisterDataLakeDelegatedAdministratorInput, optFns ...func(*securitylake.Options)) (*securitylake.DeregisterDataLakeDelegatedAdministratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterDataLakeDelegatedAdministrator")
	}

	var r0 *securitylake.DeregisterDataLakeDelegatedAdministratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeregisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) (*securitylake.DeregisterDataLakeDelegatedAdministratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.DeregisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) *securitylake.DeregisterDataLakeDelegatedAdministratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.DeregisterDataLakeDelegatedAdministratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.DeregisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataLakeExceptionSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataLakeExceptionSubscription(ctx context.Context, params *securitylake.GetDataLakeExceptionSubscriptionInput, optFns ...func(*securitylake.Options)) (*securitylake.GetDataLakeExceptionSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataLakeExceptionSubscription")
	}

	var r0 *securitylake.GetDataLakeExceptionSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) (*securitylake.GetDataLakeExceptionSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) *securitylake.GetDataLakeExceptionSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.GetDataLakeExceptionSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.GetDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataLakeOrganizationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataLakeOrganizationConfiguration(ctx context.Context, params *securitylake.GetDataLakeOrganizationConfigurationInput, optFns ...func(*securitylake.Options)) (*securitylake.GetDataLakeOrganizationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataLakeOrganizationConfiguration")
	}

	var r0 *securitylake.GetDataLakeOrganizationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) (*securitylake.GetDataLakeOrganizationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) *securitylake.GetDataLakeOrganizationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.GetDataLakeOrganizationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.GetDataLakeOrganizationConfigurationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataLakeSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataLakeSources(ctx context.Context, params *securitylake.GetDataLakeSourcesInput, optFns ...func(*securitylake.Options)) (*securitylake.GetDataLakeSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataLakeSources")
	}

	var r0 *securitylake.GetDataLakeSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeSourcesInput, ...func(*securitylake.Options)) (*securitylake.GetDataLakeSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetDataLakeSourcesInput, ...func(*securitylake.Options)) *securitylake.GetDataLakeSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.GetDataLakeSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.GetDataLakeSourcesInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriber provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSubscriber(ctx context.Context, params *securitylake.GetSubscriberInput, optFns ...func(*securitylake.Options)) (*securitylake.GetSubscriberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscriber")
	}

	var r0 *securitylake.GetSubscriberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetSubscriberInput, ...func(*securitylake.Options)) (*securitylake.GetSubscriberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.GetSubscriberInput, ...func(*securitylake.Options)) *securitylake.GetSubscriberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.GetSubscriberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.GetSubscriberInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataLakeExceptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataLakeExceptions(ctx context.Context, params *securitylake.ListDataLakeExceptionsInput, optFns ...func(*securitylake.Options)) (*securitylake.ListDataLakeExceptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataLakeExceptions")
	}

	var r0 *securitylake.ListDataLakeExceptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListDataLakeExceptionsInput, ...func(*securitylake.Options)) (*securitylake.ListDataLakeExceptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListDataLakeExceptionsInput, ...func(*securitylake.Options)) *securitylake.ListDataLakeExceptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.ListDataLakeExceptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.ListDataLakeExceptionsInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataLakes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataLakes(ctx context.Context, params *securitylake.ListDataLakesInput, optFns ...func(*securitylake.Options)) (*securitylake.ListDataLakesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataLakes")
	}

	var r0 *securitylake.ListDataLakesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListDataLakesInput, ...func(*securitylake.Options)) (*securitylake.ListDataLakesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListDataLakesInput, ...func(*securitylake.Options)) *securitylake.ListDataLakesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.ListDataLakesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.ListDataLakesInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLogSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLogSources(ctx context.Context, params *securitylake.ListLogSourcesInput, optFns ...func(*securitylake.Options)) (*securitylake.ListLogSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLogSources")
	}

	var r0 *securitylake.ListLogSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListLogSourcesInput, ...func(*securitylake.Options)) (*securitylake.ListLogSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListLogSourcesInput, ...func(*securitylake.Options)) *securitylake.ListLogSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.ListLogSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.ListLogSourcesInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSubscribers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSubscribers(ctx context.Context, params *securitylake.ListSubscribersInput, optFns ...func(*securitylake.Options)) (*securitylake.ListSubscribersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubscribers")
	}

	var r0 *securitylake.ListSubscribersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListSubscribersInput, ...func(*securitylake.Options)) (*securitylake.ListSubscribersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListSubscribersInput, ...func(*securitylake.Options)) *securitylake.ListSubscribersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.ListSubscribersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.ListSubscribersInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *securitylake.ListTagsForResourceInput, optFns ...func(*securitylake.Options)) (*securitylake.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *securitylake.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListTagsForResourceInput, ...func(*securitylake.Options)) (*securitylake.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.ListTagsForResourceInput, ...func(*securitylake.Options)) *securitylake.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.ListTagsForResourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() securitylake.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 securitylake.Options
	if rf, ok := ret.Get(0).(func() securitylake.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(securitylake.Options)
	}

	return r0
}

// RegisterDataLakeDelegatedAdministrator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterDataLakeDelegatedAdministrator(ctx context.Context, params *securitylake.RegisterDataLakeDelegatedAdministratorInput, optFns ...func(*securitylake.Options)) (*securitylake.RegisterDataLakeDelegatedAdministratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterDataLakeDelegatedAdministrator")
	}

	var r0 *securitylake.RegisterDataLakeDelegatedAdministratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.RegisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) (*securitylake.RegisterDataLakeDelegatedAdministratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.RegisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) *securitylake.RegisterDataLakeDelegatedAdministratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.RegisterDataLakeDelegatedAdministratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.RegisterDataLakeDelegatedAdministratorInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *securitylake.TagResourceInput, optFns ...func(*securitylake.Options)) (*securitylake.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *securitylake.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.TagResourceInput, ...func(*securitylake.Options)) (*securitylake.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.TagResourceInput, ...func(*securitylake.Options)) *securitylake.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.TagResourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *securitylake.UntagResourceInput, optFns ...func(*securitylake.Options)) (*securitylake.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *securitylake.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UntagResourceInput, ...func(*securitylake.Options)) (*securitylake.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UntagResourceInput, ...func(*securitylake.Options)) *securitylake.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.UntagResourceInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataLake provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataLake(ctx context.Context, params *securitylake.UpdateDataLakeInput, optFns ...func(*securitylake.Options)) (*securitylake.UpdateDataLakeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataLake")
	}

	var r0 *securitylake.UpdateDataLakeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateDataLakeInput, ...func(*securitylake.Options)) (*securitylake.UpdateDataLakeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateDataLakeInput, ...func(*securitylake.Options)) *securitylake.UpdateDataLakeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.UpdateDataLakeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.UpdateDataLakeInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataLakeExceptionSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataLakeExceptionSubscription(ctx context.Context, params *securitylake.UpdateDataLakeExceptionSubscriptionInput, optFns ...func(*securitylake.Options)) (*securitylake.UpdateDataLakeExceptionSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataLakeExceptionSubscription")
	}

	var r0 *securitylake.UpdateDataLakeExceptionSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) (*securitylake.UpdateDataLakeExceptionSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) *securitylake.UpdateDataLakeExceptionSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.UpdateDataLakeExceptionSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.UpdateDataLakeExceptionSubscriptionInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubscriber provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSubscriber(ctx context.Context, params *securitylake.UpdateSubscriberInput, optFns ...func(*securitylake.Options)) (*securitylake.UpdateSubscriberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubscriber")
	}

	var r0 *securitylake.UpdateSubscriberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateSubscriberInput, ...func(*securitylake.Options)) (*securitylake.UpdateSubscriberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateSubscriberInput, ...func(*securitylake.Options)) *securitylake.UpdateSubscriberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.UpdateSubscriberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.UpdateSubscriberInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubscriberNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSubscriberNotification(ctx context.Context, params *securitylake.UpdateSubscriberNotificationInput, optFns ...func(*securitylake.Options)) (*securitylake.UpdateSubscriberNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubscriberNotification")
	}

	var r0 *securitylake.UpdateSubscriberNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateSubscriberNotificationInput, ...func(*securitylake.Options)) (*securitylake.UpdateSubscriberNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *securitylake.UpdateSubscriberNotificationInput, ...func(*securitylake.Options)) *securitylake.UpdateSubscriberNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*securitylake.UpdateSubscriberNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *securitylake.UpdateSubscriberNotificationInput, ...func(*securitylake.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
