// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	networkfirewall "github.com/aws/aws-sdk-go-v2/service/networkfirewall"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptNetworkFirewallTransitGatewayAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptNetworkFirewallTransitGatewayAttachment(ctx context.Context, params *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptNetworkFirewallTransitGatewayAttachment")
	}

	var r0 *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) (*networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.AcceptNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateAvailabilityZones provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateAvailabilityZones(ctx context.Context, params *networkfirewall.AssociateAvailabilityZonesInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.AssociateAvailabilityZonesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAvailabilityZones")
	}

	var r0 *networkfirewall.AssociateAvailabilityZonesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) (*networkfirewall.AssociateAvailabilityZonesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) *networkfirewall.AssociateAvailabilityZonesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.AssociateAvailabilityZonesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.AssociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateFirewallPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateFirewallPolicy(ctx context.Context, params *networkfirewall.AssociateFirewallPolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.AssociateFirewallPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateFirewallPolicy")
	}

	var r0 *networkfirewall.AssociateFirewallPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateFirewallPolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.AssociateFirewallPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateFirewallPolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.AssociateFirewallPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.AssociateFirewallPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.AssociateFirewallPolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateSubnets(ctx context.Context, params *networkfirewall.AssociateSubnetsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.AssociateSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateSubnets")
	}

	var r0 *networkfirewall.AssociateSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateSubnetsInput, ...func(*networkfirewall.Options)) (*networkfirewall.AssociateSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.AssociateSubnetsInput, ...func(*networkfirewall.Options)) *networkfirewall.AssociateSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.AssociateSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.AssociateSubnetsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewall provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewall(ctx context.Context, params *networkfirewall.CreateFirewallInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.CreateFirewallOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewall")
	}

	var r0 *networkfirewall.CreateFirewallOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateFirewallInput, ...func(*networkfirewall.Options)) (*networkfirewall.CreateFirewallOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateFirewallInput, ...func(*networkfirewall.Options)) *networkfirewall.CreateFirewallOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.CreateFirewallOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.CreateFirewallInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallPolicy(ctx context.Context, params *networkfirewall.CreateFirewallPolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.CreateFirewallPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallPolicy")
	}

	var r0 *networkfirewall.CreateFirewallPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateFirewallPolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.CreateFirewallPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateFirewallPolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.CreateFirewallPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.CreateFirewallPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.CreateFirewallPolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRuleGroup(ctx context.Context, params *networkfirewall.CreateRuleGroupInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.CreateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRuleGroup")
	}

	var r0 *networkfirewall.CreateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateRuleGroupInput, ...func(*networkfirewall.Options)) (*networkfirewall.CreateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateRuleGroupInput, ...func(*networkfirewall.Options)) *networkfirewall.CreateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.CreateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.CreateRuleGroupInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTLSInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTLSInspectionConfiguration(ctx context.Context, params *networkfirewall.CreateTLSInspectionConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.CreateTLSInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTLSInspectionConfiguration")
	}

	var r0 *networkfirewall.CreateTLSInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.CreateTLSInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.CreateTLSInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.CreateTLSInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.CreateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcEndpointAssociation(ctx context.Context, params *networkfirewall.CreateVpcEndpointAssociationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.CreateVpcEndpointAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpointAssociation")
	}

	var r0 *networkfirewall.CreateVpcEndpointAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) (*networkfirewall.CreateVpcEndpointAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.CreateVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) *networkfirewall.CreateVpcEndpointAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.CreateVpcEndpointAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.CreateVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewall provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewall(ctx context.Context, params *networkfirewall.DeleteFirewallInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteFirewallOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewall")
	}

	var r0 *networkfirewall.DeleteFirewallOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteFirewallInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteFirewallOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteFirewallInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteFirewallOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteFirewallOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteFirewallInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallPolicy(ctx context.Context, params *networkfirewall.DeleteFirewallPolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteFirewallPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallPolicy")
	}

	var r0 *networkfirewall.DeleteFirewallPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteFirewallPolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteFirewallPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteFirewallPolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteFirewallPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteFirewallPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteFirewallPolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkFirewallTransitGatewayAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNetworkFirewallTransitGatewayAttachment(ctx context.Context, params *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkFirewallTransitGatewayAttachment")
	}

	var r0 *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *networkfirewall.DeleteResourcePolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *networkfirewall.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteResourcePolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteResourcePolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteResourcePolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRuleGroup(ctx context.Context, params *networkfirewall.DeleteRuleGroupInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRuleGroup")
	}

	var r0 *networkfirewall.DeleteRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteRuleGroupInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteRuleGroupInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteRuleGroupInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTLSInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTLSInspectionConfiguration(ctx context.Context, params *networkfirewall.DeleteTLSInspectionConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteTLSInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTLSInspectionConfiguration")
	}

	var r0 *networkfirewall.DeleteTLSInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteTLSInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteTLSInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteTLSInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcEndpointAssociation(ctx context.Context, params *networkfirewall.DeleteVpcEndpointAssociationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DeleteVpcEndpointAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpointAssociation")
	}

	var r0 *networkfirewall.DeleteVpcEndpointAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DeleteVpcEndpointAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DeleteVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) *networkfirewall.DeleteVpcEndpointAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DeleteVpcEndpointAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DeleteVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFirewall provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFirewall(ctx context.Context, params *networkfirewall.DescribeFirewallInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFirewall")
	}

	var r0 *networkfirewall.DescribeFirewallOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeFirewallOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeFirewallOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeFirewallInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFirewallMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFirewallMetadata(ctx context.Context, params *networkfirewall.DescribeFirewallMetadataInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFirewallMetadata")
	}

	var r0 *networkfirewall.DescribeFirewallMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallMetadataInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallMetadataInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeFirewallMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeFirewallMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeFirewallMetadataInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFirewallPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFirewallPolicy(ctx context.Context, params *networkfirewall.DescribeFirewallPolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFirewallPolicy")
	}

	var r0 *networkfirewall.DescribeFirewallPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallPolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFirewallPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFirewallPolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeFirewallPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeFirewallPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeFirewallPolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlowOperation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFlowOperation(ctx context.Context, params *networkfirewall.DescribeFlowOperationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFlowOperationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFlowOperation")
	}

	var r0 *networkfirewall.DescribeFlowOperationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFlowOperationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeFlowOperationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeFlowOperationInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeFlowOperationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeFlowOperationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeFlowOperationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLoggingConfiguration(ctx context.Context, params *networkfirewall.DescribeLoggingConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoggingConfiguration")
	}

	var r0 *networkfirewall.DescribeLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeLoggingConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeLoggingConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeLoggingConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResourcePolicy(ctx context.Context, params *networkfirewall.DescribeResourcePolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourcePolicy")
	}

	var r0 *networkfirewall.DescribeResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeResourcePolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeResourcePolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeResourcePolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRuleGroup(ctx context.Context, params *networkfirewall.DescribeRuleGroupInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRuleGroup")
	}

	var r0 *networkfirewall.DescribeRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeRuleGroupInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRuleGroupMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRuleGroupMetadata(ctx context.Context, params *networkfirewall.DescribeRuleGroupMetadataInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRuleGroupMetadata")
	}

	var r0 *networkfirewall.DescribeRuleGroupMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupMetadataInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupMetadataInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeRuleGroupMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeRuleGroupMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeRuleGroupMetadataInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRuleGroupSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRuleGroupSummary(ctx context.Context, params *networkfirewall.DescribeRuleGroupSummaryInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRuleGroupSummary")
	}

	var r0 *networkfirewall.DescribeRuleGroupSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupSummaryInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeRuleGroupSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeRuleGroupSummaryInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeRuleGroupSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeRuleGroupSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeRuleGroupSummaryInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTLSInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTLSInspectionConfiguration(ctx context.Context, params *networkfirewall.DescribeTLSInspectionConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeTLSInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTLSInspectionConfiguration")
	}

	var r0 *networkfirewall.DescribeTLSInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeTLSInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeTLSInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeTLSInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcEndpointAssociation(ctx context.Context, params *networkfirewall.DescribeVpcEndpointAssociationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DescribeVpcEndpointAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointAssociation")
	}

	var r0 *networkfirewall.DescribeVpcEndpointAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) (*networkfirewall.DescribeVpcEndpointAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DescribeVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) *networkfirewall.DescribeVpcEndpointAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DescribeVpcEndpointAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DescribeVpcEndpointAssociationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAvailabilityZones provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateAvailabilityZones(ctx context.Context, params *networkfirewall.DisassociateAvailabilityZonesInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DisassociateAvailabilityZonesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAvailabilityZones")
	}

	var r0 *networkfirewall.DisassociateAvailabilityZonesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DisassociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) (*networkfirewall.DisassociateAvailabilityZonesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DisassociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) *networkfirewall.DisassociateAvailabilityZonesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DisassociateAvailabilityZonesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DisassociateAvailabilityZonesInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateSubnets(ctx context.Context, params *networkfirewall.DisassociateSubnetsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.DisassociateSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateSubnets")
	}

	var r0 *networkfirewall.DisassociateSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DisassociateSubnetsInput, ...func(*networkfirewall.Options)) (*networkfirewall.DisassociateSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.DisassociateSubnetsInput, ...func(*networkfirewall.Options)) *networkfirewall.DisassociateSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.DisassociateSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.DisassociateSubnetsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnalysisReportResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnalysisReportResults(ctx context.Context, params *networkfirewall.GetAnalysisReportResultsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.GetAnalysisReportResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnalysisReportResults")
	}

	var r0 *networkfirewall.GetAnalysisReportResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.GetAnalysisReportResultsInput, ...func(*networkfirewall.Options)) (*networkfirewall.GetAnalysisReportResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.GetAnalysisReportResultsInput, ...func(*networkfirewall.Options)) *networkfirewall.GetAnalysisReportResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.GetAnalysisReportResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.GetAnalysisReportResultsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnalysisReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnalysisReports(ctx context.Context, params *networkfirewall.ListAnalysisReportsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListAnalysisReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnalysisReports")
	}

	var r0 *networkfirewall.ListAnalysisReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListAnalysisReportsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListAnalysisReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListAnalysisReportsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListAnalysisReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListAnalysisReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListAnalysisReportsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallPolicies(ctx context.Context, params *networkfirewall.ListFirewallPoliciesInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListFirewallPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallPolicies")
	}

	var r0 *networkfirewall.ListFirewallPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFirewallPoliciesInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListFirewallPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFirewallPoliciesInput, ...func(*networkfirewall.Options)) *networkfirewall.ListFirewallPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListFirewallPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListFirewallPoliciesInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewalls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewalls(ctx context.Context, params *networkfirewall.ListFirewallsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListFirewallsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewalls")
	}

	var r0 *networkfirewall.ListFirewallsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFirewallsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListFirewallsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFirewallsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListFirewallsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListFirewallsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListFirewallsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlowOperationResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlowOperationResults(ctx context.Context, params *networkfirewall.ListFlowOperationResultsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListFlowOperationResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlowOperationResults")
	}

	var r0 *networkfirewall.ListFlowOperationResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFlowOperationResultsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListFlowOperationResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFlowOperationResultsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListFlowOperationResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListFlowOperationResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListFlowOperationResultsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlowOperations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFlowOperations(ctx context.Context, params *networkfirewall.ListFlowOperationsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListFlowOperationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFlowOperations")
	}

	var r0 *networkfirewall.ListFlowOperationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFlowOperationsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListFlowOperationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListFlowOperationsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListFlowOperationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListFlowOperationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListFlowOperationsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuleGroups(ctx context.Context, params *networkfirewall.ListRuleGroupsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuleGroups")
	}

	var r0 *networkfirewall.ListRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListRuleGroupsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListRuleGroupsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListRuleGroupsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTLSInspectionConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTLSInspectionConfigurations(ctx context.Context, params *networkfirewall.ListTLSInspectionConfigurationsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListTLSInspectionConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTLSInspectionConfigurations")
	}

	var r0 *networkfirewall.ListTLSInspectionConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListTLSInspectionConfigurationsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListTLSInspectionConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListTLSInspectionConfigurationsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListTLSInspectionConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListTLSInspectionConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListTLSInspectionConfigurationsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *networkfirewall.ListTagsForResourceInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *networkfirewall.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListTagsForResourceInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListTagsForResourceInput, ...func(*networkfirewall.Options)) *networkfirewall.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListTagsForResourceInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcEndpointAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcEndpointAssociations(ctx context.Context, params *networkfirewall.ListVpcEndpointAssociationsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.ListVpcEndpointAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcEndpointAssociations")
	}

	var r0 *networkfirewall.ListVpcEndpointAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListVpcEndpointAssociationsInput, ...func(*networkfirewall.Options)) (*networkfirewall.ListVpcEndpointAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.ListVpcEndpointAssociationsInput, ...func(*networkfirewall.Options)) *networkfirewall.ListVpcEndpointAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.ListVpcEndpointAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.ListVpcEndpointAssociationsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() networkfirewall.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 networkfirewall.Options
	if rf, ok := ret.Get(0).(func() networkfirewall.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(networkfirewall.Options)
	}

	return r0
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *networkfirewall.PutResourcePolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *networkfirewall.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.PutResourcePolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.PutResourcePolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.PutResourcePolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectNetworkFirewallTransitGatewayAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectNetworkFirewallTransitGatewayAttachment(ctx context.Context, params *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectNetworkFirewallTransitGatewayAttachment")
	}

	var r0 *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) (*networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.RejectNetworkFirewallTransitGatewayAttachmentInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartAnalysisReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartAnalysisReport(ctx context.Context, params *networkfirewall.StartAnalysisReportInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.StartAnalysisReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartAnalysisReport")
	}

	var r0 *networkfirewall.StartAnalysisReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartAnalysisReportInput, ...func(*networkfirewall.Options)) (*networkfirewall.StartAnalysisReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartAnalysisReportInput, ...func(*networkfirewall.Options)) *networkfirewall.StartAnalysisReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.StartAnalysisReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.StartAnalysisReportInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFlowCapture provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFlowCapture(ctx context.Context, params *networkfirewall.StartFlowCaptureInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.StartFlowCaptureOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFlowCapture")
	}

	var r0 *networkfirewall.StartFlowCaptureOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartFlowCaptureInput, ...func(*networkfirewall.Options)) (*networkfirewall.StartFlowCaptureOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartFlowCaptureInput, ...func(*networkfirewall.Options)) *networkfirewall.StartFlowCaptureOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.StartFlowCaptureOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.StartFlowCaptureInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFlowFlush provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFlowFlush(ctx context.Context, params *networkfirewall.StartFlowFlushInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.StartFlowFlushOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFlowFlush")
	}

	var r0 *networkfirewall.StartFlowFlushOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartFlowFlushInput, ...func(*networkfirewall.Options)) (*networkfirewall.StartFlowFlushOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.StartFlowFlushInput, ...func(*networkfirewall.Options)) *networkfirewall.StartFlowFlushOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.StartFlowFlushOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.StartFlowFlushInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *networkfirewall.TagResourceInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *networkfirewall.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.TagResourceInput, ...func(*networkfirewall.Options)) (*networkfirewall.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.TagResourceInput, ...func(*networkfirewall.Options)) *networkfirewall.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.TagResourceInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *networkfirewall.UntagResourceInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *networkfirewall.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UntagResourceInput, ...func(*networkfirewall.Options)) (*networkfirewall.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UntagResourceInput, ...func(*networkfirewall.Options)) *networkfirewall.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UntagResourceInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAvailabilityZoneChangeProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAvailabilityZoneChangeProtection(ctx context.Context, params *networkfirewall.UpdateAvailabilityZoneChangeProtectionInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateAvailabilityZoneChangeProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAvailabilityZoneChangeProtection")
	}

	var r0 *networkfirewall.UpdateAvailabilityZoneChangeProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateAvailabilityZoneChangeProtectionInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateAvailabilityZoneChangeProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateAvailabilityZoneChangeProtectionInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateAvailabilityZoneChangeProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateAvailabilityZoneChangeProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateAvailabilityZoneChangeProtectionInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallAnalysisSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallAnalysisSettings(ctx context.Context, params *networkfirewall.UpdateFirewallAnalysisSettingsInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallAnalysisSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallAnalysisSettings")
	}

	var r0 *networkfirewall.UpdateFirewallAnalysisSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallAnalysisSettingsInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallAnalysisSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallAnalysisSettingsInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallAnalysisSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallAnalysisSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallAnalysisSettingsInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallDeleteProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallDeleteProtection(ctx context.Context, params *networkfirewall.UpdateFirewallDeleteProtectionInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallDeleteProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallDeleteProtection")
	}

	var r0 *networkfirewall.UpdateFirewallDeleteProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallDeleteProtectionInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallDeleteProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallDeleteProtectionInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallDeleteProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallDeleteProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallDeleteProtectionInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallDescription(ctx context.Context, params *networkfirewall.UpdateFirewallDescriptionInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallDescription")
	}

	var r0 *networkfirewall.UpdateFirewallDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallDescriptionInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallDescriptionInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallDescriptionInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallEncryptionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallEncryptionConfiguration(ctx context.Context, params *networkfirewall.UpdateFirewallEncryptionConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallEncryptionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallEncryptionConfiguration")
	}

	var r0 *networkfirewall.UpdateFirewallEncryptionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallEncryptionConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallEncryptionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallEncryptionConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallEncryptionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallEncryptionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallEncryptionConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallPolicy(ctx context.Context, params *networkfirewall.UpdateFirewallPolicyInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallPolicy")
	}

	var r0 *networkfirewall.UpdateFirewallPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallPolicyInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallPolicyInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallPolicyInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallPolicyChangeProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallPolicyChangeProtection(ctx context.Context, params *networkfirewall.UpdateFirewallPolicyChangeProtectionInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallPolicyChangeProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallPolicyChangeProtection")
	}

	var r0 *networkfirewall.UpdateFirewallPolicyChangeProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallPolicyChangeProtectionInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateFirewallPolicyChangeProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateFirewallPolicyChangeProtectionInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateFirewallPolicyChangeProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateFirewallPolicyChangeProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateFirewallPolicyChangeProtectionInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLoggingConfiguration(ctx context.Context, params *networkfirewall.UpdateLoggingConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLoggingConfiguration")
	}

	var r0 *networkfirewall.UpdateLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateLoggingConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateLoggingConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateLoggingConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleGroup(ctx context.Context, params *networkfirewall.UpdateRuleGroupInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleGroup")
	}

	var r0 *networkfirewall.UpdateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateRuleGroupInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateRuleGroupInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateRuleGroupInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubnetChangeProtection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSubnetChangeProtection(ctx context.Context, params *networkfirewall.UpdateSubnetChangeProtectionInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateSubnetChangeProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubnetChangeProtection")
	}

	var r0 *networkfirewall.UpdateSubnetChangeProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateSubnetChangeProtectionInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateSubnetChangeProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateSubnetChangeProtectionInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateSubnetChangeProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateSubnetChangeProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateSubnetChangeProtectionInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTLSInspectionConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTLSInspectionConfiguration(ctx context.Context, params *networkfirewall.UpdateTLSInspectionConfigurationInput, optFns ...func(*networkfirewall.Options)) (*networkfirewall.UpdateTLSInspectionConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTLSInspectionConfiguration")
	}

	var r0 *networkfirewall.UpdateTLSInspectionConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) (*networkfirewall.UpdateTLSInspectionConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networkfirewall.UpdateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) *networkfirewall.UpdateTLSInspectionConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkfirewall.UpdateTLSInspectionConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networkfirewall.UpdateTLSInspectionConfigurationInput, ...func(*networkfirewall.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
