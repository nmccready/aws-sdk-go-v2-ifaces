// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	wafregional "github.com/aws/aws-sdk-go-v2/service/wafregional"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateWebACL(ctx context.Context, params *wafregional.AssociateWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.AssociateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateWebACL")
	}

	var r0 *wafregional.AssociateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.AssociateWebACLInput, ...func(*wafregional.Options)) (*wafregional.AssociateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.AssociateWebACLInput, ...func(*wafregional.Options)) *wafregional.AssociateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.AssociateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.AssociateWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateByteMatchSet(ctx context.Context, params *wafregional.CreateByteMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateByteMatchSet")
	}

	var r0 *wafregional.CreateByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateByteMatchSetInput, ...func(*wafregional.Options)) (*wafregional.CreateByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateByteMatchSetInput, ...func(*wafregional.Options)) *wafregional.CreateByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateByteMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGeoMatchSet(ctx context.Context, params *wafregional.CreateGeoMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGeoMatchSet")
	}

	var r0 *wafregional.CreateGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateGeoMatchSetInput, ...func(*wafregional.Options)) (*wafregional.CreateGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateGeoMatchSetInput, ...func(*wafregional.Options)) *wafregional.CreateGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateGeoMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIPSet(ctx context.Context, params *wafregional.CreateIPSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIPSet")
	}

	var r0 *wafregional.CreateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateIPSetInput, ...func(*wafregional.Options)) (*wafregional.CreateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateIPSetInput, ...func(*wafregional.Options)) *wafregional.CreateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateIPSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRateBasedRule(ctx context.Context, params *wafregional.CreateRateBasedRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRateBasedRule")
	}

	var r0 *wafregional.CreateRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRateBasedRuleInput, ...func(*wafregional.Options)) (*wafregional.CreateRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRateBasedRuleInput, ...func(*wafregional.Options)) *wafregional.CreateRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateRateBasedRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegexMatchSet(ctx context.Context, params *wafregional.CreateRegexMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegexMatchSet")
	}

	var r0 *wafregional.CreateRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRegexMatchSetInput, ...func(*wafregional.Options)) (*wafregional.CreateRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRegexMatchSetInput, ...func(*wafregional.Options)) *wafregional.CreateRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateRegexMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegexPatternSet(ctx context.Context, params *wafregional.CreateRegexPatternSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegexPatternSet")
	}

	var r0 *wafregional.CreateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRegexPatternSetInput, ...func(*wafregional.Options)) (*wafregional.CreateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRegexPatternSetInput, ...func(*wafregional.Options)) *wafregional.CreateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateRegexPatternSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRule(ctx context.Context, params *wafregional.CreateRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 *wafregional.CreateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRuleInput, ...func(*wafregional.Options)) (*wafregional.CreateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRuleInput, ...func(*wafregional.Options)) *wafregional.CreateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRuleGroup(ctx context.Context, params *wafregional.CreateRuleGroupInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRuleGroup")
	}

	var r0 *wafregional.CreateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRuleGroupInput, ...func(*wafregional.Options)) (*wafregional.CreateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateRuleGroupInput, ...func(*wafregional.Options)) *wafregional.CreateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateRuleGroupInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSizeConstraintSet(ctx context.Context, params *wafregional.CreateSizeConstraintSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSizeConstraintSet")
	}

	var r0 *wafregional.CreateSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateSizeConstraintSetInput, ...func(*wafregional.Options)) (*wafregional.CreateSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateSizeConstraintSetInput, ...func(*wafregional.Options)) *wafregional.CreateSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateSizeConstraintSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSqlInjectionMatchSet(ctx context.Context, params *wafregional.CreateSqlInjectionMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSqlInjectionMatchSet")
	}

	var r0 *wafregional.CreateSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) (*wafregional.CreateSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) *wafregional.CreateSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebACL(ctx context.Context, params *wafregional.CreateWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebACL")
	}

	var r0 *wafregional.CreateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateWebACLInput, ...func(*wafregional.Options)) (*wafregional.CreateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateWebACLInput, ...func(*wafregional.Options)) *wafregional.CreateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebACLMigrationStack provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebACLMigrationStack(ctx context.Context, params *wafregional.CreateWebACLMigrationStackInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateWebACLMigrationStackOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebACLMigrationStack")
	}

	var r0 *wafregional.CreateWebACLMigrationStackOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateWebACLMigrationStackInput, ...func(*wafregional.Options)) (*wafregional.CreateWebACLMigrationStackOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateWebACLMigrationStackInput, ...func(*wafregional.Options)) *wafregional.CreateWebACLMigrationStackOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateWebACLMigrationStackOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateWebACLMigrationStackInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateXssMatchSet(ctx context.Context, params *wafregional.CreateXssMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.CreateXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateXssMatchSet")
	}

	var r0 *wafregional.CreateXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateXssMatchSetInput, ...func(*wafregional.Options)) (*wafregional.CreateXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.CreateXssMatchSetInput, ...func(*wafregional.Options)) *wafregional.CreateXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.CreateXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.CreateXssMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteByteMatchSet(ctx context.Context, params *wafregional.DeleteByteMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByteMatchSet")
	}

	var r0 *wafregional.DeleteByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteByteMatchSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteByteMatchSetInput, ...func(*wafregional.Options)) *wafregional.DeleteByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteByteMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGeoMatchSet(ctx context.Context, params *wafregional.DeleteGeoMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGeoMatchSet")
	}

	var r0 *wafregional.DeleteGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteGeoMatchSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteGeoMatchSetInput, ...func(*wafregional.Options)) *wafregional.DeleteGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteGeoMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIPSet(ctx context.Context, params *wafregional.DeleteIPSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIPSet")
	}

	var r0 *wafregional.DeleteIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteIPSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteIPSetInput, ...func(*wafregional.Options)) *wafregional.DeleteIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteIPSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLoggingConfiguration(ctx context.Context, params *wafregional.DeleteLoggingConfigurationInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoggingConfiguration")
	}

	var r0 *wafregional.DeleteLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteLoggingConfigurationInput, ...func(*wafregional.Options)) (*wafregional.DeleteLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteLoggingConfigurationInput, ...func(*wafregional.Options)) *wafregional.DeleteLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteLoggingConfigurationInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePermissionPolicy(ctx context.Context, params *wafregional.DeletePermissionPolicyInput, optFns ...func(*wafregional.Options)) (*wafregional.DeletePermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionPolicy")
	}

	var r0 *wafregional.DeletePermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeletePermissionPolicyInput, ...func(*wafregional.Options)) (*wafregional.DeletePermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeletePermissionPolicyInput, ...func(*wafregional.Options)) *wafregional.DeletePermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeletePermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeletePermissionPolicyInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRateBasedRule(ctx context.Context, params *wafregional.DeleteRateBasedRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRateBasedRule")
	}

	var r0 *wafregional.DeleteRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRateBasedRuleInput, ...func(*wafregional.Options)) (*wafregional.DeleteRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRateBasedRuleInput, ...func(*wafregional.Options)) *wafregional.DeleteRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteRateBasedRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegexMatchSet(ctx context.Context, params *wafregional.DeleteRegexMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegexMatchSet")
	}

	var r0 *wafregional.DeleteRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRegexMatchSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRegexMatchSetInput, ...func(*wafregional.Options)) *wafregional.DeleteRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteRegexMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegexPatternSet(ctx context.Context, params *wafregional.DeleteRegexPatternSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegexPatternSet")
	}

	var r0 *wafregional.DeleteRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRegexPatternSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRegexPatternSetInput, ...func(*wafregional.Options)) *wafregional.DeleteRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteRegexPatternSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRule(ctx context.Context, params *wafregional.DeleteRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 *wafregional.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRuleInput, ...func(*wafregional.Options)) (*wafregional.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRuleInput, ...func(*wafregional.Options)) *wafregional.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRuleGroup(ctx context.Context, params *wafregional.DeleteRuleGroupInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRuleGroup")
	}

	var r0 *wafregional.DeleteRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRuleGroupInput, ...func(*wafregional.Options)) (*wafregional.DeleteRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteRuleGroupInput, ...func(*wafregional.Options)) *wafregional.DeleteRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteRuleGroupInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSizeConstraintSet(ctx context.Context, params *wafregional.DeleteSizeConstraintSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSizeConstraintSet")
	}

	var r0 *wafregional.DeleteSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteSizeConstraintSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteSizeConstraintSetInput, ...func(*wafregional.Options)) *wafregional.DeleteSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteSizeConstraintSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSqlInjectionMatchSet(ctx context.Context, params *wafregional.DeleteSqlInjectionMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSqlInjectionMatchSet")
	}

	var r0 *wafregional.DeleteSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteSqlInjectionMatchSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteSqlInjectionMatchSetInput, ...func(*wafregional.Options)) *wafregional.DeleteSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteSqlInjectionMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWebACL(ctx context.Context, params *wafregional.DeleteWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWebACL")
	}

	var r0 *wafregional.DeleteWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteWebACLInput, ...func(*wafregional.Options)) (*wafregional.DeleteWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteWebACLInput, ...func(*wafregional.Options)) *wafregional.DeleteWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteXssMatchSet(ctx context.Context, params *wafregional.DeleteXssMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.DeleteXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteXssMatchSet")
	}

	var r0 *wafregional.DeleteXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteXssMatchSetInput, ...func(*wafregional.Options)) (*wafregional.DeleteXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DeleteXssMatchSetInput, ...func(*wafregional.Options)) *wafregional.DeleteXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DeleteXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DeleteXssMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateWebACL(ctx context.Context, params *wafregional.DisassociateWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.DisassociateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateWebACL")
	}

	var r0 *wafregional.DisassociateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DisassociateWebACLInput, ...func(*wafregional.Options)) (*wafregional.DisassociateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.DisassociateWebACLInput, ...func(*wafregional.Options)) *wafregional.DisassociateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.DisassociateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.DisassociateWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetByteMatchSet(ctx context.Context, params *wafregional.GetByteMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetByteMatchSet")
	}

	var r0 *wafregional.GetByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetByteMatchSetInput, ...func(*wafregional.Options)) (*wafregional.GetByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetByteMatchSetInput, ...func(*wafregional.Options)) *wafregional.GetByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetByteMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChangeToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChangeToken(ctx context.Context, params *wafregional.GetChangeTokenInput, optFns ...func(*wafregional.Options)) (*wafregional.GetChangeTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChangeToken")
	}

	var r0 *wafregional.GetChangeTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetChangeTokenInput, ...func(*wafregional.Options)) (*wafregional.GetChangeTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetChangeTokenInput, ...func(*wafregional.Options)) *wafregional.GetChangeTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetChangeTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetChangeTokenInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChangeTokenStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChangeTokenStatus(ctx context.Context, params *wafregional.GetChangeTokenStatusInput, optFns ...func(*wafregional.Options)) (*wafregional.GetChangeTokenStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChangeTokenStatus")
	}

	var r0 *wafregional.GetChangeTokenStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetChangeTokenStatusInput, ...func(*wafregional.Options)) (*wafregional.GetChangeTokenStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetChangeTokenStatusInput, ...func(*wafregional.Options)) *wafregional.GetChangeTokenStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetChangeTokenStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetChangeTokenStatusInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGeoMatchSet(ctx context.Context, params *wafregional.GetGeoMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGeoMatchSet")
	}

	var r0 *wafregional.GetGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetGeoMatchSetInput, ...func(*wafregional.Options)) (*wafregional.GetGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetGeoMatchSetInput, ...func(*wafregional.Options)) *wafregional.GetGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetGeoMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIPSet(ctx context.Context, params *wafregional.GetIPSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIPSet")
	}

	var r0 *wafregional.GetIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetIPSetInput, ...func(*wafregional.Options)) (*wafregional.GetIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetIPSetInput, ...func(*wafregional.Options)) *wafregional.GetIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetIPSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLoggingConfiguration(ctx context.Context, params *wafregional.GetLoggingConfigurationInput, optFns ...func(*wafregional.Options)) (*wafregional.GetLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLoggingConfiguration")
	}

	var r0 *wafregional.GetLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetLoggingConfigurationInput, ...func(*wafregional.Options)) (*wafregional.GetLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetLoggingConfigurationInput, ...func(*wafregional.Options)) *wafregional.GetLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetLoggingConfigurationInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPermissionPolicy(ctx context.Context, params *wafregional.GetPermissionPolicyInput, optFns ...func(*wafregional.Options)) (*wafregional.GetPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionPolicy")
	}

	var r0 *wafregional.GetPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetPermissionPolicyInput, ...func(*wafregional.Options)) (*wafregional.GetPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetPermissionPolicyInput, ...func(*wafregional.Options)) *wafregional.GetPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetPermissionPolicyInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRateBasedRule(ctx context.Context, params *wafregional.GetRateBasedRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRateBasedRule")
	}

	var r0 *wafregional.GetRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRateBasedRuleInput, ...func(*wafregional.Options)) (*wafregional.GetRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRateBasedRuleInput, ...func(*wafregional.Options)) *wafregional.GetRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRateBasedRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateBasedRuleManagedKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRateBasedRuleManagedKeys(ctx context.Context, params *wafregional.GetRateBasedRuleManagedKeysInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRateBasedRuleManagedKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRateBasedRuleManagedKeys")
	}

	var r0 *wafregional.GetRateBasedRuleManagedKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRateBasedRuleManagedKeysInput, ...func(*wafregional.Options)) (*wafregional.GetRateBasedRuleManagedKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRateBasedRuleManagedKeysInput, ...func(*wafregional.Options)) *wafregional.GetRateBasedRuleManagedKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRateBasedRuleManagedKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRateBasedRuleManagedKeysInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegexMatchSet(ctx context.Context, params *wafregional.GetRegexMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegexMatchSet")
	}

	var r0 *wafregional.GetRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRegexMatchSetInput, ...func(*wafregional.Options)) (*wafregional.GetRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRegexMatchSetInput, ...func(*wafregional.Options)) *wafregional.GetRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRegexMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegexPatternSet(ctx context.Context, params *wafregional.GetRegexPatternSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegexPatternSet")
	}

	var r0 *wafregional.GetRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRegexPatternSetInput, ...func(*wafregional.Options)) (*wafregional.GetRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRegexPatternSetInput, ...func(*wafregional.Options)) *wafregional.GetRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRegexPatternSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRule(ctx context.Context, params *wafregional.GetRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 *wafregional.GetRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRuleInput, ...func(*wafregional.Options)) (*wafregional.GetRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRuleInput, ...func(*wafregional.Options)) *wafregional.GetRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRuleGroup(ctx context.Context, params *wafregional.GetRuleGroupInput, optFns ...func(*wafregional.Options)) (*wafregional.GetRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRuleGroup")
	}

	var r0 *wafregional.GetRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRuleGroupInput, ...func(*wafregional.Options)) (*wafregional.GetRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetRuleGroupInput, ...func(*wafregional.Options)) *wafregional.GetRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetRuleGroupInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSampledRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSampledRequests(ctx context.Context, params *wafregional.GetSampledRequestsInput, optFns ...func(*wafregional.Options)) (*wafregional.GetSampledRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSampledRequests")
	}

	var r0 *wafregional.GetSampledRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSampledRequestsInput, ...func(*wafregional.Options)) (*wafregional.GetSampledRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSampledRequestsInput, ...func(*wafregional.Options)) *wafregional.GetSampledRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetSampledRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetSampledRequestsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSizeConstraintSet(ctx context.Context, params *wafregional.GetSizeConstraintSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSizeConstraintSet")
	}

	var r0 *wafregional.GetSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSizeConstraintSetInput, ...func(*wafregional.Options)) (*wafregional.GetSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSizeConstraintSetInput, ...func(*wafregional.Options)) *wafregional.GetSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetSizeConstraintSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSqlInjectionMatchSet(ctx context.Context, params *wafregional.GetSqlInjectionMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSqlInjectionMatchSet")
	}

	var r0 *wafregional.GetSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSqlInjectionMatchSetInput, ...func(*wafregional.Options)) (*wafregional.GetSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetSqlInjectionMatchSetInput, ...func(*wafregional.Options)) *wafregional.GetSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetSqlInjectionMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWebACL(ctx context.Context, params *wafregional.GetWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.GetWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWebACL")
	}

	var r0 *wafregional.GetWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetWebACLInput, ...func(*wafregional.Options)) (*wafregional.GetWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetWebACLInput, ...func(*wafregional.Options)) *wafregional.GetWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebACLForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWebACLForResource(ctx context.Context, params *wafregional.GetWebACLForResourceInput, optFns ...func(*wafregional.Options)) (*wafregional.GetWebACLForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWebACLForResource")
	}

	var r0 *wafregional.GetWebACLForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetWebACLForResourceInput, ...func(*wafregional.Options)) (*wafregional.GetWebACLForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetWebACLForResourceInput, ...func(*wafregional.Options)) *wafregional.GetWebACLForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetWebACLForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetWebACLForResourceInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetXssMatchSet(ctx context.Context, params *wafregional.GetXssMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.GetXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetXssMatchSet")
	}

	var r0 *wafregional.GetXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetXssMatchSetInput, ...func(*wafregional.Options)) (*wafregional.GetXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.GetXssMatchSetInput, ...func(*wafregional.Options)) *wafregional.GetXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.GetXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.GetXssMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActivatedRulesInRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActivatedRulesInRuleGroup(ctx context.Context, params *wafregional.ListActivatedRulesInRuleGroupInput, optFns ...func(*wafregional.Options)) (*wafregional.ListActivatedRulesInRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActivatedRulesInRuleGroup")
	}

	var r0 *wafregional.ListActivatedRulesInRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListActivatedRulesInRuleGroupInput, ...func(*wafregional.Options)) (*wafregional.ListActivatedRulesInRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListActivatedRulesInRuleGroupInput, ...func(*wafregional.Options)) *wafregional.ListActivatedRulesInRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListActivatedRulesInRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListActivatedRulesInRuleGroupInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListByteMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListByteMatchSets(ctx context.Context, params *wafregional.ListByteMatchSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListByteMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListByteMatchSets")
	}

	var r0 *wafregional.ListByteMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListByteMatchSetsInput, ...func(*wafregional.Options)) (*wafregional.ListByteMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListByteMatchSetsInput, ...func(*wafregional.Options)) *wafregional.ListByteMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListByteMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListByteMatchSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGeoMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGeoMatchSets(ctx context.Context, params *wafregional.ListGeoMatchSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListGeoMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGeoMatchSets")
	}

	var r0 *wafregional.ListGeoMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListGeoMatchSetsInput, ...func(*wafregional.Options)) (*wafregional.ListGeoMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListGeoMatchSetsInput, ...func(*wafregional.Options)) *wafregional.ListGeoMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListGeoMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListGeoMatchSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIPSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIPSets(ctx context.Context, params *wafregional.ListIPSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListIPSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIPSets")
	}

	var r0 *wafregional.ListIPSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListIPSetsInput, ...func(*wafregional.Options)) (*wafregional.ListIPSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListIPSetsInput, ...func(*wafregional.Options)) *wafregional.ListIPSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListIPSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListIPSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLoggingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLoggingConfigurations(ctx context.Context, params *wafregional.ListLoggingConfigurationsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListLoggingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLoggingConfigurations")
	}

	var r0 *wafregional.ListLoggingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListLoggingConfigurationsInput, ...func(*wafregional.Options)) (*wafregional.ListLoggingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListLoggingConfigurationsInput, ...func(*wafregional.Options)) *wafregional.ListLoggingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListLoggingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListLoggingConfigurationsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRateBasedRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRateBasedRules(ctx context.Context, params *wafregional.ListRateBasedRulesInput, optFns ...func(*wafregional.Options)) (*wafregional.ListRateBasedRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRateBasedRules")
	}

	var r0 *wafregional.ListRateBasedRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRateBasedRulesInput, ...func(*wafregional.Options)) (*wafregional.ListRateBasedRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRateBasedRulesInput, ...func(*wafregional.Options)) *wafregional.ListRateBasedRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListRateBasedRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListRateBasedRulesInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegexMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegexMatchSets(ctx context.Context, params *wafregional.ListRegexMatchSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListRegexMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegexMatchSets")
	}

	var r0 *wafregional.ListRegexMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRegexMatchSetsInput, ...func(*wafregional.Options)) (*wafregional.ListRegexMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRegexMatchSetsInput, ...func(*wafregional.Options)) *wafregional.ListRegexMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListRegexMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListRegexMatchSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegexPatternSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegexPatternSets(ctx context.Context, params *wafregional.ListRegexPatternSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListRegexPatternSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegexPatternSets")
	}

	var r0 *wafregional.ListRegexPatternSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRegexPatternSetsInput, ...func(*wafregional.Options)) (*wafregional.ListRegexPatternSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRegexPatternSetsInput, ...func(*wafregional.Options)) *wafregional.ListRegexPatternSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListRegexPatternSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListRegexPatternSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResourcesForWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResourcesForWebACL(ctx context.Context, params *wafregional.ListResourcesForWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.ListResourcesForWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResourcesForWebACL")
	}

	var r0 *wafregional.ListResourcesForWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListResourcesForWebACLInput, ...func(*wafregional.Options)) (*wafregional.ListResourcesForWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListResourcesForWebACLInput, ...func(*wafregional.Options)) *wafregional.ListResourcesForWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListResourcesForWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListResourcesForWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuleGroups(ctx context.Context, params *wafregional.ListRuleGroupsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuleGroups")
	}

	var r0 *wafregional.ListRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRuleGroupsInput, ...func(*wafregional.Options)) (*wafregional.ListRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRuleGroupsInput, ...func(*wafregional.Options)) *wafregional.ListRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListRuleGroupsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRules(ctx context.Context, params *wafregional.ListRulesInput, optFns ...func(*wafregional.Options)) (*wafregional.ListRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 *wafregional.ListRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRulesInput, ...func(*wafregional.Options)) (*wafregional.ListRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListRulesInput, ...func(*wafregional.Options)) *wafregional.ListRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListRulesInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSizeConstraintSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSizeConstraintSets(ctx context.Context, params *wafregional.ListSizeConstraintSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListSizeConstraintSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSizeConstraintSets")
	}

	var r0 *wafregional.ListSizeConstraintSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSizeConstraintSetsInput, ...func(*wafregional.Options)) (*wafregional.ListSizeConstraintSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSizeConstraintSetsInput, ...func(*wafregional.Options)) *wafregional.ListSizeConstraintSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListSizeConstraintSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListSizeConstraintSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSqlInjectionMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSqlInjectionMatchSets(ctx context.Context, params *wafregional.ListSqlInjectionMatchSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListSqlInjectionMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSqlInjectionMatchSets")
	}

	var r0 *wafregional.ListSqlInjectionMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSqlInjectionMatchSetsInput, ...func(*wafregional.Options)) (*wafregional.ListSqlInjectionMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSqlInjectionMatchSetsInput, ...func(*wafregional.Options)) *wafregional.ListSqlInjectionMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListSqlInjectionMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListSqlInjectionMatchSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSubscribedRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSubscribedRuleGroups(ctx context.Context, params *wafregional.ListSubscribedRuleGroupsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListSubscribedRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubscribedRuleGroups")
	}

	var r0 *wafregional.ListSubscribedRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSubscribedRuleGroupsInput, ...func(*wafregional.Options)) (*wafregional.ListSubscribedRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListSubscribedRuleGroupsInput, ...func(*wafregional.Options)) *wafregional.ListSubscribedRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListSubscribedRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListSubscribedRuleGroupsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *wafregional.ListTagsForResourceInput, optFns ...func(*wafregional.Options)) (*wafregional.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *wafregional.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListTagsForResourceInput, ...func(*wafregional.Options)) (*wafregional.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListTagsForResourceInput, ...func(*wafregional.Options)) *wafregional.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListTagsForResourceInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWebACLs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWebACLs(ctx context.Context, params *wafregional.ListWebACLsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListWebACLsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWebACLs")
	}

	var r0 *wafregional.ListWebACLsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListWebACLsInput, ...func(*wafregional.Options)) (*wafregional.ListWebACLsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListWebACLsInput, ...func(*wafregional.Options)) *wafregional.ListWebACLsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListWebACLsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListWebACLsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListXssMatchSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListXssMatchSets(ctx context.Context, params *wafregional.ListXssMatchSetsInput, optFns ...func(*wafregional.Options)) (*wafregional.ListXssMatchSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListXssMatchSets")
	}

	var r0 *wafregional.ListXssMatchSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListXssMatchSetsInput, ...func(*wafregional.Options)) (*wafregional.ListXssMatchSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.ListXssMatchSetsInput, ...func(*wafregional.Options)) *wafregional.ListXssMatchSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.ListXssMatchSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.ListXssMatchSetsInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() wafregional.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 wafregional.Options
	if rf, ok := ret.Get(0).(func() wafregional.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wafregional.Options)
	}

	return r0
}

// PutLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLoggingConfiguration(ctx context.Context, params *wafregional.PutLoggingConfigurationInput, optFns ...func(*wafregional.Options)) (*wafregional.PutLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLoggingConfiguration")
	}

	var r0 *wafregional.PutLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.PutLoggingConfigurationInput, ...func(*wafregional.Options)) (*wafregional.PutLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.PutLoggingConfigurationInput, ...func(*wafregional.Options)) *wafregional.PutLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.PutLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.PutLoggingConfigurationInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPermissionPolicy(ctx context.Context, params *wafregional.PutPermissionPolicyInput, optFns ...func(*wafregional.Options)) (*wafregional.PutPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPermissionPolicy")
	}

	var r0 *wafregional.PutPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.PutPermissionPolicyInput, ...func(*wafregional.Options)) (*wafregional.PutPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.PutPermissionPolicyInput, ...func(*wafregional.Options)) *wafregional.PutPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.PutPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.PutPermissionPolicyInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *wafregional.TagResourceInput, optFns ...func(*wafregional.Options)) (*wafregional.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *wafregional.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.TagResourceInput, ...func(*wafregional.Options)) (*wafregional.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.TagResourceInput, ...func(*wafregional.Options)) *wafregional.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.TagResourceInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *wafregional.UntagResourceInput, optFns ...func(*wafregional.Options)) (*wafregional.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *wafregional.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UntagResourceInput, ...func(*wafregional.Options)) (*wafregional.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UntagResourceInput, ...func(*wafregional.Options)) *wafregional.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UntagResourceInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateByteMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateByteMatchSet(ctx context.Context, params *wafregional.UpdateByteMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateByteMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByteMatchSet")
	}

	var r0 *wafregional.UpdateByteMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateByteMatchSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateByteMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateByteMatchSetInput, ...func(*wafregional.Options)) *wafregional.UpdateByteMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateByteMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateByteMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGeoMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGeoMatchSet(ctx context.Context, params *wafregional.UpdateGeoMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateGeoMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGeoMatchSet")
	}

	var r0 *wafregional.UpdateGeoMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateGeoMatchSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateGeoMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateGeoMatchSetInput, ...func(*wafregional.Options)) *wafregional.UpdateGeoMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateGeoMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateGeoMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIPSet(ctx context.Context, params *wafregional.UpdateIPSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIPSet")
	}

	var r0 *wafregional.UpdateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateIPSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateIPSetInput, ...func(*wafregional.Options)) *wafregional.UpdateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateIPSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRateBasedRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRateBasedRule(ctx context.Context, params *wafregional.UpdateRateBasedRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateRateBasedRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRateBasedRule")
	}

	var r0 *wafregional.UpdateRateBasedRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRateBasedRuleInput, ...func(*wafregional.Options)) (*wafregional.UpdateRateBasedRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRateBasedRuleInput, ...func(*wafregional.Options)) *wafregional.UpdateRateBasedRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateRateBasedRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateRateBasedRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegexMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegexMatchSet(ctx context.Context, params *wafregional.UpdateRegexMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateRegexMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegexMatchSet")
	}

	var r0 *wafregional.UpdateRegexMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRegexMatchSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateRegexMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRegexMatchSetInput, ...func(*wafregional.Options)) *wafregional.UpdateRegexMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateRegexMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateRegexMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegexPatternSet(ctx context.Context, params *wafregional.UpdateRegexPatternSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegexPatternSet")
	}

	var r0 *wafregional.UpdateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRegexPatternSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRegexPatternSetInput, ...func(*wafregional.Options)) *wafregional.UpdateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateRegexPatternSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRule(ctx context.Context, params *wafregional.UpdateRuleInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 *wafregional.UpdateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRuleInput, ...func(*wafregional.Options)) (*wafregional.UpdateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRuleInput, ...func(*wafregional.Options)) *wafregional.UpdateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateRuleInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleGroup(ctx context.Context, params *wafregional.UpdateRuleGroupInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleGroup")
	}

	var r0 *wafregional.UpdateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRuleGroupInput, ...func(*wafregional.Options)) (*wafregional.UpdateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateRuleGroupInput, ...func(*wafregional.Options)) *wafregional.UpdateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateRuleGroupInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSizeConstraintSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSizeConstraintSet(ctx context.Context, params *wafregional.UpdateSizeConstraintSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateSizeConstraintSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSizeConstraintSet")
	}

	var r0 *wafregional.UpdateSizeConstraintSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateSizeConstraintSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateSizeConstraintSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateSizeConstraintSetInput, ...func(*wafregional.Options)) *wafregional.UpdateSizeConstraintSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateSizeConstraintSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateSizeConstraintSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSqlInjectionMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSqlInjectionMatchSet(ctx context.Context, params *wafregional.UpdateSqlInjectionMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateSqlInjectionMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSqlInjectionMatchSet")
	}

	var r0 *wafregional.UpdateSqlInjectionMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateSqlInjectionMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) *wafregional.UpdateSqlInjectionMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateSqlInjectionMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateSqlInjectionMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWebACL(ctx context.Context, params *wafregional.UpdateWebACLInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWebACL")
	}

	var r0 *wafregional.UpdateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateWebACLInput, ...func(*wafregional.Options)) (*wafregional.UpdateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateWebACLInput, ...func(*wafregional.Options)) *wafregional.UpdateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateWebACLInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateXssMatchSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateXssMatchSet(ctx context.Context, params *wafregional.UpdateXssMatchSetInput, optFns ...func(*wafregional.Options)) (*wafregional.UpdateXssMatchSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateXssMatchSet")
	}

	var r0 *wafregional.UpdateXssMatchSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateXssMatchSetInput, ...func(*wafregional.Options)) (*wafregional.UpdateXssMatchSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafregional.UpdateXssMatchSetInput, ...func(*wafregional.Options)) *wafregional.UpdateXssMatchSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafregional.UpdateXssMatchSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafregional.UpdateXssMatchSetInput, ...func(*wafregional.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
