// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	rekognition "github.com/aws/aws-sdk-go-v2/service/rekognition"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateFaces(ctx context.Context, params *rekognition.AssociateFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.AssociateFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateFaces")
	}

	var r0 *rekognition.AssociateFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.AssociateFacesInput, ...func(*rekognition.Options)) (*rekognition.AssociateFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.AssociateFacesInput, ...func(*rekognition.Options)) *rekognition.AssociateFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.AssociateFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.AssociateFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompareFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CompareFaces(ctx context.Context, params *rekognition.CompareFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.CompareFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompareFaces")
	}

	var r0 *rekognition.CompareFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CompareFacesInput, ...func(*rekognition.Options)) (*rekognition.CompareFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CompareFacesInput, ...func(*rekognition.Options)) *rekognition.CompareFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CompareFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CompareFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyProjectVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyProjectVersion(ctx context.Context, params *rekognition.CopyProjectVersionInput, optFns ...func(*rekognition.Options)) (*rekognition.CopyProjectVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyProjectVersion")
	}

	var r0 *rekognition.CopyProjectVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CopyProjectVersionInput, ...func(*rekognition.Options)) (*rekognition.CopyProjectVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CopyProjectVersionInput, ...func(*rekognition.Options)) *rekognition.CopyProjectVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CopyProjectVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CopyProjectVersionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCollection(ctx context.Context, params *rekognition.CreateCollectionInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 *rekognition.CreateCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateCollectionInput, ...func(*rekognition.Options)) (*rekognition.CreateCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateCollectionInput, ...func(*rekognition.Options)) *rekognition.CreateCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateCollectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataset(ctx context.Context, params *rekognition.CreateDatasetInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataset")
	}

	var r0 *rekognition.CreateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateDatasetInput, ...func(*rekognition.Options)) (*rekognition.CreateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateDatasetInput, ...func(*rekognition.Options)) *rekognition.CreateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateDatasetInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFaceLivenessSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFaceLivenessSession(ctx context.Context, params *rekognition.CreateFaceLivenessSessionInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateFaceLivenessSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFaceLivenessSession")
	}

	var r0 *rekognition.CreateFaceLivenessSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateFaceLivenessSessionInput, ...func(*rekognition.Options)) (*rekognition.CreateFaceLivenessSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateFaceLivenessSessionInput, ...func(*rekognition.Options)) *rekognition.CreateFaceLivenessSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateFaceLivenessSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateFaceLivenessSessionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProject(ctx context.Context, params *rekognition.CreateProjectInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *rekognition.CreateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateProjectInput, ...func(*rekognition.Options)) (*rekognition.CreateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateProjectInput, ...func(*rekognition.Options)) *rekognition.CreateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateProjectInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProjectVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProjectVersion(ctx context.Context, params *rekognition.CreateProjectVersionInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateProjectVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectVersion")
	}

	var r0 *rekognition.CreateProjectVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateProjectVersionInput, ...func(*rekognition.Options)) (*rekognition.CreateProjectVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateProjectVersionInput, ...func(*rekognition.Options)) *rekognition.CreateProjectVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateProjectVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateProjectVersionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateStreamProcessor(ctx context.Context, params *rekognition.CreateStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStreamProcessor")
	}

	var r0 *rekognition.CreateStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.CreateStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.CreateStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUser(ctx context.Context, params *rekognition.CreateUserInput, optFns ...func(*rekognition.Options)) (*rekognition.CreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *rekognition.CreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateUserInput, ...func(*rekognition.Options)) (*rekognition.CreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.CreateUserInput, ...func(*rekognition.Options)) *rekognition.CreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.CreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.CreateUserInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCollection(ctx context.Context, params *rekognition.DeleteCollectionInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCollection")
	}

	var r0 *rekognition.DeleteCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteCollectionInput, ...func(*rekognition.Options)) (*rekognition.DeleteCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteCollectionInput, ...func(*rekognition.Options)) *rekognition.DeleteCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteCollectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataset(ctx context.Context, params *rekognition.DeleteDatasetInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataset")
	}

	var r0 *rekognition.DeleteDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteDatasetInput, ...func(*rekognition.Options)) (*rekognition.DeleteDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteDatasetInput, ...func(*rekognition.Options)) *rekognition.DeleteDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteDatasetInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFaces(ctx context.Context, params *rekognition.DeleteFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFaces")
	}

	var r0 *rekognition.DeleteFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteFacesInput, ...func(*rekognition.Options)) (*rekognition.DeleteFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteFacesInput, ...func(*rekognition.Options)) *rekognition.DeleteFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProject(ctx context.Context, params *rekognition.DeleteProjectInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *rekognition.DeleteProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectInput, ...func(*rekognition.Options)) (*rekognition.DeleteProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectInput, ...func(*rekognition.Options)) *rekognition.DeleteProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteProjectInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProjectPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProjectPolicy(ctx context.Context, params *rekognition.DeleteProjectPolicyInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteProjectPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectPolicy")
	}

	var r0 *rekognition.DeleteProjectPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectPolicyInput, ...func(*rekognition.Options)) (*rekognition.DeleteProjectPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectPolicyInput, ...func(*rekognition.Options)) *rekognition.DeleteProjectPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteProjectPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteProjectPolicyInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProjectVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProjectVersion(ctx context.Context, params *rekognition.DeleteProjectVersionInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteProjectVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectVersion")
	}

	var r0 *rekognition.DeleteProjectVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectVersionInput, ...func(*rekognition.Options)) (*rekognition.DeleteProjectVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteProjectVersionInput, ...func(*rekognition.Options)) *rekognition.DeleteProjectVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteProjectVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteProjectVersionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteStreamProcessor(ctx context.Context, params *rekognition.DeleteStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStreamProcessor")
	}

	var r0 *rekognition.DeleteStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.DeleteStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.DeleteStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUser(ctx context.Context, params *rekognition.DeleteUserInput, optFns ...func(*rekognition.Options)) (*rekognition.DeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *rekognition.DeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteUserInput, ...func(*rekognition.Options)) (*rekognition.DeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DeleteUserInput, ...func(*rekognition.Options)) *rekognition.DeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DeleteUserInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCollection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCollection(ctx context.Context, params *rekognition.DescribeCollectionInput, optFns ...func(*rekognition.Options)) (*rekognition.DescribeCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCollection")
	}

	var r0 *rekognition.DescribeCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeCollectionInput, ...func(*rekognition.Options)) (*rekognition.DescribeCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeCollectionInput, ...func(*rekognition.Options)) *rekognition.DescribeCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DescribeCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DescribeCollectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataset(ctx context.Context, params *rekognition.DescribeDatasetInput, optFns ...func(*rekognition.Options)) (*rekognition.DescribeDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataset")
	}

	var r0 *rekognition.DescribeDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeDatasetInput, ...func(*rekognition.Options)) (*rekognition.DescribeDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeDatasetInput, ...func(*rekognition.Options)) *rekognition.DescribeDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DescribeDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DescribeDatasetInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeProjectVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeProjectVersions(ctx context.Context, params *rekognition.DescribeProjectVersionsInput, optFns ...func(*rekognition.Options)) (*rekognition.DescribeProjectVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeProjectVersions")
	}

	var r0 *rekognition.DescribeProjectVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeProjectVersionsInput, ...func(*rekognition.Options)) (*rekognition.DescribeProjectVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeProjectVersionsInput, ...func(*rekognition.Options)) *rekognition.DescribeProjectVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DescribeProjectVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DescribeProjectVersionsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeProjects(ctx context.Context, params *rekognition.DescribeProjectsInput, optFns ...func(*rekognition.Options)) (*rekognition.DescribeProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeProjects")
	}

	var r0 *rekognition.DescribeProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeProjectsInput, ...func(*rekognition.Options)) (*rekognition.DescribeProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeProjectsInput, ...func(*rekognition.Options)) *rekognition.DescribeProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DescribeProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DescribeProjectsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStreamProcessor(ctx context.Context, params *rekognition.DescribeStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.DescribeStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStreamProcessor")
	}

	var r0 *rekognition.DescribeStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.DescribeStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DescribeStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.DescribeStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DescribeStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DescribeStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectCustomLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectCustomLabels(ctx context.Context, params *rekognition.DetectCustomLabelsInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectCustomLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectCustomLabels")
	}

	var r0 *rekognition.DetectCustomLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectCustomLabelsInput, ...func(*rekognition.Options)) (*rekognition.DetectCustomLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectCustomLabelsInput, ...func(*rekognition.Options)) *rekognition.DetectCustomLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectCustomLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectCustomLabelsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectFaces(ctx context.Context, params *rekognition.DetectFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectFaces")
	}

	var r0 *rekognition.DetectFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectFacesInput, ...func(*rekognition.Options)) (*rekognition.DetectFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectFacesInput, ...func(*rekognition.Options)) *rekognition.DetectFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectLabels(ctx context.Context, params *rekognition.DetectLabelsInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectLabels")
	}

	var r0 *rekognition.DetectLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectLabelsInput, ...func(*rekognition.Options)) (*rekognition.DetectLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectLabelsInput, ...func(*rekognition.Options)) *rekognition.DetectLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectLabelsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectModerationLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectModerationLabels(ctx context.Context, params *rekognition.DetectModerationLabelsInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectModerationLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectModerationLabels")
	}

	var r0 *rekognition.DetectModerationLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectModerationLabelsInput, ...func(*rekognition.Options)) (*rekognition.DetectModerationLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectModerationLabelsInput, ...func(*rekognition.Options)) *rekognition.DetectModerationLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectModerationLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectModerationLabelsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectProtectiveEquipment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectProtectiveEquipment(ctx context.Context, params *rekognition.DetectProtectiveEquipmentInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectProtectiveEquipmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectProtectiveEquipment")
	}

	var r0 *rekognition.DetectProtectiveEquipmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectProtectiveEquipmentInput, ...func(*rekognition.Options)) (*rekognition.DetectProtectiveEquipmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectProtectiveEquipmentInput, ...func(*rekognition.Options)) *rekognition.DetectProtectiveEquipmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectProtectiveEquipmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectProtectiveEquipmentInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetectText provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DetectText(ctx context.Context, params *rekognition.DetectTextInput, optFns ...func(*rekognition.Options)) (*rekognition.DetectTextOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetectText")
	}

	var r0 *rekognition.DetectTextOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectTextInput, ...func(*rekognition.Options)) (*rekognition.DetectTextOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DetectTextInput, ...func(*rekognition.Options)) *rekognition.DetectTextOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DetectTextOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DetectTextInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateFaces(ctx context.Context, params *rekognition.DisassociateFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.DisassociateFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateFaces")
	}

	var r0 *rekognition.DisassociateFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DisassociateFacesInput, ...func(*rekognition.Options)) (*rekognition.DisassociateFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DisassociateFacesInput, ...func(*rekognition.Options)) *rekognition.DisassociateFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DisassociateFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DisassociateFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DistributeDatasetEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DistributeDatasetEntries(ctx context.Context, params *rekognition.DistributeDatasetEntriesInput, optFns ...func(*rekognition.Options)) (*rekognition.DistributeDatasetEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DistributeDatasetEntries")
	}

	var r0 *rekognition.DistributeDatasetEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DistributeDatasetEntriesInput, ...func(*rekognition.Options)) (*rekognition.DistributeDatasetEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.DistributeDatasetEntriesInput, ...func(*rekognition.Options)) *rekognition.DistributeDatasetEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.DistributeDatasetEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.DistributeDatasetEntriesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCelebrityInfo provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCelebrityInfo(ctx context.Context, params *rekognition.GetCelebrityInfoInput, optFns ...func(*rekognition.Options)) (*rekognition.GetCelebrityInfoOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCelebrityInfo")
	}

	var r0 *rekognition.GetCelebrityInfoOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetCelebrityInfoInput, ...func(*rekognition.Options)) (*rekognition.GetCelebrityInfoOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetCelebrityInfoInput, ...func(*rekognition.Options)) *rekognition.GetCelebrityInfoOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetCelebrityInfoOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetCelebrityInfoInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCelebrityRecognition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCelebrityRecognition(ctx context.Context, params *rekognition.GetCelebrityRecognitionInput, optFns ...func(*rekognition.Options)) (*rekognition.GetCelebrityRecognitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCelebrityRecognition")
	}

	var r0 *rekognition.GetCelebrityRecognitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetCelebrityRecognitionInput, ...func(*rekognition.Options)) (*rekognition.GetCelebrityRecognitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetCelebrityRecognitionInput, ...func(*rekognition.Options)) *rekognition.GetCelebrityRecognitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetCelebrityRecognitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetCelebrityRecognitionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContentModeration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetContentModeration(ctx context.Context, params *rekognition.GetContentModerationInput, optFns ...func(*rekognition.Options)) (*rekognition.GetContentModerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContentModeration")
	}

	var r0 *rekognition.GetContentModerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetContentModerationInput, ...func(*rekognition.Options)) (*rekognition.GetContentModerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetContentModerationInput, ...func(*rekognition.Options)) *rekognition.GetContentModerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetContentModerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetContentModerationInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFaceDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFaceDetection(ctx context.Context, params *rekognition.GetFaceDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.GetFaceDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFaceDetection")
	}

	var r0 *rekognition.GetFaceDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceDetectionInput, ...func(*rekognition.Options)) (*rekognition.GetFaceDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceDetectionInput, ...func(*rekognition.Options)) *rekognition.GetFaceDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetFaceDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetFaceDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFaceLivenessSessionResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFaceLivenessSessionResults(ctx context.Context, params *rekognition.GetFaceLivenessSessionResultsInput, optFns ...func(*rekognition.Options)) (*rekognition.GetFaceLivenessSessionResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFaceLivenessSessionResults")
	}

	var r0 *rekognition.GetFaceLivenessSessionResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceLivenessSessionResultsInput, ...func(*rekognition.Options)) (*rekognition.GetFaceLivenessSessionResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceLivenessSessionResultsInput, ...func(*rekognition.Options)) *rekognition.GetFaceLivenessSessionResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetFaceLivenessSessionResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetFaceLivenessSessionResultsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFaceSearch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFaceSearch(ctx context.Context, params *rekognition.GetFaceSearchInput, optFns ...func(*rekognition.Options)) (*rekognition.GetFaceSearchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFaceSearch")
	}

	var r0 *rekognition.GetFaceSearchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceSearchInput, ...func(*rekognition.Options)) (*rekognition.GetFaceSearchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetFaceSearchInput, ...func(*rekognition.Options)) *rekognition.GetFaceSearchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetFaceSearchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetFaceSearchInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLabelDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLabelDetection(ctx context.Context, params *rekognition.GetLabelDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.GetLabelDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLabelDetection")
	}

	var r0 *rekognition.GetLabelDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetLabelDetectionInput, ...func(*rekognition.Options)) (*rekognition.GetLabelDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetLabelDetectionInput, ...func(*rekognition.Options)) *rekognition.GetLabelDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetLabelDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetLabelDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMediaAnalysisJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMediaAnalysisJob(ctx context.Context, params *rekognition.GetMediaAnalysisJobInput, optFns ...func(*rekognition.Options)) (*rekognition.GetMediaAnalysisJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMediaAnalysisJob")
	}

	var r0 *rekognition.GetMediaAnalysisJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetMediaAnalysisJobInput, ...func(*rekognition.Options)) (*rekognition.GetMediaAnalysisJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetMediaAnalysisJobInput, ...func(*rekognition.Options)) *rekognition.GetMediaAnalysisJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetMediaAnalysisJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetMediaAnalysisJobInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPersonTracking provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPersonTracking(ctx context.Context, params *rekognition.GetPersonTrackingInput, optFns ...func(*rekognition.Options)) (*rekognition.GetPersonTrackingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPersonTracking")
	}

	var r0 *rekognition.GetPersonTrackingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetPersonTrackingInput, ...func(*rekognition.Options)) (*rekognition.GetPersonTrackingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetPersonTrackingInput, ...func(*rekognition.Options)) *rekognition.GetPersonTrackingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetPersonTrackingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetPersonTrackingInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSegmentDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSegmentDetection(ctx context.Context, params *rekognition.GetSegmentDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.GetSegmentDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSegmentDetection")
	}

	var r0 *rekognition.GetSegmentDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetSegmentDetectionInput, ...func(*rekognition.Options)) (*rekognition.GetSegmentDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetSegmentDetectionInput, ...func(*rekognition.Options)) *rekognition.GetSegmentDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetSegmentDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetSegmentDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTextDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTextDetection(ctx context.Context, params *rekognition.GetTextDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.GetTextDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTextDetection")
	}

	var r0 *rekognition.GetTextDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetTextDetectionInput, ...func(*rekognition.Options)) (*rekognition.GetTextDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.GetTextDetectionInput, ...func(*rekognition.Options)) *rekognition.GetTextDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.GetTextDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.GetTextDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IndexFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) IndexFaces(ctx context.Context, params *rekognition.IndexFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.IndexFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IndexFaces")
	}

	var r0 *rekognition.IndexFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.IndexFacesInput, ...func(*rekognition.Options)) (*rekognition.IndexFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.IndexFacesInput, ...func(*rekognition.Options)) *rekognition.IndexFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.IndexFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.IndexFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollections(ctx context.Context, params *rekognition.ListCollectionsInput, optFns ...func(*rekognition.Options)) (*rekognition.ListCollectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollections")
	}

	var r0 *rekognition.ListCollectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListCollectionsInput, ...func(*rekognition.Options)) (*rekognition.ListCollectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListCollectionsInput, ...func(*rekognition.Options)) *rekognition.ListCollectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListCollectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListCollectionsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasetEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasetEntries(ctx context.Context, params *rekognition.ListDatasetEntriesInput, optFns ...func(*rekognition.Options)) (*rekognition.ListDatasetEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasetEntries")
	}

	var r0 *rekognition.ListDatasetEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListDatasetEntriesInput, ...func(*rekognition.Options)) (*rekognition.ListDatasetEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListDatasetEntriesInput, ...func(*rekognition.Options)) *rekognition.ListDatasetEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListDatasetEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListDatasetEntriesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasetLabels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasetLabels(ctx context.Context, params *rekognition.ListDatasetLabelsInput, optFns ...func(*rekognition.Options)) (*rekognition.ListDatasetLabelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasetLabels")
	}

	var r0 *rekognition.ListDatasetLabelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListDatasetLabelsInput, ...func(*rekognition.Options)) (*rekognition.ListDatasetLabelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListDatasetLabelsInput, ...func(*rekognition.Options)) *rekognition.ListDatasetLabelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListDatasetLabelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListDatasetLabelsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFaces(ctx context.Context, params *rekognition.ListFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.ListFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFaces")
	}

	var r0 *rekognition.ListFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListFacesInput, ...func(*rekognition.Options)) (*rekognition.ListFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListFacesInput, ...func(*rekognition.Options)) *rekognition.ListFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMediaAnalysisJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMediaAnalysisJobs(ctx context.Context, params *rekognition.ListMediaAnalysisJobsInput, optFns ...func(*rekognition.Options)) (*rekognition.ListMediaAnalysisJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMediaAnalysisJobs")
	}

	var r0 *rekognition.ListMediaAnalysisJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListMediaAnalysisJobsInput, ...func(*rekognition.Options)) (*rekognition.ListMediaAnalysisJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListMediaAnalysisJobsInput, ...func(*rekognition.Options)) *rekognition.ListMediaAnalysisJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListMediaAnalysisJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListMediaAnalysisJobsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjectPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProjectPolicies(ctx context.Context, params *rekognition.ListProjectPoliciesInput, optFns ...func(*rekognition.Options)) (*rekognition.ListProjectPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectPolicies")
	}

	var r0 *rekognition.ListProjectPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListProjectPoliciesInput, ...func(*rekognition.Options)) (*rekognition.ListProjectPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListProjectPoliciesInput, ...func(*rekognition.Options)) *rekognition.ListProjectPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListProjectPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListProjectPoliciesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStreamProcessors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStreamProcessors(ctx context.Context, params *rekognition.ListStreamProcessorsInput, optFns ...func(*rekognition.Options)) (*rekognition.ListStreamProcessorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreamProcessors")
	}

	var r0 *rekognition.ListStreamProcessorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListStreamProcessorsInput, ...func(*rekognition.Options)) (*rekognition.ListStreamProcessorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListStreamProcessorsInput, ...func(*rekognition.Options)) *rekognition.ListStreamProcessorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListStreamProcessorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListStreamProcessorsInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *rekognition.ListTagsForResourceInput, optFns ...func(*rekognition.Options)) (*rekognition.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *rekognition.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListTagsForResourceInput, ...func(*rekognition.Options)) (*rekognition.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListTagsForResourceInput, ...func(*rekognition.Options)) *rekognition.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListTagsForResourceInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUsers(ctx context.Context, params *rekognition.ListUsersInput, optFns ...func(*rekognition.Options)) (*rekognition.ListUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *rekognition.ListUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListUsersInput, ...func(*rekognition.Options)) (*rekognition.ListUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.ListUsersInput, ...func(*rekognition.Options)) *rekognition.ListUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.ListUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.ListUsersInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() rekognition.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 rekognition.Options
	if rf, ok := ret.Get(0).(func() rekognition.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(rekognition.Options)
	}

	return r0
}

// PutProjectPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutProjectPolicy(ctx context.Context, params *rekognition.PutProjectPolicyInput, optFns ...func(*rekognition.Options)) (*rekognition.PutProjectPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutProjectPolicy")
	}

	var r0 *rekognition.PutProjectPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.PutProjectPolicyInput, ...func(*rekognition.Options)) (*rekognition.PutProjectPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.PutProjectPolicyInput, ...func(*rekognition.Options)) *rekognition.PutProjectPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.PutProjectPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.PutProjectPolicyInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecognizeCelebrities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RecognizeCelebrities(ctx context.Context, params *rekognition.RecognizeCelebritiesInput, optFns ...func(*rekognition.Options)) (*rekognition.RecognizeCelebritiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RecognizeCelebrities")
	}

	var r0 *rekognition.RecognizeCelebritiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.RecognizeCelebritiesInput, ...func(*rekognition.Options)) (*rekognition.RecognizeCelebritiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.RecognizeCelebritiesInput, ...func(*rekognition.Options)) *rekognition.RecognizeCelebritiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.RecognizeCelebritiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.RecognizeCelebritiesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchFaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchFaces(ctx context.Context, params *rekognition.SearchFacesInput, optFns ...func(*rekognition.Options)) (*rekognition.SearchFacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchFaces")
	}

	var r0 *rekognition.SearchFacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchFacesInput, ...func(*rekognition.Options)) (*rekognition.SearchFacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchFacesInput, ...func(*rekognition.Options)) *rekognition.SearchFacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.SearchFacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.SearchFacesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchFacesByImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchFacesByImage(ctx context.Context, params *rekognition.SearchFacesByImageInput, optFns ...func(*rekognition.Options)) (*rekognition.SearchFacesByImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchFacesByImage")
	}

	var r0 *rekognition.SearchFacesByImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchFacesByImageInput, ...func(*rekognition.Options)) (*rekognition.SearchFacesByImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchFacesByImageInput, ...func(*rekognition.Options)) *rekognition.SearchFacesByImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.SearchFacesByImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.SearchFacesByImageInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchUsers(ctx context.Context, params *rekognition.SearchUsersInput, optFns ...func(*rekognition.Options)) (*rekognition.SearchUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchUsers")
	}

	var r0 *rekognition.SearchUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchUsersInput, ...func(*rekognition.Options)) (*rekognition.SearchUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchUsersInput, ...func(*rekognition.Options)) *rekognition.SearchUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.SearchUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.SearchUsersInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchUsersByImage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchUsersByImage(ctx context.Context, params *rekognition.SearchUsersByImageInput, optFns ...func(*rekognition.Options)) (*rekognition.SearchUsersByImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchUsersByImage")
	}

	var r0 *rekognition.SearchUsersByImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchUsersByImageInput, ...func(*rekognition.Options)) (*rekognition.SearchUsersByImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.SearchUsersByImageInput, ...func(*rekognition.Options)) *rekognition.SearchUsersByImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.SearchUsersByImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.SearchUsersByImageInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartCelebrityRecognition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCelebrityRecognition(ctx context.Context, params *rekognition.StartCelebrityRecognitionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartCelebrityRecognitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCelebrityRecognition")
	}

	var r0 *rekognition.StartCelebrityRecognitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartCelebrityRecognitionInput, ...func(*rekognition.Options)) (*rekognition.StartCelebrityRecognitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartCelebrityRecognitionInput, ...func(*rekognition.Options)) *rekognition.StartCelebrityRecognitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartCelebrityRecognitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartCelebrityRecognitionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartContentModeration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartContentModeration(ctx context.Context, params *rekognition.StartContentModerationInput, optFns ...func(*rekognition.Options)) (*rekognition.StartContentModerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartContentModeration")
	}

	var r0 *rekognition.StartContentModerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartContentModerationInput, ...func(*rekognition.Options)) (*rekognition.StartContentModerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartContentModerationInput, ...func(*rekognition.Options)) *rekognition.StartContentModerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartContentModerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartContentModerationInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFaceDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFaceDetection(ctx context.Context, params *rekognition.StartFaceDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartFaceDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFaceDetection")
	}

	var r0 *rekognition.StartFaceDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartFaceDetectionInput, ...func(*rekognition.Options)) (*rekognition.StartFaceDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartFaceDetectionInput, ...func(*rekognition.Options)) *rekognition.StartFaceDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartFaceDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartFaceDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartFaceSearch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartFaceSearch(ctx context.Context, params *rekognition.StartFaceSearchInput, optFns ...func(*rekognition.Options)) (*rekognition.StartFaceSearchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartFaceSearch")
	}

	var r0 *rekognition.StartFaceSearchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartFaceSearchInput, ...func(*rekognition.Options)) (*rekognition.StartFaceSearchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartFaceSearchInput, ...func(*rekognition.Options)) *rekognition.StartFaceSearchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartFaceSearchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartFaceSearchInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartLabelDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartLabelDetection(ctx context.Context, params *rekognition.StartLabelDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartLabelDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartLabelDetection")
	}

	var r0 *rekognition.StartLabelDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartLabelDetectionInput, ...func(*rekognition.Options)) (*rekognition.StartLabelDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartLabelDetectionInput, ...func(*rekognition.Options)) *rekognition.StartLabelDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartLabelDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartLabelDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMediaAnalysisJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMediaAnalysisJob(ctx context.Context, params *rekognition.StartMediaAnalysisJobInput, optFns ...func(*rekognition.Options)) (*rekognition.StartMediaAnalysisJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMediaAnalysisJob")
	}

	var r0 *rekognition.StartMediaAnalysisJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartMediaAnalysisJobInput, ...func(*rekognition.Options)) (*rekognition.StartMediaAnalysisJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartMediaAnalysisJobInput, ...func(*rekognition.Options)) *rekognition.StartMediaAnalysisJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartMediaAnalysisJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartMediaAnalysisJobInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartPersonTracking provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartPersonTracking(ctx context.Context, params *rekognition.StartPersonTrackingInput, optFns ...func(*rekognition.Options)) (*rekognition.StartPersonTrackingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartPersonTracking")
	}

	var r0 *rekognition.StartPersonTrackingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartPersonTrackingInput, ...func(*rekognition.Options)) (*rekognition.StartPersonTrackingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartPersonTrackingInput, ...func(*rekognition.Options)) *rekognition.StartPersonTrackingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartPersonTrackingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartPersonTrackingInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartProjectVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartProjectVersion(ctx context.Context, params *rekognition.StartProjectVersionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartProjectVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartProjectVersion")
	}

	var r0 *rekognition.StartProjectVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartProjectVersionInput, ...func(*rekognition.Options)) (*rekognition.StartProjectVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartProjectVersionInput, ...func(*rekognition.Options)) *rekognition.StartProjectVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartProjectVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartProjectVersionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartSegmentDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartSegmentDetection(ctx context.Context, params *rekognition.StartSegmentDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartSegmentDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartSegmentDetection")
	}

	var r0 *rekognition.StartSegmentDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartSegmentDetectionInput, ...func(*rekognition.Options)) (*rekognition.StartSegmentDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartSegmentDetectionInput, ...func(*rekognition.Options)) *rekognition.StartSegmentDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartSegmentDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartSegmentDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartStreamProcessor(ctx context.Context, params *rekognition.StartStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.StartStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartStreamProcessor")
	}

	var r0 *rekognition.StartStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.StartStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.StartStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTextDetection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTextDetection(ctx context.Context, params *rekognition.StartTextDetectionInput, optFns ...func(*rekognition.Options)) (*rekognition.StartTextDetectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTextDetection")
	}

	var r0 *rekognition.StartTextDetectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartTextDetectionInput, ...func(*rekognition.Options)) (*rekognition.StartTextDetectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StartTextDetectionInput, ...func(*rekognition.Options)) *rekognition.StartTextDetectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StartTextDetectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StartTextDetectionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopProjectVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopProjectVersion(ctx context.Context, params *rekognition.StopProjectVersionInput, optFns ...func(*rekognition.Options)) (*rekognition.StopProjectVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopProjectVersion")
	}

	var r0 *rekognition.StopProjectVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StopProjectVersionInput, ...func(*rekognition.Options)) (*rekognition.StopProjectVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StopProjectVersionInput, ...func(*rekognition.Options)) *rekognition.StopProjectVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StopProjectVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StopProjectVersionInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopStreamProcessor(ctx context.Context, params *rekognition.StopStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.StopStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopStreamProcessor")
	}

	var r0 *rekognition.StopStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StopStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.StopStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.StopStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.StopStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.StopStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.StopStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *rekognition.TagResourceInput, optFns ...func(*rekognition.Options)) (*rekognition.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *rekognition.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.TagResourceInput, ...func(*rekognition.Options)) (*rekognition.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.TagResourceInput, ...func(*rekognition.Options)) *rekognition.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.TagResourceInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *rekognition.UntagResourceInput, optFns ...func(*rekognition.Options)) (*rekognition.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *rekognition.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UntagResourceInput, ...func(*rekognition.Options)) (*rekognition.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UntagResourceInput, ...func(*rekognition.Options)) *rekognition.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.UntagResourceInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDatasetEntries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDatasetEntries(ctx context.Context, params *rekognition.UpdateDatasetEntriesInput, optFns ...func(*rekognition.Options)) (*rekognition.UpdateDatasetEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatasetEntries")
	}

	var r0 *rekognition.UpdateDatasetEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UpdateDatasetEntriesInput, ...func(*rekognition.Options)) (*rekognition.UpdateDatasetEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UpdateDatasetEntriesInput, ...func(*rekognition.Options)) *rekognition.UpdateDatasetEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.UpdateDatasetEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.UpdateDatasetEntriesInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStreamProcessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStreamProcessor(ctx context.Context, params *rekognition.UpdateStreamProcessorInput, optFns ...func(*rekognition.Options)) (*rekognition.UpdateStreamProcessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStreamProcessor")
	}

	var r0 *rekognition.UpdateStreamProcessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UpdateStreamProcessorInput, ...func(*rekognition.Options)) (*rekognition.UpdateStreamProcessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rekognition.UpdateStreamProcessorInput, ...func(*rekognition.Options)) *rekognition.UpdateStreamProcessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rekognition.UpdateStreamProcessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rekognition.UpdateStreamProcessorInput, ...func(*rekognition.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
