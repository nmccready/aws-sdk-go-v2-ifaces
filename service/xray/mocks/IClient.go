// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	xray "github.com/aws/aws-sdk-go-v2/service/xray"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchGetTraces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetTraces(ctx context.Context, params *xray.BatchGetTracesInput, optFns ...func(*xray.Options)) (*xray.BatchGetTracesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetTraces")
	}

	var r0 *xray.BatchGetTracesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.BatchGetTracesInput, ...func(*xray.Options)) (*xray.BatchGetTracesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.BatchGetTracesInput, ...func(*xray.Options)) *xray.BatchGetTracesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.BatchGetTracesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.BatchGetTracesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGroup(ctx context.Context, params *xray.CreateGroupInput, optFns ...func(*xray.Options)) (*xray.CreateGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGroup")
	}

	var r0 *xray.CreateGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.CreateGroupInput, ...func(*xray.Options)) (*xray.CreateGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.CreateGroupInput, ...func(*xray.Options)) *xray.CreateGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.CreateGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.CreateGroupInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSamplingRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSamplingRule(ctx context.Context, params *xray.CreateSamplingRuleInput, optFns ...func(*xray.Options)) (*xray.CreateSamplingRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSamplingRule")
	}

	var r0 *xray.CreateSamplingRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.CreateSamplingRuleInput, ...func(*xray.Options)) (*xray.CreateSamplingRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.CreateSamplingRuleInput, ...func(*xray.Options)) *xray.CreateSamplingRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.CreateSamplingRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.CreateSamplingRuleInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGroup(ctx context.Context, params *xray.DeleteGroupInput, optFns ...func(*xray.Options)) (*xray.DeleteGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroup")
	}

	var r0 *xray.DeleteGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteGroupInput, ...func(*xray.Options)) (*xray.DeleteGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteGroupInput, ...func(*xray.Options)) *xray.DeleteGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.DeleteGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.DeleteGroupInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *xray.DeleteResourcePolicyInput, optFns ...func(*xray.Options)) (*xray.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *xray.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteResourcePolicyInput, ...func(*xray.Options)) (*xray.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteResourcePolicyInput, ...func(*xray.Options)) *xray.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.DeleteResourcePolicyInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSamplingRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSamplingRule(ctx context.Context, params *xray.DeleteSamplingRuleInput, optFns ...func(*xray.Options)) (*xray.DeleteSamplingRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSamplingRule")
	}

	var r0 *xray.DeleteSamplingRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteSamplingRuleInput, ...func(*xray.Options)) (*xray.DeleteSamplingRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.DeleteSamplingRuleInput, ...func(*xray.Options)) *xray.DeleteSamplingRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.DeleteSamplingRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.DeleteSamplingRuleInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEncryptionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEncryptionConfig(ctx context.Context, params *xray.GetEncryptionConfigInput, optFns ...func(*xray.Options)) (*xray.GetEncryptionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEncryptionConfig")
	}

	var r0 *xray.GetEncryptionConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetEncryptionConfigInput, ...func(*xray.Options)) (*xray.GetEncryptionConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetEncryptionConfigInput, ...func(*xray.Options)) *xray.GetEncryptionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetEncryptionConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetEncryptionConfigInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGroup(ctx context.Context, params *xray.GetGroupInput, optFns ...func(*xray.Options)) (*xray.GetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroup")
	}

	var r0 *xray.GetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetGroupInput, ...func(*xray.Options)) (*xray.GetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetGroupInput, ...func(*xray.Options)) *xray.GetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetGroupInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGroups(ctx context.Context, params *xray.GetGroupsInput, optFns ...func(*xray.Options)) (*xray.GetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroups")
	}

	var r0 *xray.GetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetGroupsInput, ...func(*xray.Options)) (*xray.GetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetGroupsInput, ...func(*xray.Options)) *xray.GetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetGroupsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsight provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsight(ctx context.Context, params *xray.GetInsightInput, optFns ...func(*xray.Options)) (*xray.GetInsightOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsight")
	}

	var r0 *xray.GetInsightOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightInput, ...func(*xray.Options)) (*xray.GetInsightOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightInput, ...func(*xray.Options)) *xray.GetInsightOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetInsightOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetInsightInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsightEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsightEvents(ctx context.Context, params *xray.GetInsightEventsInput, optFns ...func(*xray.Options)) (*xray.GetInsightEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsightEvents")
	}

	var r0 *xray.GetInsightEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightEventsInput, ...func(*xray.Options)) (*xray.GetInsightEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightEventsInput, ...func(*xray.Options)) *xray.GetInsightEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetInsightEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetInsightEventsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsightImpactGraph provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsightImpactGraph(ctx context.Context, params *xray.GetInsightImpactGraphInput, optFns ...func(*xray.Options)) (*xray.GetInsightImpactGraphOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsightImpactGraph")
	}

	var r0 *xray.GetInsightImpactGraphOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightImpactGraphInput, ...func(*xray.Options)) (*xray.GetInsightImpactGraphOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightImpactGraphInput, ...func(*xray.Options)) *xray.GetInsightImpactGraphOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetInsightImpactGraphOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetInsightImpactGraphInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsightSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsightSummaries(ctx context.Context, params *xray.GetInsightSummariesInput, optFns ...func(*xray.Options)) (*xray.GetInsightSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsightSummaries")
	}

	var r0 *xray.GetInsightSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightSummariesInput, ...func(*xray.Options)) (*xray.GetInsightSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetInsightSummariesInput, ...func(*xray.Options)) *xray.GetInsightSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetInsightSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetInsightSummariesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSamplingRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSamplingRules(ctx context.Context, params *xray.GetSamplingRulesInput, optFns ...func(*xray.Options)) (*xray.GetSamplingRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSamplingRules")
	}

	var r0 *xray.GetSamplingRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingRulesInput, ...func(*xray.Options)) (*xray.GetSamplingRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingRulesInput, ...func(*xray.Options)) *xray.GetSamplingRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetSamplingRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetSamplingRulesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSamplingStatisticSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSamplingStatisticSummaries(ctx context.Context, params *xray.GetSamplingStatisticSummariesInput, optFns ...func(*xray.Options)) (*xray.GetSamplingStatisticSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSamplingStatisticSummaries")
	}

	var r0 *xray.GetSamplingStatisticSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingStatisticSummariesInput, ...func(*xray.Options)) (*xray.GetSamplingStatisticSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingStatisticSummariesInput, ...func(*xray.Options)) *xray.GetSamplingStatisticSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetSamplingStatisticSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetSamplingStatisticSummariesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSamplingTargets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSamplingTargets(ctx context.Context, params *xray.GetSamplingTargetsInput, optFns ...func(*xray.Options)) (*xray.GetSamplingTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSamplingTargets")
	}

	var r0 *xray.GetSamplingTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingTargetsInput, ...func(*xray.Options)) (*xray.GetSamplingTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetSamplingTargetsInput, ...func(*xray.Options)) *xray.GetSamplingTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetSamplingTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetSamplingTargetsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServiceGraph provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetServiceGraph(ctx context.Context, params *xray.GetServiceGraphInput, optFns ...func(*xray.Options)) (*xray.GetServiceGraphOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceGraph")
	}

	var r0 *xray.GetServiceGraphOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetServiceGraphInput, ...func(*xray.Options)) (*xray.GetServiceGraphOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetServiceGraphInput, ...func(*xray.Options)) *xray.GetServiceGraphOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetServiceGraphOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetServiceGraphInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTimeSeriesServiceStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTimeSeriesServiceStatistics(ctx context.Context, params *xray.GetTimeSeriesServiceStatisticsInput, optFns ...func(*xray.Options)) (*xray.GetTimeSeriesServiceStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeSeriesServiceStatistics")
	}

	var r0 *xray.GetTimeSeriesServiceStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTimeSeriesServiceStatisticsInput, ...func(*xray.Options)) (*xray.GetTimeSeriesServiceStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTimeSeriesServiceStatisticsInput, ...func(*xray.Options)) *xray.GetTimeSeriesServiceStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetTimeSeriesServiceStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetTimeSeriesServiceStatisticsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTraceGraph provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTraceGraph(ctx context.Context, params *xray.GetTraceGraphInput, optFns ...func(*xray.Options)) (*xray.GetTraceGraphOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTraceGraph")
	}

	var r0 *xray.GetTraceGraphOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTraceGraphInput, ...func(*xray.Options)) (*xray.GetTraceGraphOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTraceGraphInput, ...func(*xray.Options)) *xray.GetTraceGraphOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetTraceGraphOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetTraceGraphInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTraceSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTraceSummaries(ctx context.Context, params *xray.GetTraceSummariesInput, optFns ...func(*xray.Options)) (*xray.GetTraceSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTraceSummaries")
	}

	var r0 *xray.GetTraceSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTraceSummariesInput, ...func(*xray.Options)) (*xray.GetTraceSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.GetTraceSummariesInput, ...func(*xray.Options)) *xray.GetTraceSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.GetTraceSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.GetTraceSummariesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResourcePolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResourcePolicies(ctx context.Context, params *xray.ListResourcePoliciesInput, optFns ...func(*xray.Options)) (*xray.ListResourcePoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResourcePolicies")
	}

	var r0 *xray.ListResourcePoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.ListResourcePoliciesInput, ...func(*xray.Options)) (*xray.ListResourcePoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.ListResourcePoliciesInput, ...func(*xray.Options)) *xray.ListResourcePoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.ListResourcePoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.ListResourcePoliciesInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *xray.ListTagsForResourceInput, optFns ...func(*xray.Options)) (*xray.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *xray.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.ListTagsForResourceInput, ...func(*xray.Options)) (*xray.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.ListTagsForResourceInput, ...func(*xray.Options)) *xray.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.ListTagsForResourceInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() xray.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 xray.Options
	if rf, ok := ret.Get(0).(func() xray.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(xray.Options)
	}

	return r0
}

// PutEncryptionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutEncryptionConfig(ctx context.Context, params *xray.PutEncryptionConfigInput, optFns ...func(*xray.Options)) (*xray.PutEncryptionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEncryptionConfig")
	}

	var r0 *xray.PutEncryptionConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutEncryptionConfigInput, ...func(*xray.Options)) (*xray.PutEncryptionConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutEncryptionConfigInput, ...func(*xray.Options)) *xray.PutEncryptionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.PutEncryptionConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.PutEncryptionConfigInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *xray.PutResourcePolicyInput, optFns ...func(*xray.Options)) (*xray.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *xray.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutResourcePolicyInput, ...func(*xray.Options)) (*xray.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutResourcePolicyInput, ...func(*xray.Options)) *xray.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.PutResourcePolicyInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTelemetryRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTelemetryRecords(ctx context.Context, params *xray.PutTelemetryRecordsInput, optFns ...func(*xray.Options)) (*xray.PutTelemetryRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTelemetryRecords")
	}

	var r0 *xray.PutTelemetryRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutTelemetryRecordsInput, ...func(*xray.Options)) (*xray.PutTelemetryRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutTelemetryRecordsInput, ...func(*xray.Options)) *xray.PutTelemetryRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.PutTelemetryRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.PutTelemetryRecordsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTraceSegments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTraceSegments(ctx context.Context, params *xray.PutTraceSegmentsInput, optFns ...func(*xray.Options)) (*xray.PutTraceSegmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTraceSegments")
	}

	var r0 *xray.PutTraceSegmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutTraceSegmentsInput, ...func(*xray.Options)) (*xray.PutTraceSegmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.PutTraceSegmentsInput, ...func(*xray.Options)) *xray.PutTraceSegmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.PutTraceSegmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.PutTraceSegmentsInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *xray.TagResourceInput, optFns ...func(*xray.Options)) (*xray.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *xray.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.TagResourceInput, ...func(*xray.Options)) (*xray.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.TagResourceInput, ...func(*xray.Options)) *xray.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.TagResourceInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *xray.UntagResourceInput, optFns ...func(*xray.Options)) (*xray.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *xray.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UntagResourceInput, ...func(*xray.Options)) (*xray.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UntagResourceInput, ...func(*xray.Options)) *xray.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.UntagResourceInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGroup(ctx context.Context, params *xray.UpdateGroupInput, optFns ...func(*xray.Options)) (*xray.UpdateGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroup")
	}

	var r0 *xray.UpdateGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UpdateGroupInput, ...func(*xray.Options)) (*xray.UpdateGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UpdateGroupInput, ...func(*xray.Options)) *xray.UpdateGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.UpdateGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.UpdateGroupInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSamplingRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSamplingRule(ctx context.Context, params *xray.UpdateSamplingRuleInput, optFns ...func(*xray.Options)) (*xray.UpdateSamplingRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSamplingRule")
	}

	var r0 *xray.UpdateSamplingRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UpdateSamplingRuleInput, ...func(*xray.Options)) (*xray.UpdateSamplingRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *xray.UpdateSamplingRuleInput, ...func(*xray.Options)) *xray.UpdateSamplingRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*xray.UpdateSamplingRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *xray.UpdateSamplingRuleInput, ...func(*xray.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
