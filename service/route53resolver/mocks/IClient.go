// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	route53resolver "github.com/aws/aws-sdk-go-v2/service/route53resolver"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateFirewallRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateFirewallRuleGroup(ctx context.Context, params *route53resolver.AssociateFirewallRuleGroupInput, optFns ...func(*route53resolver.Options)) (*route53resolver.AssociateFirewallRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateFirewallRuleGroup")
	}

	var r0 *route53resolver.AssociateFirewallRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) (*route53resolver.AssociateFirewallRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) *route53resolver.AssociateFirewallRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.AssociateFirewallRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.AssociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateResolverEndpointIpAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateResolverEndpointIpAddress(ctx context.Context, params *route53resolver.AssociateResolverEndpointIpAddressInput, optFns ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverEndpointIpAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateResolverEndpointIpAddress")
	}

	var r0 *route53resolver.AssociateResolverEndpointIpAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverEndpointIpAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) *route53resolver.AssociateResolverEndpointIpAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.AssociateResolverEndpointIpAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.AssociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateResolverQueryLogConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateResolverQueryLogConfig(ctx context.Context, params *route53resolver.AssociateResolverQueryLogConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverQueryLogConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateResolverQueryLogConfig")
	}

	var r0 *route53resolver.AssociateResolverQueryLogConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverQueryLogConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) *route53resolver.AssociateResolverQueryLogConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.AssociateResolverQueryLogConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.AssociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateResolverRule(ctx context.Context, params *route53resolver.AssociateResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateResolverRule")
	}

	var r0 *route53resolver.AssociateResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.AssociateResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.AssociateResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.AssociateResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.AssociateResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.AssociateResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallDomainList(ctx context.Context, params *route53resolver.CreateFirewallDomainListInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallDomainList")
	}

	var r0 *route53resolver.CreateFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallDomainListInput, ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallDomainListInput, ...func(*route53resolver.Options)) *route53resolver.CreateFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateFirewallDomainListInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallRule(ctx context.Context, params *route53resolver.CreateFirewallRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallRule")
	}

	var r0 *route53resolver.CreateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallRuleInput, ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallRuleInput, ...func(*route53resolver.Options)) *route53resolver.CreateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateFirewallRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFirewallRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFirewallRuleGroup(ctx context.Context, params *route53resolver.CreateFirewallRuleGroupInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFirewallRuleGroup")
	}

	var r0 *route53resolver.CreateFirewallRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallRuleGroupInput, ...func(*route53resolver.Options)) (*route53resolver.CreateFirewallRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateFirewallRuleGroupInput, ...func(*route53resolver.Options)) *route53resolver.CreateFirewallRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateFirewallRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateFirewallRuleGroupInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOutpostResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateOutpostResolver(ctx context.Context, params *route53resolver.CreateOutpostResolverInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateOutpostResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateOutpostResolver")
	}

	var r0 *route53resolver.CreateOutpostResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateOutpostResolverInput, ...func(*route53resolver.Options)) (*route53resolver.CreateOutpostResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateOutpostResolverInput, ...func(*route53resolver.Options)) *route53resolver.CreateOutpostResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateOutpostResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateOutpostResolverInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResolverEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResolverEndpoint(ctx context.Context, params *route53resolver.CreateResolverEndpointInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateResolverEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResolverEndpoint")
	}

	var r0 *route53resolver.CreateResolverEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverEndpointInput, ...func(*route53resolver.Options)) (*route53resolver.CreateResolverEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverEndpointInput, ...func(*route53resolver.Options)) *route53resolver.CreateResolverEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateResolverEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateResolverEndpointInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResolverQueryLogConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResolverQueryLogConfig(ctx context.Context, params *route53resolver.CreateResolverQueryLogConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateResolverQueryLogConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResolverQueryLogConfig")
	}

	var r0 *route53resolver.CreateResolverQueryLogConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) (*route53resolver.CreateResolverQueryLogConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) *route53resolver.CreateResolverQueryLogConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateResolverQueryLogConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateResolverRule(ctx context.Context, params *route53resolver.CreateResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.CreateResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResolverRule")
	}

	var r0 *route53resolver.CreateResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.CreateResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.CreateResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.CreateResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.CreateResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.CreateResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallDomainList(ctx context.Context, params *route53resolver.DeleteFirewallDomainListInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallDomainList")
	}

	var r0 *route53resolver.DeleteFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallDomainListInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallDomainListInput, ...func(*route53resolver.Options)) *route53resolver.DeleteFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteFirewallDomainListInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallRule(ctx context.Context, params *route53resolver.DeleteFirewallRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallRule")
	}

	var r0 *route53resolver.DeleteFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallRuleInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallRuleInput, ...func(*route53resolver.Options)) *route53resolver.DeleteFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteFirewallRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallRuleGroup(ctx context.Context, params *route53resolver.DeleteFirewallRuleGroupInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallRuleGroup")
	}

	var r0 *route53resolver.DeleteFirewallRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallRuleGroupInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteFirewallRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteFirewallRuleGroupInput, ...func(*route53resolver.Options)) *route53resolver.DeleteFirewallRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteFirewallRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteFirewallRuleGroupInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutpostResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteOutpostResolver(ctx context.Context, params *route53resolver.DeleteOutpostResolverInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteOutpostResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutpostResolver")
	}

	var r0 *route53resolver.DeleteOutpostResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteOutpostResolverInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteOutpostResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteOutpostResolverInput, ...func(*route53resolver.Options)) *route53resolver.DeleteOutpostResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteOutpostResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteOutpostResolverInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResolverEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResolverEndpoint(ctx context.Context, params *route53resolver.DeleteResolverEndpointInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResolverEndpoint")
	}

	var r0 *route53resolver.DeleteResolverEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverEndpointInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverEndpointInput, ...func(*route53resolver.Options)) *route53resolver.DeleteResolverEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteResolverEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteResolverEndpointInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResolverQueryLogConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResolverQueryLogConfig(ctx context.Context, params *route53resolver.DeleteResolverQueryLogConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverQueryLogConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResolverQueryLogConfig")
	}

	var r0 *route53resolver.DeleteResolverQueryLogConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverQueryLogConfigInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverQueryLogConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverQueryLogConfigInput, ...func(*route53resolver.Options)) *route53resolver.DeleteResolverQueryLogConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteResolverQueryLogConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteResolverQueryLogConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResolverRule(ctx context.Context, params *route53resolver.DeleteResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResolverRule")
	}

	var r0 *route53resolver.DeleteResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.DeleteResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DeleteResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.DeleteResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DeleteResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DeleteResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateFirewallRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateFirewallRuleGroup(ctx context.Context, params *route53resolver.DisassociateFirewallRuleGroupInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DisassociateFirewallRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateFirewallRuleGroup")
	}

	var r0 *route53resolver.DisassociateFirewallRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) (*route53resolver.DisassociateFirewallRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) *route53resolver.DisassociateFirewallRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DisassociateFirewallRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DisassociateFirewallRuleGroupInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateResolverEndpointIpAddress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateResolverEndpointIpAddress(ctx context.Context, params *route53resolver.DisassociateResolverEndpointIpAddressInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverEndpointIpAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateResolverEndpointIpAddress")
	}

	var r0 *route53resolver.DisassociateResolverEndpointIpAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverEndpointIpAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) *route53resolver.DisassociateResolverEndpointIpAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DisassociateResolverEndpointIpAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DisassociateResolverEndpointIpAddressInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateResolverQueryLogConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateResolverQueryLogConfig(ctx context.Context, params *route53resolver.DisassociateResolverQueryLogConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverQueryLogConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateResolverQueryLogConfig")
	}

	var r0 *route53resolver.DisassociateResolverQueryLogConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverQueryLogConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) *route53resolver.DisassociateResolverQueryLogConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DisassociateResolverQueryLogConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DisassociateResolverQueryLogConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateResolverRule(ctx context.Context, params *route53resolver.DisassociateResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateResolverRule")
	}

	var r0 *route53resolver.DisassociateResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.DisassociateResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.DisassociateResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.DisassociateResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.DisassociateResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.DisassociateResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallConfig(ctx context.Context, params *route53resolver.GetFirewallConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetFirewallConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallConfig")
	}

	var r0 *route53resolver.GetFirewallConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallConfigInput, ...func(*route53resolver.Options)) (*route53resolver.GetFirewallConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallConfigInput, ...func(*route53resolver.Options)) *route53resolver.GetFirewallConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetFirewallConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetFirewallConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallDomainList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallDomainList(ctx context.Context, params *route53resolver.GetFirewallDomainListInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetFirewallDomainListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallDomainList")
	}

	var r0 *route53resolver.GetFirewallDomainListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallDomainListInput, ...func(*route53resolver.Options)) (*route53resolver.GetFirewallDomainListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallDomainListInput, ...func(*route53resolver.Options)) *route53resolver.GetFirewallDomainListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetFirewallDomainListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetFirewallDomainListInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallRuleGroup(ctx context.Context, params *route53resolver.GetFirewallRuleGroupInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallRuleGroup")
	}

	var r0 *route53resolver.GetFirewallRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupInput, ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupInput, ...func(*route53resolver.Options)) *route53resolver.GetFirewallRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetFirewallRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetFirewallRuleGroupInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallRuleGroupAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallRuleGroupAssociation(ctx context.Context, params *route53resolver.GetFirewallRuleGroupAssociationInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallRuleGroupAssociation")
	}

	var r0 *route53resolver.GetFirewallRuleGroupAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) *route53resolver.GetFirewallRuleGroupAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetFirewallRuleGroupAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirewallRuleGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFirewallRuleGroupPolicy(ctx context.Context, params *route53resolver.GetFirewallRuleGroupPolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallRuleGroupPolicy")
	}

	var r0 *route53resolver.GetFirewallRuleGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) (*route53resolver.GetFirewallRuleGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) *route53resolver.GetFirewallRuleGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetFirewallRuleGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutpostResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetOutpostResolver(ctx context.Context, params *route53resolver.GetOutpostResolverInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetOutpostResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOutpostResolver")
	}

	var r0 *route53resolver.GetOutpostResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetOutpostResolverInput, ...func(*route53resolver.Options)) (*route53resolver.GetOutpostResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetOutpostResolverInput, ...func(*route53resolver.Options)) *route53resolver.GetOutpostResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetOutpostResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetOutpostResolverInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverConfig(ctx context.Context, params *route53resolver.GetResolverConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverConfig")
	}

	var r0 *route53resolver.GetResolverConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverConfigInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverConfigInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverDnssecConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverDnssecConfig(ctx context.Context, params *route53resolver.GetResolverDnssecConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverDnssecConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverDnssecConfig")
	}

	var r0 *route53resolver.GetResolverDnssecConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverDnssecConfigInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverDnssecConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverDnssecConfigInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverDnssecConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverDnssecConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverDnssecConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverEndpoint(ctx context.Context, params *route53resolver.GetResolverEndpointInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverEndpoint")
	}

	var r0 *route53resolver.GetResolverEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverEndpointInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverEndpointInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverEndpointInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverQueryLogConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverQueryLogConfig(ctx context.Context, params *route53resolver.GetResolverQueryLogConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverQueryLogConfig")
	}

	var r0 *route53resolver.GetResolverQueryLogConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverQueryLogConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverQueryLogConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverQueryLogConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverQueryLogConfigAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverQueryLogConfigAssociation(ctx context.Context, params *route53resolver.GetResolverQueryLogConfigAssociationInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverQueryLogConfigAssociation")
	}

	var r0 *route53resolver.GetResolverQueryLogConfigAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigAssociationInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigAssociationInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverQueryLogConfigAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverQueryLogConfigAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverQueryLogConfigAssociationInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverQueryLogConfigPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverQueryLogConfigPolicy(ctx context.Context, params *route53resolver.GetResolverQueryLogConfigPolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverQueryLogConfigPolicy")
	}

	var r0 *route53resolver.GetResolverQueryLogConfigPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverQueryLogConfigPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverQueryLogConfigPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverQueryLogConfigPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverRule(ctx context.Context, params *route53resolver.GetResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverRule")
	}

	var r0 *route53resolver.GetResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverRuleAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverRuleAssociation(ctx context.Context, params *route53resolver.GetResolverRuleAssociationInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverRuleAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverRuleAssociation")
	}

	var r0 *route53resolver.GetResolverRuleAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRuleAssociationInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverRuleAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRuleAssociationInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverRuleAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverRuleAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverRuleAssociationInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResolverRulePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResolverRulePolicy(ctx context.Context, params *route53resolver.GetResolverRulePolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.GetResolverRulePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResolverRulePolicy")
	}

	var r0 *route53resolver.GetResolverRulePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRulePolicyInput, ...func(*route53resolver.Options)) (*route53resolver.GetResolverRulePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.GetResolverRulePolicyInput, ...func(*route53resolver.Options)) *route53resolver.GetResolverRulePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.GetResolverRulePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.GetResolverRulePolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportFirewallDomains(ctx context.Context, params *route53resolver.ImportFirewallDomainsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ImportFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportFirewallDomains")
	}

	var r0 *route53resolver.ImportFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ImportFirewallDomainsInput, ...func(*route53resolver.Options)) (*route53resolver.ImportFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ImportFirewallDomainsInput, ...func(*route53resolver.Options)) *route53resolver.ImportFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ImportFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ImportFirewallDomainsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallConfigs(ctx context.Context, params *route53resolver.ListFirewallConfigsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallConfigs")
	}

	var r0 *route53resolver.ListFirewallConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallConfigsInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallConfigsInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallConfigsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallDomainLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallDomainLists(ctx context.Context, params *route53resolver.ListFirewallDomainListsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallDomainListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallDomainLists")
	}

	var r0 *route53resolver.ListFirewallDomainListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallDomainListsInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallDomainListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallDomainListsInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallDomainListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallDomainListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallDomainListsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallDomains(ctx context.Context, params *route53resolver.ListFirewallDomainsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallDomains")
	}

	var r0 *route53resolver.ListFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallDomainsInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallDomainsInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallDomainsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallRuleGroupAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallRuleGroupAssociations(ctx context.Context, params *route53resolver.ListFirewallRuleGroupAssociationsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRuleGroupAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallRuleGroupAssociations")
	}

	var r0 *route53resolver.ListFirewallRuleGroupAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRuleGroupAssociationsInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRuleGroupAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRuleGroupAssociationsInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallRuleGroupAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallRuleGroupAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallRuleGroupAssociationsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallRuleGroups(ctx context.Context, params *route53resolver.ListFirewallRuleGroupsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallRuleGroups")
	}

	var r0 *route53resolver.ListFirewallRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRuleGroupsInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRuleGroupsInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallRuleGroupsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewallRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFirewallRules(ctx context.Context, params *route53resolver.ListFirewallRulesInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFirewallRules")
	}

	var r0 *route53resolver.ListFirewallRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRulesInput, ...func(*route53resolver.Options)) (*route53resolver.ListFirewallRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListFirewallRulesInput, ...func(*route53resolver.Options)) *route53resolver.ListFirewallRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListFirewallRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListFirewallRulesInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOutpostResolvers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListOutpostResolvers(ctx context.Context, params *route53resolver.ListOutpostResolversInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListOutpostResolversOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListOutpostResolvers")
	}

	var r0 *route53resolver.ListOutpostResolversOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListOutpostResolversInput, ...func(*route53resolver.Options)) (*route53resolver.ListOutpostResolversOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListOutpostResolversInput, ...func(*route53resolver.Options)) *route53resolver.ListOutpostResolversOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListOutpostResolversOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListOutpostResolversInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverConfigs(ctx context.Context, params *route53resolver.ListResolverConfigsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverConfigs")
	}

	var r0 *route53resolver.ListResolverConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverConfigsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverConfigsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverConfigsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverDnssecConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverDnssecConfigs(ctx context.Context, params *route53resolver.ListResolverDnssecConfigsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverDnssecConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverDnssecConfigs")
	}

	var r0 *route53resolver.ListResolverDnssecConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverDnssecConfigsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverDnssecConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverDnssecConfigsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverDnssecConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverDnssecConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverDnssecConfigsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverEndpointIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverEndpointIpAddresses(ctx context.Context, params *route53resolver.ListResolverEndpointIpAddressesInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverEndpointIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverEndpointIpAddresses")
	}

	var r0 *route53resolver.ListResolverEndpointIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverEndpointIpAddressesInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverEndpointIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverEndpointIpAddressesInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverEndpointIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverEndpointIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverEndpointIpAddressesInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverEndpoints(ctx context.Context, params *route53resolver.ListResolverEndpointsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverEndpoints")
	}

	var r0 *route53resolver.ListResolverEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverEndpointsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverEndpointsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverEndpointsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverQueryLogConfigAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverQueryLogConfigAssociations(ctx context.Context, params *route53resolver.ListResolverQueryLogConfigAssociationsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverQueryLogConfigAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverQueryLogConfigAssociations")
	}

	var r0 *route53resolver.ListResolverQueryLogConfigAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverQueryLogConfigAssociationsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverQueryLogConfigAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverQueryLogConfigAssociationsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverQueryLogConfigAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverQueryLogConfigAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverQueryLogConfigAssociationsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverQueryLogConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverQueryLogConfigs(ctx context.Context, params *route53resolver.ListResolverQueryLogConfigsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverQueryLogConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverQueryLogConfigs")
	}

	var r0 *route53resolver.ListResolverQueryLogConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverQueryLogConfigsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverQueryLogConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverQueryLogConfigsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverQueryLogConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverQueryLogConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverQueryLogConfigsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverRuleAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverRuleAssociations(ctx context.Context, params *route53resolver.ListResolverRuleAssociationsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverRuleAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverRuleAssociations")
	}

	var r0 *route53resolver.ListResolverRuleAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverRuleAssociationsInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverRuleAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverRuleAssociationsInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverRuleAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverRuleAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverRuleAssociationsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResolverRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResolverRules(ctx context.Context, params *route53resolver.ListResolverRulesInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListResolverRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResolverRules")
	}

	var r0 *route53resolver.ListResolverRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverRulesInput, ...func(*route53resolver.Options)) (*route53resolver.ListResolverRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListResolverRulesInput, ...func(*route53resolver.Options)) *route53resolver.ListResolverRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListResolverRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListResolverRulesInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *route53resolver.ListTagsForResourceInput, optFns ...func(*route53resolver.Options)) (*route53resolver.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *route53resolver.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListTagsForResourceInput, ...func(*route53resolver.Options)) (*route53resolver.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.ListTagsForResourceInput, ...func(*route53resolver.Options)) *route53resolver.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.ListTagsForResourceInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() route53resolver.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 route53resolver.Options
	if rf, ok := ret.Get(0).(func() route53resolver.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(route53resolver.Options)
	}

	return r0
}

// PutFirewallRuleGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFirewallRuleGroupPolicy(ctx context.Context, params *route53resolver.PutFirewallRuleGroupPolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.PutFirewallRuleGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFirewallRuleGroupPolicy")
	}

	var r0 *route53resolver.PutFirewallRuleGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) (*route53resolver.PutFirewallRuleGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) *route53resolver.PutFirewallRuleGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.PutFirewallRuleGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.PutFirewallRuleGroupPolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResolverQueryLogConfigPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResolverQueryLogConfigPolicy(ctx context.Context, params *route53resolver.PutResolverQueryLogConfigPolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.PutResolverQueryLogConfigPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResolverQueryLogConfigPolicy")
	}

	var r0 *route53resolver.PutResolverQueryLogConfigPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) (*route53resolver.PutResolverQueryLogConfigPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) *route53resolver.PutResolverQueryLogConfigPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.PutResolverQueryLogConfigPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.PutResolverQueryLogConfigPolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResolverRulePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResolverRulePolicy(ctx context.Context, params *route53resolver.PutResolverRulePolicyInput, optFns ...func(*route53resolver.Options)) (*route53resolver.PutResolverRulePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResolverRulePolicy")
	}

	var r0 *route53resolver.PutResolverRulePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutResolverRulePolicyInput, ...func(*route53resolver.Options)) (*route53resolver.PutResolverRulePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.PutResolverRulePolicyInput, ...func(*route53resolver.Options)) *route53resolver.PutResolverRulePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.PutResolverRulePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.PutResolverRulePolicyInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *route53resolver.TagResourceInput, optFns ...func(*route53resolver.Options)) (*route53resolver.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *route53resolver.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.TagResourceInput, ...func(*route53resolver.Options)) (*route53resolver.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.TagResourceInput, ...func(*route53resolver.Options)) *route53resolver.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.TagResourceInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *route53resolver.UntagResourceInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *route53resolver.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UntagResourceInput, ...func(*route53resolver.Options)) (*route53resolver.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UntagResourceInput, ...func(*route53resolver.Options)) *route53resolver.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UntagResourceInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallConfig(ctx context.Context, params *route53resolver.UpdateFirewallConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallConfig")
	}

	var r0 *route53resolver.UpdateFirewallConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallConfigInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallConfigInput, ...func(*route53resolver.Options)) *route53resolver.UpdateFirewallConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateFirewallConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateFirewallConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallDomains(ctx context.Context, params *route53resolver.UpdateFirewallDomainsInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallDomains")
	}

	var r0 *route53resolver.UpdateFirewallDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallDomainsInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallDomainsInput, ...func(*route53resolver.Options)) *route53resolver.UpdateFirewallDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateFirewallDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateFirewallDomainsInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallRule(ctx context.Context, params *route53resolver.UpdateFirewallRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallRule")
	}

	var r0 *route53resolver.UpdateFirewallRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallRuleInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallRuleInput, ...func(*route53resolver.Options)) *route53resolver.UpdateFirewallRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateFirewallRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateFirewallRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirewallRuleGroupAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFirewallRuleGroupAssociation(ctx context.Context, params *route53resolver.UpdateFirewallRuleGroupAssociationInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallRuleGroupAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallRuleGroupAssociation")
	}

	var r0 *route53resolver.UpdateFirewallRuleGroupAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateFirewallRuleGroupAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) *route53resolver.UpdateFirewallRuleGroupAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateFirewallRuleGroupAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateFirewallRuleGroupAssociationInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOutpostResolver provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateOutpostResolver(ctx context.Context, params *route53resolver.UpdateOutpostResolverInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateOutpostResolverOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOutpostResolver")
	}

	var r0 *route53resolver.UpdateOutpostResolverOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateOutpostResolverInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateOutpostResolverOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateOutpostResolverInput, ...func(*route53resolver.Options)) *route53resolver.UpdateOutpostResolverOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateOutpostResolverOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateOutpostResolverInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResolverConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResolverConfig(ctx context.Context, params *route53resolver.UpdateResolverConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResolverConfig")
	}

	var r0 *route53resolver.UpdateResolverConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverConfigInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverConfigInput, ...func(*route53resolver.Options)) *route53resolver.UpdateResolverConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateResolverConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateResolverConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResolverDnssecConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResolverDnssecConfig(ctx context.Context, params *route53resolver.UpdateResolverDnssecConfigInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverDnssecConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResolverDnssecConfig")
	}

	var r0 *route53resolver.UpdateResolverDnssecConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverDnssecConfigInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverDnssecConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverDnssecConfigInput, ...func(*route53resolver.Options)) *route53resolver.UpdateResolverDnssecConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateResolverDnssecConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateResolverDnssecConfigInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResolverEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResolverEndpoint(ctx context.Context, params *route53resolver.UpdateResolverEndpointInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResolverEndpoint")
	}

	var r0 *route53resolver.UpdateResolverEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverEndpointInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverEndpointInput, ...func(*route53resolver.Options)) *route53resolver.UpdateResolverEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateResolverEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateResolverEndpointInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResolverRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResolverRule(ctx context.Context, params *route53resolver.UpdateResolverRuleInput, optFns ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResolverRule")
	}

	var r0 *route53resolver.UpdateResolverRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverRuleInput, ...func(*route53resolver.Options)) (*route53resolver.UpdateResolverRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *route53resolver.UpdateResolverRuleInput, ...func(*route53resolver.Options)) *route53resolver.UpdateResolverRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*route53resolver.UpdateResolverRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *route53resolver.UpdateResolverRuleInput, ...func(*route53resolver.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
