// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	dax "github.com/aws/aws-sdk-go-v2/service/dax"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCluster(ctx context.Context, params *dax.CreateClusterInput, optFns ...func(*dax.Options)) (*dax.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *dax.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateClusterInput, ...func(*dax.Options)) (*dax.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateClusterInput, ...func(*dax.Options)) *dax.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.CreateClusterInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateParameterGroup(ctx context.Context, params *dax.CreateParameterGroupInput, optFns ...func(*dax.Options)) (*dax.CreateParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterGroup")
	}

	var r0 *dax.CreateParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateParameterGroupInput, ...func(*dax.Options)) (*dax.CreateParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateParameterGroupInput, ...func(*dax.Options)) *dax.CreateParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.CreateParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.CreateParameterGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSubnetGroup(ctx context.Context, params *dax.CreateSubnetGroupInput, optFns ...func(*dax.Options)) (*dax.CreateSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnetGroup")
	}

	var r0 *dax.CreateSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateSubnetGroupInput, ...func(*dax.Options)) (*dax.CreateSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.CreateSubnetGroupInput, ...func(*dax.Options)) *dax.CreateSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.CreateSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.CreateSubnetGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecreaseReplicationFactor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DecreaseReplicationFactor(ctx context.Context, params *dax.DecreaseReplicationFactorInput, optFns ...func(*dax.Options)) (*dax.DecreaseReplicationFactorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DecreaseReplicationFactor")
	}

	var r0 *dax.DecreaseReplicationFactorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DecreaseReplicationFactorInput, ...func(*dax.Options)) (*dax.DecreaseReplicationFactorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DecreaseReplicationFactorInput, ...func(*dax.Options)) *dax.DecreaseReplicationFactorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DecreaseReplicationFactorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DecreaseReplicationFactorInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCluster(ctx context.Context, params *dax.DeleteClusterInput, optFns ...func(*dax.Options)) (*dax.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 *dax.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteClusterInput, ...func(*dax.Options)) (*dax.DeleteClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteClusterInput, ...func(*dax.Options)) *dax.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DeleteClusterInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteParameterGroup(ctx context.Context, params *dax.DeleteParameterGroupInput, optFns ...func(*dax.Options)) (*dax.DeleteParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteParameterGroup")
	}

	var r0 *dax.DeleteParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteParameterGroupInput, ...func(*dax.Options)) (*dax.DeleteParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteParameterGroupInput, ...func(*dax.Options)) *dax.DeleteParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DeleteParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DeleteParameterGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSubnetGroup(ctx context.Context, params *dax.DeleteSubnetGroupInput, optFns ...func(*dax.Options)) (*dax.DeleteSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnetGroup")
	}

	var r0 *dax.DeleteSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteSubnetGroupInput, ...func(*dax.Options)) (*dax.DeleteSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DeleteSubnetGroupInput, ...func(*dax.Options)) *dax.DeleteSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DeleteSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DeleteSubnetGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusters(ctx context.Context, params *dax.DescribeClustersInput, optFns ...func(*dax.Options)) (*dax.DescribeClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusters")
	}

	var r0 *dax.DescribeClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeClustersInput, ...func(*dax.Options)) (*dax.DescribeClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeClustersInput, ...func(*dax.Options)) *dax.DescribeClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeClustersInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDefaultParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDefaultParameters(ctx context.Context, params *dax.DescribeDefaultParametersInput, optFns ...func(*dax.Options)) (*dax.DescribeDefaultParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDefaultParameters")
	}

	var r0 *dax.DescribeDefaultParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeDefaultParametersInput, ...func(*dax.Options)) (*dax.DescribeDefaultParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeDefaultParametersInput, ...func(*dax.Options)) *dax.DescribeDefaultParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeDefaultParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeDefaultParametersInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEvents(ctx context.Context, params *dax.DescribeEventsInput, optFns ...func(*dax.Options)) (*dax.DescribeEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEvents")
	}

	var r0 *dax.DescribeEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeEventsInput, ...func(*dax.Options)) (*dax.DescribeEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeEventsInput, ...func(*dax.Options)) *dax.DescribeEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeEventsInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeParameterGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeParameterGroups(ctx context.Context, params *dax.DescribeParameterGroupsInput, optFns ...func(*dax.Options)) (*dax.DescribeParameterGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeParameterGroups")
	}

	var r0 *dax.DescribeParameterGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeParameterGroupsInput, ...func(*dax.Options)) (*dax.DescribeParameterGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeParameterGroupsInput, ...func(*dax.Options)) *dax.DescribeParameterGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeParameterGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeParameterGroupsInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeParameters(ctx context.Context, params *dax.DescribeParametersInput, optFns ...func(*dax.Options)) (*dax.DescribeParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeParameters")
	}

	var r0 *dax.DescribeParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeParametersInput, ...func(*dax.Options)) (*dax.DescribeParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeParametersInput, ...func(*dax.Options)) *dax.DescribeParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeParametersInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSubnetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSubnetGroups(ctx context.Context, params *dax.DescribeSubnetGroupsInput, optFns ...func(*dax.Options)) (*dax.DescribeSubnetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSubnetGroups")
	}

	var r0 *dax.DescribeSubnetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeSubnetGroupsInput, ...func(*dax.Options)) (*dax.DescribeSubnetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.DescribeSubnetGroupsInput, ...func(*dax.Options)) *dax.DescribeSubnetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.DescribeSubnetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.DescribeSubnetGroupsInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseReplicationFactor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) IncreaseReplicationFactor(ctx context.Context, params *dax.IncreaseReplicationFactorInput, optFns ...func(*dax.Options)) (*dax.IncreaseReplicationFactorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IncreaseReplicationFactor")
	}

	var r0 *dax.IncreaseReplicationFactorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.IncreaseReplicationFactorInput, ...func(*dax.Options)) (*dax.IncreaseReplicationFactorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.IncreaseReplicationFactorInput, ...func(*dax.Options)) *dax.IncreaseReplicationFactorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.IncreaseReplicationFactorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.IncreaseReplicationFactorInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *dax.ListTagsInput, optFns ...func(*dax.Options)) (*dax.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *dax.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.ListTagsInput, ...func(*dax.Options)) (*dax.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.ListTagsInput, ...func(*dax.Options)) *dax.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.ListTagsInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() dax.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 dax.Options
	if rf, ok := ret.Get(0).(func() dax.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(dax.Options)
	}

	return r0
}

// RebootNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootNode(ctx context.Context, params *dax.RebootNodeInput, optFns ...func(*dax.Options)) (*dax.RebootNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootNode")
	}

	var r0 *dax.RebootNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.RebootNodeInput, ...func(*dax.Options)) (*dax.RebootNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.RebootNodeInput, ...func(*dax.Options)) *dax.RebootNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.RebootNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.RebootNodeInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *dax.TagResourceInput, optFns ...func(*dax.Options)) (*dax.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *dax.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.TagResourceInput, ...func(*dax.Options)) (*dax.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.TagResourceInput, ...func(*dax.Options)) *dax.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.TagResourceInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *dax.UntagResourceInput, optFns ...func(*dax.Options)) (*dax.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *dax.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UntagResourceInput, ...func(*dax.Options)) (*dax.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UntagResourceInput, ...func(*dax.Options)) *dax.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.UntagResourceInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCluster(ctx context.Context, params *dax.UpdateClusterInput, optFns ...func(*dax.Options)) (*dax.UpdateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCluster")
	}

	var r0 *dax.UpdateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateClusterInput, ...func(*dax.Options)) (*dax.UpdateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateClusterInput, ...func(*dax.Options)) *dax.UpdateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.UpdateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.UpdateClusterInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateParameterGroup(ctx context.Context, params *dax.UpdateParameterGroupInput, optFns ...func(*dax.Options)) (*dax.UpdateParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParameterGroup")
	}

	var r0 *dax.UpdateParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateParameterGroupInput, ...func(*dax.Options)) (*dax.UpdateParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateParameterGroupInput, ...func(*dax.Options)) *dax.UpdateParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.UpdateParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.UpdateParameterGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSubnetGroup(ctx context.Context, params *dax.UpdateSubnetGroupInput, optFns ...func(*dax.Options)) (*dax.UpdateSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubnetGroup")
	}

	var r0 *dax.UpdateSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateSubnetGroupInput, ...func(*dax.Options)) (*dax.UpdateSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dax.UpdateSubnetGroupInput, ...func(*dax.Options)) *dax.UpdateSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dax.UpdateSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dax.UpdateSubnetGroupInput, ...func(*dax.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
