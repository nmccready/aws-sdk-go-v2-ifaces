// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	kms "github.com/aws/aws-sdk-go-v2/service/kms"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CancelKeyDeletion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelKeyDeletion(ctx context.Context, params *kms.CancelKeyDeletionInput, optFns ...func(*kms.Options)) (*kms.CancelKeyDeletionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelKeyDeletion")
	}

	var r0 *kms.CancelKeyDeletionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CancelKeyDeletionInput, ...func(*kms.Options)) (*kms.CancelKeyDeletionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CancelKeyDeletionInput, ...func(*kms.Options)) *kms.CancelKeyDeletionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.CancelKeyDeletionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.CancelKeyDeletionInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectCustomKeyStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ConnectCustomKeyStore(ctx context.Context, params *kms.ConnectCustomKeyStoreInput, optFns ...func(*kms.Options)) (*kms.ConnectCustomKeyStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConnectCustomKeyStore")
	}

	var r0 *kms.ConnectCustomKeyStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ConnectCustomKeyStoreInput, ...func(*kms.Options)) (*kms.ConnectCustomKeyStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ConnectCustomKeyStoreInput, ...func(*kms.Options)) *kms.ConnectCustomKeyStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ConnectCustomKeyStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ConnectCustomKeyStoreInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAlias(ctx context.Context, params *kms.CreateAliasInput, optFns ...func(*kms.Options)) (*kms.CreateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 *kms.CreateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateAliasInput, ...func(*kms.Options)) (*kms.CreateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateAliasInput, ...func(*kms.Options)) *kms.CreateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.CreateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.CreateAliasInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomKeyStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomKeyStore(ctx context.Context, params *kms.CreateCustomKeyStoreInput, optFns ...func(*kms.Options)) (*kms.CreateCustomKeyStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomKeyStore")
	}

	var r0 *kms.CreateCustomKeyStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateCustomKeyStoreInput, ...func(*kms.Options)) (*kms.CreateCustomKeyStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateCustomKeyStoreInput, ...func(*kms.Options)) *kms.CreateCustomKeyStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.CreateCustomKeyStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.CreateCustomKeyStoreInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGrant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGrant(ctx context.Context, params *kms.CreateGrantInput, optFns ...func(*kms.Options)) (*kms.CreateGrantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGrant")
	}

	var r0 *kms.CreateGrantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateGrantInput, ...func(*kms.Options)) (*kms.CreateGrantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateGrantInput, ...func(*kms.Options)) *kms.CreateGrantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.CreateGrantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.CreateGrantInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateKey(ctx context.Context, params *kms.CreateKeyInput, optFns ...func(*kms.Options)) (*kms.CreateKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKey")
	}

	var r0 *kms.CreateKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateKeyInput, ...func(*kms.Options)) (*kms.CreateKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.CreateKeyInput, ...func(*kms.Options)) *kms.CreateKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.CreateKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.CreateKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Decrypt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Decrypt(ctx context.Context, params *kms.DecryptInput, optFns ...func(*kms.Options)) (*kms.DecryptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Decrypt")
	}

	var r0 *kms.DecryptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DecryptInput, ...func(*kms.Options)) (*kms.DecryptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DecryptInput, ...func(*kms.Options)) *kms.DecryptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DecryptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DecryptInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAlias(ctx context.Context, params *kms.DeleteAliasInput, optFns ...func(*kms.Options)) (*kms.DeleteAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAlias")
	}

	var r0 *kms.DeleteAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteAliasInput, ...func(*kms.Options)) (*kms.DeleteAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteAliasInput, ...func(*kms.Options)) *kms.DeleteAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DeleteAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DeleteAliasInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomKeyStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomKeyStore(ctx context.Context, params *kms.DeleteCustomKeyStoreInput, optFns ...func(*kms.Options)) (*kms.DeleteCustomKeyStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomKeyStore")
	}

	var r0 *kms.DeleteCustomKeyStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteCustomKeyStoreInput, ...func(*kms.Options)) (*kms.DeleteCustomKeyStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteCustomKeyStoreInput, ...func(*kms.Options)) *kms.DeleteCustomKeyStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DeleteCustomKeyStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DeleteCustomKeyStoreInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImportedKeyMaterial provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteImportedKeyMaterial(ctx context.Context, params *kms.DeleteImportedKeyMaterialInput, optFns ...func(*kms.Options)) (*kms.DeleteImportedKeyMaterialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteImportedKeyMaterial")
	}

	var r0 *kms.DeleteImportedKeyMaterialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteImportedKeyMaterialInput, ...func(*kms.Options)) (*kms.DeleteImportedKeyMaterialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeleteImportedKeyMaterialInput, ...func(*kms.Options)) *kms.DeleteImportedKeyMaterialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DeleteImportedKeyMaterialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DeleteImportedKeyMaterialInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeriveSharedSecret provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeriveSharedSecret(ctx context.Context, params *kms.DeriveSharedSecretInput, optFns ...func(*kms.Options)) (*kms.DeriveSharedSecretOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeriveSharedSecret")
	}

	var r0 *kms.DeriveSharedSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeriveSharedSecretInput, ...func(*kms.Options)) (*kms.DeriveSharedSecretOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DeriveSharedSecretInput, ...func(*kms.Options)) *kms.DeriveSharedSecretOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DeriveSharedSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DeriveSharedSecretInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomKeyStores provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomKeyStores(ctx context.Context, params *kms.DescribeCustomKeyStoresInput, optFns ...func(*kms.Options)) (*kms.DescribeCustomKeyStoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomKeyStores")
	}

	var r0 *kms.DescribeCustomKeyStoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DescribeCustomKeyStoresInput, ...func(*kms.Options)) (*kms.DescribeCustomKeyStoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DescribeCustomKeyStoresInput, ...func(*kms.Options)) *kms.DescribeCustomKeyStoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DescribeCustomKeyStoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DescribeCustomKeyStoresInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeKey(ctx context.Context, params *kms.DescribeKeyInput, optFns ...func(*kms.Options)) (*kms.DescribeKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeKey")
	}

	var r0 *kms.DescribeKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DescribeKeyInput, ...func(*kms.Options)) (*kms.DescribeKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DescribeKeyInput, ...func(*kms.Options)) *kms.DescribeKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DescribeKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DescribeKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableKey(ctx context.Context, params *kms.DisableKeyInput, optFns ...func(*kms.Options)) (*kms.DisableKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableKey")
	}

	var r0 *kms.DisableKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisableKeyInput, ...func(*kms.Options)) (*kms.DisableKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisableKeyInput, ...func(*kms.Options)) *kms.DisableKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DisableKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DisableKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableKeyRotation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableKeyRotation(ctx context.Context, params *kms.DisableKeyRotationInput, optFns ...func(*kms.Options)) (*kms.DisableKeyRotationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableKeyRotation")
	}

	var r0 *kms.DisableKeyRotationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisableKeyRotationInput, ...func(*kms.Options)) (*kms.DisableKeyRotationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisableKeyRotationInput, ...func(*kms.Options)) *kms.DisableKeyRotationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DisableKeyRotationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DisableKeyRotationInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisconnectCustomKeyStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisconnectCustomKeyStore(ctx context.Context, params *kms.DisconnectCustomKeyStoreInput, optFns ...func(*kms.Options)) (*kms.DisconnectCustomKeyStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectCustomKeyStore")
	}

	var r0 *kms.DisconnectCustomKeyStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisconnectCustomKeyStoreInput, ...func(*kms.Options)) (*kms.DisconnectCustomKeyStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.DisconnectCustomKeyStoreInput, ...func(*kms.Options)) *kms.DisconnectCustomKeyStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.DisconnectCustomKeyStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.DisconnectCustomKeyStoreInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableKey(ctx context.Context, params *kms.EnableKeyInput, optFns ...func(*kms.Options)) (*kms.EnableKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableKey")
	}

	var r0 *kms.EnableKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EnableKeyInput, ...func(*kms.Options)) (*kms.EnableKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EnableKeyInput, ...func(*kms.Options)) *kms.EnableKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.EnableKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.EnableKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableKeyRotation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableKeyRotation(ctx context.Context, params *kms.EnableKeyRotationInput, optFns ...func(*kms.Options)) (*kms.EnableKeyRotationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableKeyRotation")
	}

	var r0 *kms.EnableKeyRotationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EnableKeyRotationInput, ...func(*kms.Options)) (*kms.EnableKeyRotationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EnableKeyRotationInput, ...func(*kms.Options)) *kms.EnableKeyRotationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.EnableKeyRotationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.EnableKeyRotationInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Encrypt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Encrypt(ctx context.Context, params *kms.EncryptInput, optFns ...func(*kms.Options)) (*kms.EncryptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Encrypt")
	}

	var r0 *kms.EncryptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EncryptInput, ...func(*kms.Options)) (*kms.EncryptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.EncryptInput, ...func(*kms.Options)) *kms.EncryptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.EncryptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.EncryptInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateDataKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateDataKey(ctx context.Context, params *kms.GenerateDataKeyInput, optFns ...func(*kms.Options)) (*kms.GenerateDataKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateDataKey")
	}

	var r0 *kms.GenerateDataKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyInput, ...func(*kms.Options)) (*kms.GenerateDataKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyInput, ...func(*kms.Options)) *kms.GenerateDataKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateDataKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateDataKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateDataKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateDataKeyPair(ctx context.Context, params *kms.GenerateDataKeyPairInput, optFns ...func(*kms.Options)) (*kms.GenerateDataKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateDataKeyPair")
	}

	var r0 *kms.GenerateDataKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyPairInput, ...func(*kms.Options)) (*kms.GenerateDataKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyPairInput, ...func(*kms.Options)) *kms.GenerateDataKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateDataKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateDataKeyPairInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateDataKeyPairWithoutPlaintext provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateDataKeyPairWithoutPlaintext(ctx context.Context, params *kms.GenerateDataKeyPairWithoutPlaintextInput, optFns ...func(*kms.Options)) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateDataKeyPairWithoutPlaintext")
	}

	var r0 *kms.GenerateDataKeyPairWithoutPlaintextOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, ...func(*kms.Options)) (*kms.GenerateDataKeyPairWithoutPlaintextOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, ...func(*kms.Options)) *kms.GenerateDataKeyPairWithoutPlaintextOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateDataKeyPairWithoutPlaintextOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateDataKeyPairWithoutPlaintextInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateDataKeyWithoutPlaintext provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateDataKeyWithoutPlaintext(ctx context.Context, params *kms.GenerateDataKeyWithoutPlaintextInput, optFns ...func(*kms.Options)) (*kms.GenerateDataKeyWithoutPlaintextOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateDataKeyWithoutPlaintext")
	}

	var r0 *kms.GenerateDataKeyWithoutPlaintextOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, ...func(*kms.Options)) (*kms.GenerateDataKeyWithoutPlaintextOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, ...func(*kms.Options)) *kms.GenerateDataKeyWithoutPlaintextOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateDataKeyWithoutPlaintextOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateDataKeyWithoutPlaintextInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateMac provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateMac(ctx context.Context, params *kms.GenerateMacInput, optFns ...func(*kms.Options)) (*kms.GenerateMacOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateMac")
	}

	var r0 *kms.GenerateMacOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateMacInput, ...func(*kms.Options)) (*kms.GenerateMacOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateMacInput, ...func(*kms.Options)) *kms.GenerateMacOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateMacOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateMacInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateRandom provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateRandom(ctx context.Context, params *kms.GenerateRandomInput, optFns ...func(*kms.Options)) (*kms.GenerateRandomOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateRandom")
	}

	var r0 *kms.GenerateRandomOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateRandomInput, ...func(*kms.Options)) (*kms.GenerateRandomOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GenerateRandomInput, ...func(*kms.Options)) *kms.GenerateRandomOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GenerateRandomOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GenerateRandomInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKeyPolicy(ctx context.Context, params *kms.GetKeyPolicyInput, optFns ...func(*kms.Options)) (*kms.GetKeyPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyPolicy")
	}

	var r0 *kms.GetKeyPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetKeyPolicyInput, ...func(*kms.Options)) (*kms.GetKeyPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetKeyPolicyInput, ...func(*kms.Options)) *kms.GetKeyPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GetKeyPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GetKeyPolicyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyRotationStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetKeyRotationStatus(ctx context.Context, params *kms.GetKeyRotationStatusInput, optFns ...func(*kms.Options)) (*kms.GetKeyRotationStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyRotationStatus")
	}

	var r0 *kms.GetKeyRotationStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetKeyRotationStatusInput, ...func(*kms.Options)) (*kms.GetKeyRotationStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetKeyRotationStatusInput, ...func(*kms.Options)) *kms.GetKeyRotationStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GetKeyRotationStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GetKeyRotationStatusInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParametersForImport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetParametersForImport(ctx context.Context, params *kms.GetParametersForImportInput, optFns ...func(*kms.Options)) (*kms.GetParametersForImportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParametersForImport")
	}

	var r0 *kms.GetParametersForImportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetParametersForImportInput, ...func(*kms.Options)) (*kms.GetParametersForImportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetParametersForImportInput, ...func(*kms.Options)) *kms.GetParametersForImportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GetParametersForImportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GetParametersForImportInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPublicKey(ctx context.Context, params *kms.GetPublicKeyInput, optFns ...func(*kms.Options)) (*kms.GetPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKey")
	}

	var r0 *kms.GetPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetPublicKeyInput, ...func(*kms.Options)) (*kms.GetPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.GetPublicKeyInput, ...func(*kms.Options)) *kms.GetPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.GetPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.GetPublicKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKeyMaterial provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportKeyMaterial(ctx context.Context, params *kms.ImportKeyMaterialInput, optFns ...func(*kms.Options)) (*kms.ImportKeyMaterialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportKeyMaterial")
	}

	var r0 *kms.ImportKeyMaterialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ImportKeyMaterialInput, ...func(*kms.Options)) (*kms.ImportKeyMaterialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ImportKeyMaterialInput, ...func(*kms.Options)) *kms.ImportKeyMaterialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ImportKeyMaterialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ImportKeyMaterialInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAliases(ctx context.Context, params *kms.ListAliasesInput, optFns ...func(*kms.Options)) (*kms.ListAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAliases")
	}

	var r0 *kms.ListAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListAliasesInput, ...func(*kms.Options)) (*kms.ListAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListAliasesInput, ...func(*kms.Options)) *kms.ListAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListAliasesInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGrants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGrants(ctx context.Context, params *kms.ListGrantsInput, optFns ...func(*kms.Options)) (*kms.ListGrantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGrants")
	}

	var r0 *kms.ListGrantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListGrantsInput, ...func(*kms.Options)) (*kms.ListGrantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListGrantsInput, ...func(*kms.Options)) *kms.ListGrantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListGrantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListGrantsInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeyPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeyPolicies(ctx context.Context, params *kms.ListKeyPoliciesInput, optFns ...func(*kms.Options)) (*kms.ListKeyPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeyPolicies")
	}

	var r0 *kms.ListKeyPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeyPoliciesInput, ...func(*kms.Options)) (*kms.ListKeyPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeyPoliciesInput, ...func(*kms.Options)) *kms.ListKeyPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListKeyPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListKeyPoliciesInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeyRotations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeyRotations(ctx context.Context, params *kms.ListKeyRotationsInput, optFns ...func(*kms.Options)) (*kms.ListKeyRotationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeyRotations")
	}

	var r0 *kms.ListKeyRotationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeyRotationsInput, ...func(*kms.Options)) (*kms.ListKeyRotationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeyRotationsInput, ...func(*kms.Options)) *kms.ListKeyRotationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListKeyRotationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListKeyRotationsInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeys(ctx context.Context, params *kms.ListKeysInput, optFns ...func(*kms.Options)) (*kms.ListKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeys")
	}

	var r0 *kms.ListKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeysInput, ...func(*kms.Options)) (*kms.ListKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListKeysInput, ...func(*kms.Options)) *kms.ListKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListKeysInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResourceTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResourceTags(ctx context.Context, params *kms.ListResourceTagsInput, optFns ...func(*kms.Options)) (*kms.ListResourceTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResourceTags")
	}

	var r0 *kms.ListResourceTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListResourceTagsInput, ...func(*kms.Options)) (*kms.ListResourceTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListResourceTagsInput, ...func(*kms.Options)) *kms.ListResourceTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListResourceTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListResourceTagsInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRetirableGrants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRetirableGrants(ctx context.Context, params *kms.ListRetirableGrantsInput, optFns ...func(*kms.Options)) (*kms.ListRetirableGrantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRetirableGrants")
	}

	var r0 *kms.ListRetirableGrantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListRetirableGrantsInput, ...func(*kms.Options)) (*kms.ListRetirableGrantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ListRetirableGrantsInput, ...func(*kms.Options)) *kms.ListRetirableGrantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ListRetirableGrantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ListRetirableGrantsInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() kms.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 kms.Options
	if rf, ok := ret.Get(0).(func() kms.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kms.Options)
	}

	return r0
}

// PutKeyPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutKeyPolicy(ctx context.Context, params *kms.PutKeyPolicyInput, optFns ...func(*kms.Options)) (*kms.PutKeyPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutKeyPolicy")
	}

	var r0 *kms.PutKeyPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.PutKeyPolicyInput, ...func(*kms.Options)) (*kms.PutKeyPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.PutKeyPolicyInput, ...func(*kms.Options)) *kms.PutKeyPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.PutKeyPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.PutKeyPolicyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReEncrypt provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReEncrypt(ctx context.Context, params *kms.ReEncryptInput, optFns ...func(*kms.Options)) (*kms.ReEncryptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReEncrypt")
	}

	var r0 *kms.ReEncryptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ReEncryptInput, ...func(*kms.Options)) (*kms.ReEncryptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ReEncryptInput, ...func(*kms.Options)) *kms.ReEncryptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ReEncryptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ReEncryptInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplicateKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReplicateKey(ctx context.Context, params *kms.ReplicateKeyInput, optFns ...func(*kms.Options)) (*kms.ReplicateKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplicateKey")
	}

	var r0 *kms.ReplicateKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ReplicateKeyInput, ...func(*kms.Options)) (*kms.ReplicateKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ReplicateKeyInput, ...func(*kms.Options)) *kms.ReplicateKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ReplicateKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ReplicateKeyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetireGrant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetireGrant(ctx context.Context, params *kms.RetireGrantInput, optFns ...func(*kms.Options)) (*kms.RetireGrantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetireGrant")
	}

	var r0 *kms.RetireGrantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RetireGrantInput, ...func(*kms.Options)) (*kms.RetireGrantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RetireGrantInput, ...func(*kms.Options)) *kms.RetireGrantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.RetireGrantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.RetireGrantInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeGrant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeGrant(ctx context.Context, params *kms.RevokeGrantInput, optFns ...func(*kms.Options)) (*kms.RevokeGrantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeGrant")
	}

	var r0 *kms.RevokeGrantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RevokeGrantInput, ...func(*kms.Options)) (*kms.RevokeGrantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RevokeGrantInput, ...func(*kms.Options)) *kms.RevokeGrantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.RevokeGrantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.RevokeGrantInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RotateKeyOnDemand provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RotateKeyOnDemand(ctx context.Context, params *kms.RotateKeyOnDemandInput, optFns ...func(*kms.Options)) (*kms.RotateKeyOnDemandOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotateKeyOnDemand")
	}

	var r0 *kms.RotateKeyOnDemandOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RotateKeyOnDemandInput, ...func(*kms.Options)) (*kms.RotateKeyOnDemandOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.RotateKeyOnDemandInput, ...func(*kms.Options)) *kms.RotateKeyOnDemandOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.RotateKeyOnDemandOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.RotateKeyOnDemandInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ScheduleKeyDeletion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ScheduleKeyDeletion(ctx context.Context, params *kms.ScheduleKeyDeletionInput, optFns ...func(*kms.Options)) (*kms.ScheduleKeyDeletionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleKeyDeletion")
	}

	var r0 *kms.ScheduleKeyDeletionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ScheduleKeyDeletionInput, ...func(*kms.Options)) (*kms.ScheduleKeyDeletionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.ScheduleKeyDeletionInput, ...func(*kms.Options)) *kms.ScheduleKeyDeletionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.ScheduleKeyDeletionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.ScheduleKeyDeletionInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Sign provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Sign(ctx context.Context, params *kms.SignInput, optFns ...func(*kms.Options)) (*kms.SignOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Sign")
	}

	var r0 *kms.SignOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.SignInput, ...func(*kms.Options)) (*kms.SignOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.SignInput, ...func(*kms.Options)) *kms.SignOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.SignOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.SignInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *kms.TagResourceInput, optFns ...func(*kms.Options)) (*kms.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *kms.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.TagResourceInput, ...func(*kms.Options)) (*kms.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.TagResourceInput, ...func(*kms.Options)) *kms.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.TagResourceInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *kms.UntagResourceInput, optFns ...func(*kms.Options)) (*kms.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *kms.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UntagResourceInput, ...func(*kms.Options)) (*kms.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UntagResourceInput, ...func(*kms.Options)) *kms.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.UntagResourceInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAlias(ctx context.Context, params *kms.UpdateAliasInput, optFns ...func(*kms.Options)) (*kms.UpdateAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAlias")
	}

	var r0 *kms.UpdateAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateAliasInput, ...func(*kms.Options)) (*kms.UpdateAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateAliasInput, ...func(*kms.Options)) *kms.UpdateAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.UpdateAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.UpdateAliasInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCustomKeyStore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCustomKeyStore(ctx context.Context, params *kms.UpdateCustomKeyStoreInput, optFns ...func(*kms.Options)) (*kms.UpdateCustomKeyStoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomKeyStore")
	}

	var r0 *kms.UpdateCustomKeyStoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateCustomKeyStoreInput, ...func(*kms.Options)) (*kms.UpdateCustomKeyStoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateCustomKeyStoreInput, ...func(*kms.Options)) *kms.UpdateCustomKeyStoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.UpdateCustomKeyStoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.UpdateCustomKeyStoreInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKeyDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateKeyDescription(ctx context.Context, params *kms.UpdateKeyDescriptionInput, optFns ...func(*kms.Options)) (*kms.UpdateKeyDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKeyDescription")
	}

	var r0 *kms.UpdateKeyDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateKeyDescriptionInput, ...func(*kms.Options)) (*kms.UpdateKeyDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdateKeyDescriptionInput, ...func(*kms.Options)) *kms.UpdateKeyDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.UpdateKeyDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.UpdateKeyDescriptionInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrimaryRegion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePrimaryRegion(ctx context.Context, params *kms.UpdatePrimaryRegionInput, optFns ...func(*kms.Options)) (*kms.UpdatePrimaryRegionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrimaryRegion")
	}

	var r0 *kms.UpdatePrimaryRegionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdatePrimaryRegionInput, ...func(*kms.Options)) (*kms.UpdatePrimaryRegionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.UpdatePrimaryRegionInput, ...func(*kms.Options)) *kms.UpdatePrimaryRegionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.UpdatePrimaryRegionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.UpdatePrimaryRegionInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Verify provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Verify(ctx context.Context, params *kms.VerifyInput, optFns ...func(*kms.Options)) (*kms.VerifyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 *kms.VerifyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.VerifyInput, ...func(*kms.Options)) (*kms.VerifyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.VerifyInput, ...func(*kms.Options)) *kms.VerifyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.VerifyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.VerifyInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyMac provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) VerifyMac(ctx context.Context, params *kms.VerifyMacInput, optFns ...func(*kms.Options)) (*kms.VerifyMacOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMac")
	}

	var r0 *kms.VerifyMacOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kms.VerifyMacInput, ...func(*kms.Options)) (*kms.VerifyMacOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kms.VerifyMacInput, ...func(*kms.Options)) *kms.VerifyMacOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kms.VerifyMacOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kms.VerifyMacInput, ...func(*kms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
