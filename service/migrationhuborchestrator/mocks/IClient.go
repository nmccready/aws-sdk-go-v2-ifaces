// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	migrationhuborchestrator "github.com/aws/aws-sdk-go-v2/service/migrationhuborchestrator"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTemplate(ctx context.Context, params *migrationhuborchestrator.CreateTemplateInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTemplate")
	}

	var r0 *migrationhuborchestrator.CreateTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateTemplateInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateTemplateInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.CreateTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.CreateTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.CreateTemplateInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkflow(ctx context.Context, params *migrationhuborchestrator.CreateWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflow")
	}

	var r0 *migrationhuborchestrator.CreateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.CreateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.CreateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.CreateWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkflowStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkflowStep(ctx context.Context, params *migrationhuborchestrator.CreateWorkflowStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowStep")
	}

	var r0 *migrationhuborchestrator.CreateWorkflowStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.CreateWorkflowStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.CreateWorkflowStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkflowStepGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkflowStepGroup(ctx context.Context, params *migrationhuborchestrator.CreateWorkflowStepGroupInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowStepGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowStepGroup")
	}

	var r0 *migrationhuborchestrator.CreateWorkflowStepGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.CreateWorkflowStepGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.CreateWorkflowStepGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.CreateWorkflowStepGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.CreateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTemplate(ctx context.Context, params *migrationhuborchestrator.DeleteTemplateInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTemplate")
	}

	var r0 *migrationhuborchestrator.DeleteTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteTemplateInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteTemplateInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.DeleteTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.DeleteTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.DeleteTemplateInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflow(ctx context.Context, params *migrationhuborchestrator.DeleteWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 *migrationhuborchestrator.DeleteWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.DeleteWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.DeleteWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflowStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflowStep(ctx context.Context, params *migrationhuborchestrator.DeleteWorkflowStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowStep")
	}

	var r0 *migrationhuborchestrator.DeleteWorkflowStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.DeleteWorkflowStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.DeleteWorkflowStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflowStepGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflowStepGroup(ctx context.Context, params *migrationhuborchestrator.DeleteWorkflowStepGroupInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowStepGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowStepGroup")
	}

	var r0 *migrationhuborchestrator.DeleteWorkflowStepGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.DeleteWorkflowStepGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.DeleteWorkflowStepGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.DeleteWorkflowStepGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.DeleteWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTemplate(ctx context.Context, params *migrationhuborchestrator.GetTemplateInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplate")
	}

	var r0 *migrationhuborchestrator.GetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetTemplateInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemplateStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTemplateStep(ctx context.Context, params *migrationhuborchestrator.GetTemplateStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplateStep")
	}

	var r0 *migrationhuborchestrator.GetTemplateStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetTemplateStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetTemplateStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetTemplateStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemplateStepGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTemplateStepGroup(ctx context.Context, params *migrationhuborchestrator.GetTemplateStepGroupInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateStepGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplateStepGroup")
	}

	var r0 *migrationhuborchestrator.GetTemplateStepGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateStepGroupInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetTemplateStepGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetTemplateStepGroupInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetTemplateStepGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetTemplateStepGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetTemplateStepGroupInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflow(ctx context.Context, params *migrationhuborchestrator.GetWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *migrationhuborchestrator.GetWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowStep(ctx context.Context, params *migrationhuborchestrator.GetWorkflowStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowStep")
	}

	var r0 *migrationhuborchestrator.GetWorkflowStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetWorkflowStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetWorkflowStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowStepGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowStepGroup(ctx context.Context, params *migrationhuborchestrator.GetWorkflowStepGroupInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowStepGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowStepGroup")
	}

	var r0 *migrationhuborchestrator.GetWorkflowStepGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.GetWorkflowStepGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.GetWorkflowStepGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.GetWorkflowStepGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.GetWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPlugins provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPlugins(ctx context.Context, params *migrationhuborchestrator.ListPluginsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListPluginsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPlugins")
	}

	var r0 *migrationhuborchestrator.ListPluginsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListPluginsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListPluginsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListPluginsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListPluginsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListPluginsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListPluginsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *migrationhuborchestrator.ListTagsForResourceInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *migrationhuborchestrator.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTagsForResourceInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTagsForResourceInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListTagsForResourceInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTemplateStepGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTemplateStepGroups(ctx context.Context, params *migrationhuborchestrator.ListTemplateStepGroupsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplateStepGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplateStepGroups")
	}

	var r0 *migrationhuborchestrator.ListTemplateStepGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplateStepGroupsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplateStepGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplateStepGroupsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListTemplateStepGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListTemplateStepGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListTemplateStepGroupsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTemplateSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTemplateSteps(ctx context.Context, params *migrationhuborchestrator.ListTemplateStepsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplateStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplateSteps")
	}

	var r0 *migrationhuborchestrator.ListTemplateStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplateStepsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplateStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplateStepsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListTemplateStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListTemplateStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListTemplateStepsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTemplates(ctx context.Context, params *migrationhuborchestrator.ListTemplatesInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplates")
	}

	var r0 *migrationhuborchestrator.ListTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplatesInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListTemplatesInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListTemplatesInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflowStepGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflowStepGroups(ctx context.Context, params *migrationhuborchestrator.ListWorkflowStepGroupsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowStepGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowStepGroups")
	}

	var r0 *migrationhuborchestrator.ListWorkflowStepGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepGroupsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowStepGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepGroupsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListWorkflowStepGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListWorkflowStepGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepGroupsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflowSteps provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflowSteps(ctx context.Context, params *migrationhuborchestrator.ListWorkflowStepsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowStepsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowSteps")
	}

	var r0 *migrationhuborchestrator.ListWorkflowStepsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowStepsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListWorkflowStepsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListWorkflowStepsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListWorkflowStepsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflows(ctx context.Context, params *migrationhuborchestrator.ListWorkflowsInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *migrationhuborchestrator.ListWorkflowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowsInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.ListWorkflowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.ListWorkflowsInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.ListWorkflowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.ListWorkflowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.ListWorkflowsInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() migrationhuborchestrator.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 migrationhuborchestrator.Options
	if rf, ok := ret.Get(0).(func() migrationhuborchestrator.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(migrationhuborchestrator.Options)
	}

	return r0
}

// RetryWorkflowStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RetryWorkflowStep(ctx context.Context, params *migrationhuborchestrator.RetryWorkflowStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.RetryWorkflowStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryWorkflowStep")
	}

	var r0 *migrationhuborchestrator.RetryWorkflowStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.RetryWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.RetryWorkflowStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.RetryWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.RetryWorkflowStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.RetryWorkflowStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.RetryWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartWorkflow(ctx context.Context, params *migrationhuborchestrator.StartWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.StartWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartWorkflow")
	}

	var r0 *migrationhuborchestrator.StartWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.StartWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.StartWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.StartWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.StartWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.StartWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.StartWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopWorkflow(ctx context.Context, params *migrationhuborchestrator.StopWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.StopWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopWorkflow")
	}

	var r0 *migrationhuborchestrator.StopWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.StopWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.StopWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.StopWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.StopWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.StopWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.StopWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *migrationhuborchestrator.TagResourceInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *migrationhuborchestrator.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.TagResourceInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.TagResourceInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.TagResourceInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *migrationhuborchestrator.UntagResourceInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *migrationhuborchestrator.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UntagResourceInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UntagResourceInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.UntagResourceInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTemplate(ctx context.Context, params *migrationhuborchestrator.UpdateTemplateInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTemplate")
	}

	var r0 *migrationhuborchestrator.UpdateTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateTemplateInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateTemplateInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.UpdateTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.UpdateTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.UpdateTemplateInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorkflow(ctx context.Context, params *migrationhuborchestrator.UpdateWorkflowInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflow")
	}

	var r0 *migrationhuborchestrator.UpdateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.UpdateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.UpdateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflowStep provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorkflowStep(ctx context.Context, params *migrationhuborchestrator.UpdateWorkflowStepInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowStepOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowStep")
	}

	var r0 *migrationhuborchestrator.UpdateWorkflowStepOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowStepOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.UpdateWorkflowStepOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.UpdateWorkflowStepOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflowStepGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorkflowStepGroup(ctx context.Context, params *migrationhuborchestrator.UpdateWorkflowStepGroupInput, optFns ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowStepGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowStepGroup")
	}

	var r0 *migrationhuborchestrator.UpdateWorkflowStepGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) (*migrationhuborchestrator.UpdateWorkflowStepGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) *migrationhuborchestrator.UpdateWorkflowStepGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*migrationhuborchestrator.UpdateWorkflowStepGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *migrationhuborchestrator.UpdateWorkflowStepGroupInput, ...func(*migrationhuborchestrator.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
