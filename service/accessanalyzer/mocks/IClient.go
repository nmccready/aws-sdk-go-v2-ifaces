// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	accessanalyzer "github.com/aws/aws-sdk-go-v2/service/accessanalyzer"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// ApplyArchiveRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ApplyArchiveRule(ctx context.Context, params *accessanalyzer.ApplyArchiveRuleInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ApplyArchiveRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplyArchiveRule")
	}

	var r0 *accessanalyzer.ApplyArchiveRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ApplyArchiveRuleInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ApplyArchiveRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ApplyArchiveRuleInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ApplyArchiveRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ApplyArchiveRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ApplyArchiveRuleInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelPolicyGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelPolicyGeneration(ctx context.Context, params *accessanalyzer.CancelPolicyGenerationInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CancelPolicyGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelPolicyGeneration")
	}

	var r0 *accessanalyzer.CancelPolicyGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CancelPolicyGenerationInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CancelPolicyGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CancelPolicyGenerationInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CancelPolicyGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CancelPolicyGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CancelPolicyGenerationInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckAccessNotGranted provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CheckAccessNotGranted(ctx context.Context, params *accessanalyzer.CheckAccessNotGrantedInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckAccessNotGrantedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckAccessNotGranted")
	}

	var r0 *accessanalyzer.CheckAccessNotGrantedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckAccessNotGrantedInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckAccessNotGrantedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckAccessNotGrantedInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CheckAccessNotGrantedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CheckAccessNotGrantedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CheckAccessNotGrantedInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckNoNewAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CheckNoNewAccess(ctx context.Context, params *accessanalyzer.CheckNoNewAccessInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckNoNewAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckNoNewAccess")
	}

	var r0 *accessanalyzer.CheckNoNewAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckNoNewAccessInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckNoNewAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckNoNewAccessInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CheckNoNewAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CheckNoNewAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CheckNoNewAccessInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckNoPublicAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CheckNoPublicAccess(ctx context.Context, params *accessanalyzer.CheckNoPublicAccessInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckNoPublicAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckNoPublicAccess")
	}

	var r0 *accessanalyzer.CheckNoPublicAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckNoPublicAccessInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CheckNoPublicAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CheckNoPublicAccessInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CheckNoPublicAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CheckNoPublicAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CheckNoPublicAccessInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessPreview(ctx context.Context, params *accessanalyzer.CreateAccessPreviewInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateAccessPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessPreview")
	}

	var r0 *accessanalyzer.CreateAccessPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateAccessPreviewInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateAccessPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateAccessPreviewInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CreateAccessPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CreateAccessPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CreateAccessPreviewInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAnalyzer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAnalyzer(ctx context.Context, params *accessanalyzer.CreateAnalyzerInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateAnalyzerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAnalyzer")
	}

	var r0 *accessanalyzer.CreateAnalyzerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateAnalyzerInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateAnalyzerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateAnalyzerInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CreateAnalyzerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CreateAnalyzerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CreateAnalyzerInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateArchiveRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateArchiveRule(ctx context.Context, params *accessanalyzer.CreateArchiveRuleInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateArchiveRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateArchiveRule")
	}

	var r0 *accessanalyzer.CreateArchiveRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateArchiveRuleInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.CreateArchiveRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.CreateArchiveRuleInput, ...func(*accessanalyzer.Options)) *accessanalyzer.CreateArchiveRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.CreateArchiveRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.CreateArchiveRuleInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAnalyzer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAnalyzer(ctx context.Context, params *accessanalyzer.DeleteAnalyzerInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.DeleteAnalyzerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAnalyzer")
	}

	var r0 *accessanalyzer.DeleteAnalyzerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.DeleteAnalyzerInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.DeleteAnalyzerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.DeleteAnalyzerInput, ...func(*accessanalyzer.Options)) *accessanalyzer.DeleteAnalyzerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.DeleteAnalyzerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.DeleteAnalyzerInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteArchiveRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteArchiveRule(ctx context.Context, params *accessanalyzer.DeleteArchiveRuleInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.DeleteArchiveRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteArchiveRule")
	}

	var r0 *accessanalyzer.DeleteArchiveRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.DeleteArchiveRuleInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.DeleteArchiveRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.DeleteArchiveRuleInput, ...func(*accessanalyzer.Options)) *accessanalyzer.DeleteArchiveRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.DeleteArchiveRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.DeleteArchiveRuleInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateFindingRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateFindingRecommendation(ctx context.Context, params *accessanalyzer.GenerateFindingRecommendationInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GenerateFindingRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateFindingRecommendation")
	}

	var r0 *accessanalyzer.GenerateFindingRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GenerateFindingRecommendationInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GenerateFindingRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GenerateFindingRecommendationInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GenerateFindingRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GenerateFindingRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GenerateFindingRecommendationInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccessPreview provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccessPreview(ctx context.Context, params *accessanalyzer.GetAccessPreviewInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAccessPreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessPreview")
	}

	var r0 *accessanalyzer.GetAccessPreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAccessPreviewInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAccessPreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAccessPreviewInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetAccessPreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetAccessPreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetAccessPreviewInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnalyzedResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnalyzedResource(ctx context.Context, params *accessanalyzer.GetAnalyzedResourceInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAnalyzedResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnalyzedResource")
	}

	var r0 *accessanalyzer.GetAnalyzedResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAnalyzedResourceInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAnalyzedResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAnalyzedResourceInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetAnalyzedResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetAnalyzedResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetAnalyzedResourceInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnalyzer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnalyzer(ctx context.Context, params *accessanalyzer.GetAnalyzerInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAnalyzerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnalyzer")
	}

	var r0 *accessanalyzer.GetAnalyzerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAnalyzerInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetAnalyzerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetAnalyzerInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetAnalyzerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetAnalyzerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetAnalyzerInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetArchiveRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetArchiveRule(ctx context.Context, params *accessanalyzer.GetArchiveRuleInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetArchiveRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetArchiveRule")
	}

	var r0 *accessanalyzer.GetArchiveRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetArchiveRuleInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetArchiveRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetArchiveRuleInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetArchiveRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetArchiveRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetArchiveRuleInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFinding provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFinding(ctx context.Context, params *accessanalyzer.GetFindingInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFinding")
	}

	var r0 *accessanalyzer.GetFindingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetFindingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetFindingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetFindingInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFindingRecommendation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFindingRecommendation(ctx context.Context, params *accessanalyzer.GetFindingRecommendationInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingRecommendationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFindingRecommendation")
	}

	var r0 *accessanalyzer.GetFindingRecommendationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingRecommendationInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingRecommendationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingRecommendationInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetFindingRecommendationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetFindingRecommendationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetFindingRecommendationInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFindingV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFindingV2(ctx context.Context, params *accessanalyzer.GetFindingV2Input, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFindingV2")
	}

	var r0 *accessanalyzer.GetFindingV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingV2Input, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingV2Input, ...func(*accessanalyzer.Options)) *accessanalyzer.GetFindingV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetFindingV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetFindingV2Input, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFindingsStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFindingsStatistics(ctx context.Context, params *accessanalyzer.GetFindingsStatisticsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingsStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFindingsStatistics")
	}

	var r0 *accessanalyzer.GetFindingsStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingsStatisticsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetFindingsStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetFindingsStatisticsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetFindingsStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetFindingsStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetFindingsStatisticsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGeneratedPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGeneratedPolicy(ctx context.Context, params *accessanalyzer.GetGeneratedPolicyInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.GetGeneratedPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGeneratedPolicy")
	}

	var r0 *accessanalyzer.GetGeneratedPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetGeneratedPolicyInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.GetGeneratedPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.GetGeneratedPolicyInput, ...func(*accessanalyzer.Options)) *accessanalyzer.GetGeneratedPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.GetGeneratedPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.GetGeneratedPolicyInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessPreviewFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessPreviewFindings(ctx context.Context, params *accessanalyzer.ListAccessPreviewFindingsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAccessPreviewFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessPreviewFindings")
	}

	var r0 *accessanalyzer.ListAccessPreviewFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAccessPreviewFindingsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAccessPreviewFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAccessPreviewFindingsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListAccessPreviewFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListAccessPreviewFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListAccessPreviewFindingsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessPreviews provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessPreviews(ctx context.Context, params *accessanalyzer.ListAccessPreviewsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAccessPreviewsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessPreviews")
	}

	var r0 *accessanalyzer.ListAccessPreviewsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAccessPreviewsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAccessPreviewsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAccessPreviewsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListAccessPreviewsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListAccessPreviewsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListAccessPreviewsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnalyzedResources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnalyzedResources(ctx context.Context, params *accessanalyzer.ListAnalyzedResourcesInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzedResourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnalyzedResources")
	}

	var r0 *accessanalyzer.ListAnalyzedResourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzedResourcesInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzedResourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzedResourcesInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListAnalyzedResourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListAnalyzedResourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListAnalyzedResourcesInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnalyzers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnalyzers(ctx context.Context, params *accessanalyzer.ListAnalyzersInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnalyzers")
	}

	var r0 *accessanalyzer.ListAnalyzersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListAnalyzersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListAnalyzersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListArchiveRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListArchiveRules(ctx context.Context, params *accessanalyzer.ListArchiveRulesInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListArchiveRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListArchiveRules")
	}

	var r0 *accessanalyzer.ListArchiveRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListArchiveRulesInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListArchiveRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListArchiveRulesInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListArchiveRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListArchiveRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListArchiveRulesInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFindings(ctx context.Context, params *accessanalyzer.ListFindingsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFindings")
	}

	var r0 *accessanalyzer.ListFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListFindingsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListFindingsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListFindingsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFindingsV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFindingsV2(ctx context.Context, params *accessanalyzer.ListFindingsV2Input, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListFindingsV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFindingsV2")
	}

	var r0 *accessanalyzer.ListFindingsV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListFindingsV2Input, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListFindingsV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListFindingsV2Input, ...func(*accessanalyzer.Options)) *accessanalyzer.ListFindingsV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListFindingsV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListFindingsV2Input, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPolicyGenerations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPolicyGenerations(ctx context.Context, params *accessanalyzer.ListPolicyGenerationsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListPolicyGenerationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPolicyGenerations")
	}

	var r0 *accessanalyzer.ListPolicyGenerationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListPolicyGenerationsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListPolicyGenerationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListPolicyGenerationsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListPolicyGenerationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListPolicyGenerationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListPolicyGenerationsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *accessanalyzer.ListTagsForResourceInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *accessanalyzer.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListTagsForResourceInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListTagsForResourceInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListTagsForResourceInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() accessanalyzer.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 accessanalyzer.Options
	if rf, ok := ret.Get(0).(func() accessanalyzer.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(accessanalyzer.Options)
	}

	return r0
}

// StartPolicyGeneration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartPolicyGeneration(ctx context.Context, params *accessanalyzer.StartPolicyGenerationInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.StartPolicyGenerationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartPolicyGeneration")
	}

	var r0 *accessanalyzer.StartPolicyGenerationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.StartPolicyGenerationInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.StartPolicyGenerationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.StartPolicyGenerationInput, ...func(*accessanalyzer.Options)) *accessanalyzer.StartPolicyGenerationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.StartPolicyGenerationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.StartPolicyGenerationInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartResourceScan provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartResourceScan(ctx context.Context, params *accessanalyzer.StartResourceScanInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.StartResourceScanOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartResourceScan")
	}

	var r0 *accessanalyzer.StartResourceScanOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.StartResourceScanInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.StartResourceScanOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.StartResourceScanInput, ...func(*accessanalyzer.Options)) *accessanalyzer.StartResourceScanOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.StartResourceScanOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.StartResourceScanInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *accessanalyzer.TagResourceInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *accessanalyzer.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.TagResourceInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.TagResourceInput, ...func(*accessanalyzer.Options)) *accessanalyzer.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.TagResourceInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *accessanalyzer.UntagResourceInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *accessanalyzer.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UntagResourceInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UntagResourceInput, ...func(*accessanalyzer.Options)) *accessanalyzer.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.UntagResourceInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAnalyzer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAnalyzer(ctx context.Context, params *accessanalyzer.UpdateAnalyzerInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateAnalyzerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnalyzer")
	}

	var r0 *accessanalyzer.UpdateAnalyzerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateAnalyzerInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateAnalyzerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateAnalyzerInput, ...func(*accessanalyzer.Options)) *accessanalyzer.UpdateAnalyzerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.UpdateAnalyzerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.UpdateAnalyzerInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateArchiveRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateArchiveRule(ctx context.Context, params *accessanalyzer.UpdateArchiveRuleInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateArchiveRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateArchiveRule")
	}

	var r0 *accessanalyzer.UpdateArchiveRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateArchiveRuleInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateArchiveRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateArchiveRuleInput, ...func(*accessanalyzer.Options)) *accessanalyzer.UpdateArchiveRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.UpdateArchiveRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.UpdateArchiveRuleInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFindings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFindings(ctx context.Context, params *accessanalyzer.UpdateFindingsInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFindings")
	}

	var r0 *accessanalyzer.UpdateFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateFindingsInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.UpdateFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.UpdateFindingsInput, ...func(*accessanalyzer.Options)) *accessanalyzer.UpdateFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.UpdateFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.UpdateFindingsInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidatePolicy(ctx context.Context, params *accessanalyzer.ValidatePolicyInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ValidatePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePolicy")
	}

	var r0 *accessanalyzer.ValidatePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ValidatePolicyInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ValidatePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ValidatePolicyInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ValidatePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ValidatePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ValidatePolicyInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
