// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	kafka "github.com/aws/aws-sdk-go-v2/service/kafka"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchAssociateScramSecret provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchAssociateScramSecret(ctx context.Context, params *kafka.BatchAssociateScramSecretInput, optFns ...func(*kafka.Options)) (*kafka.BatchAssociateScramSecretOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchAssociateScramSecret")
	}

	var r0 *kafka.BatchAssociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...func(*kafka.Options)) (*kafka.BatchAssociateScramSecretOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...func(*kafka.Options)) *kafka.BatchAssociateScramSecretOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchAssociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDisassociateScramSecret provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDisassociateScramSecret(ctx context.Context, params *kafka.BatchDisassociateScramSecretInput, optFns ...func(*kafka.Options)) (*kafka.BatchDisassociateScramSecretOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDisassociateScramSecret")
	}

	var r0 *kafka.BatchDisassociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...func(*kafka.Options)) (*kafka.BatchDisassociateScramSecretOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...func(*kafka.Options)) *kafka.BatchDisassociateScramSecretOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchDisassociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCluster(ctx context.Context, params *kafka.CreateClusterInput, optFns ...func(*kafka.Options)) (*kafka.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *kafka.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterInput, ...func(*kafka.Options)) (*kafka.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterInput, ...func(*kafka.Options)) *kafka.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateClusterInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClusterV2(ctx context.Context, params *kafka.CreateClusterV2Input, optFns ...func(*kafka.Options)) (*kafka.CreateClusterV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterV2")
	}

	var r0 *kafka.CreateClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterV2Input, ...func(*kafka.Options)) (*kafka.CreateClusterV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterV2Input, ...func(*kafka.Options)) *kafka.CreateClusterV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateClusterV2Input, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguration(ctx context.Context, params *kafka.CreateConfigurationInput, optFns ...func(*kafka.Options)) (*kafka.CreateConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguration")
	}

	var r0 *kafka.CreateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateConfigurationInput, ...func(*kafka.Options)) (*kafka.CreateConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateConfigurationInput, ...func(*kafka.Options)) *kafka.CreateConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateConfigurationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReplicator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateReplicator(ctx context.Context, params *kafka.CreateReplicatorInput, optFns ...func(*kafka.Options)) (*kafka.CreateReplicatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReplicator")
	}

	var r0 *kafka.CreateReplicatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateReplicatorInput, ...func(*kafka.Options)) (*kafka.CreateReplicatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateReplicatorInput, ...func(*kafka.Options)) *kafka.CreateReplicatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateReplicatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateReplicatorInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateVpcConnection(ctx context.Context, params *kafka.CreateVpcConnectionInput, optFns ...func(*kafka.Options)) (*kafka.CreateVpcConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcConnection")
	}

	var r0 *kafka.CreateVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateVpcConnectionInput, ...func(*kafka.Options)) (*kafka.CreateVpcConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateVpcConnectionInput, ...func(*kafka.Options)) *kafka.CreateVpcConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateVpcConnectionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCluster(ctx context.Context, params *kafka.DeleteClusterInput, optFns ...func(*kafka.Options)) (*kafka.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 *kafka.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterInput, ...func(*kafka.Options)) (*kafka.DeleteClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterInput, ...func(*kafka.Options)) *kafka.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteClusterInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClusterPolicy(ctx context.Context, params *kafka.DeleteClusterPolicyInput, optFns ...func(*kafka.Options)) (*kafka.DeleteClusterPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusterPolicy")
	}

	var r0 *kafka.DeleteClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...func(*kafka.Options)) (*kafka.DeleteClusterPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...func(*kafka.Options)) *kafka.DeleteClusterPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguration(ctx context.Context, params *kafka.DeleteConfigurationInput, optFns ...func(*kafka.Options)) (*kafka.DeleteConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguration")
	}

	var r0 *kafka.DeleteConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteConfigurationInput, ...func(*kafka.Options)) (*kafka.DeleteConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteConfigurationInput, ...func(*kafka.Options)) *kafka.DeleteConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteConfigurationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReplicator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteReplicator(ctx context.Context, params *kafka.DeleteReplicatorInput, optFns ...func(*kafka.Options)) (*kafka.DeleteReplicatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReplicator")
	}

	var r0 *kafka.DeleteReplicatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteReplicatorInput, ...func(*kafka.Options)) (*kafka.DeleteReplicatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteReplicatorInput, ...func(*kafka.Options)) *kafka.DeleteReplicatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteReplicatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteReplicatorInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteVpcConnection(ctx context.Context, params *kafka.DeleteVpcConnectionInput, optFns ...func(*kafka.Options)) (*kafka.DeleteVpcConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcConnection")
	}

	var r0 *kafka.DeleteVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...func(*kafka.Options)) (*kafka.DeleteVpcConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...func(*kafka.Options)) *kafka.DeleteVpcConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCluster(ctx context.Context, params *kafka.DescribeClusterInput, optFns ...func(*kafka.Options)) (*kafka.DescribeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCluster")
	}

	var r0 *kafka.DescribeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterInput, ...func(*kafka.Options)) (*kafka.DescribeClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterInput, ...func(*kafka.Options)) *kafka.DescribeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterOperation(ctx context.Context, params *kafka.DescribeClusterOperationInput, optFns ...func(*kafka.Options)) (*kafka.DescribeClusterOperationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterOperation")
	}

	var r0 *kafka.DescribeClusterOperationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationInput, ...func(*kafka.Options)) (*kafka.DescribeClusterOperationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationInput, ...func(*kafka.Options)) *kafka.DescribeClusterOperationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterOperationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperationV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterOperationV2(ctx context.Context, params *kafka.DescribeClusterOperationV2Input, optFns ...func(*kafka.Options)) (*kafka.DescribeClusterOperationV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterOperationV2")
	}

	var r0 *kafka.DescribeClusterOperationV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...func(*kafka.Options)) (*kafka.DescribeClusterOperationV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...func(*kafka.Options)) *kafka.DescribeClusterOperationV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterV2(ctx context.Context, params *kafka.DescribeClusterV2Input, optFns ...func(*kafka.Options)) (*kafka.DescribeClusterV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterV2")
	}

	var r0 *kafka.DescribeClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterV2Input, ...func(*kafka.Options)) (*kafka.DescribeClusterV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterV2Input, ...func(*kafka.Options)) *kafka.DescribeClusterV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterV2Input, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConfiguration(ctx context.Context, params *kafka.DescribeConfigurationInput, optFns ...func(*kafka.Options)) (*kafka.DescribeConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConfiguration")
	}

	var r0 *kafka.DescribeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationInput, ...func(*kafka.Options)) (*kafka.DescribeConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationInput, ...func(*kafka.Options)) *kafka.DescribeConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeConfigurationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfigurationRevision provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConfigurationRevision(ctx context.Context, params *kafka.DescribeConfigurationRevisionInput, optFns ...func(*kafka.Options)) (*kafka.DescribeConfigurationRevisionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConfigurationRevision")
	}

	var r0 *kafka.DescribeConfigurationRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...func(*kafka.Options)) (*kafka.DescribeConfigurationRevisionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...func(*kafka.Options)) *kafka.DescribeConfigurationRevisionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReplicator provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReplicator(ctx context.Context, params *kafka.DescribeReplicatorInput, optFns ...func(*kafka.Options)) (*kafka.DescribeReplicatorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReplicator")
	}

	var r0 *kafka.DescribeReplicatorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeReplicatorInput, ...func(*kafka.Options)) (*kafka.DescribeReplicatorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeReplicatorInput, ...func(*kafka.Options)) *kafka.DescribeReplicatorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeReplicatorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeReplicatorInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeVpcConnection(ctx context.Context, params *kafka.DescribeVpcConnectionInput, optFns ...func(*kafka.Options)) (*kafka.DescribeVpcConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcConnection")
	}

	var r0 *kafka.DescribeVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...func(*kafka.Options)) (*kafka.DescribeVpcConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...func(*kafka.Options)) *kafka.DescribeVpcConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBootstrapBrokers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBootstrapBrokers(ctx context.Context, params *kafka.GetBootstrapBrokersInput, optFns ...func(*kafka.Options)) (*kafka.GetBootstrapBrokersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBootstrapBrokers")
	}

	var r0 *kafka.GetBootstrapBrokersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...func(*kafka.Options)) (*kafka.GetBootstrapBrokersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...func(*kafka.Options)) *kafka.GetBootstrapBrokersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetBootstrapBrokersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClusterPolicy(ctx context.Context, params *kafka.GetClusterPolicyInput, optFns ...func(*kafka.Options)) (*kafka.GetClusterPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterPolicy")
	}

	var r0 *kafka.GetClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetClusterPolicyInput, ...func(*kafka.Options)) (*kafka.GetClusterPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetClusterPolicyInput, ...func(*kafka.Options)) *kafka.GetClusterPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetClusterPolicyInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompatibleKafkaVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCompatibleKafkaVersions(ctx context.Context, params *kafka.GetCompatibleKafkaVersionsInput, optFns ...func(*kafka.Options)) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCompatibleKafkaVersions")
	}

	var r0 *kafka.GetCompatibleKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...func(*kafka.Options)) (*kafka.GetCompatibleKafkaVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...func(*kafka.Options)) *kafka.GetCompatibleKafkaVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetCompatibleKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClientVpcConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClientVpcConnections(ctx context.Context, params *kafka.ListClientVpcConnectionsInput, optFns ...func(*kafka.Options)) (*kafka.ListClientVpcConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClientVpcConnections")
	}

	var r0 *kafka.ListClientVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...func(*kafka.Options)) (*kafka.ListClientVpcConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...func(*kafka.Options)) *kafka.ListClientVpcConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClientVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClusterOperations(ctx context.Context, params *kafka.ListClusterOperationsInput, optFns ...func(*kafka.Options)) (*kafka.ListClusterOperationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusterOperations")
	}

	var r0 *kafka.ListClusterOperationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsInput, ...func(*kafka.Options)) (*kafka.ListClusterOperationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsInput, ...func(*kafka.Options)) *kafka.ListClusterOperationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClusterOperationsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperationsV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClusterOperationsV2(ctx context.Context, params *kafka.ListClusterOperationsV2Input, optFns ...func(*kafka.Options)) (*kafka.ListClusterOperationsV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusterOperationsV2")
	}

	var r0 *kafka.ListClusterOperationsV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...func(*kafka.Options)) (*kafka.ListClusterOperationsV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...func(*kafka.Options)) *kafka.ListClusterOperationsV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClusters(ctx context.Context, params *kafka.ListClustersInput, optFns ...func(*kafka.Options)) (*kafka.ListClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusters")
	}

	var r0 *kafka.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersInput, ...func(*kafka.Options)) (*kafka.ListClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersInput, ...func(*kafka.Options)) *kafka.ListClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClustersInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClustersV2 provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClustersV2(ctx context.Context, params *kafka.ListClustersV2Input, optFns ...func(*kafka.Options)) (*kafka.ListClustersV2Output, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClustersV2")
	}

	var r0 *kafka.ListClustersV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersV2Input, ...func(*kafka.Options)) (*kafka.ListClustersV2Output, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersV2Input, ...func(*kafka.Options)) *kafka.ListClustersV2Output); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClustersV2Input, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurationRevisions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfigurationRevisions(ctx context.Context, params *kafka.ListConfigurationRevisionsInput, optFns ...func(*kafka.Options)) (*kafka.ListConfigurationRevisionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfigurationRevisions")
	}

	var r0 *kafka.ListConfigurationRevisionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...func(*kafka.Options)) (*kafka.ListConfigurationRevisionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...func(*kafka.Options)) *kafka.ListConfigurationRevisionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationRevisionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfigurations(ctx context.Context, params *kafka.ListConfigurationsInput, optFns ...func(*kafka.Options)) (*kafka.ListConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfigurations")
	}

	var r0 *kafka.ListConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationsInput, ...func(*kafka.Options)) (*kafka.ListConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationsInput, ...func(*kafka.Options)) *kafka.ListConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListConfigurationsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKafkaVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKafkaVersions(ctx context.Context, params *kafka.ListKafkaVersionsInput, optFns ...func(*kafka.Options)) (*kafka.ListKafkaVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKafkaVersions")
	}

	var r0 *kafka.ListKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListKafkaVersionsInput, ...func(*kafka.Options)) (*kafka.ListKafkaVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListKafkaVersionsInput, ...func(*kafka.Options)) *kafka.ListKafkaVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListKafkaVersionsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNodes(ctx context.Context, params *kafka.ListNodesInput, optFns ...func(*kafka.Options)) (*kafka.ListNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNodes")
	}

	var r0 *kafka.ListNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListNodesInput, ...func(*kafka.Options)) (*kafka.ListNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListNodesInput, ...func(*kafka.Options)) *kafka.ListNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListNodesInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReplicators provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReplicators(ctx context.Context, params *kafka.ListReplicatorsInput, optFns ...func(*kafka.Options)) (*kafka.ListReplicatorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReplicators")
	}

	var r0 *kafka.ListReplicatorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListReplicatorsInput, ...func(*kafka.Options)) (*kafka.ListReplicatorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListReplicatorsInput, ...func(*kafka.Options)) *kafka.ListReplicatorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListReplicatorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListReplicatorsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListScramSecrets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListScramSecrets(ctx context.Context, params *kafka.ListScramSecretsInput, optFns ...func(*kafka.Options)) (*kafka.ListScramSecretsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListScramSecrets")
	}

	var r0 *kafka.ListScramSecretsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListScramSecretsInput, ...func(*kafka.Options)) (*kafka.ListScramSecretsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListScramSecretsInput, ...func(*kafka.Options)) *kafka.ListScramSecretsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListScramSecretsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListScramSecretsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *kafka.ListTagsForResourceInput, optFns ...func(*kafka.Options)) (*kafka.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *kafka.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListTagsForResourceInput, ...func(*kafka.Options)) (*kafka.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListTagsForResourceInput, ...func(*kafka.Options)) *kafka.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListTagsForResourceInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListVpcConnections(ctx context.Context, params *kafka.ListVpcConnectionsInput, optFns ...func(*kafka.Options)) (*kafka.ListVpcConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListVpcConnections")
	}

	var r0 *kafka.ListVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListVpcConnectionsInput, ...func(*kafka.Options)) (*kafka.ListVpcConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListVpcConnectionsInput, ...func(*kafka.Options)) *kafka.ListVpcConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListVpcConnectionsInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() kafka.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 kafka.Options
	if rf, ok := ret.Get(0).(func() kafka.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.Options)
	}

	return r0
}

// PutClusterPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutClusterPolicy(ctx context.Context, params *kafka.PutClusterPolicyInput, optFns ...func(*kafka.Options)) (*kafka.PutClusterPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutClusterPolicy")
	}

	var r0 *kafka.PutClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.PutClusterPolicyInput, ...func(*kafka.Options)) (*kafka.PutClusterPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.PutClusterPolicyInput, ...func(*kafka.Options)) *kafka.PutClusterPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.PutClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.PutClusterPolicyInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootBroker(ctx context.Context, params *kafka.RebootBrokerInput, optFns ...func(*kafka.Options)) (*kafka.RebootBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootBroker")
	}

	var r0 *kafka.RebootBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RebootBrokerInput, ...func(*kafka.Options)) (*kafka.RebootBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RebootBrokerInput, ...func(*kafka.Options)) *kafka.RebootBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RebootBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.RebootBrokerInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectClientVpcConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectClientVpcConnection(ctx context.Context, params *kafka.RejectClientVpcConnectionInput, optFns ...func(*kafka.Options)) (*kafka.RejectClientVpcConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectClientVpcConnection")
	}

	var r0 *kafka.RejectClientVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...func(*kafka.Options)) (*kafka.RejectClientVpcConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...func(*kafka.Options)) *kafka.RejectClientVpcConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RejectClientVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *kafka.TagResourceInput, optFns ...func(*kafka.Options)) (*kafka.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *kafka.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.TagResourceInput, ...func(*kafka.Options)) (*kafka.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.TagResourceInput, ...func(*kafka.Options)) *kafka.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.TagResourceInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *kafka.UntagResourceInput, optFns ...func(*kafka.Options)) (*kafka.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *kafka.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UntagResourceInput, ...func(*kafka.Options)) (*kafka.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UntagResourceInput, ...func(*kafka.Options)) *kafka.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UntagResourceInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerCount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBrokerCount(ctx context.Context, params *kafka.UpdateBrokerCountInput, optFns ...func(*kafka.Options)) (*kafka.UpdateBrokerCountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBrokerCount")
	}

	var r0 *kafka.UpdateBrokerCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerCountInput, ...func(*kafka.Options)) (*kafka.UpdateBrokerCountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerCountInput, ...func(*kafka.Options)) *kafka.UpdateBrokerCountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerCountInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerStorage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBrokerStorage(ctx context.Context, params *kafka.UpdateBrokerStorageInput, optFns ...func(*kafka.Options)) (*kafka.UpdateBrokerStorageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBrokerStorage")
	}

	var r0 *kafka.UpdateBrokerStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...func(*kafka.Options)) (*kafka.UpdateBrokerStorageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...func(*kafka.Options)) *kafka.UpdateBrokerStorageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBrokerType(ctx context.Context, params *kafka.UpdateBrokerTypeInput, optFns ...func(*kafka.Options)) (*kafka.UpdateBrokerTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBrokerType")
	}

	var r0 *kafka.UpdateBrokerTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...func(*kafka.Options)) (*kafka.UpdateBrokerTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...func(*kafka.Options)) *kafka.UpdateBrokerTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateClusterConfiguration(ctx context.Context, params *kafka.UpdateClusterConfigurationInput, optFns ...func(*kafka.Options)) (*kafka.UpdateClusterConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClusterConfiguration")
	}

	var r0 *kafka.UpdateClusterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...func(*kafka.Options)) (*kafka.UpdateClusterConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...func(*kafka.Options)) *kafka.UpdateClusterConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterKafkaVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateClusterKafkaVersion(ctx context.Context, params *kafka.UpdateClusterKafkaVersionInput, optFns ...func(*kafka.Options)) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClusterKafkaVersion")
	}

	var r0 *kafka.UpdateClusterKafkaVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...func(*kafka.Options)) (*kafka.UpdateClusterKafkaVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...func(*kafka.Options)) *kafka.UpdateClusterKafkaVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterKafkaVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguration(ctx context.Context, params *kafka.UpdateConfigurationInput, optFns ...func(*kafka.Options)) (*kafka.UpdateConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguration")
	}

	var r0 *kafka.UpdateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConfigurationInput, ...func(*kafka.Options)) (*kafka.UpdateConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConfigurationInput, ...func(*kafka.Options)) *kafka.UpdateConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateConfigurationInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnectivity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConnectivity(ctx context.Context, params *kafka.UpdateConnectivityInput, optFns ...func(*kafka.Options)) (*kafka.UpdateConnectivityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnectivity")
	}

	var r0 *kafka.UpdateConnectivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConnectivityInput, ...func(*kafka.Options)) (*kafka.UpdateConnectivityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConnectivityInput, ...func(*kafka.Options)) *kafka.UpdateConnectivityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConnectivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateConnectivityInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMonitoring provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMonitoring(ctx context.Context, params *kafka.UpdateMonitoringInput, optFns ...func(*kafka.Options)) (*kafka.UpdateMonitoringOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMonitoring")
	}

	var r0 *kafka.UpdateMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateMonitoringInput, ...func(*kafka.Options)) (*kafka.UpdateMonitoringOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateMonitoringInput, ...func(*kafka.Options)) *kafka.UpdateMonitoringOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateMonitoringInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateReplicationInfo provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateReplicationInfo(ctx context.Context, params *kafka.UpdateReplicationInfoInput, optFns ...func(*kafka.Options)) (*kafka.UpdateReplicationInfoOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateReplicationInfo")
	}

	var r0 *kafka.UpdateReplicationInfoOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateReplicationInfoInput, ...func(*kafka.Options)) (*kafka.UpdateReplicationInfoOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateReplicationInfoInput, ...func(*kafka.Options)) *kafka.UpdateReplicationInfoOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateReplicationInfoOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateReplicationInfoInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSecurity(ctx context.Context, params *kafka.UpdateSecurityInput, optFns ...func(*kafka.Options)) (*kafka.UpdateSecurityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurity")
	}

	var r0 *kafka.UpdateSecurityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateSecurityInput, ...func(*kafka.Options)) (*kafka.UpdateSecurityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateSecurityInput, ...func(*kafka.Options)) *kafka.UpdateSecurityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateSecurityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateSecurityInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStorage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateStorage(ctx context.Context, params *kafka.UpdateStorageInput, optFns ...func(*kafka.Options)) (*kafka.UpdateStorageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStorage")
	}

	var r0 *kafka.UpdateStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateStorageInput, ...func(*kafka.Options)) (*kafka.UpdateStorageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateStorageInput, ...func(*kafka.Options)) *kafka.UpdateStorageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateStorageInput, ...func(*kafka.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
