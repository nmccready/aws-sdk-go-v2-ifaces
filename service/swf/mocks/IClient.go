// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	swf "github.com/aws/aws-sdk-go-v2/service/swf"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CountClosedWorkflowExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CountClosedWorkflowExecutions(ctx context.Context, params *swf.CountClosedWorkflowExecutionsInput, optFns ...func(*swf.Options)) (*swf.CountClosedWorkflowExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CountClosedWorkflowExecutions")
	}

	var r0 *swf.CountClosedWorkflowExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountClosedWorkflowExecutionsInput, ...func(*swf.Options)) (*swf.CountClosedWorkflowExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountClosedWorkflowExecutionsInput, ...func(*swf.Options)) *swf.CountClosedWorkflowExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.CountClosedWorkflowExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.CountClosedWorkflowExecutionsInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountOpenWorkflowExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CountOpenWorkflowExecutions(ctx context.Context, params *swf.CountOpenWorkflowExecutionsInput, optFns ...func(*swf.Options)) (*swf.CountOpenWorkflowExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CountOpenWorkflowExecutions")
	}

	var r0 *swf.CountOpenWorkflowExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountOpenWorkflowExecutionsInput, ...func(*swf.Options)) (*swf.CountOpenWorkflowExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountOpenWorkflowExecutionsInput, ...func(*swf.Options)) *swf.CountOpenWorkflowExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.CountOpenWorkflowExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.CountOpenWorkflowExecutionsInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPendingActivityTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CountPendingActivityTasks(ctx context.Context, params *swf.CountPendingActivityTasksInput, optFns ...func(*swf.Options)) (*swf.CountPendingActivityTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CountPendingActivityTasks")
	}

	var r0 *swf.CountPendingActivityTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountPendingActivityTasksInput, ...func(*swf.Options)) (*swf.CountPendingActivityTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountPendingActivityTasksInput, ...func(*swf.Options)) *swf.CountPendingActivityTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.CountPendingActivityTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.CountPendingActivityTasksInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPendingDecisionTasks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CountPendingDecisionTasks(ctx context.Context, params *swf.CountPendingDecisionTasksInput, optFns ...func(*swf.Options)) (*swf.CountPendingDecisionTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CountPendingDecisionTasks")
	}

	var r0 *swf.CountPendingDecisionTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountPendingDecisionTasksInput, ...func(*swf.Options)) (*swf.CountPendingDecisionTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.CountPendingDecisionTasksInput, ...func(*swf.Options)) *swf.CountPendingDecisionTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.CountPendingDecisionTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.CountPendingDecisionTasksInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteActivityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteActivityType(ctx context.Context, params *swf.DeleteActivityTypeInput, optFns ...func(*swf.Options)) (*swf.DeleteActivityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteActivityType")
	}

	var r0 *swf.DeleteActivityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeleteActivityTypeInput, ...func(*swf.Options)) (*swf.DeleteActivityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeleteActivityTypeInput, ...func(*swf.Options)) *swf.DeleteActivityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DeleteActivityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DeleteActivityTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflowType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflowType(ctx context.Context, params *swf.DeleteWorkflowTypeInput, optFns ...func(*swf.Options)) (*swf.DeleteWorkflowTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowType")
	}

	var r0 *swf.DeleteWorkflowTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeleteWorkflowTypeInput, ...func(*swf.Options)) (*swf.DeleteWorkflowTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeleteWorkflowTypeInput, ...func(*swf.Options)) *swf.DeleteWorkflowTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DeleteWorkflowTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DeleteWorkflowTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprecateActivityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprecateActivityType(ctx context.Context, params *swf.DeprecateActivityTypeInput, optFns ...func(*swf.Options)) (*swf.DeprecateActivityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprecateActivityType")
	}

	var r0 *swf.DeprecateActivityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateActivityTypeInput, ...func(*swf.Options)) (*swf.DeprecateActivityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateActivityTypeInput, ...func(*swf.Options)) *swf.DeprecateActivityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DeprecateActivityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DeprecateActivityTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprecateDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprecateDomain(ctx context.Context, params *swf.DeprecateDomainInput, optFns ...func(*swf.Options)) (*swf.DeprecateDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprecateDomain")
	}

	var r0 *swf.DeprecateDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateDomainInput, ...func(*swf.Options)) (*swf.DeprecateDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateDomainInput, ...func(*swf.Options)) *swf.DeprecateDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DeprecateDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DeprecateDomainInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprecateWorkflowType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeprecateWorkflowType(ctx context.Context, params *swf.DeprecateWorkflowTypeInput, optFns ...func(*swf.Options)) (*swf.DeprecateWorkflowTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprecateWorkflowType")
	}

	var r0 *swf.DeprecateWorkflowTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateWorkflowTypeInput, ...func(*swf.Options)) (*swf.DeprecateWorkflowTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DeprecateWorkflowTypeInput, ...func(*swf.Options)) *swf.DeprecateWorkflowTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DeprecateWorkflowTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DeprecateWorkflowTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeActivityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeActivityType(ctx context.Context, params *swf.DescribeActivityTypeInput, optFns ...func(*swf.Options)) (*swf.DescribeActivityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeActivityType")
	}

	var r0 *swf.DescribeActivityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeActivityTypeInput, ...func(*swf.Options)) (*swf.DescribeActivityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeActivityTypeInput, ...func(*swf.Options)) *swf.DescribeActivityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DescribeActivityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DescribeActivityTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDomain(ctx context.Context, params *swf.DescribeDomainInput, optFns ...func(*swf.Options)) (*swf.DescribeDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDomain")
	}

	var r0 *swf.DescribeDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeDomainInput, ...func(*swf.Options)) (*swf.DescribeDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeDomainInput, ...func(*swf.Options)) *swf.DescribeDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DescribeDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DescribeDomainInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorkflowExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorkflowExecution(ctx context.Context, params *swf.DescribeWorkflowExecutionInput, optFns ...func(*swf.Options)) (*swf.DescribeWorkflowExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorkflowExecution")
	}

	var r0 *swf.DescribeWorkflowExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeWorkflowExecutionInput, ...func(*swf.Options)) (*swf.DescribeWorkflowExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeWorkflowExecutionInput, ...func(*swf.Options)) *swf.DescribeWorkflowExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DescribeWorkflowExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DescribeWorkflowExecutionInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorkflowType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorkflowType(ctx context.Context, params *swf.DescribeWorkflowTypeInput, optFns ...func(*swf.Options)) (*swf.DescribeWorkflowTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorkflowType")
	}

	var r0 *swf.DescribeWorkflowTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeWorkflowTypeInput, ...func(*swf.Options)) (*swf.DescribeWorkflowTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.DescribeWorkflowTypeInput, ...func(*swf.Options)) *swf.DescribeWorkflowTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.DescribeWorkflowTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.DescribeWorkflowTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowExecutionHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowExecutionHistory(ctx context.Context, params *swf.GetWorkflowExecutionHistoryInput, optFns ...func(*swf.Options)) (*swf.GetWorkflowExecutionHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowExecutionHistory")
	}

	var r0 *swf.GetWorkflowExecutionHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.GetWorkflowExecutionHistoryInput, ...func(*swf.Options)) (*swf.GetWorkflowExecutionHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.GetWorkflowExecutionHistoryInput, ...func(*swf.Options)) *swf.GetWorkflowExecutionHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.GetWorkflowExecutionHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.GetWorkflowExecutionHistoryInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActivityTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListActivityTypes(ctx context.Context, params *swf.ListActivityTypesInput, optFns ...func(*swf.Options)) (*swf.ListActivityTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListActivityTypes")
	}

	var r0 *swf.ListActivityTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListActivityTypesInput, ...func(*swf.Options)) (*swf.ListActivityTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListActivityTypesInput, ...func(*swf.Options)) *swf.ListActivityTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListActivityTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListActivityTypesInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClosedWorkflowExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListClosedWorkflowExecutions(ctx context.Context, params *swf.ListClosedWorkflowExecutionsInput, optFns ...func(*swf.Options)) (*swf.ListClosedWorkflowExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClosedWorkflowExecutions")
	}

	var r0 *swf.ListClosedWorkflowExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListClosedWorkflowExecutionsInput, ...func(*swf.Options)) (*swf.ListClosedWorkflowExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListClosedWorkflowExecutionsInput, ...func(*swf.Options)) *swf.ListClosedWorkflowExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListClosedWorkflowExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListClosedWorkflowExecutionsInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDomains provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDomains(ctx context.Context, params *swf.ListDomainsInput, optFns ...func(*swf.Options)) (*swf.ListDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDomains")
	}

	var r0 *swf.ListDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListDomainsInput, ...func(*swf.Options)) (*swf.ListDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListDomainsInput, ...func(*swf.Options)) *swf.ListDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListDomainsInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOpenWorkflowExecutions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListOpenWorkflowExecutions(ctx context.Context, params *swf.ListOpenWorkflowExecutionsInput, optFns ...func(*swf.Options)) (*swf.ListOpenWorkflowExecutionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListOpenWorkflowExecutions")
	}

	var r0 *swf.ListOpenWorkflowExecutionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListOpenWorkflowExecutionsInput, ...func(*swf.Options)) (*swf.ListOpenWorkflowExecutionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListOpenWorkflowExecutionsInput, ...func(*swf.Options)) *swf.ListOpenWorkflowExecutionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListOpenWorkflowExecutionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListOpenWorkflowExecutionsInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *swf.ListTagsForResourceInput, optFns ...func(*swf.Options)) (*swf.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *swf.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListTagsForResourceInput, ...func(*swf.Options)) (*swf.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListTagsForResourceInput, ...func(*swf.Options)) *swf.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListTagsForResourceInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflowTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflowTypes(ctx context.Context, params *swf.ListWorkflowTypesInput, optFns ...func(*swf.Options)) (*swf.ListWorkflowTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowTypes")
	}

	var r0 *swf.ListWorkflowTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListWorkflowTypesInput, ...func(*swf.Options)) (*swf.ListWorkflowTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.ListWorkflowTypesInput, ...func(*swf.Options)) *swf.ListWorkflowTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.ListWorkflowTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.ListWorkflowTypesInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() swf.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 swf.Options
	if rf, ok := ret.Get(0).(func() swf.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(swf.Options)
	}

	return r0
}

// PollForActivityTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PollForActivityTask(ctx context.Context, params *swf.PollForActivityTaskInput, optFns ...func(*swf.Options)) (*swf.PollForActivityTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForActivityTask")
	}

	var r0 *swf.PollForActivityTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.PollForActivityTaskInput, ...func(*swf.Options)) (*swf.PollForActivityTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.PollForActivityTaskInput, ...func(*swf.Options)) *swf.PollForActivityTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.PollForActivityTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.PollForActivityTaskInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PollForDecisionTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PollForDecisionTask(ctx context.Context, params *swf.PollForDecisionTaskInput, optFns ...func(*swf.Options)) (*swf.PollForDecisionTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForDecisionTask")
	}

	var r0 *swf.PollForDecisionTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.PollForDecisionTaskInput, ...func(*swf.Options)) (*swf.PollForDecisionTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.PollForDecisionTaskInput, ...func(*swf.Options)) *swf.PollForDecisionTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.PollForDecisionTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.PollForDecisionTaskInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecordActivityTaskHeartbeat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RecordActivityTaskHeartbeat(ctx context.Context, params *swf.RecordActivityTaskHeartbeatInput, optFns ...func(*swf.Options)) (*swf.RecordActivityTaskHeartbeatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RecordActivityTaskHeartbeat")
	}

	var r0 *swf.RecordActivityTaskHeartbeatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RecordActivityTaskHeartbeatInput, ...func(*swf.Options)) (*swf.RecordActivityTaskHeartbeatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RecordActivityTaskHeartbeatInput, ...func(*swf.Options)) *swf.RecordActivityTaskHeartbeatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RecordActivityTaskHeartbeatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RecordActivityTaskHeartbeatInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterActivityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterActivityType(ctx context.Context, params *swf.RegisterActivityTypeInput, optFns ...func(*swf.Options)) (*swf.RegisterActivityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterActivityType")
	}

	var r0 *swf.RegisterActivityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterActivityTypeInput, ...func(*swf.Options)) (*swf.RegisterActivityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterActivityTypeInput, ...func(*swf.Options)) *swf.RegisterActivityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RegisterActivityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RegisterActivityTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterDomain(ctx context.Context, params *swf.RegisterDomainInput, optFns ...func(*swf.Options)) (*swf.RegisterDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterDomain")
	}

	var r0 *swf.RegisterDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterDomainInput, ...func(*swf.Options)) (*swf.RegisterDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterDomainInput, ...func(*swf.Options)) *swf.RegisterDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RegisterDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RegisterDomainInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterWorkflowType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterWorkflowType(ctx context.Context, params *swf.RegisterWorkflowTypeInput, optFns ...func(*swf.Options)) (*swf.RegisterWorkflowTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterWorkflowType")
	}

	var r0 *swf.RegisterWorkflowTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterWorkflowTypeInput, ...func(*swf.Options)) (*swf.RegisterWorkflowTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RegisterWorkflowTypeInput, ...func(*swf.Options)) *swf.RegisterWorkflowTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RegisterWorkflowTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RegisterWorkflowTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestCancelWorkflowExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RequestCancelWorkflowExecution(ctx context.Context, params *swf.RequestCancelWorkflowExecutionInput, optFns ...func(*swf.Options)) (*swf.RequestCancelWorkflowExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestCancelWorkflowExecution")
	}

	var r0 *swf.RequestCancelWorkflowExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RequestCancelWorkflowExecutionInput, ...func(*swf.Options)) (*swf.RequestCancelWorkflowExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RequestCancelWorkflowExecutionInput, ...func(*swf.Options)) *swf.RequestCancelWorkflowExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RequestCancelWorkflowExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RequestCancelWorkflowExecutionInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RespondActivityTaskCanceled provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RespondActivityTaskCanceled(ctx context.Context, params *swf.RespondActivityTaskCanceledInput, optFns ...func(*swf.Options)) (*swf.RespondActivityTaskCanceledOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RespondActivityTaskCanceled")
	}

	var r0 *swf.RespondActivityTaskCanceledOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskCanceledInput, ...func(*swf.Options)) (*swf.RespondActivityTaskCanceledOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskCanceledInput, ...func(*swf.Options)) *swf.RespondActivityTaskCanceledOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RespondActivityTaskCanceledOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RespondActivityTaskCanceledInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RespondActivityTaskCompleted provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RespondActivityTaskCompleted(ctx context.Context, params *swf.RespondActivityTaskCompletedInput, optFns ...func(*swf.Options)) (*swf.RespondActivityTaskCompletedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RespondActivityTaskCompleted")
	}

	var r0 *swf.RespondActivityTaskCompletedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskCompletedInput, ...func(*swf.Options)) (*swf.RespondActivityTaskCompletedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskCompletedInput, ...func(*swf.Options)) *swf.RespondActivityTaskCompletedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RespondActivityTaskCompletedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RespondActivityTaskCompletedInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RespondActivityTaskFailed provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RespondActivityTaskFailed(ctx context.Context, params *swf.RespondActivityTaskFailedInput, optFns ...func(*swf.Options)) (*swf.RespondActivityTaskFailedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RespondActivityTaskFailed")
	}

	var r0 *swf.RespondActivityTaskFailedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskFailedInput, ...func(*swf.Options)) (*swf.RespondActivityTaskFailedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondActivityTaskFailedInput, ...func(*swf.Options)) *swf.RespondActivityTaskFailedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RespondActivityTaskFailedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RespondActivityTaskFailedInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RespondDecisionTaskCompleted provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RespondDecisionTaskCompleted(ctx context.Context, params *swf.RespondDecisionTaskCompletedInput, optFns ...func(*swf.Options)) (*swf.RespondDecisionTaskCompletedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RespondDecisionTaskCompleted")
	}

	var r0 *swf.RespondDecisionTaskCompletedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondDecisionTaskCompletedInput, ...func(*swf.Options)) (*swf.RespondDecisionTaskCompletedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.RespondDecisionTaskCompletedInput, ...func(*swf.Options)) *swf.RespondDecisionTaskCompletedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.RespondDecisionTaskCompletedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.RespondDecisionTaskCompletedInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignalWorkflowExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SignalWorkflowExecution(ctx context.Context, params *swf.SignalWorkflowExecutionInput, optFns ...func(*swf.Options)) (*swf.SignalWorkflowExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SignalWorkflowExecution")
	}

	var r0 *swf.SignalWorkflowExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.SignalWorkflowExecutionInput, ...func(*swf.Options)) (*swf.SignalWorkflowExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.SignalWorkflowExecutionInput, ...func(*swf.Options)) *swf.SignalWorkflowExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.SignalWorkflowExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.SignalWorkflowExecutionInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartWorkflowExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartWorkflowExecution(ctx context.Context, params *swf.StartWorkflowExecutionInput, optFns ...func(*swf.Options)) (*swf.StartWorkflowExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartWorkflowExecution")
	}

	var r0 *swf.StartWorkflowExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.StartWorkflowExecutionInput, ...func(*swf.Options)) (*swf.StartWorkflowExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.StartWorkflowExecutionInput, ...func(*swf.Options)) *swf.StartWorkflowExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.StartWorkflowExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.StartWorkflowExecutionInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *swf.TagResourceInput, optFns ...func(*swf.Options)) (*swf.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *swf.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.TagResourceInput, ...func(*swf.Options)) (*swf.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.TagResourceInput, ...func(*swf.Options)) *swf.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.TagResourceInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateWorkflowExecution provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateWorkflowExecution(ctx context.Context, params *swf.TerminateWorkflowExecutionInput, optFns ...func(*swf.Options)) (*swf.TerminateWorkflowExecutionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateWorkflowExecution")
	}

	var r0 *swf.TerminateWorkflowExecutionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.TerminateWorkflowExecutionInput, ...func(*swf.Options)) (*swf.TerminateWorkflowExecutionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.TerminateWorkflowExecutionInput, ...func(*swf.Options)) *swf.TerminateWorkflowExecutionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.TerminateWorkflowExecutionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.TerminateWorkflowExecutionInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UndeprecateActivityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UndeprecateActivityType(ctx context.Context, params *swf.UndeprecateActivityTypeInput, optFns ...func(*swf.Options)) (*swf.UndeprecateActivityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UndeprecateActivityType")
	}

	var r0 *swf.UndeprecateActivityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateActivityTypeInput, ...func(*swf.Options)) (*swf.UndeprecateActivityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateActivityTypeInput, ...func(*swf.Options)) *swf.UndeprecateActivityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.UndeprecateActivityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.UndeprecateActivityTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UndeprecateDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UndeprecateDomain(ctx context.Context, params *swf.UndeprecateDomainInput, optFns ...func(*swf.Options)) (*swf.UndeprecateDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UndeprecateDomain")
	}

	var r0 *swf.UndeprecateDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateDomainInput, ...func(*swf.Options)) (*swf.UndeprecateDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateDomainInput, ...func(*swf.Options)) *swf.UndeprecateDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.UndeprecateDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.UndeprecateDomainInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UndeprecateWorkflowType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UndeprecateWorkflowType(ctx context.Context, params *swf.UndeprecateWorkflowTypeInput, optFns ...func(*swf.Options)) (*swf.UndeprecateWorkflowTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UndeprecateWorkflowType")
	}

	var r0 *swf.UndeprecateWorkflowTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateWorkflowTypeInput, ...func(*swf.Options)) (*swf.UndeprecateWorkflowTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UndeprecateWorkflowTypeInput, ...func(*swf.Options)) *swf.UndeprecateWorkflowTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.UndeprecateWorkflowTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.UndeprecateWorkflowTypeInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *swf.UntagResourceInput, optFns ...func(*swf.Options)) (*swf.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *swf.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UntagResourceInput, ...func(*swf.Options)) (*swf.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *swf.UntagResourceInput, ...func(*swf.Options)) *swf.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*swf.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *swf.UntagResourceInput, ...func(*swf.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
