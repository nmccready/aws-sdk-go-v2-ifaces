// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	codecatalyst "github.com/aws/aws-sdk-go-v2/service/codecatalyst"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessToken(ctx context.Context, params *codecatalyst.CreateAccessTokenInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.CreateAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessToken")
	}

	var r0 *codecatalyst.CreateAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateAccessTokenInput, ...func(*codecatalyst.Options)) (*codecatalyst.CreateAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateAccessTokenInput, ...func(*codecatalyst.Options)) *codecatalyst.CreateAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.CreateAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.CreateAccessTokenInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDevEnvironment(ctx context.Context, params *codecatalyst.CreateDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.CreateDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDevEnvironment")
	}

	var r0 *codecatalyst.CreateDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.CreateDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.CreateDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.CreateDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.CreateDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProject(ctx context.Context, params *codecatalyst.CreateProjectInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.CreateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *codecatalyst.CreateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateProjectInput, ...func(*codecatalyst.Options)) (*codecatalyst.CreateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateProjectInput, ...func(*codecatalyst.Options)) *codecatalyst.CreateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.CreateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.CreateProjectInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSourceRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSourceRepository(ctx context.Context, params *codecatalyst.CreateSourceRepositoryInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.CreateSourceRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSourceRepository")
	}

	var r0 *codecatalyst.CreateSourceRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateSourceRepositoryInput, ...func(*codecatalyst.Options)) (*codecatalyst.CreateSourceRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateSourceRepositoryInput, ...func(*codecatalyst.Options)) *codecatalyst.CreateSourceRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.CreateSourceRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.CreateSourceRepositoryInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSourceRepositoryBranch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSourceRepositoryBranch(ctx context.Context, params *codecatalyst.CreateSourceRepositoryBranchInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.CreateSourceRepositoryBranchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSourceRepositoryBranch")
	}

	var r0 *codecatalyst.CreateSourceRepositoryBranchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateSourceRepositoryBranchInput, ...func(*codecatalyst.Options)) (*codecatalyst.CreateSourceRepositoryBranchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.CreateSourceRepositoryBranchInput, ...func(*codecatalyst.Options)) *codecatalyst.CreateSourceRepositoryBranchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.CreateSourceRepositoryBranchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.CreateSourceRepositoryBranchInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessToken provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccessToken(ctx context.Context, params *codecatalyst.DeleteAccessTokenInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.DeleteAccessTokenOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessToken")
	}

	var r0 *codecatalyst.DeleteAccessTokenOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteAccessTokenInput, ...func(*codecatalyst.Options)) (*codecatalyst.DeleteAccessTokenOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteAccessTokenInput, ...func(*codecatalyst.Options)) *codecatalyst.DeleteAccessTokenOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.DeleteAccessTokenOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.DeleteAccessTokenInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDevEnvironment(ctx context.Context, params *codecatalyst.DeleteDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.DeleteDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDevEnvironment")
	}

	var r0 *codecatalyst.DeleteDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.DeleteDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.DeleteDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.DeleteDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.DeleteDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProject(ctx context.Context, params *codecatalyst.DeleteProjectInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.DeleteProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *codecatalyst.DeleteProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteProjectInput, ...func(*codecatalyst.Options)) (*codecatalyst.DeleteProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteProjectInput, ...func(*codecatalyst.Options)) *codecatalyst.DeleteProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.DeleteProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.DeleteProjectInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSourceRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSourceRepository(ctx context.Context, params *codecatalyst.DeleteSourceRepositoryInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.DeleteSourceRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSourceRepository")
	}

	var r0 *codecatalyst.DeleteSourceRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteSourceRepositoryInput, ...func(*codecatalyst.Options)) (*codecatalyst.DeleteSourceRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteSourceRepositoryInput, ...func(*codecatalyst.Options)) *codecatalyst.DeleteSourceRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.DeleteSourceRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.DeleteSourceRepositoryInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSpace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSpace(ctx context.Context, params *codecatalyst.DeleteSpaceInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.DeleteSpaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSpace")
	}

	var r0 *codecatalyst.DeleteSpaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteSpaceInput, ...func(*codecatalyst.Options)) (*codecatalyst.DeleteSpaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.DeleteSpaceInput, ...func(*codecatalyst.Options)) *codecatalyst.DeleteSpaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.DeleteSpaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.DeleteSpaceInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDevEnvironment(ctx context.Context, params *codecatalyst.GetDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDevEnvironment")
	}

	var r0 *codecatalyst.GetDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.GetDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetProject(ctx context.Context, params *codecatalyst.GetProjectInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *codecatalyst.GetProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetProjectInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetProjectInput, ...func(*codecatalyst.Options)) *codecatalyst.GetProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetProjectInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSourceRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSourceRepository(ctx context.Context, params *codecatalyst.GetSourceRepositoryInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetSourceRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSourceRepository")
	}

	var r0 *codecatalyst.GetSourceRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSourceRepositoryInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetSourceRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSourceRepositoryInput, ...func(*codecatalyst.Options)) *codecatalyst.GetSourceRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetSourceRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetSourceRepositoryInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSourceRepositoryCloneUrls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSourceRepositoryCloneUrls(ctx context.Context, params *codecatalyst.GetSourceRepositoryCloneUrlsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetSourceRepositoryCloneUrlsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSourceRepositoryCloneUrls")
	}

	var r0 *codecatalyst.GetSourceRepositoryCloneUrlsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSourceRepositoryCloneUrlsInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetSourceRepositoryCloneUrlsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSourceRepositoryCloneUrlsInput, ...func(*codecatalyst.Options)) *codecatalyst.GetSourceRepositoryCloneUrlsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetSourceRepositoryCloneUrlsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetSourceRepositoryCloneUrlsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSpace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSpace(ctx context.Context, params *codecatalyst.GetSpaceInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetSpaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSpace")
	}

	var r0 *codecatalyst.GetSpaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSpaceInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetSpaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSpaceInput, ...func(*codecatalyst.Options)) *codecatalyst.GetSpaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetSpaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetSpaceInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSubscription(ctx context.Context, params *codecatalyst.GetSubscriptionInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscription")
	}

	var r0 *codecatalyst.GetSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSubscriptionInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetSubscriptionInput, ...func(*codecatalyst.Options)) *codecatalyst.GetSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetSubscriptionInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUserDetails(ctx context.Context, params *codecatalyst.GetUserDetailsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetUserDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDetails")
	}

	var r0 *codecatalyst.GetUserDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetUserDetailsInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetUserDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetUserDetailsInput, ...func(*codecatalyst.Options)) *codecatalyst.GetUserDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetUserDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetUserDetailsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflow(ctx context.Context, params *codecatalyst.GetWorkflowInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *codecatalyst.GetWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetWorkflowInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetWorkflowInput, ...func(*codecatalyst.Options)) *codecatalyst.GetWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetWorkflowInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowRun(ctx context.Context, params *codecatalyst.GetWorkflowRunInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.GetWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRun")
	}

	var r0 *codecatalyst.GetWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetWorkflowRunInput, ...func(*codecatalyst.Options)) (*codecatalyst.GetWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.GetWorkflowRunInput, ...func(*codecatalyst.Options)) *codecatalyst.GetWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.GetWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.GetWorkflowRunInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessTokens provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessTokens(ctx context.Context, params *codecatalyst.ListAccessTokensInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListAccessTokensOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessTokens")
	}

	var r0 *codecatalyst.ListAccessTokensOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListAccessTokensInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListAccessTokensOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListAccessTokensInput, ...func(*codecatalyst.Options)) *codecatalyst.ListAccessTokensOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListAccessTokensOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListAccessTokensInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDevEnvironmentSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDevEnvironmentSessions(ctx context.Context, params *codecatalyst.ListDevEnvironmentSessionsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListDevEnvironmentSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevEnvironmentSessions")
	}

	var r0 *codecatalyst.ListDevEnvironmentSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListDevEnvironmentSessionsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListDevEnvironmentSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListDevEnvironmentSessionsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListDevEnvironmentSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListDevEnvironmentSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListDevEnvironmentSessionsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDevEnvironments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDevEnvironments(ctx context.Context, params *codecatalyst.ListDevEnvironmentsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListDevEnvironmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevEnvironments")
	}

	var r0 *codecatalyst.ListDevEnvironmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListDevEnvironmentsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListDevEnvironmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListDevEnvironmentsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListDevEnvironmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListDevEnvironmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListDevEnvironmentsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventLogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventLogs(ctx context.Context, params *codecatalyst.ListEventLogsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListEventLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventLogs")
	}

	var r0 *codecatalyst.ListEventLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListEventLogsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListEventLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListEventLogsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListEventLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListEventLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListEventLogsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProjects(ctx context.Context, params *codecatalyst.ListProjectsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 *codecatalyst.ListProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListProjectsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListProjectsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListProjectsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSourceRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSourceRepositories(ctx context.Context, params *codecatalyst.ListSourceRepositoriesInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListSourceRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSourceRepositories")
	}

	var r0 *codecatalyst.ListSourceRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSourceRepositoriesInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListSourceRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSourceRepositoriesInput, ...func(*codecatalyst.Options)) *codecatalyst.ListSourceRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListSourceRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListSourceRepositoriesInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSourceRepositoryBranches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSourceRepositoryBranches(ctx context.Context, params *codecatalyst.ListSourceRepositoryBranchesInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListSourceRepositoryBranchesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSourceRepositoryBranches")
	}

	var r0 *codecatalyst.ListSourceRepositoryBranchesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSourceRepositoryBranchesInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListSourceRepositoryBranchesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSourceRepositoryBranchesInput, ...func(*codecatalyst.Options)) *codecatalyst.ListSourceRepositoryBranchesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListSourceRepositoryBranchesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListSourceRepositoryBranchesInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSpaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSpaces(ctx context.Context, params *codecatalyst.ListSpacesInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListSpacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSpaces")
	}

	var r0 *codecatalyst.ListSpacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSpacesInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListSpacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListSpacesInput, ...func(*codecatalyst.Options)) *codecatalyst.ListSpacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListSpacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListSpacesInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflowRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflowRuns(ctx context.Context, params *codecatalyst.ListWorkflowRunsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListWorkflowRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowRuns")
	}

	var r0 *codecatalyst.ListWorkflowRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListWorkflowRunsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListWorkflowRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListWorkflowRunsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListWorkflowRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListWorkflowRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListWorkflowRunsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflows(ctx context.Context, params *codecatalyst.ListWorkflowsInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.ListWorkflowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *codecatalyst.ListWorkflowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListWorkflowsInput, ...func(*codecatalyst.Options)) (*codecatalyst.ListWorkflowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.ListWorkflowsInput, ...func(*codecatalyst.Options)) *codecatalyst.ListWorkflowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.ListWorkflowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.ListWorkflowsInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() codecatalyst.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 codecatalyst.Options
	if rf, ok := ret.Get(0).(func() codecatalyst.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(codecatalyst.Options)
	}

	return r0
}

// StartDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDevEnvironment(ctx context.Context, params *codecatalyst.StartDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.StartDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDevEnvironment")
	}

	var r0 *codecatalyst.StartDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.StartDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.StartDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.StartDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.StartDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDevEnvironmentSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDevEnvironmentSession(ctx context.Context, params *codecatalyst.StartDevEnvironmentSessionInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.StartDevEnvironmentSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDevEnvironmentSession")
	}

	var r0 *codecatalyst.StartDevEnvironmentSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) (*codecatalyst.StartDevEnvironmentSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) *codecatalyst.StartDevEnvironmentSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.StartDevEnvironmentSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.StartDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartWorkflowRun(ctx context.Context, params *codecatalyst.StartWorkflowRunInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.StartWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartWorkflowRun")
	}

	var r0 *codecatalyst.StartWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartWorkflowRunInput, ...func(*codecatalyst.Options)) (*codecatalyst.StartWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StartWorkflowRunInput, ...func(*codecatalyst.Options)) *codecatalyst.StartWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.StartWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.StartWorkflowRunInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopDevEnvironment(ctx context.Context, params *codecatalyst.StopDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.StopDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopDevEnvironment")
	}

	var r0 *codecatalyst.StopDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StopDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.StopDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StopDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.StopDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.StopDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.StopDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopDevEnvironmentSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopDevEnvironmentSession(ctx context.Context, params *codecatalyst.StopDevEnvironmentSessionInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.StopDevEnvironmentSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopDevEnvironmentSession")
	}

	var r0 *codecatalyst.StopDevEnvironmentSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StopDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) (*codecatalyst.StopDevEnvironmentSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.StopDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) *codecatalyst.StopDevEnvironmentSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.StopDevEnvironmentSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.StopDevEnvironmentSessionInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDevEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDevEnvironment(ctx context.Context, params *codecatalyst.UpdateDevEnvironmentInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.UpdateDevEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDevEnvironment")
	}

	var r0 *codecatalyst.UpdateDevEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateDevEnvironmentInput, ...func(*codecatalyst.Options)) (*codecatalyst.UpdateDevEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateDevEnvironmentInput, ...func(*codecatalyst.Options)) *codecatalyst.UpdateDevEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.UpdateDevEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.UpdateDevEnvironmentInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProject(ctx context.Context, params *codecatalyst.UpdateProjectInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.UpdateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 *codecatalyst.UpdateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateProjectInput, ...func(*codecatalyst.Options)) (*codecatalyst.UpdateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateProjectInput, ...func(*codecatalyst.Options)) *codecatalyst.UpdateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.UpdateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.UpdateProjectInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSpace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSpace(ctx context.Context, params *codecatalyst.UpdateSpaceInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.UpdateSpaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSpace")
	}

	var r0 *codecatalyst.UpdateSpaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateSpaceInput, ...func(*codecatalyst.Options)) (*codecatalyst.UpdateSpaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.UpdateSpaceInput, ...func(*codecatalyst.Options)) *codecatalyst.UpdateSpaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.UpdateSpaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.UpdateSpaceInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifySession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) VerifySession(ctx context.Context, params *codecatalyst.VerifySessionInput, optFns ...func(*codecatalyst.Options)) (*codecatalyst.VerifySessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifySession")
	}

	var r0 *codecatalyst.VerifySessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.VerifySessionInput, ...func(*codecatalyst.Options)) (*codecatalyst.VerifySessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecatalyst.VerifySessionInput, ...func(*codecatalyst.Options)) *codecatalyst.VerifySessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecatalyst.VerifySessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecatalyst.VerifySessionInput, ...func(*codecatalyst.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
