// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	codecommit "github.com/aws/aws-sdk-go-v2/service/codecommit"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateApprovalRuleTemplateWithRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateApprovalRuleTemplateWithRepository(ctx context.Context, params *codecommit.AssociateApprovalRuleTemplateWithRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.AssociateApprovalRuleTemplateWithRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateApprovalRuleTemplateWithRepository")
	}

	var r0 *codecommit.AssociateApprovalRuleTemplateWithRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.AssociateApprovalRuleTemplateWithRepositoryInput, ...func(*codecommit.Options)) (*codecommit.AssociateApprovalRuleTemplateWithRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.AssociateApprovalRuleTemplateWithRepositoryInput, ...func(*codecommit.Options)) *codecommit.AssociateApprovalRuleTemplateWithRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.AssociateApprovalRuleTemplateWithRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.AssociateApprovalRuleTemplateWithRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchAssociateApprovalRuleTemplateWithRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchAssociateApprovalRuleTemplateWithRepositories(ctx context.Context, params *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesInput, optFns ...func(*codecommit.Options)) (*codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchAssociateApprovalRuleTemplateWithRepositories")
	}

	var r0 *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesInput, ...func(*codecommit.Options)) (*codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesInput, ...func(*codecommit.Options)) *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.BatchAssociateApprovalRuleTemplateWithRepositoriesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDescribeMergeConflicts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDescribeMergeConflicts(ctx context.Context, params *codecommit.BatchDescribeMergeConflictsInput, optFns ...func(*codecommit.Options)) (*codecommit.BatchDescribeMergeConflictsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDescribeMergeConflicts")
	}

	var r0 *codecommit.BatchDescribeMergeConflictsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchDescribeMergeConflictsInput, ...func(*codecommit.Options)) (*codecommit.BatchDescribeMergeConflictsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchDescribeMergeConflictsInput, ...func(*codecommit.Options)) *codecommit.BatchDescribeMergeConflictsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.BatchDescribeMergeConflictsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.BatchDescribeMergeConflictsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDisassociateApprovalRuleTemplateFromRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDisassociateApprovalRuleTemplateFromRepositories(ctx context.Context, params *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, optFns ...func(*codecommit.Options)) (*codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDisassociateApprovalRuleTemplateFromRepositories")
	}

	var r0 *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, ...func(*codecommit.Options)) (*codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, ...func(*codecommit.Options)) *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetCommits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetCommits(ctx context.Context, params *codecommit.BatchGetCommitsInput, optFns ...func(*codecommit.Options)) (*codecommit.BatchGetCommitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetCommits")
	}

	var r0 *codecommit.BatchGetCommitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchGetCommitsInput, ...func(*codecommit.Options)) (*codecommit.BatchGetCommitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchGetCommitsInput, ...func(*codecommit.Options)) *codecommit.BatchGetCommitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.BatchGetCommitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.BatchGetCommitsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetRepositories(ctx context.Context, params *codecommit.BatchGetRepositoriesInput, optFns ...func(*codecommit.Options)) (*codecommit.BatchGetRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetRepositories")
	}

	var r0 *codecommit.BatchGetRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchGetRepositoriesInput, ...func(*codecommit.Options)) (*codecommit.BatchGetRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.BatchGetRepositoriesInput, ...func(*codecommit.Options)) *codecommit.BatchGetRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.BatchGetRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.BatchGetRepositoriesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateApprovalRuleTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApprovalRuleTemplate(ctx context.Context, params *codecommit.CreateApprovalRuleTemplateInput, optFns ...func(*codecommit.Options)) (*codecommit.CreateApprovalRuleTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApprovalRuleTemplate")
	}

	var r0 *codecommit.CreateApprovalRuleTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateApprovalRuleTemplateInput, ...func(*codecommit.Options)) (*codecommit.CreateApprovalRuleTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateApprovalRuleTemplateInput, ...func(*codecommit.Options)) *codecommit.CreateApprovalRuleTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreateApprovalRuleTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreateApprovalRuleTemplateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBranch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBranch(ctx context.Context, params *codecommit.CreateBranchInput, optFns ...func(*codecommit.Options)) (*codecommit.CreateBranchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranch")
	}

	var r0 *codecommit.CreateBranchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateBranchInput, ...func(*codecommit.Options)) (*codecommit.CreateBranchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateBranchInput, ...func(*codecommit.Options)) *codecommit.CreateBranchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreateBranchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreateBranchInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCommit(ctx context.Context, params *codecommit.CreateCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.CreateCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCommit")
	}

	var r0 *codecommit.CreateCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateCommitInput, ...func(*codecommit.Options)) (*codecommit.CreateCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateCommitInput, ...func(*codecommit.Options)) *codecommit.CreateCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreateCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreateCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePullRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePullRequest(ctx context.Context, params *codecommit.CreatePullRequestInput, optFns ...func(*codecommit.Options)) (*codecommit.CreatePullRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePullRequest")
	}

	var r0 *codecommit.CreatePullRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreatePullRequestInput, ...func(*codecommit.Options)) (*codecommit.CreatePullRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreatePullRequestInput, ...func(*codecommit.Options)) *codecommit.CreatePullRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreatePullRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreatePullRequestInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePullRequestApprovalRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePullRequestApprovalRule(ctx context.Context, params *codecommit.CreatePullRequestApprovalRuleInput, optFns ...func(*codecommit.Options)) (*codecommit.CreatePullRequestApprovalRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePullRequestApprovalRule")
	}

	var r0 *codecommit.CreatePullRequestApprovalRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreatePullRequestApprovalRuleInput, ...func(*codecommit.Options)) (*codecommit.CreatePullRequestApprovalRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreatePullRequestApprovalRuleInput, ...func(*codecommit.Options)) *codecommit.CreatePullRequestApprovalRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreatePullRequestApprovalRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreatePullRequestApprovalRuleInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRepository(ctx context.Context, params *codecommit.CreateRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.CreateRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepository")
	}

	var r0 *codecommit.CreateRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateRepositoryInput, ...func(*codecommit.Options)) (*codecommit.CreateRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateRepositoryInput, ...func(*codecommit.Options)) *codecommit.CreateRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreateRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreateRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUnreferencedMergeCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUnreferencedMergeCommit(ctx context.Context, params *codecommit.CreateUnreferencedMergeCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.CreateUnreferencedMergeCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUnreferencedMergeCommit")
	}

	var r0 *codecommit.CreateUnreferencedMergeCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateUnreferencedMergeCommitInput, ...func(*codecommit.Options)) (*codecommit.CreateUnreferencedMergeCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.CreateUnreferencedMergeCommitInput, ...func(*codecommit.Options)) *codecommit.CreateUnreferencedMergeCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.CreateUnreferencedMergeCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.CreateUnreferencedMergeCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApprovalRuleTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApprovalRuleTemplate(ctx context.Context, params *codecommit.DeleteApprovalRuleTemplateInput, optFns ...func(*codecommit.Options)) (*codecommit.DeleteApprovalRuleTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApprovalRuleTemplate")
	}

	var r0 *codecommit.DeleteApprovalRuleTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteApprovalRuleTemplateInput, ...func(*codecommit.Options)) (*codecommit.DeleteApprovalRuleTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteApprovalRuleTemplateInput, ...func(*codecommit.Options)) *codecommit.DeleteApprovalRuleTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeleteApprovalRuleTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeleteApprovalRuleTemplateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBranch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBranch(ctx context.Context, params *codecommit.DeleteBranchInput, optFns ...func(*codecommit.Options)) (*codecommit.DeleteBranchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranch")
	}

	var r0 *codecommit.DeleteBranchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteBranchInput, ...func(*codecommit.Options)) (*codecommit.DeleteBranchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteBranchInput, ...func(*codecommit.Options)) *codecommit.DeleteBranchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeleteBranchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeleteBranchInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCommentContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCommentContent(ctx context.Context, params *codecommit.DeleteCommentContentInput, optFns ...func(*codecommit.Options)) (*codecommit.DeleteCommentContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCommentContent")
	}

	var r0 *codecommit.DeleteCommentContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteCommentContentInput, ...func(*codecommit.Options)) (*codecommit.DeleteCommentContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteCommentContentInput, ...func(*codecommit.Options)) *codecommit.DeleteCommentContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeleteCommentContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeleteCommentContentInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFile(ctx context.Context, params *codecommit.DeleteFileInput, optFns ...func(*codecommit.Options)) (*codecommit.DeleteFileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 *codecommit.DeleteFileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteFileInput, ...func(*codecommit.Options)) (*codecommit.DeleteFileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteFileInput, ...func(*codecommit.Options)) *codecommit.DeleteFileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeleteFileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeleteFileInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePullRequestApprovalRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePullRequestApprovalRule(ctx context.Context, params *codecommit.DeletePullRequestApprovalRuleInput, optFns ...func(*codecommit.Options)) (*codecommit.DeletePullRequestApprovalRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePullRequestApprovalRule")
	}

	var r0 *codecommit.DeletePullRequestApprovalRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeletePullRequestApprovalRuleInput, ...func(*codecommit.Options)) (*codecommit.DeletePullRequestApprovalRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeletePullRequestApprovalRuleInput, ...func(*codecommit.Options)) *codecommit.DeletePullRequestApprovalRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeletePullRequestApprovalRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeletePullRequestApprovalRuleInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRepository(ctx context.Context, params *codecommit.DeleteRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.DeleteRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepository")
	}

	var r0 *codecommit.DeleteRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteRepositoryInput, ...func(*codecommit.Options)) (*codecommit.DeleteRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DeleteRepositoryInput, ...func(*codecommit.Options)) *codecommit.DeleteRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DeleteRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DeleteRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMergeConflicts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeMergeConflicts(ctx context.Context, params *codecommit.DescribeMergeConflictsInput, optFns ...func(*codecommit.Options)) (*codecommit.DescribeMergeConflictsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMergeConflicts")
	}

	var r0 *codecommit.DescribeMergeConflictsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DescribeMergeConflictsInput, ...func(*codecommit.Options)) (*codecommit.DescribeMergeConflictsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DescribeMergeConflictsInput, ...func(*codecommit.Options)) *codecommit.DescribeMergeConflictsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DescribeMergeConflictsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DescribeMergeConflictsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePullRequestEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePullRequestEvents(ctx context.Context, params *codecommit.DescribePullRequestEventsInput, optFns ...func(*codecommit.Options)) (*codecommit.DescribePullRequestEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePullRequestEvents")
	}

	var r0 *codecommit.DescribePullRequestEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DescribePullRequestEventsInput, ...func(*codecommit.Options)) (*codecommit.DescribePullRequestEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DescribePullRequestEventsInput, ...func(*codecommit.Options)) *codecommit.DescribePullRequestEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DescribePullRequestEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DescribePullRequestEventsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateApprovalRuleTemplateFromRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateApprovalRuleTemplateFromRepository(ctx context.Context, params *codecommit.DisassociateApprovalRuleTemplateFromRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.DisassociateApprovalRuleTemplateFromRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateApprovalRuleTemplateFromRepository")
	}

	var r0 *codecommit.DisassociateApprovalRuleTemplateFromRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DisassociateApprovalRuleTemplateFromRepositoryInput, ...func(*codecommit.Options)) (*codecommit.DisassociateApprovalRuleTemplateFromRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.DisassociateApprovalRuleTemplateFromRepositoryInput, ...func(*codecommit.Options)) *codecommit.DisassociateApprovalRuleTemplateFromRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.DisassociateApprovalRuleTemplateFromRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.DisassociateApprovalRuleTemplateFromRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvaluatePullRequestApprovalRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EvaluatePullRequestApprovalRules(ctx context.Context, params *codecommit.EvaluatePullRequestApprovalRulesInput, optFns ...func(*codecommit.Options)) (*codecommit.EvaluatePullRequestApprovalRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvaluatePullRequestApprovalRules")
	}

	var r0 *codecommit.EvaluatePullRequestApprovalRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.EvaluatePullRequestApprovalRulesInput, ...func(*codecommit.Options)) (*codecommit.EvaluatePullRequestApprovalRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.EvaluatePullRequestApprovalRulesInput, ...func(*codecommit.Options)) *codecommit.EvaluatePullRequestApprovalRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.EvaluatePullRequestApprovalRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.EvaluatePullRequestApprovalRulesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApprovalRuleTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetApprovalRuleTemplate(ctx context.Context, params *codecommit.GetApprovalRuleTemplateInput, optFns ...func(*codecommit.Options)) (*codecommit.GetApprovalRuleTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApprovalRuleTemplate")
	}

	var r0 *codecommit.GetApprovalRuleTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetApprovalRuleTemplateInput, ...func(*codecommit.Options)) (*codecommit.GetApprovalRuleTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetApprovalRuleTemplateInput, ...func(*codecommit.Options)) *codecommit.GetApprovalRuleTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetApprovalRuleTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetApprovalRuleTemplateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlob(ctx context.Context, params *codecommit.GetBlobInput, optFns ...func(*codecommit.Options)) (*codecommit.GetBlobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlob")
	}

	var r0 *codecommit.GetBlobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetBlobInput, ...func(*codecommit.Options)) (*codecommit.GetBlobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetBlobInput, ...func(*codecommit.Options)) *codecommit.GetBlobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetBlobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetBlobInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBranch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBranch(ctx context.Context, params *codecommit.GetBranchInput, optFns ...func(*codecommit.Options)) (*codecommit.GetBranchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBranch")
	}

	var r0 *codecommit.GetBranchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetBranchInput, ...func(*codecommit.Options)) (*codecommit.GetBranchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetBranchInput, ...func(*codecommit.Options)) *codecommit.GetBranchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetBranchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetBranchInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetComment(ctx context.Context, params *codecommit.GetCommentInput, optFns ...func(*codecommit.Options)) (*codecommit.GetCommentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetComment")
	}

	var r0 *codecommit.GetCommentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentInput, ...func(*codecommit.Options)) (*codecommit.GetCommentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentInput, ...func(*codecommit.Options)) *codecommit.GetCommentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetCommentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetCommentInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommentReactions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCommentReactions(ctx context.Context, params *codecommit.GetCommentReactionsInput, optFns ...func(*codecommit.Options)) (*codecommit.GetCommentReactionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommentReactions")
	}

	var r0 *codecommit.GetCommentReactionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentReactionsInput, ...func(*codecommit.Options)) (*codecommit.GetCommentReactionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentReactionsInput, ...func(*codecommit.Options)) *codecommit.GetCommentReactionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetCommentReactionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetCommentReactionsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommentsForComparedCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCommentsForComparedCommit(ctx context.Context, params *codecommit.GetCommentsForComparedCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.GetCommentsForComparedCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommentsForComparedCommit")
	}

	var r0 *codecommit.GetCommentsForComparedCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentsForComparedCommitInput, ...func(*codecommit.Options)) (*codecommit.GetCommentsForComparedCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentsForComparedCommitInput, ...func(*codecommit.Options)) *codecommit.GetCommentsForComparedCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetCommentsForComparedCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetCommentsForComparedCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommentsForPullRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCommentsForPullRequest(ctx context.Context, params *codecommit.GetCommentsForPullRequestInput, optFns ...func(*codecommit.Options)) (*codecommit.GetCommentsForPullRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommentsForPullRequest")
	}

	var r0 *codecommit.GetCommentsForPullRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentsForPullRequestInput, ...func(*codecommit.Options)) (*codecommit.GetCommentsForPullRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommentsForPullRequestInput, ...func(*codecommit.Options)) *codecommit.GetCommentsForPullRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetCommentsForPullRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetCommentsForPullRequestInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCommit(ctx context.Context, params *codecommit.GetCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.GetCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommit")
	}

	var r0 *codecommit.GetCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommitInput, ...func(*codecommit.Options)) (*codecommit.GetCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetCommitInput, ...func(*codecommit.Options)) *codecommit.GetCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDifferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDifferences(ctx context.Context, params *codecommit.GetDifferencesInput, optFns ...func(*codecommit.Options)) (*codecommit.GetDifferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDifferences")
	}

	var r0 *codecommit.GetDifferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetDifferencesInput, ...func(*codecommit.Options)) (*codecommit.GetDifferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetDifferencesInput, ...func(*codecommit.Options)) *codecommit.GetDifferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetDifferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetDifferencesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFile(ctx context.Context, params *codecommit.GetFileInput, optFns ...func(*codecommit.Options)) (*codecommit.GetFileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFile")
	}

	var r0 *codecommit.GetFileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetFileInput, ...func(*codecommit.Options)) (*codecommit.GetFileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetFileInput, ...func(*codecommit.Options)) *codecommit.GetFileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetFileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetFileInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFolder provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFolder(ctx context.Context, params *codecommit.GetFolderInput, optFns ...func(*codecommit.Options)) (*codecommit.GetFolderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFolder")
	}

	var r0 *codecommit.GetFolderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetFolderInput, ...func(*codecommit.Options)) (*codecommit.GetFolderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetFolderInput, ...func(*codecommit.Options)) *codecommit.GetFolderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetFolderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetFolderInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMergeCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMergeCommit(ctx context.Context, params *codecommit.GetMergeCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.GetMergeCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeCommit")
	}

	var r0 *codecommit.GetMergeCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeCommitInput, ...func(*codecommit.Options)) (*codecommit.GetMergeCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeCommitInput, ...func(*codecommit.Options)) *codecommit.GetMergeCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetMergeCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetMergeCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMergeConflicts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMergeConflicts(ctx context.Context, params *codecommit.GetMergeConflictsInput, optFns ...func(*codecommit.Options)) (*codecommit.GetMergeConflictsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeConflicts")
	}

	var r0 *codecommit.GetMergeConflictsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeConflictsInput, ...func(*codecommit.Options)) (*codecommit.GetMergeConflictsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeConflictsInput, ...func(*codecommit.Options)) *codecommit.GetMergeConflictsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetMergeConflictsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetMergeConflictsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMergeOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMergeOptions(ctx context.Context, params *codecommit.GetMergeOptionsInput, optFns ...func(*codecommit.Options)) (*codecommit.GetMergeOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeOptions")
	}

	var r0 *codecommit.GetMergeOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeOptionsInput, ...func(*codecommit.Options)) (*codecommit.GetMergeOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetMergeOptionsInput, ...func(*codecommit.Options)) *codecommit.GetMergeOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetMergeOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetMergeOptionsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPullRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPullRequest(ctx context.Context, params *codecommit.GetPullRequestInput, optFns ...func(*codecommit.Options)) (*codecommit.GetPullRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPullRequest")
	}

	var r0 *codecommit.GetPullRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestInput, ...func(*codecommit.Options)) (*codecommit.GetPullRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestInput, ...func(*codecommit.Options)) *codecommit.GetPullRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetPullRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetPullRequestInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPullRequestApprovalStates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPullRequestApprovalStates(ctx context.Context, params *codecommit.GetPullRequestApprovalStatesInput, optFns ...func(*codecommit.Options)) (*codecommit.GetPullRequestApprovalStatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPullRequestApprovalStates")
	}

	var r0 *codecommit.GetPullRequestApprovalStatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestApprovalStatesInput, ...func(*codecommit.Options)) (*codecommit.GetPullRequestApprovalStatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestApprovalStatesInput, ...func(*codecommit.Options)) *codecommit.GetPullRequestApprovalStatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetPullRequestApprovalStatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetPullRequestApprovalStatesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPullRequestOverrideState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPullRequestOverrideState(ctx context.Context, params *codecommit.GetPullRequestOverrideStateInput, optFns ...func(*codecommit.Options)) (*codecommit.GetPullRequestOverrideStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPullRequestOverrideState")
	}

	var r0 *codecommit.GetPullRequestOverrideStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestOverrideStateInput, ...func(*codecommit.Options)) (*codecommit.GetPullRequestOverrideStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetPullRequestOverrideStateInput, ...func(*codecommit.Options)) *codecommit.GetPullRequestOverrideStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetPullRequestOverrideStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetPullRequestOverrideStateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRepository(ctx context.Context, params *codecommit.GetRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.GetRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepository")
	}

	var r0 *codecommit.GetRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetRepositoryInput, ...func(*codecommit.Options)) (*codecommit.GetRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetRepositoryInput, ...func(*codecommit.Options)) *codecommit.GetRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoryTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRepositoryTriggers(ctx context.Context, params *codecommit.GetRepositoryTriggersInput, optFns ...func(*codecommit.Options)) (*codecommit.GetRepositoryTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryTriggers")
	}

	var r0 *codecommit.GetRepositoryTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetRepositoryTriggersInput, ...func(*codecommit.Options)) (*codecommit.GetRepositoryTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.GetRepositoryTriggersInput, ...func(*codecommit.Options)) *codecommit.GetRepositoryTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.GetRepositoryTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.GetRepositoryTriggersInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApprovalRuleTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApprovalRuleTemplates(ctx context.Context, params *codecommit.ListApprovalRuleTemplatesInput, optFns ...func(*codecommit.Options)) (*codecommit.ListApprovalRuleTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApprovalRuleTemplates")
	}

	var r0 *codecommit.ListApprovalRuleTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListApprovalRuleTemplatesInput, ...func(*codecommit.Options)) (*codecommit.ListApprovalRuleTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListApprovalRuleTemplatesInput, ...func(*codecommit.Options)) *codecommit.ListApprovalRuleTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListApprovalRuleTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListApprovalRuleTemplatesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssociatedApprovalRuleTemplatesForRepository provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssociatedApprovalRuleTemplatesForRepository(ctx context.Context, params *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryInput, optFns ...func(*codecommit.Options)) (*codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssociatedApprovalRuleTemplatesForRepository")
	}

	var r0 *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryInput, ...func(*codecommit.Options)) (*codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryInput, ...func(*codecommit.Options)) *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBranches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBranches(ctx context.Context, params *codecommit.ListBranchesInput, optFns ...func(*codecommit.Options)) (*codecommit.ListBranchesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBranches")
	}

	var r0 *codecommit.ListBranchesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListBranchesInput, ...func(*codecommit.Options)) (*codecommit.ListBranchesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListBranchesInput, ...func(*codecommit.Options)) *codecommit.ListBranchesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListBranchesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListBranchesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFileCommitHistory provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFileCommitHistory(ctx context.Context, params *codecommit.ListFileCommitHistoryInput, optFns ...func(*codecommit.Options)) (*codecommit.ListFileCommitHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFileCommitHistory")
	}

	var r0 *codecommit.ListFileCommitHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListFileCommitHistoryInput, ...func(*codecommit.Options)) (*codecommit.ListFileCommitHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListFileCommitHistoryInput, ...func(*codecommit.Options)) *codecommit.ListFileCommitHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListFileCommitHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListFileCommitHistoryInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPullRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPullRequests(ctx context.Context, params *codecommit.ListPullRequestsInput, optFns ...func(*codecommit.Options)) (*codecommit.ListPullRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPullRequests")
	}

	var r0 *codecommit.ListPullRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListPullRequestsInput, ...func(*codecommit.Options)) (*codecommit.ListPullRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListPullRequestsInput, ...func(*codecommit.Options)) *codecommit.ListPullRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListPullRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListPullRequestsInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRepositories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRepositories(ctx context.Context, params *codecommit.ListRepositoriesInput, optFns ...func(*codecommit.Options)) (*codecommit.ListRepositoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositories")
	}

	var r0 *codecommit.ListRepositoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListRepositoriesInput, ...func(*codecommit.Options)) (*codecommit.ListRepositoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListRepositoriesInput, ...func(*codecommit.Options)) *codecommit.ListRepositoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListRepositoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListRepositoriesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRepositoriesForApprovalRuleTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRepositoriesForApprovalRuleTemplate(ctx context.Context, params *codecommit.ListRepositoriesForApprovalRuleTemplateInput, optFns ...func(*codecommit.Options)) (*codecommit.ListRepositoriesForApprovalRuleTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositoriesForApprovalRuleTemplate")
	}

	var r0 *codecommit.ListRepositoriesForApprovalRuleTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListRepositoriesForApprovalRuleTemplateInput, ...func(*codecommit.Options)) (*codecommit.ListRepositoriesForApprovalRuleTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListRepositoriesForApprovalRuleTemplateInput, ...func(*codecommit.Options)) *codecommit.ListRepositoriesForApprovalRuleTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListRepositoriesForApprovalRuleTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListRepositoriesForApprovalRuleTemplateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *codecommit.ListTagsForResourceInput, optFns ...func(*codecommit.Options)) (*codecommit.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *codecommit.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListTagsForResourceInput, ...func(*codecommit.Options)) (*codecommit.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.ListTagsForResourceInput, ...func(*codecommit.Options)) *codecommit.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.ListTagsForResourceInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBranchesByFastForward provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergeBranchesByFastForward(ctx context.Context, params *codecommit.MergeBranchesByFastForwardInput, optFns ...func(*codecommit.Options)) (*codecommit.MergeBranchesByFastForwardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeBranchesByFastForward")
	}

	var r0 *codecommit.MergeBranchesByFastForwardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesByFastForwardInput, ...func(*codecommit.Options)) (*codecommit.MergeBranchesByFastForwardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesByFastForwardInput, ...func(*codecommit.Options)) *codecommit.MergeBranchesByFastForwardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergeBranchesByFastForwardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergeBranchesByFastForwardInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBranchesBySquash provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergeBranchesBySquash(ctx context.Context, params *codecommit.MergeBranchesBySquashInput, optFns ...func(*codecommit.Options)) (*codecommit.MergeBranchesBySquashOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeBranchesBySquash")
	}

	var r0 *codecommit.MergeBranchesBySquashOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesBySquashInput, ...func(*codecommit.Options)) (*codecommit.MergeBranchesBySquashOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesBySquashInput, ...func(*codecommit.Options)) *codecommit.MergeBranchesBySquashOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergeBranchesBySquashOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergeBranchesBySquashInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBranchesByThreeWay provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergeBranchesByThreeWay(ctx context.Context, params *codecommit.MergeBranchesByThreeWayInput, optFns ...func(*codecommit.Options)) (*codecommit.MergeBranchesByThreeWayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeBranchesByThreeWay")
	}

	var r0 *codecommit.MergeBranchesByThreeWayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesByThreeWayInput, ...func(*codecommit.Options)) (*codecommit.MergeBranchesByThreeWayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergeBranchesByThreeWayInput, ...func(*codecommit.Options)) *codecommit.MergeBranchesByThreeWayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergeBranchesByThreeWayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergeBranchesByThreeWayInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergePullRequestByFastForward provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergePullRequestByFastForward(ctx context.Context, params *codecommit.MergePullRequestByFastForwardInput, optFns ...func(*codecommit.Options)) (*codecommit.MergePullRequestByFastForwardOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergePullRequestByFastForward")
	}

	var r0 *codecommit.MergePullRequestByFastForwardOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestByFastForwardInput, ...func(*codecommit.Options)) (*codecommit.MergePullRequestByFastForwardOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestByFastForwardInput, ...func(*codecommit.Options)) *codecommit.MergePullRequestByFastForwardOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergePullRequestByFastForwardOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergePullRequestByFastForwardInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergePullRequestBySquash provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergePullRequestBySquash(ctx context.Context, params *codecommit.MergePullRequestBySquashInput, optFns ...func(*codecommit.Options)) (*codecommit.MergePullRequestBySquashOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergePullRequestBySquash")
	}

	var r0 *codecommit.MergePullRequestBySquashOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestBySquashInput, ...func(*codecommit.Options)) (*codecommit.MergePullRequestBySquashOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestBySquashInput, ...func(*codecommit.Options)) *codecommit.MergePullRequestBySquashOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergePullRequestBySquashOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergePullRequestBySquashInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergePullRequestByThreeWay provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) MergePullRequestByThreeWay(ctx context.Context, params *codecommit.MergePullRequestByThreeWayInput, optFns ...func(*codecommit.Options)) (*codecommit.MergePullRequestByThreeWayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergePullRequestByThreeWay")
	}

	var r0 *codecommit.MergePullRequestByThreeWayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestByThreeWayInput, ...func(*codecommit.Options)) (*codecommit.MergePullRequestByThreeWayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.MergePullRequestByThreeWayInput, ...func(*codecommit.Options)) *codecommit.MergePullRequestByThreeWayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.MergePullRequestByThreeWayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.MergePullRequestByThreeWayInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() codecommit.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 codecommit.Options
	if rf, ok := ret.Get(0).(func() codecommit.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(codecommit.Options)
	}

	return r0
}

// OverridePullRequestApprovalRules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) OverridePullRequestApprovalRules(ctx context.Context, params *codecommit.OverridePullRequestApprovalRulesInput, optFns ...func(*codecommit.Options)) (*codecommit.OverridePullRequestApprovalRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OverridePullRequestApprovalRules")
	}

	var r0 *codecommit.OverridePullRequestApprovalRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.OverridePullRequestApprovalRulesInput, ...func(*codecommit.Options)) (*codecommit.OverridePullRequestApprovalRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.OverridePullRequestApprovalRulesInput, ...func(*codecommit.Options)) *codecommit.OverridePullRequestApprovalRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.OverridePullRequestApprovalRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.OverridePullRequestApprovalRulesInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostCommentForComparedCommit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PostCommentForComparedCommit(ctx context.Context, params *codecommit.PostCommentForComparedCommitInput, optFns ...func(*codecommit.Options)) (*codecommit.PostCommentForComparedCommitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostCommentForComparedCommit")
	}

	var r0 *codecommit.PostCommentForComparedCommitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentForComparedCommitInput, ...func(*codecommit.Options)) (*codecommit.PostCommentForComparedCommitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentForComparedCommitInput, ...func(*codecommit.Options)) *codecommit.PostCommentForComparedCommitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PostCommentForComparedCommitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PostCommentForComparedCommitInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostCommentForPullRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PostCommentForPullRequest(ctx context.Context, params *codecommit.PostCommentForPullRequestInput, optFns ...func(*codecommit.Options)) (*codecommit.PostCommentForPullRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostCommentForPullRequest")
	}

	var r0 *codecommit.PostCommentForPullRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentForPullRequestInput, ...func(*codecommit.Options)) (*codecommit.PostCommentForPullRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentForPullRequestInput, ...func(*codecommit.Options)) *codecommit.PostCommentForPullRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PostCommentForPullRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PostCommentForPullRequestInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostCommentReply provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PostCommentReply(ctx context.Context, params *codecommit.PostCommentReplyInput, optFns ...func(*codecommit.Options)) (*codecommit.PostCommentReplyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostCommentReply")
	}

	var r0 *codecommit.PostCommentReplyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentReplyInput, ...func(*codecommit.Options)) (*codecommit.PostCommentReplyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PostCommentReplyInput, ...func(*codecommit.Options)) *codecommit.PostCommentReplyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PostCommentReplyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PostCommentReplyInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutCommentReaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutCommentReaction(ctx context.Context, params *codecommit.PutCommentReactionInput, optFns ...func(*codecommit.Options)) (*codecommit.PutCommentReactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutCommentReaction")
	}

	var r0 *codecommit.PutCommentReactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutCommentReactionInput, ...func(*codecommit.Options)) (*codecommit.PutCommentReactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutCommentReactionInput, ...func(*codecommit.Options)) *codecommit.PutCommentReactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PutCommentReactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PutCommentReactionInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutFile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutFile(ctx context.Context, params *codecommit.PutFileInput, optFns ...func(*codecommit.Options)) (*codecommit.PutFileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutFile")
	}

	var r0 *codecommit.PutFileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutFileInput, ...func(*codecommit.Options)) (*codecommit.PutFileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutFileInput, ...func(*codecommit.Options)) *codecommit.PutFileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PutFileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PutFileInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRepositoryTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRepositoryTriggers(ctx context.Context, params *codecommit.PutRepositoryTriggersInput, optFns ...func(*codecommit.Options)) (*codecommit.PutRepositoryTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRepositoryTriggers")
	}

	var r0 *codecommit.PutRepositoryTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutRepositoryTriggersInput, ...func(*codecommit.Options)) (*codecommit.PutRepositoryTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.PutRepositoryTriggersInput, ...func(*codecommit.Options)) *codecommit.PutRepositoryTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.PutRepositoryTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.PutRepositoryTriggersInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *codecommit.TagResourceInput, optFns ...func(*codecommit.Options)) (*codecommit.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *codecommit.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.TagResourceInput, ...func(*codecommit.Options)) (*codecommit.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.TagResourceInput, ...func(*codecommit.Options)) *codecommit.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.TagResourceInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestRepositoryTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestRepositoryTriggers(ctx context.Context, params *codecommit.TestRepositoryTriggersInput, optFns ...func(*codecommit.Options)) (*codecommit.TestRepositoryTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestRepositoryTriggers")
	}

	var r0 *codecommit.TestRepositoryTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.TestRepositoryTriggersInput, ...func(*codecommit.Options)) (*codecommit.TestRepositoryTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.TestRepositoryTriggersInput, ...func(*codecommit.Options)) *codecommit.TestRepositoryTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.TestRepositoryTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.TestRepositoryTriggersInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *codecommit.UntagResourceInput, optFns ...func(*codecommit.Options)) (*codecommit.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *codecommit.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UntagResourceInput, ...func(*codecommit.Options)) (*codecommit.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UntagResourceInput, ...func(*codecommit.Options)) *codecommit.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UntagResourceInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApprovalRuleTemplateContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApprovalRuleTemplateContent(ctx context.Context, params *codecommit.UpdateApprovalRuleTemplateContentInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApprovalRuleTemplateContent")
	}

	var r0 *codecommit.UpdateApprovalRuleTemplateContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateContentInput, ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateContentInput, ...func(*codecommit.Options)) *codecommit.UpdateApprovalRuleTemplateContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateApprovalRuleTemplateContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateContentInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApprovalRuleTemplateDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApprovalRuleTemplateDescription(ctx context.Context, params *codecommit.UpdateApprovalRuleTemplateDescriptionInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApprovalRuleTemplateDescription")
	}

	var r0 *codecommit.UpdateApprovalRuleTemplateDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateDescriptionInput, ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateDescriptionInput, ...func(*codecommit.Options)) *codecommit.UpdateApprovalRuleTemplateDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateApprovalRuleTemplateDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateDescriptionInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApprovalRuleTemplateName provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApprovalRuleTemplateName(ctx context.Context, params *codecommit.UpdateApprovalRuleTemplateNameInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateNameOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApprovalRuleTemplateName")
	}

	var r0 *codecommit.UpdateApprovalRuleTemplateNameOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateNameInput, ...func(*codecommit.Options)) (*codecommit.UpdateApprovalRuleTemplateNameOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateNameInput, ...func(*codecommit.Options)) *codecommit.UpdateApprovalRuleTemplateNameOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateApprovalRuleTemplateNameOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateApprovalRuleTemplateNameInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateComment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateComment(ctx context.Context, params *codecommit.UpdateCommentInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateCommentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateComment")
	}

	var r0 *codecommit.UpdateCommentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateCommentInput, ...func(*codecommit.Options)) (*codecommit.UpdateCommentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateCommentInput, ...func(*codecommit.Options)) *codecommit.UpdateCommentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateCommentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateCommentInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDefaultBranch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDefaultBranch(ctx context.Context, params *codecommit.UpdateDefaultBranchInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateDefaultBranchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDefaultBranch")
	}

	var r0 *codecommit.UpdateDefaultBranchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateDefaultBranchInput, ...func(*codecommit.Options)) (*codecommit.UpdateDefaultBranchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateDefaultBranchInput, ...func(*codecommit.Options)) *codecommit.UpdateDefaultBranchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateDefaultBranchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateDefaultBranchInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullRequestApprovalRuleContent provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullRequestApprovalRuleContent(ctx context.Context, params *codecommit.UpdatePullRequestApprovalRuleContentInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestApprovalRuleContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullRequestApprovalRuleContent")
	}

	var r0 *codecommit.UpdatePullRequestApprovalRuleContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestApprovalRuleContentInput, ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestApprovalRuleContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestApprovalRuleContentInput, ...func(*codecommit.Options)) *codecommit.UpdatePullRequestApprovalRuleContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdatePullRequestApprovalRuleContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdatePullRequestApprovalRuleContentInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullRequestApprovalState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullRequestApprovalState(ctx context.Context, params *codecommit.UpdatePullRequestApprovalStateInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestApprovalStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullRequestApprovalState")
	}

	var r0 *codecommit.UpdatePullRequestApprovalStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestApprovalStateInput, ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestApprovalStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestApprovalStateInput, ...func(*codecommit.Options)) *codecommit.UpdatePullRequestApprovalStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdatePullRequestApprovalStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdatePullRequestApprovalStateInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullRequestDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullRequestDescription(ctx context.Context, params *codecommit.UpdatePullRequestDescriptionInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullRequestDescription")
	}

	var r0 *codecommit.UpdatePullRequestDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestDescriptionInput, ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestDescriptionInput, ...func(*codecommit.Options)) *codecommit.UpdatePullRequestDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdatePullRequestDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdatePullRequestDescriptionInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullRequestStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullRequestStatus(ctx context.Context, params *codecommit.UpdatePullRequestStatusInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullRequestStatus")
	}

	var r0 *codecommit.UpdatePullRequestStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestStatusInput, ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestStatusInput, ...func(*codecommit.Options)) *codecommit.UpdatePullRequestStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdatePullRequestStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdatePullRequestStatusInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePullRequestTitle provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePullRequestTitle(ctx context.Context, params *codecommit.UpdatePullRequestTitleInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestTitleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePullRequestTitle")
	}

	var r0 *codecommit.UpdatePullRequestTitleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestTitleInput, ...func(*codecommit.Options)) (*codecommit.UpdatePullRequestTitleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdatePullRequestTitleInput, ...func(*codecommit.Options)) *codecommit.UpdatePullRequestTitleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdatePullRequestTitleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdatePullRequestTitleInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRepositoryDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRepositoryDescription(ctx context.Context, params *codecommit.UpdateRepositoryDescriptionInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepositoryDescription")
	}

	var r0 *codecommit.UpdateRepositoryDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryDescriptionInput, ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryDescriptionInput, ...func(*codecommit.Options)) *codecommit.UpdateRepositoryDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateRepositoryDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateRepositoryDescriptionInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRepositoryEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRepositoryEncryptionKey(ctx context.Context, params *codecommit.UpdateRepositoryEncryptionKeyInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepositoryEncryptionKey")
	}

	var r0 *codecommit.UpdateRepositoryEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryEncryptionKeyInput, ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryEncryptionKeyInput, ...func(*codecommit.Options)) *codecommit.UpdateRepositoryEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateRepositoryEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateRepositoryEncryptionKeyInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRepositoryName provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRepositoryName(ctx context.Context, params *codecommit.UpdateRepositoryNameInput, optFns ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryNameOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepositoryName")
	}

	var r0 *codecommit.UpdateRepositoryNameOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryNameInput, ...func(*codecommit.Options)) (*codecommit.UpdateRepositoryNameOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codecommit.UpdateRepositoryNameInput, ...func(*codecommit.Options)) *codecommit.UpdateRepositoryNameOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codecommit.UpdateRepositoryNameOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codecommit.UpdateRepositoryNameInput, ...func(*codecommit.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
