// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	appintegrations "github.com/aws/aws-sdk-go-v2/service/appintegrations"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateApplication(ctx context.Context, params *appintegrations.CreateApplicationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.CreateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApplication")
	}

	var r0 *appintegrations.CreateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateApplicationInput, ...func(*appintegrations.Options)) (*appintegrations.CreateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateApplicationInput, ...func(*appintegrations.Options)) *appintegrations.CreateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.CreateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.CreateApplicationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataIntegration(ctx context.Context, params *appintegrations.CreateDataIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.CreateDataIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataIntegration")
	}

	var r0 *appintegrations.CreateDataIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateDataIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.CreateDataIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateDataIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.CreateDataIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.CreateDataIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.CreateDataIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventIntegration(ctx context.Context, params *appintegrations.CreateEventIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.CreateEventIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventIntegration")
	}

	var r0 *appintegrations.CreateEventIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateEventIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.CreateEventIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.CreateEventIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.CreateEventIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.CreateEventIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.CreateEventIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteApplication(ctx context.Context, params *appintegrations.DeleteApplicationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.DeleteApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApplication")
	}

	var r0 *appintegrations.DeleteApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteApplicationInput, ...func(*appintegrations.Options)) (*appintegrations.DeleteApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteApplicationInput, ...func(*appintegrations.Options)) *appintegrations.DeleteApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.DeleteApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.DeleteApplicationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataIntegration(ctx context.Context, params *appintegrations.DeleteDataIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.DeleteDataIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataIntegration")
	}

	var r0 *appintegrations.DeleteDataIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteDataIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.DeleteDataIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteDataIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.DeleteDataIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.DeleteDataIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.DeleteDataIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventIntegration(ctx context.Context, params *appintegrations.DeleteEventIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.DeleteEventIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventIntegration")
	}

	var r0 *appintegrations.DeleteEventIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteEventIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.DeleteEventIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.DeleteEventIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.DeleteEventIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.DeleteEventIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.DeleteEventIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetApplication(ctx context.Context, params *appintegrations.GetApplicationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.GetApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApplication")
	}

	var r0 *appintegrations.GetApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetApplicationInput, ...func(*appintegrations.Options)) (*appintegrations.GetApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetApplicationInput, ...func(*appintegrations.Options)) *appintegrations.GetApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.GetApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.GetApplicationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataIntegration(ctx context.Context, params *appintegrations.GetDataIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.GetDataIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataIntegration")
	}

	var r0 *appintegrations.GetDataIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetDataIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.GetDataIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetDataIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.GetDataIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.GetDataIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.GetDataIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEventIntegration(ctx context.Context, params *appintegrations.GetEventIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.GetEventIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventIntegration")
	}

	var r0 *appintegrations.GetEventIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetEventIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.GetEventIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.GetEventIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.GetEventIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.GetEventIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.GetEventIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplicationAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplicationAssociations(ctx context.Context, params *appintegrations.ListApplicationAssociationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListApplicationAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplicationAssociations")
	}

	var r0 *appintegrations.ListApplicationAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListApplicationAssociationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListApplicationAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListApplicationAssociationsInput, ...func(*appintegrations.Options)) *appintegrations.ListApplicationAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListApplicationAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListApplicationAssociationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListApplications(ctx context.Context, params *appintegrations.ListApplicationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApplications")
	}

	var r0 *appintegrations.ListApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListApplicationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListApplicationsInput, ...func(*appintegrations.Options)) *appintegrations.ListApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListApplicationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataIntegrationAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataIntegrationAssociations(ctx context.Context, params *appintegrations.ListDataIntegrationAssociationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListDataIntegrationAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataIntegrationAssociations")
	}

	var r0 *appintegrations.ListDataIntegrationAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListDataIntegrationAssociationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListDataIntegrationAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListDataIntegrationAssociationsInput, ...func(*appintegrations.Options)) *appintegrations.ListDataIntegrationAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListDataIntegrationAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListDataIntegrationAssociationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataIntegrations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataIntegrations(ctx context.Context, params *appintegrations.ListDataIntegrationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListDataIntegrationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataIntegrations")
	}

	var r0 *appintegrations.ListDataIntegrationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListDataIntegrationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListDataIntegrationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListDataIntegrationsInput, ...func(*appintegrations.Options)) *appintegrations.ListDataIntegrationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListDataIntegrationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListDataIntegrationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventIntegrationAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventIntegrationAssociations(ctx context.Context, params *appintegrations.ListEventIntegrationAssociationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListEventIntegrationAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventIntegrationAssociations")
	}

	var r0 *appintegrations.ListEventIntegrationAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListEventIntegrationAssociationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListEventIntegrationAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListEventIntegrationAssociationsInput, ...func(*appintegrations.Options)) *appintegrations.ListEventIntegrationAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListEventIntegrationAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListEventIntegrationAssociationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEventIntegrations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEventIntegrations(ctx context.Context, params *appintegrations.ListEventIntegrationsInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListEventIntegrationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventIntegrations")
	}

	var r0 *appintegrations.ListEventIntegrationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListEventIntegrationsInput, ...func(*appintegrations.Options)) (*appintegrations.ListEventIntegrationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListEventIntegrationsInput, ...func(*appintegrations.Options)) *appintegrations.ListEventIntegrationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListEventIntegrationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListEventIntegrationsInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *appintegrations.ListTagsForResourceInput, optFns ...func(*appintegrations.Options)) (*appintegrations.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *appintegrations.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListTagsForResourceInput, ...func(*appintegrations.Options)) (*appintegrations.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.ListTagsForResourceInput, ...func(*appintegrations.Options)) *appintegrations.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.ListTagsForResourceInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() appintegrations.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 appintegrations.Options
	if rf, ok := ret.Get(0).(func() appintegrations.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(appintegrations.Options)
	}

	return r0
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *appintegrations.TagResourceInput, optFns ...func(*appintegrations.Options)) (*appintegrations.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *appintegrations.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.TagResourceInput, ...func(*appintegrations.Options)) (*appintegrations.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.TagResourceInput, ...func(*appintegrations.Options)) *appintegrations.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.TagResourceInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *appintegrations.UntagResourceInput, optFns ...func(*appintegrations.Options)) (*appintegrations.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *appintegrations.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UntagResourceInput, ...func(*appintegrations.Options)) (*appintegrations.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UntagResourceInput, ...func(*appintegrations.Options)) *appintegrations.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.UntagResourceInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateApplication(ctx context.Context, params *appintegrations.UpdateApplicationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.UpdateApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApplication")
	}

	var r0 *appintegrations.UpdateApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateApplicationInput, ...func(*appintegrations.Options)) (*appintegrations.UpdateApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateApplicationInput, ...func(*appintegrations.Options)) *appintegrations.UpdateApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.UpdateApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.UpdateApplicationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataIntegration(ctx context.Context, params *appintegrations.UpdateDataIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.UpdateDataIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataIntegration")
	}

	var r0 *appintegrations.UpdateDataIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateDataIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.UpdateDataIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateDataIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.UpdateDataIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.UpdateDataIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.UpdateDataIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEventIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEventIntegration(ctx context.Context, params *appintegrations.UpdateEventIntegrationInput, optFns ...func(*appintegrations.Options)) (*appintegrations.UpdateEventIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventIntegration")
	}

	var r0 *appintegrations.UpdateEventIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateEventIntegrationInput, ...func(*appintegrations.Options)) (*appintegrations.UpdateEventIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *appintegrations.UpdateEventIntegrationInput, ...func(*appintegrations.Options)) *appintegrations.UpdateEventIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appintegrations.UpdateEventIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *appintegrations.UpdateEventIntegrationInput, ...func(*appintegrations.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
