// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	batch "github.com/aws/aws-sdk-go-v2/service/batch"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CancelJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelJob(ctx context.Context, params *batch.CancelJobInput, optFns ...func(*batch.Options)) (*batch.CancelJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelJob")
	}

	var r0 *batch.CancelJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CancelJobInput, ...func(*batch.Options)) (*batch.CancelJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CancelJobInput, ...func(*batch.Options)) *batch.CancelJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.CancelJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.CancelJobInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateComputeEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateComputeEnvironment(ctx context.Context, params *batch.CreateComputeEnvironmentInput, optFns ...func(*batch.Options)) (*batch.CreateComputeEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateComputeEnvironment")
	}

	var r0 *batch.CreateComputeEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateComputeEnvironmentInput, ...func(*batch.Options)) (*batch.CreateComputeEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateComputeEnvironmentInput, ...func(*batch.Options)) *batch.CreateComputeEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.CreateComputeEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.CreateComputeEnvironmentInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConsumableResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConsumableResource(ctx context.Context, params *batch.CreateConsumableResourceInput, optFns ...func(*batch.Options)) (*batch.CreateConsumableResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConsumableResource")
	}

	var r0 *batch.CreateConsumableResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateConsumableResourceInput, ...func(*batch.Options)) (*batch.CreateConsumableResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateConsumableResourceInput, ...func(*batch.Options)) *batch.CreateConsumableResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.CreateConsumableResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.CreateConsumableResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateJobQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateJobQueue(ctx context.Context, params *batch.CreateJobQueueInput, optFns ...func(*batch.Options)) (*batch.CreateJobQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateJobQueue")
	}

	var r0 *batch.CreateJobQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateJobQueueInput, ...func(*batch.Options)) (*batch.CreateJobQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateJobQueueInput, ...func(*batch.Options)) *batch.CreateJobQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.CreateJobQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.CreateJobQueueInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSchedulingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSchedulingPolicy(ctx context.Context, params *batch.CreateSchedulingPolicyInput, optFns ...func(*batch.Options)) (*batch.CreateSchedulingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSchedulingPolicy")
	}

	var r0 *batch.CreateSchedulingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateSchedulingPolicyInput, ...func(*batch.Options)) (*batch.CreateSchedulingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.CreateSchedulingPolicyInput, ...func(*batch.Options)) *batch.CreateSchedulingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.CreateSchedulingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.CreateSchedulingPolicyInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteComputeEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteComputeEnvironment(ctx context.Context, params *batch.DeleteComputeEnvironmentInput, optFns ...func(*batch.Options)) (*batch.DeleteComputeEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteComputeEnvironment")
	}

	var r0 *batch.DeleteComputeEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteComputeEnvironmentInput, ...func(*batch.Options)) (*batch.DeleteComputeEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteComputeEnvironmentInput, ...func(*batch.Options)) *batch.DeleteComputeEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DeleteComputeEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DeleteComputeEnvironmentInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConsumableResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConsumableResource(ctx context.Context, params *batch.DeleteConsumableResourceInput, optFns ...func(*batch.Options)) (*batch.DeleteConsumableResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConsumableResource")
	}

	var r0 *batch.DeleteConsumableResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteConsumableResourceInput, ...func(*batch.Options)) (*batch.DeleteConsumableResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteConsumableResourceInput, ...func(*batch.Options)) *batch.DeleteConsumableResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DeleteConsumableResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DeleteConsumableResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteJobQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteJobQueue(ctx context.Context, params *batch.DeleteJobQueueInput, optFns ...func(*batch.Options)) (*batch.DeleteJobQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJobQueue")
	}

	var r0 *batch.DeleteJobQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteJobQueueInput, ...func(*batch.Options)) (*batch.DeleteJobQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteJobQueueInput, ...func(*batch.Options)) *batch.DeleteJobQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DeleteJobQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DeleteJobQueueInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSchedulingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSchedulingPolicy(ctx context.Context, params *batch.DeleteSchedulingPolicyInput, optFns ...func(*batch.Options)) (*batch.DeleteSchedulingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSchedulingPolicy")
	}

	var r0 *batch.DeleteSchedulingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteSchedulingPolicyInput, ...func(*batch.Options)) (*batch.DeleteSchedulingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeleteSchedulingPolicyInput, ...func(*batch.Options)) *batch.DeleteSchedulingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DeleteSchedulingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DeleteSchedulingPolicyInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterJobDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterJobDefinition(ctx context.Context, params *batch.DeregisterJobDefinitionInput, optFns ...func(*batch.Options)) (*batch.DeregisterJobDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterJobDefinition")
	}

	var r0 *batch.DeregisterJobDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeregisterJobDefinitionInput, ...func(*batch.Options)) (*batch.DeregisterJobDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DeregisterJobDefinitionInput, ...func(*batch.Options)) *batch.DeregisterJobDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DeregisterJobDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DeregisterJobDefinitionInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeComputeEnvironments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeComputeEnvironments(ctx context.Context, params *batch.DescribeComputeEnvironmentsInput, optFns ...func(*batch.Options)) (*batch.DescribeComputeEnvironmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeComputeEnvironments")
	}

	var r0 *batch.DescribeComputeEnvironmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeComputeEnvironmentsInput, ...func(*batch.Options)) (*batch.DescribeComputeEnvironmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeComputeEnvironmentsInput, ...func(*batch.Options)) *batch.DescribeComputeEnvironmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeComputeEnvironmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeComputeEnvironmentsInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConsumableResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConsumableResource(ctx context.Context, params *batch.DescribeConsumableResourceInput, optFns ...func(*batch.Options)) (*batch.DescribeConsumableResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConsumableResource")
	}

	var r0 *batch.DescribeConsumableResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeConsumableResourceInput, ...func(*batch.Options)) (*batch.DescribeConsumableResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeConsumableResourceInput, ...func(*batch.Options)) *batch.DescribeConsumableResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeConsumableResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeConsumableResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJobDefinitions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJobDefinitions(ctx context.Context, params *batch.DescribeJobDefinitionsInput, optFns ...func(*batch.Options)) (*batch.DescribeJobDefinitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJobDefinitions")
	}

	var r0 *batch.DescribeJobDefinitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobDefinitionsInput, ...func(*batch.Options)) (*batch.DescribeJobDefinitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobDefinitionsInput, ...func(*batch.Options)) *batch.DescribeJobDefinitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeJobDefinitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeJobDefinitionsInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJobQueues provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJobQueues(ctx context.Context, params *batch.DescribeJobQueuesInput, optFns ...func(*batch.Options)) (*batch.DescribeJobQueuesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJobQueues")
	}

	var r0 *batch.DescribeJobQueuesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobQueuesInput, ...func(*batch.Options)) (*batch.DescribeJobQueuesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobQueuesInput, ...func(*batch.Options)) *batch.DescribeJobQueuesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeJobQueuesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeJobQueuesInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJobs(ctx context.Context, params *batch.DescribeJobsInput, optFns ...func(*batch.Options)) (*batch.DescribeJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJobs")
	}

	var r0 *batch.DescribeJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobsInput, ...func(*batch.Options)) (*batch.DescribeJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeJobsInput, ...func(*batch.Options)) *batch.DescribeJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeJobsInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSchedulingPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSchedulingPolicies(ctx context.Context, params *batch.DescribeSchedulingPoliciesInput, optFns ...func(*batch.Options)) (*batch.DescribeSchedulingPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSchedulingPolicies")
	}

	var r0 *batch.DescribeSchedulingPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeSchedulingPoliciesInput, ...func(*batch.Options)) (*batch.DescribeSchedulingPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.DescribeSchedulingPoliciesInput, ...func(*batch.Options)) *batch.DescribeSchedulingPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.DescribeSchedulingPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.DescribeSchedulingPoliciesInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobQueueSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobQueueSnapshot(ctx context.Context, params *batch.GetJobQueueSnapshotInput, optFns ...func(*batch.Options)) (*batch.GetJobQueueSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobQueueSnapshot")
	}

	var r0 *batch.GetJobQueueSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.GetJobQueueSnapshotInput, ...func(*batch.Options)) (*batch.GetJobQueueSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.GetJobQueueSnapshotInput, ...func(*batch.Options)) *batch.GetJobQueueSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.GetJobQueueSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.GetJobQueueSnapshotInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConsumableResources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConsumableResources(ctx context.Context, params *batch.ListConsumableResourcesInput, optFns ...func(*batch.Options)) (*batch.ListConsumableResourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConsumableResources")
	}

	var r0 *batch.ListConsumableResourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListConsumableResourcesInput, ...func(*batch.Options)) (*batch.ListConsumableResourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListConsumableResourcesInput, ...func(*batch.Options)) *batch.ListConsumableResourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.ListConsumableResourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.ListConsumableResourcesInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobs(ctx context.Context, params *batch.ListJobsInput, optFns ...func(*batch.Options)) (*batch.ListJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 *batch.ListJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListJobsInput, ...func(*batch.Options)) (*batch.ListJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListJobsInput, ...func(*batch.Options)) *batch.ListJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.ListJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.ListJobsInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobsByConsumableResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobsByConsumableResource(ctx context.Context, params *batch.ListJobsByConsumableResourceInput, optFns ...func(*batch.Options)) (*batch.ListJobsByConsumableResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobsByConsumableResource")
	}

	var r0 *batch.ListJobsByConsumableResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListJobsByConsumableResourceInput, ...func(*batch.Options)) (*batch.ListJobsByConsumableResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListJobsByConsumableResourceInput, ...func(*batch.Options)) *batch.ListJobsByConsumableResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.ListJobsByConsumableResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.ListJobsByConsumableResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSchedulingPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSchedulingPolicies(ctx context.Context, params *batch.ListSchedulingPoliciesInput, optFns ...func(*batch.Options)) (*batch.ListSchedulingPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSchedulingPolicies")
	}

	var r0 *batch.ListSchedulingPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListSchedulingPoliciesInput, ...func(*batch.Options)) (*batch.ListSchedulingPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListSchedulingPoliciesInput, ...func(*batch.Options)) *batch.ListSchedulingPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.ListSchedulingPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.ListSchedulingPoliciesInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *batch.ListTagsForResourceInput, optFns ...func(*batch.Options)) (*batch.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *batch.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListTagsForResourceInput, ...func(*batch.Options)) (*batch.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.ListTagsForResourceInput, ...func(*batch.Options)) *batch.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.ListTagsForResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() batch.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 batch.Options
	if rf, ok := ret.Get(0).(func() batch.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(batch.Options)
	}

	return r0
}

// RegisterJobDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterJobDefinition(ctx context.Context, params *batch.RegisterJobDefinitionInput, optFns ...func(*batch.Options)) (*batch.RegisterJobDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterJobDefinition")
	}

	var r0 *batch.RegisterJobDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.RegisterJobDefinitionInput, ...func(*batch.Options)) (*batch.RegisterJobDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.RegisterJobDefinitionInput, ...func(*batch.Options)) *batch.RegisterJobDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.RegisterJobDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.RegisterJobDefinitionInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SubmitJob(ctx context.Context, params *batch.SubmitJobInput, optFns ...func(*batch.Options)) (*batch.SubmitJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubmitJob")
	}

	var r0 *batch.SubmitJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.SubmitJobInput, ...func(*batch.Options)) (*batch.SubmitJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.SubmitJobInput, ...func(*batch.Options)) *batch.SubmitJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.SubmitJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.SubmitJobInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *batch.TagResourceInput, optFns ...func(*batch.Options)) (*batch.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *batch.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.TagResourceInput, ...func(*batch.Options)) (*batch.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.TagResourceInput, ...func(*batch.Options)) *batch.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.TagResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TerminateJob(ctx context.Context, params *batch.TerminateJobInput, optFns ...func(*batch.Options)) (*batch.TerminateJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateJob")
	}

	var r0 *batch.TerminateJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.TerminateJobInput, ...func(*batch.Options)) (*batch.TerminateJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.TerminateJobInput, ...func(*batch.Options)) *batch.TerminateJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.TerminateJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.TerminateJobInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *batch.UntagResourceInput, optFns ...func(*batch.Options)) (*batch.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *batch.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UntagResourceInput, ...func(*batch.Options)) (*batch.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UntagResourceInput, ...func(*batch.Options)) *batch.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.UntagResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateComputeEnvironment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateComputeEnvironment(ctx context.Context, params *batch.UpdateComputeEnvironmentInput, optFns ...func(*batch.Options)) (*batch.UpdateComputeEnvironmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateComputeEnvironment")
	}

	var r0 *batch.UpdateComputeEnvironmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateComputeEnvironmentInput, ...func(*batch.Options)) (*batch.UpdateComputeEnvironmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateComputeEnvironmentInput, ...func(*batch.Options)) *batch.UpdateComputeEnvironmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.UpdateComputeEnvironmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.UpdateComputeEnvironmentInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConsumableResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConsumableResource(ctx context.Context, params *batch.UpdateConsumableResourceInput, optFns ...func(*batch.Options)) (*batch.UpdateConsumableResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConsumableResource")
	}

	var r0 *batch.UpdateConsumableResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateConsumableResourceInput, ...func(*batch.Options)) (*batch.UpdateConsumableResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateConsumableResourceInput, ...func(*batch.Options)) *batch.UpdateConsumableResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.UpdateConsumableResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.UpdateConsumableResourceInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateJobQueue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateJobQueue(ctx context.Context, params *batch.UpdateJobQueueInput, optFns ...func(*batch.Options)) (*batch.UpdateJobQueueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobQueue")
	}

	var r0 *batch.UpdateJobQueueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateJobQueueInput, ...func(*batch.Options)) (*batch.UpdateJobQueueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateJobQueueInput, ...func(*batch.Options)) *batch.UpdateJobQueueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.UpdateJobQueueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.UpdateJobQueueInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSchedulingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSchedulingPolicy(ctx context.Context, params *batch.UpdateSchedulingPolicyInput, optFns ...func(*batch.Options)) (*batch.UpdateSchedulingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSchedulingPolicy")
	}

	var r0 *batch.UpdateSchedulingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateSchedulingPolicyInput, ...func(*batch.Options)) (*batch.UpdateSchedulingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batch.UpdateSchedulingPolicyInput, ...func(*batch.Options)) *batch.UpdateSchedulingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batch.UpdateSchedulingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batch.UpdateSchedulingPolicyInput, ...func(*batch.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
