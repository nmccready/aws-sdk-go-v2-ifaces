// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	glue "github.com/aws/aws-sdk-go-v2/service/glue"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchCreatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreatePartition(ctx context.Context, params *glue.BatchCreatePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchCreatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreatePartition")
	}

	var r0 *glue.BatchCreatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) (*glue.BatchCreatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) *glue.BatchCreatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchCreatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchCreatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteConnection(ctx context.Context, params *glue.BatchDeleteConnectionInput, optFns ...func(*glue.Options)) (*glue.BatchDeleteConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteConnection")
	}

	var r0 *glue.BatchDeleteConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteConnectionInput, ...func(*glue.Options)) (*glue.BatchDeleteConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteConnectionInput, ...func(*glue.Options)) *glue.BatchDeleteConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchDeleteConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchDeleteConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeletePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeletePartition(ctx context.Context, params *glue.BatchDeletePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchDeletePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeletePartition")
	}

	var r0 *glue.BatchDeletePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) (*glue.BatchDeletePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) *glue.BatchDeletePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchDeletePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchDeletePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteTable(ctx context.Context, params *glue.BatchDeleteTableInput, optFns ...func(*glue.Options)) (*glue.BatchDeleteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteTable")
	}

	var r0 *glue.BatchDeleteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteTableInput, ...func(*glue.Options)) (*glue.BatchDeleteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteTableInput, ...func(*glue.Options)) *glue.BatchDeleteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchDeleteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchDeleteTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteTableVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteTableVersion(ctx context.Context, params *glue.BatchDeleteTableVersionInput, optFns ...func(*glue.Options)) (*glue.BatchDeleteTableVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteTableVersion")
	}

	var r0 *glue.BatchDeleteTableVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteTableVersionInput, ...func(*glue.Options)) (*glue.BatchDeleteTableVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchDeleteTableVersionInput, ...func(*glue.Options)) *glue.BatchDeleteTableVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchDeleteTableVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchDeleteTableVersionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetBlueprints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetBlueprints(ctx context.Context, params *glue.BatchGetBlueprintsInput, optFns ...func(*glue.Options)) (*glue.BatchGetBlueprintsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetBlueprints")
	}

	var r0 *glue.BatchGetBlueprintsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetBlueprintsInput, ...func(*glue.Options)) (*glue.BatchGetBlueprintsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetBlueprintsInput, ...func(*glue.Options)) *glue.BatchGetBlueprintsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetBlueprintsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetBlueprintsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetCrawlers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetCrawlers(ctx context.Context, params *glue.BatchGetCrawlersInput, optFns ...func(*glue.Options)) (*glue.BatchGetCrawlersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetCrawlers")
	}

	var r0 *glue.BatchGetCrawlersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetCrawlersInput, ...func(*glue.Options)) (*glue.BatchGetCrawlersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetCrawlersInput, ...func(*glue.Options)) *glue.BatchGetCrawlersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetCrawlersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetCrawlersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetCustomEntityTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetCustomEntityTypes(ctx context.Context, params *glue.BatchGetCustomEntityTypesInput, optFns ...func(*glue.Options)) (*glue.BatchGetCustomEntityTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetCustomEntityTypes")
	}

	var r0 *glue.BatchGetCustomEntityTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetCustomEntityTypesInput, ...func(*glue.Options)) (*glue.BatchGetCustomEntityTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetCustomEntityTypesInput, ...func(*glue.Options)) *glue.BatchGetCustomEntityTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetCustomEntityTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetCustomEntityTypesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetDataQualityResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetDataQualityResult(ctx context.Context, params *glue.BatchGetDataQualityResultInput, optFns ...func(*glue.Options)) (*glue.BatchGetDataQualityResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetDataQualityResult")
	}

	var r0 *glue.BatchGetDataQualityResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetDataQualityResultInput, ...func(*glue.Options)) (*glue.BatchGetDataQualityResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetDataQualityResultInput, ...func(*glue.Options)) *glue.BatchGetDataQualityResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetDataQualityResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetDataQualityResultInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetDevEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetDevEndpoints(ctx context.Context, params *glue.BatchGetDevEndpointsInput, optFns ...func(*glue.Options)) (*glue.BatchGetDevEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetDevEndpoints")
	}

	var r0 *glue.BatchGetDevEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetDevEndpointsInput, ...func(*glue.Options)) (*glue.BatchGetDevEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetDevEndpointsInput, ...func(*glue.Options)) *glue.BatchGetDevEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetDevEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetDevEndpointsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetJobs(ctx context.Context, params *glue.BatchGetJobsInput, optFns ...func(*glue.Options)) (*glue.BatchGetJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetJobs")
	}

	var r0 *glue.BatchGetJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetJobsInput, ...func(*glue.Options)) (*glue.BatchGetJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetJobsInput, ...func(*glue.Options)) *glue.BatchGetJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetJobsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetPartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetPartition(ctx context.Context, params *glue.BatchGetPartitionInput, optFns ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetPartition")
	}

	var r0 *glue.BatchGetPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) *glue.BatchGetPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetTableOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetTableOptimizer(ctx context.Context, params *glue.BatchGetTableOptimizerInput, optFns ...func(*glue.Options)) (*glue.BatchGetTableOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetTableOptimizer")
	}

	var r0 *glue.BatchGetTableOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetTableOptimizerInput, ...func(*glue.Options)) (*glue.BatchGetTableOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetTableOptimizerInput, ...func(*glue.Options)) *glue.BatchGetTableOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetTableOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetTableOptimizerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetTriggers(ctx context.Context, params *glue.BatchGetTriggersInput, optFns ...func(*glue.Options)) (*glue.BatchGetTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetTriggers")
	}

	var r0 *glue.BatchGetTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetTriggersInput, ...func(*glue.Options)) (*glue.BatchGetTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetTriggersInput, ...func(*glue.Options)) *glue.BatchGetTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetTriggersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetWorkflows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetWorkflows(ctx context.Context, params *glue.BatchGetWorkflowsInput, optFns ...func(*glue.Options)) (*glue.BatchGetWorkflowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetWorkflows")
	}

	var r0 *glue.BatchGetWorkflowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetWorkflowsInput, ...func(*glue.Options)) (*glue.BatchGetWorkflowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchGetWorkflowsInput, ...func(*glue.Options)) *glue.BatchGetWorkflowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchGetWorkflowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchGetWorkflowsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchPutDataQualityStatisticAnnotation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchPutDataQualityStatisticAnnotation(ctx context.Context, params *glue.BatchPutDataQualityStatisticAnnotationInput, optFns ...func(*glue.Options)) (*glue.BatchPutDataQualityStatisticAnnotationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchPutDataQualityStatisticAnnotation")
	}

	var r0 *glue.BatchPutDataQualityStatisticAnnotationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchPutDataQualityStatisticAnnotationInput, ...func(*glue.Options)) (*glue.BatchPutDataQualityStatisticAnnotationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchPutDataQualityStatisticAnnotationInput, ...func(*glue.Options)) *glue.BatchPutDataQualityStatisticAnnotationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchPutDataQualityStatisticAnnotationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchPutDataQualityStatisticAnnotationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchStopJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchStopJobRun(ctx context.Context, params *glue.BatchStopJobRunInput, optFns ...func(*glue.Options)) (*glue.BatchStopJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchStopJobRun")
	}

	var r0 *glue.BatchStopJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchStopJobRunInput, ...func(*glue.Options)) (*glue.BatchStopJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchStopJobRunInput, ...func(*glue.Options)) *glue.BatchStopJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchStopJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchStopJobRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchUpdatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchUpdatePartition(ctx context.Context, params *glue.BatchUpdatePartitionInput, optFns ...func(*glue.Options)) (*glue.BatchUpdatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdatePartition")
	}

	var r0 *glue.BatchUpdatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) (*glue.BatchUpdatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) *glue.BatchUpdatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.BatchUpdatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.BatchUpdatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDataQualityRuleRecommendationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDataQualityRuleRecommendationRun(ctx context.Context, params *glue.CancelDataQualityRuleRecommendationRunInput, optFns ...func(*glue.Options)) (*glue.CancelDataQualityRuleRecommendationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDataQualityRuleRecommendationRun")
	}

	var r0 *glue.CancelDataQualityRuleRecommendationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) (*glue.CancelDataQualityRuleRecommendationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) *glue.CancelDataQualityRuleRecommendationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CancelDataQualityRuleRecommendationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CancelDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDataQualityRulesetEvaluationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDataQualityRulesetEvaluationRun(ctx context.Context, params *glue.CancelDataQualityRulesetEvaluationRunInput, optFns ...func(*glue.Options)) (*glue.CancelDataQualityRulesetEvaluationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDataQualityRulesetEvaluationRun")
	}

	var r0 *glue.CancelDataQualityRulesetEvaluationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) (*glue.CancelDataQualityRulesetEvaluationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) *glue.CancelDataQualityRulesetEvaluationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CancelDataQualityRulesetEvaluationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CancelDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelMLTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelMLTaskRun(ctx context.Context, params *glue.CancelMLTaskRunInput, optFns ...func(*glue.Options)) (*glue.CancelMLTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelMLTaskRun")
	}

	var r0 *glue.CancelMLTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelMLTaskRunInput, ...func(*glue.Options)) (*glue.CancelMLTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelMLTaskRunInput, ...func(*glue.Options)) *glue.CancelMLTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CancelMLTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CancelMLTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelStatement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelStatement(ctx context.Context, params *glue.CancelStatementInput, optFns ...func(*glue.Options)) (*glue.CancelStatementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelStatement")
	}

	var r0 *glue.CancelStatementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelStatementInput, ...func(*glue.Options)) (*glue.CancelStatementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CancelStatementInput, ...func(*glue.Options)) *glue.CancelStatementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CancelStatementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CancelStatementInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckSchemaVersionValidity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CheckSchemaVersionValidity(ctx context.Context, params *glue.CheckSchemaVersionValidityInput, optFns ...func(*glue.Options)) (*glue.CheckSchemaVersionValidityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckSchemaVersionValidity")
	}

	var r0 *glue.CheckSchemaVersionValidityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CheckSchemaVersionValidityInput, ...func(*glue.Options)) (*glue.CheckSchemaVersionValidityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CheckSchemaVersionValidityInput, ...func(*glue.Options)) *glue.CheckSchemaVersionValidityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CheckSchemaVersionValidityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CheckSchemaVersionValidityInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBlueprint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBlueprint(ctx context.Context, params *glue.CreateBlueprintInput, optFns ...func(*glue.Options)) (*glue.CreateBlueprintOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBlueprint")
	}

	var r0 *glue.CreateBlueprintOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateBlueprintInput, ...func(*glue.Options)) (*glue.CreateBlueprintOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateBlueprintInput, ...func(*glue.Options)) *glue.CreateBlueprintOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateBlueprintOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateBlueprintInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCatalog provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCatalog(ctx context.Context, params *glue.CreateCatalogInput, optFns ...func(*glue.Options)) (*glue.CreateCatalogOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCatalog")
	}

	var r0 *glue.CreateCatalogOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCatalogInput, ...func(*glue.Options)) (*glue.CreateCatalogOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCatalogInput, ...func(*glue.Options)) *glue.CreateCatalogOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateCatalogOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateCatalogInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClassifier(ctx context.Context, params *glue.CreateClassifierInput, optFns ...func(*glue.Options)) (*glue.CreateClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClassifier")
	}

	var r0 *glue.CreateClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateClassifierInput, ...func(*glue.Options)) (*glue.CreateClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateClassifierInput, ...func(*glue.Options)) *glue.CreateClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateClassifierInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateColumnStatisticsTaskSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateColumnStatisticsTaskSettings(ctx context.Context, params *glue.CreateColumnStatisticsTaskSettingsInput, optFns ...func(*glue.Options)) (*glue.CreateColumnStatisticsTaskSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateColumnStatisticsTaskSettings")
	}

	var r0 *glue.CreateColumnStatisticsTaskSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) (*glue.CreateColumnStatisticsTaskSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) *glue.CreateColumnStatisticsTaskSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateColumnStatisticsTaskSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConnection(ctx context.Context, params *glue.CreateConnectionInput, optFns ...func(*glue.Options)) (*glue.CreateConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConnection")
	}

	var r0 *glue.CreateConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateConnectionInput, ...func(*glue.Options)) (*glue.CreateConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateConnectionInput, ...func(*glue.Options)) *glue.CreateConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCrawler(ctx context.Context, params *glue.CreateCrawlerInput, optFns ...func(*glue.Options)) (*glue.CreateCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCrawler")
	}

	var r0 *glue.CreateCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCrawlerInput, ...func(*glue.Options)) (*glue.CreateCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCrawlerInput, ...func(*glue.Options)) *glue.CreateCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomEntityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomEntityType(ctx context.Context, params *glue.CreateCustomEntityTypeInput, optFns ...func(*glue.Options)) (*glue.CreateCustomEntityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomEntityType")
	}

	var r0 *glue.CreateCustomEntityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCustomEntityTypeInput, ...func(*glue.Options)) (*glue.CreateCustomEntityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateCustomEntityTypeInput, ...func(*glue.Options)) *glue.CreateCustomEntityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateCustomEntityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateCustomEntityTypeInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataQualityRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataQualityRuleset(ctx context.Context, params *glue.CreateDataQualityRulesetInput, optFns ...func(*glue.Options)) (*glue.CreateDataQualityRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataQualityRuleset")
	}

	var r0 *glue.CreateDataQualityRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDataQualityRulesetInput, ...func(*glue.Options)) (*glue.CreateDataQualityRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDataQualityRulesetInput, ...func(*glue.Options)) *glue.CreateDataQualityRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateDataQualityRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateDataQualityRulesetInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDatabase(ctx context.Context, params *glue.CreateDatabaseInput, optFns ...func(*glue.Options)) (*glue.CreateDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 *glue.CreateDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) (*glue.CreateDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) *glue.CreateDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDevEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDevEndpoint(ctx context.Context, params *glue.CreateDevEndpointInput, optFns ...func(*glue.Options)) (*glue.CreateDevEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDevEndpoint")
	}

	var r0 *glue.CreateDevEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDevEndpointInput, ...func(*glue.Options)) (*glue.CreateDevEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateDevEndpointInput, ...func(*glue.Options)) *glue.CreateDevEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateDevEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateDevEndpointInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIntegration(ctx context.Context, params *glue.CreateIntegrationInput, optFns ...func(*glue.Options)) (*glue.CreateIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIntegration")
	}

	var r0 *glue.CreateIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationInput, ...func(*glue.Options)) (*glue.CreateIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationInput, ...func(*glue.Options)) *glue.CreateIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateIntegrationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIntegrationResourceProperty provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIntegrationResourceProperty(ctx context.Context, params *glue.CreateIntegrationResourcePropertyInput, optFns ...func(*glue.Options)) (*glue.CreateIntegrationResourcePropertyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIntegrationResourceProperty")
	}

	var r0 *glue.CreateIntegrationResourcePropertyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationResourcePropertyInput, ...func(*glue.Options)) (*glue.CreateIntegrationResourcePropertyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationResourcePropertyInput, ...func(*glue.Options)) *glue.CreateIntegrationResourcePropertyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateIntegrationResourcePropertyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateIntegrationResourcePropertyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIntegrationTableProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIntegrationTableProperties(ctx context.Context, params *glue.CreateIntegrationTablePropertiesInput, optFns ...func(*glue.Options)) (*glue.CreateIntegrationTablePropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIntegrationTableProperties")
	}

	var r0 *glue.CreateIntegrationTablePropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationTablePropertiesInput, ...func(*glue.Options)) (*glue.CreateIntegrationTablePropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateIntegrationTablePropertiesInput, ...func(*glue.Options)) *glue.CreateIntegrationTablePropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateIntegrationTablePropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateIntegrationTablePropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateJob(ctx context.Context, params *glue.CreateJobInput, optFns ...func(*glue.Options)) (*glue.CreateJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 *glue.CreateJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateJobInput, ...func(*glue.Options)) (*glue.CreateJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateJobInput, ...func(*glue.Options)) *glue.CreateJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateJobInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMLTransform provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMLTransform(ctx context.Context, params *glue.CreateMLTransformInput, optFns ...func(*glue.Options)) (*glue.CreateMLTransformOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMLTransform")
	}

	var r0 *glue.CreateMLTransformOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateMLTransformInput, ...func(*glue.Options)) (*glue.CreateMLTransformOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateMLTransformInput, ...func(*glue.Options)) *glue.CreateMLTransformOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateMLTransformOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateMLTransformInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePartition(ctx context.Context, params *glue.CreatePartitionInput, optFns ...func(*glue.Options)) (*glue.CreatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartition")
	}

	var r0 *glue.CreatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreatePartitionInput, ...func(*glue.Options)) (*glue.CreatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreatePartitionInput, ...func(*glue.Options)) *glue.CreatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePartitionIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePartitionIndex(ctx context.Context, params *glue.CreatePartitionIndexInput, optFns ...func(*glue.Options)) (*glue.CreatePartitionIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartitionIndex")
	}

	var r0 *glue.CreatePartitionIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreatePartitionIndexInput, ...func(*glue.Options)) (*glue.CreatePartitionIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreatePartitionIndexInput, ...func(*glue.Options)) *glue.CreatePartitionIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreatePartitionIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreatePartitionIndexInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegistry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegistry(ctx context.Context, params *glue.CreateRegistryInput, optFns ...func(*glue.Options)) (*glue.CreateRegistryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegistry")
	}

	var r0 *glue.CreateRegistryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateRegistryInput, ...func(*glue.Options)) (*glue.CreateRegistryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateRegistryInput, ...func(*glue.Options)) *glue.CreateRegistryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateRegistryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateRegistryInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSchema(ctx context.Context, params *glue.CreateSchemaInput, optFns ...func(*glue.Options)) (*glue.CreateSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSchema")
	}

	var r0 *glue.CreateSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSchemaInput, ...func(*glue.Options)) (*glue.CreateSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSchemaInput, ...func(*glue.Options)) *glue.CreateSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateSchemaInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateScript provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateScript(ctx context.Context, params *glue.CreateScriptInput, optFns ...func(*glue.Options)) (*glue.CreateScriptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateScript")
	}

	var r0 *glue.CreateScriptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateScriptInput, ...func(*glue.Options)) (*glue.CreateScriptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateScriptInput, ...func(*glue.Options)) *glue.CreateScriptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateScriptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateScriptInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSecurityConfiguration(ctx context.Context, params *glue.CreateSecurityConfigurationInput, optFns ...func(*glue.Options)) (*glue.CreateSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityConfiguration")
	}

	var r0 *glue.CreateSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSecurityConfigurationInput, ...func(*glue.Options)) (*glue.CreateSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSecurityConfigurationInput, ...func(*glue.Options)) *glue.CreateSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateSecurityConfigurationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSession(ctx context.Context, params *glue.CreateSessionInput, optFns ...func(*glue.Options)) (*glue.CreateSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 *glue.CreateSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSessionInput, ...func(*glue.Options)) (*glue.CreateSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateSessionInput, ...func(*glue.Options)) *glue.CreateSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateSessionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTable(ctx context.Context, params *glue.CreateTableInput, optFns ...func(*glue.Options)) (*glue.CreateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTable")
	}

	var r0 *glue.CreateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) (*glue.CreateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) *glue.CreateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTableOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTableOptimizer(ctx context.Context, params *glue.CreateTableOptimizerInput, optFns ...func(*glue.Options)) (*glue.CreateTableOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTableOptimizer")
	}

	var r0 *glue.CreateTableOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableOptimizerInput, ...func(*glue.Options)) (*glue.CreateTableOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTableOptimizerInput, ...func(*glue.Options)) *glue.CreateTableOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateTableOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateTableOptimizerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTrigger(ctx context.Context, params *glue.CreateTriggerInput, optFns ...func(*glue.Options)) (*glue.CreateTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrigger")
	}

	var r0 *glue.CreateTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTriggerInput, ...func(*glue.Options)) (*glue.CreateTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateTriggerInput, ...func(*glue.Options)) *glue.CreateTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUsageProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUsageProfile(ctx context.Context, params *glue.CreateUsageProfileInput, optFns ...func(*glue.Options)) (*glue.CreateUsageProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUsageProfile")
	}

	var r0 *glue.CreateUsageProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateUsageProfileInput, ...func(*glue.Options)) (*glue.CreateUsageProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateUsageProfileInput, ...func(*glue.Options)) *glue.CreateUsageProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateUsageProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateUsageProfileInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserDefinedFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUserDefinedFunction(ctx context.Context, params *glue.CreateUserDefinedFunctionInput, optFns ...func(*glue.Options)) (*glue.CreateUserDefinedFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserDefinedFunction")
	}

	var r0 *glue.CreateUserDefinedFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateUserDefinedFunctionInput, ...func(*glue.Options)) (*glue.CreateUserDefinedFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateUserDefinedFunctionInput, ...func(*glue.Options)) *glue.CreateUserDefinedFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateUserDefinedFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateUserDefinedFunctionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkflow(ctx context.Context, params *glue.CreateWorkflowInput, optFns ...func(*glue.Options)) (*glue.CreateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflow")
	}

	var r0 *glue.CreateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateWorkflowInput, ...func(*glue.Options)) (*glue.CreateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.CreateWorkflowInput, ...func(*glue.Options)) *glue.CreateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.CreateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.CreateWorkflowInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBlueprint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBlueprint(ctx context.Context, params *glue.DeleteBlueprintInput, optFns ...func(*glue.Options)) (*glue.DeleteBlueprintOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBlueprint")
	}

	var r0 *glue.DeleteBlueprintOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteBlueprintInput, ...func(*glue.Options)) (*glue.DeleteBlueprintOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteBlueprintInput, ...func(*glue.Options)) *glue.DeleteBlueprintOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteBlueprintOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteBlueprintInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCatalog provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCatalog(ctx context.Context, params *glue.DeleteCatalogInput, optFns ...func(*glue.Options)) (*glue.DeleteCatalogOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCatalog")
	}

	var r0 *glue.DeleteCatalogOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCatalogInput, ...func(*glue.Options)) (*glue.DeleteCatalogOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCatalogInput, ...func(*glue.Options)) *glue.DeleteCatalogOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteCatalogOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteCatalogInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClassifier(ctx context.Context, params *glue.DeleteClassifierInput, optFns ...func(*glue.Options)) (*glue.DeleteClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClassifier")
	}

	var r0 *glue.DeleteClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteClassifierInput, ...func(*glue.Options)) (*glue.DeleteClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteClassifierInput, ...func(*glue.Options)) *glue.DeleteClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteClassifierInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteColumnStatisticsForPartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteColumnStatisticsForPartition(ctx context.Context, params *glue.DeleteColumnStatisticsForPartitionInput, optFns ...func(*glue.Options)) (*glue.DeleteColumnStatisticsForPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteColumnStatisticsForPartition")
	}

	var r0 *glue.DeleteColumnStatisticsForPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsForPartitionInput, ...func(*glue.Options)) (*glue.DeleteColumnStatisticsForPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsForPartitionInput, ...func(*glue.Options)) *glue.DeleteColumnStatisticsForPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteColumnStatisticsForPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteColumnStatisticsForPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteColumnStatisticsForTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteColumnStatisticsForTable(ctx context.Context, params *glue.DeleteColumnStatisticsForTableInput, optFns ...func(*glue.Options)) (*glue.DeleteColumnStatisticsForTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteColumnStatisticsForTable")
	}

	var r0 *glue.DeleteColumnStatisticsForTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsForTableInput, ...func(*glue.Options)) (*glue.DeleteColumnStatisticsForTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsForTableInput, ...func(*glue.Options)) *glue.DeleteColumnStatisticsForTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteColumnStatisticsForTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteColumnStatisticsForTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteColumnStatisticsTaskSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteColumnStatisticsTaskSettings(ctx context.Context, params *glue.DeleteColumnStatisticsTaskSettingsInput, optFns ...func(*glue.Options)) (*glue.DeleteColumnStatisticsTaskSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteColumnStatisticsTaskSettings")
	}

	var r0 *glue.DeleteColumnStatisticsTaskSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) (*glue.DeleteColumnStatisticsTaskSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) *glue.DeleteColumnStatisticsTaskSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteColumnStatisticsTaskSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConnection(ctx context.Context, params *glue.DeleteConnectionInput, optFns ...func(*glue.Options)) (*glue.DeleteConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConnection")
	}

	var r0 *glue.DeleteConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteConnectionInput, ...func(*glue.Options)) (*glue.DeleteConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteConnectionInput, ...func(*glue.Options)) *glue.DeleteConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCrawler(ctx context.Context, params *glue.DeleteCrawlerInput, optFns ...func(*glue.Options)) (*glue.DeleteCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCrawler")
	}

	var r0 *glue.DeleteCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCrawlerInput, ...func(*glue.Options)) (*glue.DeleteCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCrawlerInput, ...func(*glue.Options)) *glue.DeleteCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomEntityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomEntityType(ctx context.Context, params *glue.DeleteCustomEntityTypeInput, optFns ...func(*glue.Options)) (*glue.DeleteCustomEntityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomEntityType")
	}

	var r0 *glue.DeleteCustomEntityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCustomEntityTypeInput, ...func(*glue.Options)) (*glue.DeleteCustomEntityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteCustomEntityTypeInput, ...func(*glue.Options)) *glue.DeleteCustomEntityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteCustomEntityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteCustomEntityTypeInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataQualityRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataQualityRuleset(ctx context.Context, params *glue.DeleteDataQualityRulesetInput, optFns ...func(*glue.Options)) (*glue.DeleteDataQualityRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataQualityRuleset")
	}

	var r0 *glue.DeleteDataQualityRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDataQualityRulesetInput, ...func(*glue.Options)) (*glue.DeleteDataQualityRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDataQualityRulesetInput, ...func(*glue.Options)) *glue.DeleteDataQualityRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteDataQualityRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteDataQualityRulesetInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDatabase(ctx context.Context, params *glue.DeleteDatabaseInput, optFns ...func(*glue.Options)) (*glue.DeleteDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatabase")
	}

	var r0 *glue.DeleteDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) (*glue.DeleteDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) *glue.DeleteDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDevEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDevEndpoint(ctx context.Context, params *glue.DeleteDevEndpointInput, optFns ...func(*glue.Options)) (*glue.DeleteDevEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDevEndpoint")
	}

	var r0 *glue.DeleteDevEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDevEndpointInput, ...func(*glue.Options)) (*glue.DeleteDevEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteDevEndpointInput, ...func(*glue.Options)) *glue.DeleteDevEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteDevEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteDevEndpointInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIntegration(ctx context.Context, params *glue.DeleteIntegrationInput, optFns ...func(*glue.Options)) (*glue.DeleteIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIntegration")
	}

	var r0 *glue.DeleteIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteIntegrationInput, ...func(*glue.Options)) (*glue.DeleteIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteIntegrationInput, ...func(*glue.Options)) *glue.DeleteIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteIntegrationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIntegrationTableProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIntegrationTableProperties(ctx context.Context, params *glue.DeleteIntegrationTablePropertiesInput, optFns ...func(*glue.Options)) (*glue.DeleteIntegrationTablePropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIntegrationTableProperties")
	}

	var r0 *glue.DeleteIntegrationTablePropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteIntegrationTablePropertiesInput, ...func(*glue.Options)) (*glue.DeleteIntegrationTablePropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteIntegrationTablePropertiesInput, ...func(*glue.Options)) *glue.DeleteIntegrationTablePropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteIntegrationTablePropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteIntegrationTablePropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteJob(ctx context.Context, params *glue.DeleteJobInput, optFns ...func(*glue.Options)) (*glue.DeleteJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 *glue.DeleteJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteJobInput, ...func(*glue.Options)) (*glue.DeleteJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteJobInput, ...func(*glue.Options)) *glue.DeleteJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteJobInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMLTransform provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMLTransform(ctx context.Context, params *glue.DeleteMLTransformInput, optFns ...func(*glue.Options)) (*glue.DeleteMLTransformOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMLTransform")
	}

	var r0 *glue.DeleteMLTransformOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteMLTransformInput, ...func(*glue.Options)) (*glue.DeleteMLTransformOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteMLTransformInput, ...func(*glue.Options)) *glue.DeleteMLTransformOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteMLTransformOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteMLTransformInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePartition(ctx context.Context, params *glue.DeletePartitionInput, optFns ...func(*glue.Options)) (*glue.DeletePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePartition")
	}

	var r0 *glue.DeletePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) (*glue.DeletePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) *glue.DeletePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeletePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeletePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePartitionIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePartitionIndex(ctx context.Context, params *glue.DeletePartitionIndexInput, optFns ...func(*glue.Options)) (*glue.DeletePartitionIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePartitionIndex")
	}

	var r0 *glue.DeletePartitionIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionIndexInput, ...func(*glue.Options)) (*glue.DeletePartitionIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeletePartitionIndexInput, ...func(*glue.Options)) *glue.DeletePartitionIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeletePartitionIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeletePartitionIndexInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegistry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegistry(ctx context.Context, params *glue.DeleteRegistryInput, optFns ...func(*glue.Options)) (*glue.DeleteRegistryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistry")
	}

	var r0 *glue.DeleteRegistryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteRegistryInput, ...func(*glue.Options)) (*glue.DeleteRegistryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteRegistryInput, ...func(*glue.Options)) *glue.DeleteRegistryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteRegistryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteRegistryInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *glue.DeleteResourcePolicyInput, optFns ...func(*glue.Options)) (*glue.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *glue.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteResourcePolicyInput, ...func(*glue.Options)) (*glue.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteResourcePolicyInput, ...func(*glue.Options)) *glue.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteResourcePolicyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSchema(ctx context.Context, params *glue.DeleteSchemaInput, optFns ...func(*glue.Options)) (*glue.DeleteSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSchema")
	}

	var r0 *glue.DeleteSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSchemaInput, ...func(*glue.Options)) (*glue.DeleteSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSchemaInput, ...func(*glue.Options)) *glue.DeleteSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteSchemaInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSchemaVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSchemaVersions(ctx context.Context, params *glue.DeleteSchemaVersionsInput, optFns ...func(*glue.Options)) (*glue.DeleteSchemaVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSchemaVersions")
	}

	var r0 *glue.DeleteSchemaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSchemaVersionsInput, ...func(*glue.Options)) (*glue.DeleteSchemaVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSchemaVersionsInput, ...func(*glue.Options)) *glue.DeleteSchemaVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteSchemaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteSchemaVersionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSecurityConfiguration(ctx context.Context, params *glue.DeleteSecurityConfigurationInput, optFns ...func(*glue.Options)) (*glue.DeleteSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityConfiguration")
	}

	var r0 *glue.DeleteSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSecurityConfigurationInput, ...func(*glue.Options)) (*glue.DeleteSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSecurityConfigurationInput, ...func(*glue.Options)) *glue.DeleteSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteSecurityConfigurationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSession(ctx context.Context, params *glue.DeleteSessionInput, optFns ...func(*glue.Options)) (*glue.DeleteSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 *glue.DeleteSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSessionInput, ...func(*glue.Options)) (*glue.DeleteSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteSessionInput, ...func(*glue.Options)) *glue.DeleteSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteSessionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTable(ctx context.Context, params *glue.DeleteTableInput, optFns ...func(*glue.Options)) (*glue.DeleteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTable")
	}

	var r0 *glue.DeleteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) (*glue.DeleteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) *glue.DeleteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableOptimizer(ctx context.Context, params *glue.DeleteTableOptimizerInput, optFns ...func(*glue.Options)) (*glue.DeleteTableOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableOptimizer")
	}

	var r0 *glue.DeleteTableOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableOptimizerInput, ...func(*glue.Options)) (*glue.DeleteTableOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableOptimizerInput, ...func(*glue.Options)) *glue.DeleteTableOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteTableOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteTableOptimizerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableVersion(ctx context.Context, params *glue.DeleteTableVersionInput, optFns ...func(*glue.Options)) (*glue.DeleteTableVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableVersion")
	}

	var r0 *glue.DeleteTableVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableVersionInput, ...func(*glue.Options)) (*glue.DeleteTableVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTableVersionInput, ...func(*glue.Options)) *glue.DeleteTableVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteTableVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteTableVersionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTrigger(ctx context.Context, params *glue.DeleteTriggerInput, optFns ...func(*glue.Options)) (*glue.DeleteTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrigger")
	}

	var r0 *glue.DeleteTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTriggerInput, ...func(*glue.Options)) (*glue.DeleteTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteTriggerInput, ...func(*glue.Options)) *glue.DeleteTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUsageProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUsageProfile(ctx context.Context, params *glue.DeleteUsageProfileInput, optFns ...func(*glue.Options)) (*glue.DeleteUsageProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUsageProfile")
	}

	var r0 *glue.DeleteUsageProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteUsageProfileInput, ...func(*glue.Options)) (*glue.DeleteUsageProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteUsageProfileInput, ...func(*glue.Options)) *glue.DeleteUsageProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteUsageProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteUsageProfileInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUserDefinedFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUserDefinedFunction(ctx context.Context, params *glue.DeleteUserDefinedFunctionInput, optFns ...func(*glue.Options)) (*glue.DeleteUserDefinedFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserDefinedFunction")
	}

	var r0 *glue.DeleteUserDefinedFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteUserDefinedFunctionInput, ...func(*glue.Options)) (*glue.DeleteUserDefinedFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteUserDefinedFunctionInput, ...func(*glue.Options)) *glue.DeleteUserDefinedFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteUserDefinedFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteUserDefinedFunctionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkflow(ctx context.Context, params *glue.DeleteWorkflowInput, optFns ...func(*glue.Options)) (*glue.DeleteWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 *glue.DeleteWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteWorkflowInput, ...func(*glue.Options)) (*glue.DeleteWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DeleteWorkflowInput, ...func(*glue.Options)) *glue.DeleteWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DeleteWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DeleteWorkflowInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConnectionType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConnectionType(ctx context.Context, params *glue.DescribeConnectionTypeInput, optFns ...func(*glue.Options)) (*glue.DescribeConnectionTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConnectionType")
	}

	var r0 *glue.DescribeConnectionTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeConnectionTypeInput, ...func(*glue.Options)) (*glue.DescribeConnectionTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeConnectionTypeInput, ...func(*glue.Options)) *glue.DescribeConnectionTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DescribeConnectionTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DescribeConnectionTypeInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEntity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEntity(ctx context.Context, params *glue.DescribeEntityInput, optFns ...func(*glue.Options)) (*glue.DescribeEntityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEntity")
	}

	var r0 *glue.DescribeEntityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeEntityInput, ...func(*glue.Options)) (*glue.DescribeEntityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeEntityInput, ...func(*glue.Options)) *glue.DescribeEntityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DescribeEntityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DescribeEntityInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInboundIntegrations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInboundIntegrations(ctx context.Context, params *glue.DescribeInboundIntegrationsInput, optFns ...func(*glue.Options)) (*glue.DescribeInboundIntegrationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInboundIntegrations")
	}

	var r0 *glue.DescribeInboundIntegrationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeInboundIntegrationsInput, ...func(*glue.Options)) (*glue.DescribeInboundIntegrationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeInboundIntegrationsInput, ...func(*glue.Options)) *glue.DescribeInboundIntegrationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DescribeInboundIntegrationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DescribeInboundIntegrationsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIntegrations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIntegrations(ctx context.Context, params *glue.DescribeIntegrationsInput, optFns ...func(*glue.Options)) (*glue.DescribeIntegrationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIntegrations")
	}

	var r0 *glue.DescribeIntegrationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeIntegrationsInput, ...func(*glue.Options)) (*glue.DescribeIntegrationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.DescribeIntegrationsInput, ...func(*glue.Options)) *glue.DescribeIntegrationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.DescribeIntegrationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.DescribeIntegrationsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlueprint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlueprint(ctx context.Context, params *glue.GetBlueprintInput, optFns ...func(*glue.Options)) (*glue.GetBlueprintOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlueprint")
	}

	var r0 *glue.GetBlueprintOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintInput, ...func(*glue.Options)) (*glue.GetBlueprintOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintInput, ...func(*glue.Options)) *glue.GetBlueprintOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetBlueprintOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetBlueprintInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlueprintRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlueprintRun(ctx context.Context, params *glue.GetBlueprintRunInput, optFns ...func(*glue.Options)) (*glue.GetBlueprintRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlueprintRun")
	}

	var r0 *glue.GetBlueprintRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintRunInput, ...func(*glue.Options)) (*glue.GetBlueprintRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintRunInput, ...func(*glue.Options)) *glue.GetBlueprintRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetBlueprintRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetBlueprintRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlueprintRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetBlueprintRuns(ctx context.Context, params *glue.GetBlueprintRunsInput, optFns ...func(*glue.Options)) (*glue.GetBlueprintRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlueprintRuns")
	}

	var r0 *glue.GetBlueprintRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintRunsInput, ...func(*glue.Options)) (*glue.GetBlueprintRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetBlueprintRunsInput, ...func(*glue.Options)) *glue.GetBlueprintRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetBlueprintRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetBlueprintRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCatalog provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCatalog(ctx context.Context, params *glue.GetCatalogInput, optFns ...func(*glue.Options)) (*glue.GetCatalogOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCatalog")
	}

	var r0 *glue.GetCatalogOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogInput, ...func(*glue.Options)) (*glue.GetCatalogOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogInput, ...func(*glue.Options)) *glue.GetCatalogOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCatalogOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCatalogInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCatalogImportStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCatalogImportStatus(ctx context.Context, params *glue.GetCatalogImportStatusInput, optFns ...func(*glue.Options)) (*glue.GetCatalogImportStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCatalogImportStatus")
	}

	var r0 *glue.GetCatalogImportStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogImportStatusInput, ...func(*glue.Options)) (*glue.GetCatalogImportStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogImportStatusInput, ...func(*glue.Options)) *glue.GetCatalogImportStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCatalogImportStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCatalogImportStatusInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCatalogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCatalogs(ctx context.Context, params *glue.GetCatalogsInput, optFns ...func(*glue.Options)) (*glue.GetCatalogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCatalogs")
	}

	var r0 *glue.GetCatalogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogsInput, ...func(*glue.Options)) (*glue.GetCatalogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCatalogsInput, ...func(*glue.Options)) *glue.GetCatalogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCatalogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCatalogsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClassifier(ctx context.Context, params *glue.GetClassifierInput, optFns ...func(*glue.Options)) (*glue.GetClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClassifier")
	}

	var r0 *glue.GetClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetClassifierInput, ...func(*glue.Options)) (*glue.GetClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetClassifierInput, ...func(*glue.Options)) *glue.GetClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetClassifierInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClassifiers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClassifiers(ctx context.Context, params *glue.GetClassifiersInput, optFns ...func(*glue.Options)) (*glue.GetClassifiersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClassifiers")
	}

	var r0 *glue.GetClassifiersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetClassifiersInput, ...func(*glue.Options)) (*glue.GetClassifiersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetClassifiersInput, ...func(*glue.Options)) *glue.GetClassifiersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetClassifiersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetClassifiersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetColumnStatisticsForPartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetColumnStatisticsForPartition(ctx context.Context, params *glue.GetColumnStatisticsForPartitionInput, optFns ...func(*glue.Options)) (*glue.GetColumnStatisticsForPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetColumnStatisticsForPartition")
	}

	var r0 *glue.GetColumnStatisticsForPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsForPartitionInput, ...func(*glue.Options)) (*glue.GetColumnStatisticsForPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsForPartitionInput, ...func(*glue.Options)) *glue.GetColumnStatisticsForPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetColumnStatisticsForPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetColumnStatisticsForPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetColumnStatisticsForTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetColumnStatisticsForTable(ctx context.Context, params *glue.GetColumnStatisticsForTableInput, optFns ...func(*glue.Options)) (*glue.GetColumnStatisticsForTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetColumnStatisticsForTable")
	}

	var r0 *glue.GetColumnStatisticsForTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsForTableInput, ...func(*glue.Options)) (*glue.GetColumnStatisticsForTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsForTableInput, ...func(*glue.Options)) *glue.GetColumnStatisticsForTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetColumnStatisticsForTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetColumnStatisticsForTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetColumnStatisticsTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetColumnStatisticsTaskRun(ctx context.Context, params *glue.GetColumnStatisticsTaskRunInput, optFns ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetColumnStatisticsTaskRun")
	}

	var r0 *glue.GetColumnStatisticsTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskRunInput, ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskRunInput, ...func(*glue.Options)) *glue.GetColumnStatisticsTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetColumnStatisticsTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetColumnStatisticsTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetColumnStatisticsTaskRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetColumnStatisticsTaskRuns(ctx context.Context, params *glue.GetColumnStatisticsTaskRunsInput, optFns ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetColumnStatisticsTaskRuns")
	}

	var r0 *glue.GetColumnStatisticsTaskRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskRunsInput, ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskRunsInput, ...func(*glue.Options)) *glue.GetColumnStatisticsTaskRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetColumnStatisticsTaskRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetColumnStatisticsTaskRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetColumnStatisticsTaskSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetColumnStatisticsTaskSettings(ctx context.Context, params *glue.GetColumnStatisticsTaskSettingsInput, optFns ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetColumnStatisticsTaskSettings")
	}

	var r0 *glue.GetColumnStatisticsTaskSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) (*glue.GetColumnStatisticsTaskSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) *glue.GetColumnStatisticsTaskSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetColumnStatisticsTaskSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConnection(ctx context.Context, params *glue.GetConnectionInput, optFns ...func(*glue.Options)) (*glue.GetConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConnection")
	}

	var r0 *glue.GetConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetConnectionInput, ...func(*glue.Options)) (*glue.GetConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetConnectionInput, ...func(*glue.Options)) *glue.GetConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConnections provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConnections(ctx context.Context, params *glue.GetConnectionsInput, optFns ...func(*glue.Options)) (*glue.GetConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConnections")
	}

	var r0 *glue.GetConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetConnectionsInput, ...func(*glue.Options)) (*glue.GetConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetConnectionsInput, ...func(*glue.Options)) *glue.GetConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetConnectionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCrawler(ctx context.Context, params *glue.GetCrawlerInput, optFns ...func(*glue.Options)) (*glue.GetCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCrawler")
	}

	var r0 *glue.GetCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlerInput, ...func(*glue.Options)) (*glue.GetCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlerInput, ...func(*glue.Options)) *glue.GetCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCrawlerMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCrawlerMetrics(ctx context.Context, params *glue.GetCrawlerMetricsInput, optFns ...func(*glue.Options)) (*glue.GetCrawlerMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCrawlerMetrics")
	}

	var r0 *glue.GetCrawlerMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlerMetricsInput, ...func(*glue.Options)) (*glue.GetCrawlerMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlerMetricsInput, ...func(*glue.Options)) *glue.GetCrawlerMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCrawlerMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCrawlerMetricsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCrawlers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCrawlers(ctx context.Context, params *glue.GetCrawlersInput, optFns ...func(*glue.Options)) (*glue.GetCrawlersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCrawlers")
	}

	var r0 *glue.GetCrawlersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlersInput, ...func(*glue.Options)) (*glue.GetCrawlersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCrawlersInput, ...func(*glue.Options)) *glue.GetCrawlersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCrawlersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCrawlersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCustomEntityType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCustomEntityType(ctx context.Context, params *glue.GetCustomEntityTypeInput, optFns ...func(*glue.Options)) (*glue.GetCustomEntityTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomEntityType")
	}

	var r0 *glue.GetCustomEntityTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCustomEntityTypeInput, ...func(*glue.Options)) (*glue.GetCustomEntityTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetCustomEntityTypeInput, ...func(*glue.Options)) *glue.GetCustomEntityTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetCustomEntityTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetCustomEntityTypeInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataCatalogEncryptionSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataCatalogEncryptionSettings(ctx context.Context, params *glue.GetDataCatalogEncryptionSettingsInput, optFns ...func(*glue.Options)) (*glue.GetDataCatalogEncryptionSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataCatalogEncryptionSettings")
	}

	var r0 *glue.GetDataCatalogEncryptionSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) (*glue.GetDataCatalogEncryptionSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) *glue.GetDataCatalogEncryptionSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataCatalogEncryptionSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityModel(ctx context.Context, params *glue.GetDataQualityModelInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityModel")
	}

	var r0 *glue.GetDataQualityModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityModelInput, ...func(*glue.Options)) (*glue.GetDataQualityModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityModelInput, ...func(*glue.Options)) *glue.GetDataQualityModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityModelInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityModelResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityModelResult(ctx context.Context, params *glue.GetDataQualityModelResultInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityModelResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityModelResult")
	}

	var r0 *glue.GetDataQualityModelResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityModelResultInput, ...func(*glue.Options)) (*glue.GetDataQualityModelResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityModelResultInput, ...func(*glue.Options)) *glue.GetDataQualityModelResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityModelResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityModelResultInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityResult provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityResult(ctx context.Context, params *glue.GetDataQualityResultInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityResult")
	}

	var r0 *glue.GetDataQualityResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityResultInput, ...func(*glue.Options)) (*glue.GetDataQualityResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityResultInput, ...func(*glue.Options)) *glue.GetDataQualityResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityResultInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityRuleRecommendationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityRuleRecommendationRun(ctx context.Context, params *glue.GetDataQualityRuleRecommendationRunInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityRuleRecommendationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityRuleRecommendationRun")
	}

	var r0 *glue.GetDataQualityRuleRecommendationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) (*glue.GetDataQualityRuleRecommendationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) *glue.GetDataQualityRuleRecommendationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityRuleRecommendationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityRuleset(ctx context.Context, params *glue.GetDataQualityRulesetInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityRuleset")
	}

	var r0 *glue.GetDataQualityRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRulesetInput, ...func(*glue.Options)) (*glue.GetDataQualityRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRulesetInput, ...func(*glue.Options)) *glue.GetDataQualityRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityRulesetInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataQualityRulesetEvaluationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataQualityRulesetEvaluationRun(ctx context.Context, params *glue.GetDataQualityRulesetEvaluationRunInput, optFns ...func(*glue.Options)) (*glue.GetDataQualityRulesetEvaluationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataQualityRulesetEvaluationRun")
	}

	var r0 *glue.GetDataQualityRulesetEvaluationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) (*glue.GetDataQualityRulesetEvaluationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) *glue.GetDataQualityRulesetEvaluationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataQualityRulesetEvaluationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDatabase(ctx context.Context, params *glue.GetDatabaseInput, optFns ...func(*glue.Options)) (*glue.GetDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabase")
	}

	var r0 *glue.GetDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) (*glue.GetDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) *glue.GetDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatabases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDatabases(ctx context.Context, params *glue.GetDatabasesInput, optFns ...func(*glue.Options)) (*glue.GetDatabasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabases")
	}

	var r0 *glue.GetDatabasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) (*glue.GetDatabasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) *glue.GetDatabasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDatabasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDatabasesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataflowGraph provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataflowGraph(ctx context.Context, params *glue.GetDataflowGraphInput, optFns ...func(*glue.Options)) (*glue.GetDataflowGraphOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataflowGraph")
	}

	var r0 *glue.GetDataflowGraphOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataflowGraphInput, ...func(*glue.Options)) (*glue.GetDataflowGraphOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDataflowGraphInput, ...func(*glue.Options)) *glue.GetDataflowGraphOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDataflowGraphOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDataflowGraphInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDevEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDevEndpoint(ctx context.Context, params *glue.GetDevEndpointInput, optFns ...func(*glue.Options)) (*glue.GetDevEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDevEndpoint")
	}

	var r0 *glue.GetDevEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDevEndpointInput, ...func(*glue.Options)) (*glue.GetDevEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDevEndpointInput, ...func(*glue.Options)) *glue.GetDevEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDevEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDevEndpointInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDevEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDevEndpoints(ctx context.Context, params *glue.GetDevEndpointsInput, optFns ...func(*glue.Options)) (*glue.GetDevEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDevEndpoints")
	}

	var r0 *glue.GetDevEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDevEndpointsInput, ...func(*glue.Options)) (*glue.GetDevEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetDevEndpointsInput, ...func(*glue.Options)) *glue.GetDevEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetDevEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetDevEndpointsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEntityRecords provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEntityRecords(ctx context.Context, params *glue.GetEntityRecordsInput, optFns ...func(*glue.Options)) (*glue.GetEntityRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityRecords")
	}

	var r0 *glue.GetEntityRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetEntityRecordsInput, ...func(*glue.Options)) (*glue.GetEntityRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetEntityRecordsInput, ...func(*glue.Options)) *glue.GetEntityRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetEntityRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetEntityRecordsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntegrationResourceProperty provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIntegrationResourceProperty(ctx context.Context, params *glue.GetIntegrationResourcePropertyInput, optFns ...func(*glue.Options)) (*glue.GetIntegrationResourcePropertyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIntegrationResourceProperty")
	}

	var r0 *glue.GetIntegrationResourcePropertyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetIntegrationResourcePropertyInput, ...func(*glue.Options)) (*glue.GetIntegrationResourcePropertyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetIntegrationResourcePropertyInput, ...func(*glue.Options)) *glue.GetIntegrationResourcePropertyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetIntegrationResourcePropertyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetIntegrationResourcePropertyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntegrationTableProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIntegrationTableProperties(ctx context.Context, params *glue.GetIntegrationTablePropertiesInput, optFns ...func(*glue.Options)) (*glue.GetIntegrationTablePropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIntegrationTableProperties")
	}

	var r0 *glue.GetIntegrationTablePropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetIntegrationTablePropertiesInput, ...func(*glue.Options)) (*glue.GetIntegrationTablePropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetIntegrationTablePropertiesInput, ...func(*glue.Options)) *glue.GetIntegrationTablePropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetIntegrationTablePropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetIntegrationTablePropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJob(ctx context.Context, params *glue.GetJobInput, optFns ...func(*glue.Options)) (*glue.GetJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJob")
	}

	var r0 *glue.GetJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobInput, ...func(*glue.Options)) (*glue.GetJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobInput, ...func(*glue.Options)) *glue.GetJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetJobInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobBookmark provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobBookmark(ctx context.Context, params *glue.GetJobBookmarkInput, optFns ...func(*glue.Options)) (*glue.GetJobBookmarkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobBookmark")
	}

	var r0 *glue.GetJobBookmarkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobBookmarkInput, ...func(*glue.Options)) (*glue.GetJobBookmarkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobBookmarkInput, ...func(*glue.Options)) *glue.GetJobBookmarkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetJobBookmarkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetJobBookmarkInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobRun(ctx context.Context, params *glue.GetJobRunInput, optFns ...func(*glue.Options)) (*glue.GetJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobRun")
	}

	var r0 *glue.GetJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobRunInput, ...func(*glue.Options)) (*glue.GetJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobRunInput, ...func(*glue.Options)) *glue.GetJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetJobRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobRuns(ctx context.Context, params *glue.GetJobRunsInput, optFns ...func(*glue.Options)) (*glue.GetJobRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobRuns")
	}

	var r0 *glue.GetJobRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobRunsInput, ...func(*glue.Options)) (*glue.GetJobRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobRunsInput, ...func(*glue.Options)) *glue.GetJobRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetJobRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetJobRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetJobs(ctx context.Context, params *glue.GetJobsInput, optFns ...func(*glue.Options)) (*glue.GetJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobs")
	}

	var r0 *glue.GetJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobsInput, ...func(*glue.Options)) (*glue.GetJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetJobsInput, ...func(*glue.Options)) *glue.GetJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetJobsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMLTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMLTaskRun(ctx context.Context, params *glue.GetMLTaskRunInput, optFns ...func(*glue.Options)) (*glue.GetMLTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMLTaskRun")
	}

	var r0 *glue.GetMLTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTaskRunInput, ...func(*glue.Options)) (*glue.GetMLTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTaskRunInput, ...func(*glue.Options)) *glue.GetMLTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetMLTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetMLTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMLTaskRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMLTaskRuns(ctx context.Context, params *glue.GetMLTaskRunsInput, optFns ...func(*glue.Options)) (*glue.GetMLTaskRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMLTaskRuns")
	}

	var r0 *glue.GetMLTaskRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTaskRunsInput, ...func(*glue.Options)) (*glue.GetMLTaskRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTaskRunsInput, ...func(*glue.Options)) *glue.GetMLTaskRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetMLTaskRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetMLTaskRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMLTransform provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMLTransform(ctx context.Context, params *glue.GetMLTransformInput, optFns ...func(*glue.Options)) (*glue.GetMLTransformOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMLTransform")
	}

	var r0 *glue.GetMLTransformOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTransformInput, ...func(*glue.Options)) (*glue.GetMLTransformOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTransformInput, ...func(*glue.Options)) *glue.GetMLTransformOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetMLTransformOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetMLTransformInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMLTransforms provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMLTransforms(ctx context.Context, params *glue.GetMLTransformsInput, optFns ...func(*glue.Options)) (*glue.GetMLTransformsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMLTransforms")
	}

	var r0 *glue.GetMLTransformsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTransformsInput, ...func(*glue.Options)) (*glue.GetMLTransformsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMLTransformsInput, ...func(*glue.Options)) *glue.GetMLTransformsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetMLTransformsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetMLTransformsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMapping(ctx context.Context, params *glue.GetMappingInput, optFns ...func(*glue.Options)) (*glue.GetMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMapping")
	}

	var r0 *glue.GetMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMappingInput, ...func(*glue.Options)) (*glue.GetMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetMappingInput, ...func(*glue.Options)) *glue.GetMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetMappingInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPartition(ctx context.Context, params *glue.GetPartitionInput, optFns ...func(*glue.Options)) (*glue.GetPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPartition")
	}

	var r0 *glue.GetPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) (*glue.GetPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) *glue.GetPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPartitionIndexes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPartitionIndexes(ctx context.Context, params *glue.GetPartitionIndexesInput, optFns ...func(*glue.Options)) (*glue.GetPartitionIndexesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPartitionIndexes")
	}

	var r0 *glue.GetPartitionIndexesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionIndexesInput, ...func(*glue.Options)) (*glue.GetPartitionIndexesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionIndexesInput, ...func(*glue.Options)) *glue.GetPartitionIndexesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPartitionIndexesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPartitionIndexesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPartitions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPartitions(ctx context.Context, params *glue.GetPartitionsInput, optFns ...func(*glue.Options)) (*glue.GetPartitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPartitions")
	}

	var r0 *glue.GetPartitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) (*glue.GetPartitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) *glue.GetPartitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPartitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPartitionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPlan provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPlan(ctx context.Context, params *glue.GetPlanInput, optFns ...func(*glue.Options)) (*glue.GetPlanOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPlan")
	}

	var r0 *glue.GetPlanOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPlanInput, ...func(*glue.Options)) (*glue.GetPlanOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetPlanInput, ...func(*glue.Options)) *glue.GetPlanOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetPlanOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetPlanInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegistry(ctx context.Context, params *glue.GetRegistryInput, optFns ...func(*glue.Options)) (*glue.GetRegistryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistry")
	}

	var r0 *glue.GetRegistryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetRegistryInput, ...func(*glue.Options)) (*glue.GetRegistryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetRegistryInput, ...func(*glue.Options)) *glue.GetRegistryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetRegistryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetRegistryInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicies(ctx context.Context, params *glue.GetResourcePoliciesInput, optFns ...func(*glue.Options)) (*glue.GetResourcePoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicies")
	}

	var r0 *glue.GetResourcePoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetResourcePoliciesInput, ...func(*glue.Options)) (*glue.GetResourcePoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetResourcePoliciesInput, ...func(*glue.Options)) *glue.GetResourcePoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetResourcePoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetResourcePoliciesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicy(ctx context.Context, params *glue.GetResourcePolicyInput, optFns ...func(*glue.Options)) (*glue.GetResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicy")
	}

	var r0 *glue.GetResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetResourcePolicyInput, ...func(*glue.Options)) (*glue.GetResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetResourcePolicyInput, ...func(*glue.Options)) *glue.GetResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetResourcePolicyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchema(ctx context.Context, params *glue.GetSchemaInput, optFns ...func(*glue.Options)) (*glue.GetSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchema")
	}

	var r0 *glue.GetSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaInput, ...func(*glue.Options)) (*glue.GetSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaInput, ...func(*glue.Options)) *glue.GetSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSchemaInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchemaByDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchemaByDefinition(ctx context.Context, params *glue.GetSchemaByDefinitionInput, optFns ...func(*glue.Options)) (*glue.GetSchemaByDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchemaByDefinition")
	}

	var r0 *glue.GetSchemaByDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaByDefinitionInput, ...func(*glue.Options)) (*glue.GetSchemaByDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaByDefinitionInput, ...func(*glue.Options)) *glue.GetSchemaByDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSchemaByDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSchemaByDefinitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchemaVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchemaVersion(ctx context.Context, params *glue.GetSchemaVersionInput, optFns ...func(*glue.Options)) (*glue.GetSchemaVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchemaVersion")
	}

	var r0 *glue.GetSchemaVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaVersionInput, ...func(*glue.Options)) (*glue.GetSchemaVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaVersionInput, ...func(*glue.Options)) *glue.GetSchemaVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSchemaVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSchemaVersionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchemaVersionsDiff provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchemaVersionsDiff(ctx context.Context, params *glue.GetSchemaVersionsDiffInput, optFns ...func(*glue.Options)) (*glue.GetSchemaVersionsDiffOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchemaVersionsDiff")
	}

	var r0 *glue.GetSchemaVersionsDiffOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaVersionsDiffInput, ...func(*glue.Options)) (*glue.GetSchemaVersionsDiffOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSchemaVersionsDiffInput, ...func(*glue.Options)) *glue.GetSchemaVersionsDiffOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSchemaVersionsDiffOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSchemaVersionsDiffInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecurityConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSecurityConfiguration(ctx context.Context, params *glue.GetSecurityConfigurationInput, optFns ...func(*glue.Options)) (*glue.GetSecurityConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSecurityConfiguration")
	}

	var r0 *glue.GetSecurityConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSecurityConfigurationInput, ...func(*glue.Options)) (*glue.GetSecurityConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSecurityConfigurationInput, ...func(*glue.Options)) *glue.GetSecurityConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSecurityConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSecurityConfigurationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecurityConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSecurityConfigurations(ctx context.Context, params *glue.GetSecurityConfigurationsInput, optFns ...func(*glue.Options)) (*glue.GetSecurityConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSecurityConfigurations")
	}

	var r0 *glue.GetSecurityConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSecurityConfigurationsInput, ...func(*glue.Options)) (*glue.GetSecurityConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSecurityConfigurationsInput, ...func(*glue.Options)) *glue.GetSecurityConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSecurityConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSecurityConfigurationsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSession(ctx context.Context, params *glue.GetSessionInput, optFns ...func(*glue.Options)) (*glue.GetSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *glue.GetSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSessionInput, ...func(*glue.Options)) (*glue.GetSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetSessionInput, ...func(*glue.Options)) *glue.GetSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetSessionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetStatement(ctx context.Context, params *glue.GetStatementInput, optFns ...func(*glue.Options)) (*glue.GetStatementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStatement")
	}

	var r0 *glue.GetStatementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetStatementInput, ...func(*glue.Options)) (*glue.GetStatementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetStatementInput, ...func(*glue.Options)) *glue.GetStatementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetStatementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetStatementInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTable(ctx context.Context, params *glue.GetTableInput, optFns ...func(*glue.Options)) (*glue.GetTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTable")
	}

	var r0 *glue.GetTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) (*glue.GetTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) *glue.GetTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableOptimizer(ctx context.Context, params *glue.GetTableOptimizerInput, optFns ...func(*glue.Options)) (*glue.GetTableOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableOptimizer")
	}

	var r0 *glue.GetTableOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableOptimizerInput, ...func(*glue.Options)) (*glue.GetTableOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableOptimizerInput, ...func(*glue.Options)) *glue.GetTableOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTableOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTableOptimizerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableVersion(ctx context.Context, params *glue.GetTableVersionInput, optFns ...func(*glue.Options)) (*glue.GetTableVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableVersion")
	}

	var r0 *glue.GetTableVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableVersionInput, ...func(*glue.Options)) (*glue.GetTableVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableVersionInput, ...func(*glue.Options)) *glue.GetTableVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTableVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTableVersionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableVersions(ctx context.Context, params *glue.GetTableVersionsInput, optFns ...func(*glue.Options)) (*glue.GetTableVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableVersions")
	}

	var r0 *glue.GetTableVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableVersionsInput, ...func(*glue.Options)) (*glue.GetTableVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTableVersionsInput, ...func(*glue.Options)) *glue.GetTableVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTableVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTableVersionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTables(ctx context.Context, params *glue.GetTablesInput, optFns ...func(*glue.Options)) (*glue.GetTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTables")
	}

	var r0 *glue.GetTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) (*glue.GetTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) *glue.GetTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTablesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTags(ctx context.Context, params *glue.GetTagsInput, optFns ...func(*glue.Options)) (*glue.GetTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTags")
	}

	var r0 *glue.GetTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTagsInput, ...func(*glue.Options)) (*glue.GetTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTagsInput, ...func(*glue.Options)) *glue.GetTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTagsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTrigger(ctx context.Context, params *glue.GetTriggerInput, optFns ...func(*glue.Options)) (*glue.GetTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTrigger")
	}

	var r0 *glue.GetTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTriggerInput, ...func(*glue.Options)) (*glue.GetTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTriggerInput, ...func(*glue.Options)) *glue.GetTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTriggers(ctx context.Context, params *glue.GetTriggersInput, optFns ...func(*glue.Options)) (*glue.GetTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTriggers")
	}

	var r0 *glue.GetTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTriggersInput, ...func(*glue.Options)) (*glue.GetTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetTriggersInput, ...func(*glue.Options)) *glue.GetTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetTriggersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnfilteredPartitionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUnfilteredPartitionMetadata(ctx context.Context, params *glue.GetUnfilteredPartitionMetadataInput, optFns ...func(*glue.Options)) (*glue.GetUnfilteredPartitionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUnfilteredPartitionMetadata")
	}

	var r0 *glue.GetUnfilteredPartitionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredPartitionMetadataInput, ...func(*glue.Options)) (*glue.GetUnfilteredPartitionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredPartitionMetadataInput, ...func(*glue.Options)) *glue.GetUnfilteredPartitionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUnfilteredPartitionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUnfilteredPartitionMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnfilteredPartitionsMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUnfilteredPartitionsMetadata(ctx context.Context, params *glue.GetUnfilteredPartitionsMetadataInput, optFns ...func(*glue.Options)) (*glue.GetUnfilteredPartitionsMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUnfilteredPartitionsMetadata")
	}

	var r0 *glue.GetUnfilteredPartitionsMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredPartitionsMetadataInput, ...func(*glue.Options)) (*glue.GetUnfilteredPartitionsMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredPartitionsMetadataInput, ...func(*glue.Options)) *glue.GetUnfilteredPartitionsMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUnfilteredPartitionsMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUnfilteredPartitionsMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnfilteredTableMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUnfilteredTableMetadata(ctx context.Context, params *glue.GetUnfilteredTableMetadataInput, optFns ...func(*glue.Options)) (*glue.GetUnfilteredTableMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUnfilteredTableMetadata")
	}

	var r0 *glue.GetUnfilteredTableMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredTableMetadataInput, ...func(*glue.Options)) (*glue.GetUnfilteredTableMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUnfilteredTableMetadataInput, ...func(*glue.Options)) *glue.GetUnfilteredTableMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUnfilteredTableMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUnfilteredTableMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsageProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUsageProfile(ctx context.Context, params *glue.GetUsageProfileInput, optFns ...func(*glue.Options)) (*glue.GetUsageProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUsageProfile")
	}

	var r0 *glue.GetUsageProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUsageProfileInput, ...func(*glue.Options)) (*glue.GetUsageProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUsageProfileInput, ...func(*glue.Options)) *glue.GetUsageProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUsageProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUsageProfileInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserDefinedFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUserDefinedFunction(ctx context.Context, params *glue.GetUserDefinedFunctionInput, optFns ...func(*glue.Options)) (*glue.GetUserDefinedFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefinedFunction")
	}

	var r0 *glue.GetUserDefinedFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUserDefinedFunctionInput, ...func(*glue.Options)) (*glue.GetUserDefinedFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUserDefinedFunctionInput, ...func(*glue.Options)) *glue.GetUserDefinedFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUserDefinedFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUserDefinedFunctionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserDefinedFunctions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetUserDefinedFunctions(ctx context.Context, params *glue.GetUserDefinedFunctionsInput, optFns ...func(*glue.Options)) (*glue.GetUserDefinedFunctionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefinedFunctions")
	}

	var r0 *glue.GetUserDefinedFunctionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUserDefinedFunctionsInput, ...func(*glue.Options)) (*glue.GetUserDefinedFunctionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetUserDefinedFunctionsInput, ...func(*glue.Options)) *glue.GetUserDefinedFunctionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetUserDefinedFunctionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetUserDefinedFunctionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflow(ctx context.Context, params *glue.GetWorkflowInput, optFns ...func(*glue.Options)) (*glue.GetWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *glue.GetWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowInput, ...func(*glue.Options)) (*glue.GetWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowInput, ...func(*glue.Options)) *glue.GetWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetWorkflowInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowRun(ctx context.Context, params *glue.GetWorkflowRunInput, optFns ...func(*glue.Options)) (*glue.GetWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRun")
	}

	var r0 *glue.GetWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunInput, ...func(*glue.Options)) (*glue.GetWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunInput, ...func(*glue.Options)) *glue.GetWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetWorkflowRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowRunProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowRunProperties(ctx context.Context, params *glue.GetWorkflowRunPropertiesInput, optFns ...func(*glue.Options)) (*glue.GetWorkflowRunPropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRunProperties")
	}

	var r0 *glue.GetWorkflowRunPropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunPropertiesInput, ...func(*glue.Options)) (*glue.GetWorkflowRunPropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunPropertiesInput, ...func(*glue.Options)) *glue.GetWorkflowRunPropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetWorkflowRunPropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetWorkflowRunPropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkflowRuns(ctx context.Context, params *glue.GetWorkflowRunsInput, optFns ...func(*glue.Options)) (*glue.GetWorkflowRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRuns")
	}

	var r0 *glue.GetWorkflowRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunsInput, ...func(*glue.Options)) (*glue.GetWorkflowRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.GetWorkflowRunsInput, ...func(*glue.Options)) *glue.GetWorkflowRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.GetWorkflowRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.GetWorkflowRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportCatalogToGlue provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportCatalogToGlue(ctx context.Context, params *glue.ImportCatalogToGlueInput, optFns ...func(*glue.Options)) (*glue.ImportCatalogToGlueOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportCatalogToGlue")
	}

	var r0 *glue.ImportCatalogToGlueOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ImportCatalogToGlueInput, ...func(*glue.Options)) (*glue.ImportCatalogToGlueOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ImportCatalogToGlueInput, ...func(*glue.Options)) *glue.ImportCatalogToGlueOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ImportCatalogToGlueOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ImportCatalogToGlueInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBlueprints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBlueprints(ctx context.Context, params *glue.ListBlueprintsInput, optFns ...func(*glue.Options)) (*glue.ListBlueprintsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBlueprints")
	}

	var r0 *glue.ListBlueprintsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListBlueprintsInput, ...func(*glue.Options)) (*glue.ListBlueprintsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListBlueprintsInput, ...func(*glue.Options)) *glue.ListBlueprintsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListBlueprintsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListBlueprintsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListColumnStatisticsTaskRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListColumnStatisticsTaskRuns(ctx context.Context, params *glue.ListColumnStatisticsTaskRunsInput, optFns ...func(*glue.Options)) (*glue.ListColumnStatisticsTaskRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListColumnStatisticsTaskRuns")
	}

	var r0 *glue.ListColumnStatisticsTaskRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListColumnStatisticsTaskRunsInput, ...func(*glue.Options)) (*glue.ListColumnStatisticsTaskRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListColumnStatisticsTaskRunsInput, ...func(*glue.Options)) *glue.ListColumnStatisticsTaskRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListColumnStatisticsTaskRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListColumnStatisticsTaskRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConnectionTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConnectionTypes(ctx context.Context, params *glue.ListConnectionTypesInput, optFns ...func(*glue.Options)) (*glue.ListConnectionTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConnectionTypes")
	}

	var r0 *glue.ListConnectionTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListConnectionTypesInput, ...func(*glue.Options)) (*glue.ListConnectionTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListConnectionTypesInput, ...func(*glue.Options)) *glue.ListConnectionTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListConnectionTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListConnectionTypesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCrawlers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCrawlers(ctx context.Context, params *glue.ListCrawlersInput, optFns ...func(*glue.Options)) (*glue.ListCrawlersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCrawlers")
	}

	var r0 *glue.ListCrawlersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCrawlersInput, ...func(*glue.Options)) (*glue.ListCrawlersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCrawlersInput, ...func(*glue.Options)) *glue.ListCrawlersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListCrawlersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListCrawlersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCrawls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCrawls(ctx context.Context, params *glue.ListCrawlsInput, optFns ...func(*glue.Options)) (*glue.ListCrawlsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCrawls")
	}

	var r0 *glue.ListCrawlsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCrawlsInput, ...func(*glue.Options)) (*glue.ListCrawlsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCrawlsInput, ...func(*glue.Options)) *glue.ListCrawlsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListCrawlsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListCrawlsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomEntityTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomEntityTypes(ctx context.Context, params *glue.ListCustomEntityTypesInput, optFns ...func(*glue.Options)) (*glue.ListCustomEntityTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomEntityTypes")
	}

	var r0 *glue.ListCustomEntityTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCustomEntityTypesInput, ...func(*glue.Options)) (*glue.ListCustomEntityTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListCustomEntityTypesInput, ...func(*glue.Options)) *glue.ListCustomEntityTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListCustomEntityTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListCustomEntityTypesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityResults(ctx context.Context, params *glue.ListDataQualityResultsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityResults")
	}

	var r0 *glue.ListDataQualityResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityResultsInput, ...func(*glue.Options)) (*glue.ListDataQualityResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityResultsInput, ...func(*glue.Options)) *glue.ListDataQualityResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityResultsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityRuleRecommendationRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityRuleRecommendationRuns(ctx context.Context, params *glue.ListDataQualityRuleRecommendationRunsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityRuleRecommendationRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityRuleRecommendationRuns")
	}

	var r0 *glue.ListDataQualityRuleRecommendationRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRuleRecommendationRunsInput, ...func(*glue.Options)) (*glue.ListDataQualityRuleRecommendationRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRuleRecommendationRunsInput, ...func(*glue.Options)) *glue.ListDataQualityRuleRecommendationRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityRuleRecommendationRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityRuleRecommendationRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityRulesetEvaluationRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityRulesetEvaluationRuns(ctx context.Context, params *glue.ListDataQualityRulesetEvaluationRunsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityRulesetEvaluationRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityRulesetEvaluationRuns")
	}

	var r0 *glue.ListDataQualityRulesetEvaluationRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRulesetEvaluationRunsInput, ...func(*glue.Options)) (*glue.ListDataQualityRulesetEvaluationRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRulesetEvaluationRunsInput, ...func(*glue.Options)) *glue.ListDataQualityRulesetEvaluationRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityRulesetEvaluationRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityRulesetEvaluationRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityRulesets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityRulesets(ctx context.Context, params *glue.ListDataQualityRulesetsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityRulesetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityRulesets")
	}

	var r0 *glue.ListDataQualityRulesetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRulesetsInput, ...func(*glue.Options)) (*glue.ListDataQualityRulesetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityRulesetsInput, ...func(*glue.Options)) *glue.ListDataQualityRulesetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityRulesetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityRulesetsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityStatisticAnnotations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityStatisticAnnotations(ctx context.Context, params *glue.ListDataQualityStatisticAnnotationsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityStatisticAnnotationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityStatisticAnnotations")
	}

	var r0 *glue.ListDataQualityStatisticAnnotationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityStatisticAnnotationsInput, ...func(*glue.Options)) (*glue.ListDataQualityStatisticAnnotationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityStatisticAnnotationsInput, ...func(*glue.Options)) *glue.ListDataQualityStatisticAnnotationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityStatisticAnnotationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityStatisticAnnotationsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataQualityStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataQualityStatistics(ctx context.Context, params *glue.ListDataQualityStatisticsInput, optFns ...func(*glue.Options)) (*glue.ListDataQualityStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataQualityStatistics")
	}

	var r0 *glue.ListDataQualityStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityStatisticsInput, ...func(*glue.Options)) (*glue.ListDataQualityStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDataQualityStatisticsInput, ...func(*glue.Options)) *glue.ListDataQualityStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDataQualityStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDataQualityStatisticsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDevEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDevEndpoints(ctx context.Context, params *glue.ListDevEndpointsInput, optFns ...func(*glue.Options)) (*glue.ListDevEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevEndpoints")
	}

	var r0 *glue.ListDevEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDevEndpointsInput, ...func(*glue.Options)) (*glue.ListDevEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListDevEndpointsInput, ...func(*glue.Options)) *glue.ListDevEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListDevEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListDevEndpointsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEntities(ctx context.Context, params *glue.ListEntitiesInput, optFns ...func(*glue.Options)) (*glue.ListEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEntities")
	}

	var r0 *glue.ListEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListEntitiesInput, ...func(*glue.Options)) (*glue.ListEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListEntitiesInput, ...func(*glue.Options)) *glue.ListEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListEntitiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobs(ctx context.Context, params *glue.ListJobsInput, optFns ...func(*glue.Options)) (*glue.ListJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 *glue.ListJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListJobsInput, ...func(*glue.Options)) (*glue.ListJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListJobsInput, ...func(*glue.Options)) *glue.ListJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListJobsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMLTransforms provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMLTransforms(ctx context.Context, params *glue.ListMLTransformsInput, optFns ...func(*glue.Options)) (*glue.ListMLTransformsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMLTransforms")
	}

	var r0 *glue.ListMLTransformsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListMLTransformsInput, ...func(*glue.Options)) (*glue.ListMLTransformsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListMLTransformsInput, ...func(*glue.Options)) *glue.ListMLTransformsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListMLTransformsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListMLTransformsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegistries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegistries(ctx context.Context, params *glue.ListRegistriesInput, optFns ...func(*glue.Options)) (*glue.ListRegistriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegistries")
	}

	var r0 *glue.ListRegistriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListRegistriesInput, ...func(*glue.Options)) (*glue.ListRegistriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListRegistriesInput, ...func(*glue.Options)) *glue.ListRegistriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListRegistriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListRegistriesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSchemaVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSchemaVersions(ctx context.Context, params *glue.ListSchemaVersionsInput, optFns ...func(*glue.Options)) (*glue.ListSchemaVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSchemaVersions")
	}

	var r0 *glue.ListSchemaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSchemaVersionsInput, ...func(*glue.Options)) (*glue.ListSchemaVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSchemaVersionsInput, ...func(*glue.Options)) *glue.ListSchemaVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListSchemaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListSchemaVersionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSchemas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSchemas(ctx context.Context, params *glue.ListSchemasInput, optFns ...func(*glue.Options)) (*glue.ListSchemasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSchemas")
	}

	var r0 *glue.ListSchemasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSchemasInput, ...func(*glue.Options)) (*glue.ListSchemasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSchemasInput, ...func(*glue.Options)) *glue.ListSchemasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListSchemasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListSchemasInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSessions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSessions(ctx context.Context, params *glue.ListSessionsInput, optFns ...func(*glue.Options)) (*glue.ListSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSessions")
	}

	var r0 *glue.ListSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSessionsInput, ...func(*glue.Options)) (*glue.ListSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListSessionsInput, ...func(*glue.Options)) *glue.ListSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListSessionsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStatements provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListStatements(ctx context.Context, params *glue.ListStatementsInput, optFns ...func(*glue.Options)) (*glue.ListStatementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStatements")
	}

	var r0 *glue.ListStatementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListStatementsInput, ...func(*glue.Options)) (*glue.ListStatementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListStatementsInput, ...func(*glue.Options)) *glue.ListStatementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListStatementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListStatementsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTableOptimizerRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTableOptimizerRuns(ctx context.Context, params *glue.ListTableOptimizerRunsInput, optFns ...func(*glue.Options)) (*glue.ListTableOptimizerRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTableOptimizerRuns")
	}

	var r0 *glue.ListTableOptimizerRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListTableOptimizerRunsInput, ...func(*glue.Options)) (*glue.ListTableOptimizerRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListTableOptimizerRunsInput, ...func(*glue.Options)) *glue.ListTableOptimizerRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListTableOptimizerRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListTableOptimizerRunsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTriggers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTriggers(ctx context.Context, params *glue.ListTriggersInput, optFns ...func(*glue.Options)) (*glue.ListTriggersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTriggers")
	}

	var r0 *glue.ListTriggersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListTriggersInput, ...func(*glue.Options)) (*glue.ListTriggersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListTriggersInput, ...func(*glue.Options)) *glue.ListTriggersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListTriggersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListTriggersInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsageProfiles provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUsageProfiles(ctx context.Context, params *glue.ListUsageProfilesInput, optFns ...func(*glue.Options)) (*glue.ListUsageProfilesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsageProfiles")
	}

	var r0 *glue.ListUsageProfilesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListUsageProfilesInput, ...func(*glue.Options)) (*glue.ListUsageProfilesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListUsageProfilesInput, ...func(*glue.Options)) *glue.ListUsageProfilesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListUsageProfilesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListUsageProfilesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkflows provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkflows(ctx context.Context, params *glue.ListWorkflowsInput, optFns ...func(*glue.Options)) (*glue.ListWorkflowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *glue.ListWorkflowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListWorkflowsInput, ...func(*glue.Options)) (*glue.ListWorkflowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ListWorkflowsInput, ...func(*glue.Options)) *glue.ListWorkflowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ListWorkflowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ListWorkflowsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIntegration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyIntegration(ctx context.Context, params *glue.ModifyIntegrationInput, optFns ...func(*glue.Options)) (*glue.ModifyIntegrationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIntegration")
	}

	var r0 *glue.ModifyIntegrationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ModifyIntegrationInput, ...func(*glue.Options)) (*glue.ModifyIntegrationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ModifyIntegrationInput, ...func(*glue.Options)) *glue.ModifyIntegrationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ModifyIntegrationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ModifyIntegrationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() glue.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 glue.Options
	if rf, ok := ret.Get(0).(func() glue.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(glue.Options)
	}

	return r0
}

// PutDataCatalogEncryptionSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutDataCatalogEncryptionSettings(ctx context.Context, params *glue.PutDataCatalogEncryptionSettingsInput, optFns ...func(*glue.Options)) (*glue.PutDataCatalogEncryptionSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutDataCatalogEncryptionSettings")
	}

	var r0 *glue.PutDataCatalogEncryptionSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) (*glue.PutDataCatalogEncryptionSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) *glue.PutDataCatalogEncryptionSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.PutDataCatalogEncryptionSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.PutDataCatalogEncryptionSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutDataQualityProfileAnnotation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutDataQualityProfileAnnotation(ctx context.Context, params *glue.PutDataQualityProfileAnnotationInput, optFns ...func(*glue.Options)) (*glue.PutDataQualityProfileAnnotationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutDataQualityProfileAnnotation")
	}

	var r0 *glue.PutDataQualityProfileAnnotationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutDataQualityProfileAnnotationInput, ...func(*glue.Options)) (*glue.PutDataQualityProfileAnnotationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutDataQualityProfileAnnotationInput, ...func(*glue.Options)) *glue.PutDataQualityProfileAnnotationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.PutDataQualityProfileAnnotationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.PutDataQualityProfileAnnotationInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *glue.PutResourcePolicyInput, optFns ...func(*glue.Options)) (*glue.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *glue.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutResourcePolicyInput, ...func(*glue.Options)) (*glue.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutResourcePolicyInput, ...func(*glue.Options)) *glue.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.PutResourcePolicyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutSchemaVersionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutSchemaVersionMetadata(ctx context.Context, params *glue.PutSchemaVersionMetadataInput, optFns ...func(*glue.Options)) (*glue.PutSchemaVersionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutSchemaVersionMetadata")
	}

	var r0 *glue.PutSchemaVersionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutSchemaVersionMetadataInput, ...func(*glue.Options)) (*glue.PutSchemaVersionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutSchemaVersionMetadataInput, ...func(*glue.Options)) *glue.PutSchemaVersionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.PutSchemaVersionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.PutSchemaVersionMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutWorkflowRunProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutWorkflowRunProperties(ctx context.Context, params *glue.PutWorkflowRunPropertiesInput, optFns ...func(*glue.Options)) (*glue.PutWorkflowRunPropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutWorkflowRunProperties")
	}

	var r0 *glue.PutWorkflowRunPropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutWorkflowRunPropertiesInput, ...func(*glue.Options)) (*glue.PutWorkflowRunPropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.PutWorkflowRunPropertiesInput, ...func(*glue.Options)) *glue.PutWorkflowRunPropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.PutWorkflowRunPropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.PutWorkflowRunPropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuerySchemaVersionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) QuerySchemaVersionMetadata(ctx context.Context, params *glue.QuerySchemaVersionMetadataInput, optFns ...func(*glue.Options)) (*glue.QuerySchemaVersionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QuerySchemaVersionMetadata")
	}

	var r0 *glue.QuerySchemaVersionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.QuerySchemaVersionMetadataInput, ...func(*glue.Options)) (*glue.QuerySchemaVersionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.QuerySchemaVersionMetadataInput, ...func(*glue.Options)) *glue.QuerySchemaVersionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.QuerySchemaVersionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.QuerySchemaVersionMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterSchemaVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterSchemaVersion(ctx context.Context, params *glue.RegisterSchemaVersionInput, optFns ...func(*glue.Options)) (*glue.RegisterSchemaVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterSchemaVersion")
	}

	var r0 *glue.RegisterSchemaVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RegisterSchemaVersionInput, ...func(*glue.Options)) (*glue.RegisterSchemaVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RegisterSchemaVersionInput, ...func(*glue.Options)) *glue.RegisterSchemaVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.RegisterSchemaVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.RegisterSchemaVersionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveSchemaVersionMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveSchemaVersionMetadata(ctx context.Context, params *glue.RemoveSchemaVersionMetadataInput, optFns ...func(*glue.Options)) (*glue.RemoveSchemaVersionMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSchemaVersionMetadata")
	}

	var r0 *glue.RemoveSchemaVersionMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RemoveSchemaVersionMetadataInput, ...func(*glue.Options)) (*glue.RemoveSchemaVersionMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RemoveSchemaVersionMetadataInput, ...func(*glue.Options)) *glue.RemoveSchemaVersionMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.RemoveSchemaVersionMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.RemoveSchemaVersionMetadataInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetJobBookmark provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetJobBookmark(ctx context.Context, params *glue.ResetJobBookmarkInput, optFns ...func(*glue.Options)) (*glue.ResetJobBookmarkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetJobBookmark")
	}

	var r0 *glue.ResetJobBookmarkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ResetJobBookmarkInput, ...func(*glue.Options)) (*glue.ResetJobBookmarkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ResetJobBookmarkInput, ...func(*glue.Options)) *glue.ResetJobBookmarkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ResetJobBookmarkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ResetJobBookmarkInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResumeWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResumeWorkflowRun(ctx context.Context, params *glue.ResumeWorkflowRunInput, optFns ...func(*glue.Options)) (*glue.ResumeWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeWorkflowRun")
	}

	var r0 *glue.ResumeWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ResumeWorkflowRunInput, ...func(*glue.Options)) (*glue.ResumeWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.ResumeWorkflowRunInput, ...func(*glue.Options)) *glue.ResumeWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.ResumeWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.ResumeWorkflowRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunStatement provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RunStatement(ctx context.Context, params *glue.RunStatementInput, optFns ...func(*glue.Options)) (*glue.RunStatementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunStatement")
	}

	var r0 *glue.RunStatementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RunStatementInput, ...func(*glue.Options)) (*glue.RunStatementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.RunStatementInput, ...func(*glue.Options)) *glue.RunStatementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.RunStatementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.RunStatementInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchTables(ctx context.Context, params *glue.SearchTablesInput, optFns ...func(*glue.Options)) (*glue.SearchTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTables")
	}

	var r0 *glue.SearchTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.SearchTablesInput, ...func(*glue.Options)) (*glue.SearchTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.SearchTablesInput, ...func(*glue.Options)) *glue.SearchTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.SearchTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.SearchTablesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBlueprintRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartBlueprintRun(ctx context.Context, params *glue.StartBlueprintRunInput, optFns ...func(*glue.Options)) (*glue.StartBlueprintRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartBlueprintRun")
	}

	var r0 *glue.StartBlueprintRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartBlueprintRunInput, ...func(*glue.Options)) (*glue.StartBlueprintRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartBlueprintRunInput, ...func(*glue.Options)) *glue.StartBlueprintRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartBlueprintRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartBlueprintRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartColumnStatisticsTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartColumnStatisticsTaskRun(ctx context.Context, params *glue.StartColumnStatisticsTaskRunInput, optFns ...func(*glue.Options)) (*glue.StartColumnStatisticsTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartColumnStatisticsTaskRun")
	}

	var r0 *glue.StartColumnStatisticsTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartColumnStatisticsTaskRunInput, ...func(*glue.Options)) (*glue.StartColumnStatisticsTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartColumnStatisticsTaskRunInput, ...func(*glue.Options)) *glue.StartColumnStatisticsTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartColumnStatisticsTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartColumnStatisticsTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartColumnStatisticsTaskRunSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartColumnStatisticsTaskRunSchedule(ctx context.Context, params *glue.StartColumnStatisticsTaskRunScheduleInput, optFns ...func(*glue.Options)) (*glue.StartColumnStatisticsTaskRunScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartColumnStatisticsTaskRunSchedule")
	}

	var r0 *glue.StartColumnStatisticsTaskRunScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) (*glue.StartColumnStatisticsTaskRunScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) *glue.StartColumnStatisticsTaskRunScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartColumnStatisticsTaskRunScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCrawler(ctx context.Context, params *glue.StartCrawlerInput, optFns ...func(*glue.Options)) (*glue.StartCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCrawler")
	}

	var r0 *glue.StartCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartCrawlerInput, ...func(*glue.Options)) (*glue.StartCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartCrawlerInput, ...func(*glue.Options)) *glue.StartCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartCrawlerSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartCrawlerSchedule(ctx context.Context, params *glue.StartCrawlerScheduleInput, optFns ...func(*glue.Options)) (*glue.StartCrawlerScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartCrawlerSchedule")
	}

	var r0 *glue.StartCrawlerScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartCrawlerScheduleInput, ...func(*glue.Options)) (*glue.StartCrawlerScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartCrawlerScheduleInput, ...func(*glue.Options)) *glue.StartCrawlerScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartCrawlerScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartCrawlerScheduleInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDataQualityRuleRecommendationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDataQualityRuleRecommendationRun(ctx context.Context, params *glue.StartDataQualityRuleRecommendationRunInput, optFns ...func(*glue.Options)) (*glue.StartDataQualityRuleRecommendationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDataQualityRuleRecommendationRun")
	}

	var r0 *glue.StartDataQualityRuleRecommendationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) (*glue.StartDataQualityRuleRecommendationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) *glue.StartDataQualityRuleRecommendationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartDataQualityRuleRecommendationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartDataQualityRuleRecommendationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDataQualityRulesetEvaluationRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDataQualityRulesetEvaluationRun(ctx context.Context, params *glue.StartDataQualityRulesetEvaluationRunInput, optFns ...func(*glue.Options)) (*glue.StartDataQualityRulesetEvaluationRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDataQualityRulesetEvaluationRun")
	}

	var r0 *glue.StartDataQualityRulesetEvaluationRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) (*glue.StartDataQualityRulesetEvaluationRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) *glue.StartDataQualityRulesetEvaluationRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartDataQualityRulesetEvaluationRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartDataQualityRulesetEvaluationRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartExportLabelsTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartExportLabelsTaskRun(ctx context.Context, params *glue.StartExportLabelsTaskRunInput, optFns ...func(*glue.Options)) (*glue.StartExportLabelsTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartExportLabelsTaskRun")
	}

	var r0 *glue.StartExportLabelsTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartExportLabelsTaskRunInput, ...func(*glue.Options)) (*glue.StartExportLabelsTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartExportLabelsTaskRunInput, ...func(*glue.Options)) *glue.StartExportLabelsTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartExportLabelsTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartExportLabelsTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartImportLabelsTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartImportLabelsTaskRun(ctx context.Context, params *glue.StartImportLabelsTaskRunInput, optFns ...func(*glue.Options)) (*glue.StartImportLabelsTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartImportLabelsTaskRun")
	}

	var r0 *glue.StartImportLabelsTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartImportLabelsTaskRunInput, ...func(*glue.Options)) (*glue.StartImportLabelsTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartImportLabelsTaskRunInput, ...func(*glue.Options)) *glue.StartImportLabelsTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartImportLabelsTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartImportLabelsTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartJobRun(ctx context.Context, params *glue.StartJobRunInput, optFns ...func(*glue.Options)) (*glue.StartJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartJobRun")
	}

	var r0 *glue.StartJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartJobRunInput, ...func(*glue.Options)) (*glue.StartJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartJobRunInput, ...func(*glue.Options)) *glue.StartJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartJobRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMLEvaluationTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMLEvaluationTaskRun(ctx context.Context, params *glue.StartMLEvaluationTaskRunInput, optFns ...func(*glue.Options)) (*glue.StartMLEvaluationTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMLEvaluationTaskRun")
	}

	var r0 *glue.StartMLEvaluationTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartMLEvaluationTaskRunInput, ...func(*glue.Options)) (*glue.StartMLEvaluationTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartMLEvaluationTaskRunInput, ...func(*glue.Options)) *glue.StartMLEvaluationTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartMLEvaluationTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartMLEvaluationTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartMLLabelingSetGenerationTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartMLLabelingSetGenerationTaskRun(ctx context.Context, params *glue.StartMLLabelingSetGenerationTaskRunInput, optFns ...func(*glue.Options)) (*glue.StartMLLabelingSetGenerationTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMLLabelingSetGenerationTaskRun")
	}

	var r0 *glue.StartMLLabelingSetGenerationTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartMLLabelingSetGenerationTaskRunInput, ...func(*glue.Options)) (*glue.StartMLLabelingSetGenerationTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartMLLabelingSetGenerationTaskRunInput, ...func(*glue.Options)) *glue.StartMLLabelingSetGenerationTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartMLLabelingSetGenerationTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartMLLabelingSetGenerationTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTrigger(ctx context.Context, params *glue.StartTriggerInput, optFns ...func(*glue.Options)) (*glue.StartTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTrigger")
	}

	var r0 *glue.StartTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartTriggerInput, ...func(*glue.Options)) (*glue.StartTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartTriggerInput, ...func(*glue.Options)) *glue.StartTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartWorkflowRun(ctx context.Context, params *glue.StartWorkflowRunInput, optFns ...func(*glue.Options)) (*glue.StartWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartWorkflowRun")
	}

	var r0 *glue.StartWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartWorkflowRunInput, ...func(*glue.Options)) (*glue.StartWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StartWorkflowRunInput, ...func(*glue.Options)) *glue.StartWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StartWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StartWorkflowRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopColumnStatisticsTaskRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopColumnStatisticsTaskRun(ctx context.Context, params *glue.StopColumnStatisticsTaskRunInput, optFns ...func(*glue.Options)) (*glue.StopColumnStatisticsTaskRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopColumnStatisticsTaskRun")
	}

	var r0 *glue.StopColumnStatisticsTaskRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopColumnStatisticsTaskRunInput, ...func(*glue.Options)) (*glue.StopColumnStatisticsTaskRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopColumnStatisticsTaskRunInput, ...func(*glue.Options)) *glue.StopColumnStatisticsTaskRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopColumnStatisticsTaskRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopColumnStatisticsTaskRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopColumnStatisticsTaskRunSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopColumnStatisticsTaskRunSchedule(ctx context.Context, params *glue.StopColumnStatisticsTaskRunScheduleInput, optFns ...func(*glue.Options)) (*glue.StopColumnStatisticsTaskRunScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopColumnStatisticsTaskRunSchedule")
	}

	var r0 *glue.StopColumnStatisticsTaskRunScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) (*glue.StopColumnStatisticsTaskRunScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) *glue.StopColumnStatisticsTaskRunScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopColumnStatisticsTaskRunScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopColumnStatisticsTaskRunScheduleInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopCrawler(ctx context.Context, params *glue.StopCrawlerInput, optFns ...func(*glue.Options)) (*glue.StopCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopCrawler")
	}

	var r0 *glue.StopCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopCrawlerInput, ...func(*glue.Options)) (*glue.StopCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopCrawlerInput, ...func(*glue.Options)) *glue.StopCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopCrawlerSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopCrawlerSchedule(ctx context.Context, params *glue.StopCrawlerScheduleInput, optFns ...func(*glue.Options)) (*glue.StopCrawlerScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopCrawlerSchedule")
	}

	var r0 *glue.StopCrawlerScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopCrawlerScheduleInput, ...func(*glue.Options)) (*glue.StopCrawlerScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopCrawlerScheduleInput, ...func(*glue.Options)) *glue.StopCrawlerScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopCrawlerScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopCrawlerScheduleInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopSession(ctx context.Context, params *glue.StopSessionInput, optFns ...func(*glue.Options)) (*glue.StopSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopSession")
	}

	var r0 *glue.StopSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopSessionInput, ...func(*glue.Options)) (*glue.StopSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopSessionInput, ...func(*glue.Options)) *glue.StopSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopSessionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopTrigger(ctx context.Context, params *glue.StopTriggerInput, optFns ...func(*glue.Options)) (*glue.StopTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTrigger")
	}

	var r0 *glue.StopTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopTriggerInput, ...func(*glue.Options)) (*glue.StopTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopTriggerInput, ...func(*glue.Options)) *glue.StopTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopWorkflowRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopWorkflowRun(ctx context.Context, params *glue.StopWorkflowRunInput, optFns ...func(*glue.Options)) (*glue.StopWorkflowRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopWorkflowRun")
	}

	var r0 *glue.StopWorkflowRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopWorkflowRunInput, ...func(*glue.Options)) (*glue.StopWorkflowRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.StopWorkflowRunInput, ...func(*glue.Options)) *glue.StopWorkflowRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.StopWorkflowRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.StopWorkflowRunInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *glue.TagResourceInput, optFns ...func(*glue.Options)) (*glue.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *glue.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.TagResourceInput, ...func(*glue.Options)) (*glue.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.TagResourceInput, ...func(*glue.Options)) *glue.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.TagResourceInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TestConnection(ctx context.Context, params *glue.TestConnectionInput, optFns ...func(*glue.Options)) (*glue.TestConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TestConnection")
	}

	var r0 *glue.TestConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.TestConnectionInput, ...func(*glue.Options)) (*glue.TestConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.TestConnectionInput, ...func(*glue.Options)) *glue.TestConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.TestConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.TestConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *glue.UntagResourceInput, optFns ...func(*glue.Options)) (*glue.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *glue.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UntagResourceInput, ...func(*glue.Options)) (*glue.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UntagResourceInput, ...func(*glue.Options)) *glue.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UntagResourceInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBlueprint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBlueprint(ctx context.Context, params *glue.UpdateBlueprintInput, optFns ...func(*glue.Options)) (*glue.UpdateBlueprintOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBlueprint")
	}

	var r0 *glue.UpdateBlueprintOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateBlueprintInput, ...func(*glue.Options)) (*glue.UpdateBlueprintOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateBlueprintInput, ...func(*glue.Options)) *glue.UpdateBlueprintOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateBlueprintOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateBlueprintInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCatalog provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCatalog(ctx context.Context, params *glue.UpdateCatalogInput, optFns ...func(*glue.Options)) (*glue.UpdateCatalogOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCatalog")
	}

	var r0 *glue.UpdateCatalogOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCatalogInput, ...func(*glue.Options)) (*glue.UpdateCatalogOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCatalogInput, ...func(*glue.Options)) *glue.UpdateCatalogOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateCatalogOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateCatalogInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClassifier provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateClassifier(ctx context.Context, params *glue.UpdateClassifierInput, optFns ...func(*glue.Options)) (*glue.UpdateClassifierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClassifier")
	}

	var r0 *glue.UpdateClassifierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateClassifierInput, ...func(*glue.Options)) (*glue.UpdateClassifierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateClassifierInput, ...func(*glue.Options)) *glue.UpdateClassifierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateClassifierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateClassifierInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumnStatisticsForPartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateColumnStatisticsForPartition(ctx context.Context, params *glue.UpdateColumnStatisticsForPartitionInput, optFns ...func(*glue.Options)) (*glue.UpdateColumnStatisticsForPartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumnStatisticsForPartition")
	}

	var r0 *glue.UpdateColumnStatisticsForPartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsForPartitionInput, ...func(*glue.Options)) (*glue.UpdateColumnStatisticsForPartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsForPartitionInput, ...func(*glue.Options)) *glue.UpdateColumnStatisticsForPartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateColumnStatisticsForPartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateColumnStatisticsForPartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumnStatisticsForTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateColumnStatisticsForTable(ctx context.Context, params *glue.UpdateColumnStatisticsForTableInput, optFns ...func(*glue.Options)) (*glue.UpdateColumnStatisticsForTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumnStatisticsForTable")
	}

	var r0 *glue.UpdateColumnStatisticsForTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsForTableInput, ...func(*glue.Options)) (*glue.UpdateColumnStatisticsForTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsForTableInput, ...func(*glue.Options)) *glue.UpdateColumnStatisticsForTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateColumnStatisticsForTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateColumnStatisticsForTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateColumnStatisticsTaskSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateColumnStatisticsTaskSettings(ctx context.Context, params *glue.UpdateColumnStatisticsTaskSettingsInput, optFns ...func(*glue.Options)) (*glue.UpdateColumnStatisticsTaskSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateColumnStatisticsTaskSettings")
	}

	var r0 *glue.UpdateColumnStatisticsTaskSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) (*glue.UpdateColumnStatisticsTaskSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) *glue.UpdateColumnStatisticsTaskSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateColumnStatisticsTaskSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateColumnStatisticsTaskSettingsInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnection provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConnection(ctx context.Context, params *glue.UpdateConnectionInput, optFns ...func(*glue.Options)) (*glue.UpdateConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnection")
	}

	var r0 *glue.UpdateConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateConnectionInput, ...func(*glue.Options)) (*glue.UpdateConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateConnectionInput, ...func(*glue.Options)) *glue.UpdateConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateConnectionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCrawler provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCrawler(ctx context.Context, params *glue.UpdateCrawlerInput, optFns ...func(*glue.Options)) (*glue.UpdateCrawlerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCrawler")
	}

	var r0 *glue.UpdateCrawlerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCrawlerInput, ...func(*glue.Options)) (*glue.UpdateCrawlerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCrawlerInput, ...func(*glue.Options)) *glue.UpdateCrawlerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateCrawlerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateCrawlerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCrawlerSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCrawlerSchedule(ctx context.Context, params *glue.UpdateCrawlerScheduleInput, optFns ...func(*glue.Options)) (*glue.UpdateCrawlerScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCrawlerSchedule")
	}

	var r0 *glue.UpdateCrawlerScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCrawlerScheduleInput, ...func(*glue.Options)) (*glue.UpdateCrawlerScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateCrawlerScheduleInput, ...func(*glue.Options)) *glue.UpdateCrawlerScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateCrawlerScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateCrawlerScheduleInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataQualityRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataQualityRuleset(ctx context.Context, params *glue.UpdateDataQualityRulesetInput, optFns ...func(*glue.Options)) (*glue.UpdateDataQualityRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataQualityRuleset")
	}

	var r0 *glue.UpdateDataQualityRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDataQualityRulesetInput, ...func(*glue.Options)) (*glue.UpdateDataQualityRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDataQualityRulesetInput, ...func(*glue.Options)) *glue.UpdateDataQualityRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateDataQualityRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateDataQualityRulesetInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDatabase provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDatabase(ctx context.Context, params *glue.UpdateDatabaseInput, optFns ...func(*glue.Options)) (*glue.UpdateDatabaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabase")
	}

	var r0 *glue.UpdateDatabaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) (*glue.UpdateDatabaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) *glue.UpdateDatabaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateDatabaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateDatabaseInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDevEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDevEndpoint(ctx context.Context, params *glue.UpdateDevEndpointInput, optFns ...func(*glue.Options)) (*glue.UpdateDevEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDevEndpoint")
	}

	var r0 *glue.UpdateDevEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDevEndpointInput, ...func(*glue.Options)) (*glue.UpdateDevEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateDevEndpointInput, ...func(*glue.Options)) *glue.UpdateDevEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateDevEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateDevEndpointInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIntegrationResourceProperty provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIntegrationResourceProperty(ctx context.Context, params *glue.UpdateIntegrationResourcePropertyInput, optFns ...func(*glue.Options)) (*glue.UpdateIntegrationResourcePropertyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIntegrationResourceProperty")
	}

	var r0 *glue.UpdateIntegrationResourcePropertyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateIntegrationResourcePropertyInput, ...func(*glue.Options)) (*glue.UpdateIntegrationResourcePropertyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateIntegrationResourcePropertyInput, ...func(*glue.Options)) *glue.UpdateIntegrationResourcePropertyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateIntegrationResourcePropertyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateIntegrationResourcePropertyInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIntegrationTableProperties provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIntegrationTableProperties(ctx context.Context, params *glue.UpdateIntegrationTablePropertiesInput, optFns ...func(*glue.Options)) (*glue.UpdateIntegrationTablePropertiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIntegrationTableProperties")
	}

	var r0 *glue.UpdateIntegrationTablePropertiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateIntegrationTablePropertiesInput, ...func(*glue.Options)) (*glue.UpdateIntegrationTablePropertiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateIntegrationTablePropertiesInput, ...func(*glue.Options)) *glue.UpdateIntegrationTablePropertiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateIntegrationTablePropertiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateIntegrationTablePropertiesInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateJob(ctx context.Context, params *glue.UpdateJobInput, optFns ...func(*glue.Options)) (*glue.UpdateJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJob")
	}

	var r0 *glue.UpdateJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateJobInput, ...func(*glue.Options)) (*glue.UpdateJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateJobInput, ...func(*glue.Options)) *glue.UpdateJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateJobInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateJobFromSourceControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateJobFromSourceControl(ctx context.Context, params *glue.UpdateJobFromSourceControlInput, optFns ...func(*glue.Options)) (*glue.UpdateJobFromSourceControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobFromSourceControl")
	}

	var r0 *glue.UpdateJobFromSourceControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateJobFromSourceControlInput, ...func(*glue.Options)) (*glue.UpdateJobFromSourceControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateJobFromSourceControlInput, ...func(*glue.Options)) *glue.UpdateJobFromSourceControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateJobFromSourceControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateJobFromSourceControlInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMLTransform provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMLTransform(ctx context.Context, params *glue.UpdateMLTransformInput, optFns ...func(*glue.Options)) (*glue.UpdateMLTransformOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMLTransform")
	}

	var r0 *glue.UpdateMLTransformOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateMLTransformInput, ...func(*glue.Options)) (*glue.UpdateMLTransformOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateMLTransformInput, ...func(*glue.Options)) *glue.UpdateMLTransformOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateMLTransformOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateMLTransformInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePartition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePartition(ctx context.Context, params *glue.UpdatePartitionInput, optFns ...func(*glue.Options)) (*glue.UpdatePartitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePartition")
	}

	var r0 *glue.UpdatePartitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) (*glue.UpdatePartitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) *glue.UpdatePartitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdatePartitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdatePartitionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegistry provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegistry(ctx context.Context, params *glue.UpdateRegistryInput, optFns ...func(*glue.Options)) (*glue.UpdateRegistryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegistry")
	}

	var r0 *glue.UpdateRegistryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateRegistryInput, ...func(*glue.Options)) (*glue.UpdateRegistryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateRegistryInput, ...func(*glue.Options)) *glue.UpdateRegistryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateRegistryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateRegistryInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSchema(ctx context.Context, params *glue.UpdateSchemaInput, optFns ...func(*glue.Options)) (*glue.UpdateSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSchema")
	}

	var r0 *glue.UpdateSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateSchemaInput, ...func(*glue.Options)) (*glue.UpdateSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateSchemaInput, ...func(*glue.Options)) *glue.UpdateSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateSchemaInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSourceControlFromJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSourceControlFromJob(ctx context.Context, params *glue.UpdateSourceControlFromJobInput, optFns ...func(*glue.Options)) (*glue.UpdateSourceControlFromJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSourceControlFromJob")
	}

	var r0 *glue.UpdateSourceControlFromJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateSourceControlFromJobInput, ...func(*glue.Options)) (*glue.UpdateSourceControlFromJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateSourceControlFromJobInput, ...func(*glue.Options)) *glue.UpdateSourceControlFromJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateSourceControlFromJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateSourceControlFromJobInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTable(ctx context.Context, params *glue.UpdateTableInput, optFns ...func(*glue.Options)) (*glue.UpdateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTable")
	}

	var r0 *glue.UpdateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) (*glue.UpdateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) *glue.UpdateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateTableInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTableOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTableOptimizer(ctx context.Context, params *glue.UpdateTableOptimizerInput, optFns ...func(*glue.Options)) (*glue.UpdateTableOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTableOptimizer")
	}

	var r0 *glue.UpdateTableOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableOptimizerInput, ...func(*glue.Options)) (*glue.UpdateTableOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTableOptimizerInput, ...func(*glue.Options)) *glue.UpdateTableOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateTableOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateTableOptimizerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTrigger provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTrigger(ctx context.Context, params *glue.UpdateTriggerInput, optFns ...func(*glue.Options)) (*glue.UpdateTriggerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTrigger")
	}

	var r0 *glue.UpdateTriggerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTriggerInput, ...func(*glue.Options)) (*glue.UpdateTriggerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateTriggerInput, ...func(*glue.Options)) *glue.UpdateTriggerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateTriggerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateTriggerInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUsageProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateUsageProfile(ctx context.Context, params *glue.UpdateUsageProfileInput, optFns ...func(*glue.Options)) (*glue.UpdateUsageProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUsageProfile")
	}

	var r0 *glue.UpdateUsageProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateUsageProfileInput, ...func(*glue.Options)) (*glue.UpdateUsageProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateUsageProfileInput, ...func(*glue.Options)) *glue.UpdateUsageProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateUsageProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateUsageProfileInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUserDefinedFunction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateUserDefinedFunction(ctx context.Context, params *glue.UpdateUserDefinedFunctionInput, optFns ...func(*glue.Options)) (*glue.UpdateUserDefinedFunctionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserDefinedFunction")
	}

	var r0 *glue.UpdateUserDefinedFunctionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateUserDefinedFunctionInput, ...func(*glue.Options)) (*glue.UpdateUserDefinedFunctionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateUserDefinedFunctionInput, ...func(*glue.Options)) *glue.UpdateUserDefinedFunctionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateUserDefinedFunctionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateUserDefinedFunctionInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorkflow provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorkflow(ctx context.Context, params *glue.UpdateWorkflowInput, optFns ...func(*glue.Options)) (*glue.UpdateWorkflowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflow")
	}

	var r0 *glue.UpdateWorkflowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateWorkflowInput, ...func(*glue.Options)) (*glue.UpdateWorkflowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *glue.UpdateWorkflowInput, ...func(*glue.Options)) *glue.UpdateWorkflowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*glue.UpdateWorkflowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *glue.UpdateWorkflowInput, ...func(*glue.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
