// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	cleanrooms "github.com/aws/aws-sdk-go-v2/service/cleanrooms"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchGetCollaborationAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetCollaborationAnalysisTemplate(ctx context.Context, params *cleanrooms.BatchGetCollaborationAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetCollaborationAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetCollaborationAnalysisTemplate")
	}

	var r0 *cleanrooms.BatchGetCollaborationAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetCollaborationAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.BatchGetCollaborationAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.BatchGetCollaborationAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.BatchGetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetSchema(ctx context.Context, params *cleanrooms.BatchGetSchemaInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetSchema")
	}

	var r0 *cleanrooms.BatchGetSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetSchemaInput, ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetSchemaInput, ...func(*cleanrooms.Options)) *cleanrooms.BatchGetSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.BatchGetSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.BatchGetSchemaInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetSchemaAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetSchemaAnalysisRule(ctx context.Context, params *cleanrooms.BatchGetSchemaAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetSchemaAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetSchemaAnalysisRule")
	}

	var r0 *cleanrooms.BatchGetSchemaAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.BatchGetSchemaAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.BatchGetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.BatchGetSchemaAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.BatchGetSchemaAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.BatchGetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAnalysisTemplate(ctx context.Context, params *cleanrooms.CreateAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAnalysisTemplate")
	}

	var r0 *cleanrooms.CreateAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCollaboration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCollaboration(ctx context.Context, params *cleanrooms.CreateCollaborationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateCollaborationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollaboration")
	}

	var r0 *cleanrooms.CreateCollaborationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateCollaborationInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateCollaborationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateCollaborationInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateCollaborationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateCollaborationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateCollaborationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguredAudienceModelAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguredAudienceModelAssociation(ctx context.Context, params *cleanrooms.CreateConfiguredAudienceModelAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredAudienceModelAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguredAudienceModelAssociation")
	}

	var r0 *cleanrooms.CreateConfiguredAudienceModelAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredAudienceModelAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateConfiguredAudienceModelAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateConfiguredAudienceModelAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguredTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguredTable(ctx context.Context, params *cleanrooms.CreateConfiguredTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguredTable")
	}

	var r0 *cleanrooms.CreateConfiguredTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateConfiguredTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateConfiguredTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateConfiguredTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguredTableAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguredTableAnalysisRule(ctx context.Context, params *cleanrooms.CreateConfiguredTableAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguredTableAnalysisRule")
	}

	var r0 *cleanrooms.CreateConfiguredTableAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateConfiguredTableAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateConfiguredTableAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguredTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguredTableAssociation(ctx context.Context, params *cleanrooms.CreateConfiguredTableAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguredTableAssociation")
	}

	var r0 *cleanrooms.CreateConfiguredTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateConfiguredTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateConfiguredTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguredTableAssociationAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguredTableAssociationAnalysisRule(ctx context.Context, params *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAssociationAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguredTableAssociationAnalysisRule")
	}

	var r0 *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateConfiguredTableAssociationAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateConfiguredTableAssociationAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIdMappingTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIdMappingTable(ctx context.Context, params *cleanrooms.CreateIdMappingTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateIdMappingTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIdMappingTable")
	}

	var r0 *cleanrooms.CreateIdMappingTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateIdMappingTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateIdMappingTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateIdMappingTableInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateIdMappingTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateIdMappingTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateIdMappingTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIdNamespaceAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIdNamespaceAssociation(ctx context.Context, params *cleanrooms.CreateIdNamespaceAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateIdNamespaceAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIdNamespaceAssociation")
	}

	var r0 *cleanrooms.CreateIdNamespaceAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateIdNamespaceAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateIdNamespaceAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateIdNamespaceAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMembership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMembership(ctx context.Context, params *cleanrooms.CreateMembershipInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreateMembershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMembership")
	}

	var r0 *cleanrooms.CreateMembershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateMembershipInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreateMembershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreateMembershipInput, ...func(*cleanrooms.Options)) *cleanrooms.CreateMembershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreateMembershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreateMembershipInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePrivacyBudgetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePrivacyBudgetTemplate(ctx context.Context, params *cleanrooms.CreatePrivacyBudgetTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.CreatePrivacyBudgetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePrivacyBudgetTemplate")
	}

	var r0 *cleanrooms.CreatePrivacyBudgetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.CreatePrivacyBudgetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.CreatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.CreatePrivacyBudgetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.CreatePrivacyBudgetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.CreatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAnalysisTemplate(ctx context.Context, params *cleanrooms.DeleteAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAnalysisTemplate")
	}

	var r0 *cleanrooms.DeleteAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCollaboration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCollaboration(ctx context.Context, params *cleanrooms.DeleteCollaborationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteCollaborationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCollaboration")
	}

	var r0 *cleanrooms.DeleteCollaborationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteCollaborationInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteCollaborationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteCollaborationInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteCollaborationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteCollaborationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteCollaborationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguredAudienceModelAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguredAudienceModelAssociation(ctx context.Context, params *cleanrooms.DeleteConfiguredAudienceModelAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredAudienceModelAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguredAudienceModelAssociation")
	}

	var r0 *cleanrooms.DeleteConfiguredAudienceModelAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredAudienceModelAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteConfiguredAudienceModelAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteConfiguredAudienceModelAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguredTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguredTable(ctx context.Context, params *cleanrooms.DeleteConfiguredTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguredTable")
	}

	var r0 *cleanrooms.DeleteConfiguredTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteConfiguredTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteConfiguredTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteConfiguredTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguredTableAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguredTableAnalysisRule(ctx context.Context, params *cleanrooms.DeleteConfiguredTableAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguredTableAnalysisRule")
	}

	var r0 *cleanrooms.DeleteConfiguredTableAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteConfiguredTableAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteConfiguredTableAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguredTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguredTableAssociation(ctx context.Context, params *cleanrooms.DeleteConfiguredTableAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguredTableAssociation")
	}

	var r0 *cleanrooms.DeleteConfiguredTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteConfiguredTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteConfiguredTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguredTableAssociationAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteConfiguredTableAssociationAnalysisRule(ctx context.Context, params *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfiguredTableAssociationAnalysisRule")
	}

	var r0 *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIdMappingTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIdMappingTable(ctx context.Context, params *cleanrooms.DeleteIdMappingTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteIdMappingTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIdMappingTable")
	}

	var r0 *cleanrooms.DeleteIdMappingTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteIdMappingTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteIdMappingTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteIdMappingTableInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteIdMappingTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteIdMappingTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteIdMappingTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIdNamespaceAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIdNamespaceAssociation(ctx context.Context, params *cleanrooms.DeleteIdNamespaceAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteIdNamespaceAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIdNamespaceAssociation")
	}

	var r0 *cleanrooms.DeleteIdNamespaceAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteIdNamespaceAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteIdNamespaceAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteIdNamespaceAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMember(ctx context.Context, params *cleanrooms.DeleteMemberInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMember")
	}

	var r0 *cleanrooms.DeleteMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteMemberInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteMemberInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteMemberInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMembership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMembership(ctx context.Context, params *cleanrooms.DeleteMembershipInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeleteMembershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMembership")
	}

	var r0 *cleanrooms.DeleteMembershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteMembershipInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeleteMembershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeleteMembershipInput, ...func(*cleanrooms.Options)) *cleanrooms.DeleteMembershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeleteMembershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeleteMembershipInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePrivacyBudgetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePrivacyBudgetTemplate(ctx context.Context, params *cleanrooms.DeletePrivacyBudgetTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.DeletePrivacyBudgetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePrivacyBudgetTemplate")
	}

	var r0 *cleanrooms.DeletePrivacyBudgetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeletePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.DeletePrivacyBudgetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.DeletePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.DeletePrivacyBudgetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.DeletePrivacyBudgetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.DeletePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAnalysisTemplate(ctx context.Context, params *cleanrooms.GetAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAnalysisTemplate")
	}

	var r0 *cleanrooms.GetAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.GetAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollaboration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCollaboration(ctx context.Context, params *cleanrooms.GetCollaborationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCollaboration")
	}

	var r0 *cleanrooms.GetCollaborationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetCollaborationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetCollaborationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetCollaborationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollaborationAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCollaborationAnalysisTemplate(ctx context.Context, params *cleanrooms.GetCollaborationAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCollaborationAnalysisTemplate")
	}

	var r0 *cleanrooms.GetCollaborationAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.GetCollaborationAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetCollaborationAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetCollaborationAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollaborationConfiguredAudienceModelAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCollaborationConfiguredAudienceModelAssociation(ctx context.Context, params *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationConfiguredAudienceModelAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCollaborationConfiguredAudienceModelAssociation")
	}

	var r0 *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationConfiguredAudienceModelAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetCollaborationConfiguredAudienceModelAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetCollaborationConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollaborationIdNamespaceAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCollaborationIdNamespaceAssociation(ctx context.Context, params *cleanrooms.GetCollaborationIdNamespaceAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationIdNamespaceAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCollaborationIdNamespaceAssociation")
	}

	var r0 *cleanrooms.GetCollaborationIdNamespaceAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationIdNamespaceAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetCollaborationIdNamespaceAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetCollaborationIdNamespaceAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetCollaborationIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollaborationPrivacyBudgetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCollaborationPrivacyBudgetTemplate(ctx context.Context, params *cleanrooms.GetCollaborationPrivacyBudgetTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationPrivacyBudgetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCollaborationPrivacyBudgetTemplate")
	}

	var r0 *cleanrooms.GetCollaborationPrivacyBudgetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetCollaborationPrivacyBudgetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetCollaborationPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.GetCollaborationPrivacyBudgetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetCollaborationPrivacyBudgetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetCollaborationPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredAudienceModelAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguredAudienceModelAssociation(ctx context.Context, params *cleanrooms.GetConfiguredAudienceModelAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredAudienceModelAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguredAudienceModelAssociation")
	}

	var r0 *cleanrooms.GetConfiguredAudienceModelAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredAudienceModelAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetConfiguredAudienceModelAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetConfiguredAudienceModelAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguredTable(ctx context.Context, params *cleanrooms.GetConfiguredTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguredTable")
	}

	var r0 *cleanrooms.GetConfiguredTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableInput, ...func(*cleanrooms.Options)) *cleanrooms.GetConfiguredTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetConfiguredTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetConfiguredTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredTableAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguredTableAnalysisRule(ctx context.Context, params *cleanrooms.GetConfiguredTableAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguredTableAnalysisRule")
	}

	var r0 *cleanrooms.GetConfiguredTableAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.GetConfiguredTableAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetConfiguredTableAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguredTableAssociation(ctx context.Context, params *cleanrooms.GetConfiguredTableAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguredTableAssociation")
	}

	var r0 *cleanrooms.GetConfiguredTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetConfiguredTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetConfiguredTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfiguredTableAssociationAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetConfiguredTableAssociationAnalysisRule(ctx context.Context, params *cleanrooms.GetConfiguredTableAssociationAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAssociationAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguredTableAssociationAnalysisRule")
	}

	var r0 *cleanrooms.GetConfiguredTableAssociationAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetConfiguredTableAssociationAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.GetConfiguredTableAssociationAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetConfiguredTableAssociationAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdMappingTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIdMappingTable(ctx context.Context, params *cleanrooms.GetIdMappingTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetIdMappingTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIdMappingTable")
	}

	var r0 *cleanrooms.GetIdMappingTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetIdMappingTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetIdMappingTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetIdMappingTableInput, ...func(*cleanrooms.Options)) *cleanrooms.GetIdMappingTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetIdMappingTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetIdMappingTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdNamespaceAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIdNamespaceAssociation(ctx context.Context, params *cleanrooms.GetIdNamespaceAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetIdNamespaceAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIdNamespaceAssociation")
	}

	var r0 *cleanrooms.GetIdNamespaceAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetIdNamespaceAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.GetIdNamespaceAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetIdNamespaceAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMembership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMembership(ctx context.Context, params *cleanrooms.GetMembershipInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetMembershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMembership")
	}

	var r0 *cleanrooms.GetMembershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetMembershipInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetMembershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetMembershipInput, ...func(*cleanrooms.Options)) *cleanrooms.GetMembershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetMembershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetMembershipInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPrivacyBudgetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPrivacyBudgetTemplate(ctx context.Context, params *cleanrooms.GetPrivacyBudgetTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetPrivacyBudgetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPrivacyBudgetTemplate")
	}

	var r0 *cleanrooms.GetPrivacyBudgetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetPrivacyBudgetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.GetPrivacyBudgetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetPrivacyBudgetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetPrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProtectedQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetProtectedQuery(ctx context.Context, params *cleanrooms.GetProtectedQueryInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetProtectedQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProtectedQuery")
	}

	var r0 *cleanrooms.GetProtectedQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetProtectedQueryInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetProtectedQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetProtectedQueryInput, ...func(*cleanrooms.Options)) *cleanrooms.GetProtectedQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetProtectedQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetProtectedQueryInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchema provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchema(ctx context.Context, params *cleanrooms.GetSchemaInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetSchemaOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchema")
	}

	var r0 *cleanrooms.GetSchemaOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetSchemaInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetSchemaOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetSchemaInput, ...func(*cleanrooms.Options)) *cleanrooms.GetSchemaOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetSchemaOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetSchemaInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSchemaAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSchemaAnalysisRule(ctx context.Context, params *cleanrooms.GetSchemaAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.GetSchemaAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSchemaAnalysisRule")
	}

	var r0 *cleanrooms.GetSchemaAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.GetSchemaAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.GetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.GetSchemaAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.GetSchemaAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.GetSchemaAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAnalysisTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAnalysisTemplates(ctx context.Context, params *cleanrooms.ListAnalysisTemplatesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListAnalysisTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAnalysisTemplates")
	}

	var r0 *cleanrooms.ListAnalysisTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListAnalysisTemplatesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListAnalysisTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListAnalysisTemplatesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListAnalysisTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListAnalysisTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListAnalysisTemplatesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborationAnalysisTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborationAnalysisTemplates(ctx context.Context, params *cleanrooms.ListCollaborationAnalysisTemplatesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationAnalysisTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborationAnalysisTemplates")
	}

	var r0 *cleanrooms.ListCollaborationAnalysisTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationAnalysisTemplatesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationAnalysisTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationAnalysisTemplatesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationAnalysisTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationAnalysisTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationAnalysisTemplatesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborationConfiguredAudienceModelAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborationConfiguredAudienceModelAssociations(ctx context.Context, params *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborationConfiguredAudienceModelAssociations")
	}

	var r0 *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborationIdNamespaceAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborationIdNamespaceAssociations(ctx context.Context, params *cleanrooms.ListCollaborationIdNamespaceAssociationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationIdNamespaceAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborationIdNamespaceAssociations")
	}

	var r0 *cleanrooms.ListCollaborationIdNamespaceAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationIdNamespaceAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationIdNamespaceAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationIdNamespaceAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborationPrivacyBudgetTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborationPrivacyBudgetTemplates(ctx context.Context, params *cleanrooms.ListCollaborationPrivacyBudgetTemplatesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationPrivacyBudgetTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborationPrivacyBudgetTemplates")
	}

	var r0 *cleanrooms.ListCollaborationPrivacyBudgetTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationPrivacyBudgetTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationPrivacyBudgetTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationPrivacyBudgetTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborationPrivacyBudgets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborationPrivacyBudgets(ctx context.Context, params *cleanrooms.ListCollaborationPrivacyBudgetsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationPrivacyBudgetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborationPrivacyBudgets")
	}

	var r0 *cleanrooms.ListCollaborationPrivacyBudgetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationPrivacyBudgetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationPrivacyBudgetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationPrivacyBudgetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationPrivacyBudgetsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollaborations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCollaborations(ctx context.Context, params *cleanrooms.ListCollaborationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollaborations")
	}

	var r0 *cleanrooms.ListCollaborationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListCollaborationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListCollaborationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListCollaborationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListCollaborationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListCollaborationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfiguredAudienceModelAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfiguredAudienceModelAssociations(ctx context.Context, params *cleanrooms.ListConfiguredAudienceModelAssociationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredAudienceModelAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfiguredAudienceModelAssociations")
	}

	var r0 *cleanrooms.ListConfiguredAudienceModelAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredAudienceModelAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListConfiguredAudienceModelAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListConfiguredAudienceModelAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListConfiguredAudienceModelAssociationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfiguredTableAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfiguredTableAssociations(ctx context.Context, params *cleanrooms.ListConfiguredTableAssociationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredTableAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfiguredTableAssociations")
	}

	var r0 *cleanrooms.ListConfiguredTableAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredTableAssociationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredTableAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredTableAssociationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListConfiguredTableAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListConfiguredTableAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListConfiguredTableAssociationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfiguredTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfiguredTables(ctx context.Context, params *cleanrooms.ListConfiguredTablesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfiguredTables")
	}

	var r0 *cleanrooms.ListConfiguredTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredTablesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListConfiguredTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListConfiguredTablesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListConfiguredTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListConfiguredTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListConfiguredTablesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIdMappingTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIdMappingTables(ctx context.Context, params *cleanrooms.ListIdMappingTablesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListIdMappingTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIdMappingTables")
	}

	var r0 *cleanrooms.ListIdMappingTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListIdMappingTablesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListIdMappingTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListIdMappingTablesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListIdMappingTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListIdMappingTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListIdMappingTablesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIdNamespaceAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIdNamespaceAssociations(ctx context.Context, params *cleanrooms.ListIdNamespaceAssociationsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListIdNamespaceAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIdNamespaceAssociations")
	}

	var r0 *cleanrooms.ListIdNamespaceAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListIdNamespaceAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListIdNamespaceAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListIdNamespaceAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListIdNamespaceAssociationsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMembers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMembers(ctx context.Context, params *cleanrooms.ListMembersInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMembers")
	}

	var r0 *cleanrooms.ListMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListMembersInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListMembersInput, ...func(*cleanrooms.Options)) *cleanrooms.ListMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListMembersInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMemberships provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMemberships(ctx context.Context, params *cleanrooms.ListMembershipsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListMembershipsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMemberships")
	}

	var r0 *cleanrooms.ListMembershipsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListMembershipsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListMembershipsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListMembershipsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListMembershipsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListMembershipsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListMembershipsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPrivacyBudgetTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPrivacyBudgetTemplates(ctx context.Context, params *cleanrooms.ListPrivacyBudgetTemplatesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListPrivacyBudgetTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPrivacyBudgetTemplates")
	}

	var r0 *cleanrooms.ListPrivacyBudgetTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListPrivacyBudgetTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListPrivacyBudgetTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListPrivacyBudgetTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListPrivacyBudgetTemplatesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPrivacyBudgets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPrivacyBudgets(ctx context.Context, params *cleanrooms.ListPrivacyBudgetsInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListPrivacyBudgetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPrivacyBudgets")
	}

	var r0 *cleanrooms.ListPrivacyBudgetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListPrivacyBudgetsInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListPrivacyBudgetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListPrivacyBudgetsInput, ...func(*cleanrooms.Options)) *cleanrooms.ListPrivacyBudgetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListPrivacyBudgetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListPrivacyBudgetsInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProtectedQueries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProtectedQueries(ctx context.Context, params *cleanrooms.ListProtectedQueriesInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListProtectedQueriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProtectedQueries")
	}

	var r0 *cleanrooms.ListProtectedQueriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListProtectedQueriesInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListProtectedQueriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListProtectedQueriesInput, ...func(*cleanrooms.Options)) *cleanrooms.ListProtectedQueriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListProtectedQueriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListProtectedQueriesInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSchemas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSchemas(ctx context.Context, params *cleanrooms.ListSchemasInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListSchemasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSchemas")
	}

	var r0 *cleanrooms.ListSchemasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListSchemasInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListSchemasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListSchemasInput, ...func(*cleanrooms.Options)) *cleanrooms.ListSchemasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListSchemasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListSchemasInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *cleanrooms.ListTagsForResourceInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *cleanrooms.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListTagsForResourceInput, ...func(*cleanrooms.Options)) (*cleanrooms.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.ListTagsForResourceInput, ...func(*cleanrooms.Options)) *cleanrooms.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.ListTagsForResourceInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() cleanrooms.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 cleanrooms.Options
	if rf, ok := ret.Get(0).(func() cleanrooms.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(cleanrooms.Options)
	}

	return r0
}

// PopulateIdMappingTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PopulateIdMappingTable(ctx context.Context, params *cleanrooms.PopulateIdMappingTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.PopulateIdMappingTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PopulateIdMappingTable")
	}

	var r0 *cleanrooms.PopulateIdMappingTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.PopulateIdMappingTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.PopulateIdMappingTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.PopulateIdMappingTableInput, ...func(*cleanrooms.Options)) *cleanrooms.PopulateIdMappingTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.PopulateIdMappingTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.PopulateIdMappingTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PreviewPrivacyImpact provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PreviewPrivacyImpact(ctx context.Context, params *cleanrooms.PreviewPrivacyImpactInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.PreviewPrivacyImpactOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PreviewPrivacyImpact")
	}

	var r0 *cleanrooms.PreviewPrivacyImpactOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.PreviewPrivacyImpactInput, ...func(*cleanrooms.Options)) (*cleanrooms.PreviewPrivacyImpactOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.PreviewPrivacyImpactInput, ...func(*cleanrooms.Options)) *cleanrooms.PreviewPrivacyImpactOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.PreviewPrivacyImpactOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.PreviewPrivacyImpactInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartProtectedQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartProtectedQuery(ctx context.Context, params *cleanrooms.StartProtectedQueryInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.StartProtectedQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartProtectedQuery")
	}

	var r0 *cleanrooms.StartProtectedQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.StartProtectedQueryInput, ...func(*cleanrooms.Options)) (*cleanrooms.StartProtectedQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.StartProtectedQueryInput, ...func(*cleanrooms.Options)) *cleanrooms.StartProtectedQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.StartProtectedQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.StartProtectedQueryInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *cleanrooms.TagResourceInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *cleanrooms.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.TagResourceInput, ...func(*cleanrooms.Options)) (*cleanrooms.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.TagResourceInput, ...func(*cleanrooms.Options)) *cleanrooms.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.TagResourceInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *cleanrooms.UntagResourceInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *cleanrooms.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UntagResourceInput, ...func(*cleanrooms.Options)) (*cleanrooms.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UntagResourceInput, ...func(*cleanrooms.Options)) *cleanrooms.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UntagResourceInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAnalysisTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAnalysisTemplate(ctx context.Context, params *cleanrooms.UpdateAnalysisTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateAnalysisTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnalysisTemplate")
	}

	var r0 *cleanrooms.UpdateAnalysisTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateAnalysisTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateAnalysisTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateAnalysisTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateAnalysisTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateAnalysisTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateAnalysisTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCollaboration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateCollaboration(ctx context.Context, params *cleanrooms.UpdateCollaborationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateCollaborationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCollaboration")
	}

	var r0 *cleanrooms.UpdateCollaborationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateCollaborationInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateCollaborationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateCollaborationInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateCollaborationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateCollaborationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateCollaborationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguredAudienceModelAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguredAudienceModelAssociation(ctx context.Context, params *cleanrooms.UpdateConfiguredAudienceModelAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredAudienceModelAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguredAudienceModelAssociation")
	}

	var r0 *cleanrooms.UpdateConfiguredAudienceModelAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredAudienceModelAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateConfiguredAudienceModelAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateConfiguredAudienceModelAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateConfiguredAudienceModelAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguredTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguredTable(ctx context.Context, params *cleanrooms.UpdateConfiguredTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguredTable")
	}

	var r0 *cleanrooms.UpdateConfiguredTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateConfiguredTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateConfiguredTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateConfiguredTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguredTableAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguredTableAnalysisRule(ctx context.Context, params *cleanrooms.UpdateConfiguredTableAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguredTableAnalysisRule")
	}

	var r0 *cleanrooms.UpdateConfiguredTableAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateConfiguredTableAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateConfiguredTableAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateConfiguredTableAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguredTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguredTableAssociation(ctx context.Context, params *cleanrooms.UpdateConfiguredTableAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguredTableAssociation")
	}

	var r0 *cleanrooms.UpdateConfiguredTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateConfiguredTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateConfiguredTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguredTableAssociationAnalysisRule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguredTableAssociationAnalysisRule(ctx context.Context, params *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguredTableAssociationAnalysisRule")
	}

	var r0 *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateConfiguredTableAssociationAnalysisRuleInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIdMappingTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIdMappingTable(ctx context.Context, params *cleanrooms.UpdateIdMappingTableInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateIdMappingTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIdMappingTable")
	}

	var r0 *cleanrooms.UpdateIdMappingTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateIdMappingTableInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateIdMappingTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateIdMappingTableInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateIdMappingTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateIdMappingTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateIdMappingTableInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIdNamespaceAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIdNamespaceAssociation(ctx context.Context, params *cleanrooms.UpdateIdNamespaceAssociationInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateIdNamespaceAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIdNamespaceAssociation")
	}

	var r0 *cleanrooms.UpdateIdNamespaceAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateIdNamespaceAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateIdNamespaceAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateIdNamespaceAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateIdNamespaceAssociationInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMembership provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMembership(ctx context.Context, params *cleanrooms.UpdateMembershipInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateMembershipOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMembership")
	}

	var r0 *cleanrooms.UpdateMembershipOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateMembershipInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateMembershipOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateMembershipInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateMembershipOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateMembershipOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateMembershipInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrivacyBudgetTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePrivacyBudgetTemplate(ctx context.Context, params *cleanrooms.UpdatePrivacyBudgetTemplateInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdatePrivacyBudgetTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrivacyBudgetTemplate")
	}

	var r0 *cleanrooms.UpdatePrivacyBudgetTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdatePrivacyBudgetTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdatePrivacyBudgetTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdatePrivacyBudgetTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdatePrivacyBudgetTemplateInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProtectedQuery provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProtectedQuery(ctx context.Context, params *cleanrooms.UpdateProtectedQueryInput, optFns ...func(*cleanrooms.Options)) (*cleanrooms.UpdateProtectedQueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProtectedQuery")
	}

	var r0 *cleanrooms.UpdateProtectedQueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateProtectedQueryInput, ...func(*cleanrooms.Options)) (*cleanrooms.UpdateProtectedQueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *cleanrooms.UpdateProtectedQueryInput, ...func(*cleanrooms.Options)) *cleanrooms.UpdateProtectedQueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cleanrooms.UpdateProtectedQueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *cleanrooms.UpdateProtectedQueryInput, ...func(*cleanrooms.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
