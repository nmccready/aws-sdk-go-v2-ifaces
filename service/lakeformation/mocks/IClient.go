// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	lakeformation "github.com/aws/aws-sdk-go-v2/service/lakeformation"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AddLFTagsToResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddLFTagsToResource(ctx context.Context, params *lakeformation.AddLFTagsToResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.AddLFTagsToResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddLFTagsToResource")
	}

	var r0 *lakeformation.AddLFTagsToResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.AddLFTagsToResourceInput, ...func(*lakeformation.Options)) (*lakeformation.AddLFTagsToResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.AddLFTagsToResourceInput, ...func(*lakeformation.Options)) *lakeformation.AddLFTagsToResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.AddLFTagsToResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.AddLFTagsToResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssumeDecoratedRoleWithSAML provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssumeDecoratedRoleWithSAML(ctx context.Context, params *lakeformation.AssumeDecoratedRoleWithSAMLInput, optFns ...func(*lakeformation.Options)) (*lakeformation.AssumeDecoratedRoleWithSAMLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssumeDecoratedRoleWithSAML")
	}

	var r0 *lakeformation.AssumeDecoratedRoleWithSAMLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.AssumeDecoratedRoleWithSAMLInput, ...func(*lakeformation.Options)) (*lakeformation.AssumeDecoratedRoleWithSAMLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.AssumeDecoratedRoleWithSAMLInput, ...func(*lakeformation.Options)) *lakeformation.AssumeDecoratedRoleWithSAMLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.AssumeDecoratedRoleWithSAMLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.AssumeDecoratedRoleWithSAMLInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGrantPermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGrantPermissions(ctx context.Context, params *lakeformation.BatchGrantPermissionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.BatchGrantPermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGrantPermissions")
	}

	var r0 *lakeformation.BatchGrantPermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.BatchGrantPermissionsInput, ...func(*lakeformation.Options)) (*lakeformation.BatchGrantPermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.BatchGrantPermissionsInput, ...func(*lakeformation.Options)) *lakeformation.BatchGrantPermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.BatchGrantPermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.BatchGrantPermissionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchRevokePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchRevokePermissions(ctx context.Context, params *lakeformation.BatchRevokePermissionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.BatchRevokePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchRevokePermissions")
	}

	var r0 *lakeformation.BatchRevokePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.BatchRevokePermissionsInput, ...func(*lakeformation.Options)) (*lakeformation.BatchRevokePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.BatchRevokePermissionsInput, ...func(*lakeformation.Options)) *lakeformation.BatchRevokePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.BatchRevokePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.BatchRevokePermissionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelTransaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelTransaction(ctx context.Context, params *lakeformation.CancelTransactionInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CancelTransactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelTransaction")
	}

	var r0 *lakeformation.CancelTransactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CancelTransactionInput, ...func(*lakeformation.Options)) (*lakeformation.CancelTransactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CancelTransactionInput, ...func(*lakeformation.Options)) *lakeformation.CancelTransactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CancelTransactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CancelTransactionInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CommitTransaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CommitTransaction(ctx context.Context, params *lakeformation.CommitTransactionInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CommitTransactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommitTransaction")
	}

	var r0 *lakeformation.CommitTransactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CommitTransactionInput, ...func(*lakeformation.Options)) (*lakeformation.CommitTransactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CommitTransactionInput, ...func(*lakeformation.Options)) *lakeformation.CommitTransactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CommitTransactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CommitTransactionInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataCellsFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataCellsFilter(ctx context.Context, params *lakeformation.CreateDataCellsFilterInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CreateDataCellsFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataCellsFilter")
	}

	var r0 *lakeformation.CreateDataCellsFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateDataCellsFilterInput, ...func(*lakeformation.Options)) (*lakeformation.CreateDataCellsFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateDataCellsFilterInput, ...func(*lakeformation.Options)) *lakeformation.CreateDataCellsFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CreateDataCellsFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CreateDataCellsFilterInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLFTag provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLFTag(ctx context.Context, params *lakeformation.CreateLFTagInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CreateLFTagOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLFTag")
	}

	var r0 *lakeformation.CreateLFTagOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLFTagInput, ...func(*lakeformation.Options)) (*lakeformation.CreateLFTagOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLFTagInput, ...func(*lakeformation.Options)) *lakeformation.CreateLFTagOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CreateLFTagOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CreateLFTagInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLakeFormationIdentityCenterConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLakeFormationIdentityCenterConfiguration(ctx context.Context, params *lakeformation.CreateLakeFormationIdentityCenterConfigurationInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CreateLakeFormationIdentityCenterConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLakeFormationIdentityCenterConfiguration")
	}

	var r0 *lakeformation.CreateLakeFormationIdentityCenterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) (*lakeformation.CreateLakeFormationIdentityCenterConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) *lakeformation.CreateLakeFormationIdentityCenterConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CreateLakeFormationIdentityCenterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CreateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLakeFormationOptIn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateLakeFormationOptIn(ctx context.Context, params *lakeformation.CreateLakeFormationOptInInput, optFns ...func(*lakeformation.Options)) (*lakeformation.CreateLakeFormationOptInOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLakeFormationOptIn")
	}

	var r0 *lakeformation.CreateLakeFormationOptInOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLakeFormationOptInInput, ...func(*lakeformation.Options)) (*lakeformation.CreateLakeFormationOptInOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.CreateLakeFormationOptInInput, ...func(*lakeformation.Options)) *lakeformation.CreateLakeFormationOptInOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.CreateLakeFormationOptInOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.CreateLakeFormationOptInInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataCellsFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataCellsFilter(ctx context.Context, params *lakeformation.DeleteDataCellsFilterInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeleteDataCellsFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataCellsFilter")
	}

	var r0 *lakeformation.DeleteDataCellsFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteDataCellsFilterInput, ...func(*lakeformation.Options)) (*lakeformation.DeleteDataCellsFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteDataCellsFilterInput, ...func(*lakeformation.Options)) *lakeformation.DeleteDataCellsFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeleteDataCellsFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeleteDataCellsFilterInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLFTag provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLFTag(ctx context.Context, params *lakeformation.DeleteLFTagInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeleteLFTagOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLFTag")
	}

	var r0 *lakeformation.DeleteLFTagOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLFTagInput, ...func(*lakeformation.Options)) (*lakeformation.DeleteLFTagOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLFTagInput, ...func(*lakeformation.Options)) *lakeformation.DeleteLFTagOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeleteLFTagOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeleteLFTagInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLakeFormationIdentityCenterConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLakeFormationIdentityCenterConfiguration(ctx context.Context, params *lakeformation.DeleteLakeFormationIdentityCenterConfigurationInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeleteLakeFormationIdentityCenterConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLakeFormationIdentityCenterConfiguration")
	}

	var r0 *lakeformation.DeleteLakeFormationIdentityCenterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) (*lakeformation.DeleteLakeFormationIdentityCenterConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) *lakeformation.DeleteLakeFormationIdentityCenterConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeleteLakeFormationIdentityCenterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeleteLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLakeFormationOptIn provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLakeFormationOptIn(ctx context.Context, params *lakeformation.DeleteLakeFormationOptInInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeleteLakeFormationOptInOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLakeFormationOptIn")
	}

	var r0 *lakeformation.DeleteLakeFormationOptInOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLakeFormationOptInInput, ...func(*lakeformation.Options)) (*lakeformation.DeleteLakeFormationOptInOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteLakeFormationOptInInput, ...func(*lakeformation.Options)) *lakeformation.DeleteLakeFormationOptInOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeleteLakeFormationOptInOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeleteLakeFormationOptInInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteObjectsOnCancel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteObjectsOnCancel(ctx context.Context, params *lakeformation.DeleteObjectsOnCancelInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeleteObjectsOnCancelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectsOnCancel")
	}

	var r0 *lakeformation.DeleteObjectsOnCancelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteObjectsOnCancelInput, ...func(*lakeformation.Options)) (*lakeformation.DeleteObjectsOnCancelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeleteObjectsOnCancelInput, ...func(*lakeformation.Options)) *lakeformation.DeleteObjectsOnCancelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeleteObjectsOnCancelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeleteObjectsOnCancelInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterResource(ctx context.Context, params *lakeformation.DeregisterResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DeregisterResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterResource")
	}

	var r0 *lakeformation.DeregisterResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeregisterResourceInput, ...func(*lakeformation.Options)) (*lakeformation.DeregisterResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DeregisterResourceInput, ...func(*lakeformation.Options)) *lakeformation.DeregisterResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DeregisterResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DeregisterResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLakeFormationIdentityCenterConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLakeFormationIdentityCenterConfiguration(ctx context.Context, params *lakeformation.DescribeLakeFormationIdentityCenterConfigurationInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DescribeLakeFormationIdentityCenterConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLakeFormationIdentityCenterConfiguration")
	}

	var r0 *lakeformation.DescribeLakeFormationIdentityCenterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) (*lakeformation.DescribeLakeFormationIdentityCenterConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) *lakeformation.DescribeLakeFormationIdentityCenterConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DescribeLakeFormationIdentityCenterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DescribeLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResource(ctx context.Context, params *lakeformation.DescribeResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DescribeResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResource")
	}

	var r0 *lakeformation.DescribeResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeResourceInput, ...func(*lakeformation.Options)) (*lakeformation.DescribeResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeResourceInput, ...func(*lakeformation.Options)) *lakeformation.DescribeResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DescribeResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DescribeResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTransaction(ctx context.Context, params *lakeformation.DescribeTransactionInput, optFns ...func(*lakeformation.Options)) (*lakeformation.DescribeTransactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransaction")
	}

	var r0 *lakeformation.DescribeTransactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeTransactionInput, ...func(*lakeformation.Options)) (*lakeformation.DescribeTransactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.DescribeTransactionInput, ...func(*lakeformation.Options)) *lakeformation.DescribeTransactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.DescribeTransactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.DescribeTransactionInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExtendTransaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExtendTransaction(ctx context.Context, params *lakeformation.ExtendTransactionInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ExtendTransactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExtendTransaction")
	}

	var r0 *lakeformation.ExtendTransactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ExtendTransactionInput, ...func(*lakeformation.Options)) (*lakeformation.ExtendTransactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ExtendTransactionInput, ...func(*lakeformation.Options)) *lakeformation.ExtendTransactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ExtendTransactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ExtendTransactionInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataCellsFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataCellsFilter(ctx context.Context, params *lakeformation.GetDataCellsFilterInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetDataCellsFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataCellsFilter")
	}

	var r0 *lakeformation.GetDataCellsFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataCellsFilterInput, ...func(*lakeformation.Options)) (*lakeformation.GetDataCellsFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataCellsFilterInput, ...func(*lakeformation.Options)) *lakeformation.GetDataCellsFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetDataCellsFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetDataCellsFilterInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataLakePrincipal provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataLakePrincipal(ctx context.Context, params *lakeformation.GetDataLakePrincipalInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetDataLakePrincipalOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataLakePrincipal")
	}

	var r0 *lakeformation.GetDataLakePrincipalOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataLakePrincipalInput, ...func(*lakeformation.Options)) (*lakeformation.GetDataLakePrincipalOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataLakePrincipalInput, ...func(*lakeformation.Options)) *lakeformation.GetDataLakePrincipalOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetDataLakePrincipalOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetDataLakePrincipalInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataLakeSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDataLakeSettings(ctx context.Context, params *lakeformation.GetDataLakeSettingsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetDataLakeSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataLakeSettings")
	}

	var r0 *lakeformation.GetDataLakeSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataLakeSettingsInput, ...func(*lakeformation.Options)) (*lakeformation.GetDataLakeSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetDataLakeSettingsInput, ...func(*lakeformation.Options)) *lakeformation.GetDataLakeSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetDataLakeSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetDataLakeSettingsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEffectivePermissionsForPath provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEffectivePermissionsForPath(ctx context.Context, params *lakeformation.GetEffectivePermissionsForPathInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetEffectivePermissionsForPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEffectivePermissionsForPath")
	}

	var r0 *lakeformation.GetEffectivePermissionsForPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetEffectivePermissionsForPathInput, ...func(*lakeformation.Options)) (*lakeformation.GetEffectivePermissionsForPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetEffectivePermissionsForPathInput, ...func(*lakeformation.Options)) *lakeformation.GetEffectivePermissionsForPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetEffectivePermissionsForPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetEffectivePermissionsForPathInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLFTag provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLFTag(ctx context.Context, params *lakeformation.GetLFTagInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetLFTagOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLFTag")
	}

	var r0 *lakeformation.GetLFTagOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetLFTagInput, ...func(*lakeformation.Options)) (*lakeformation.GetLFTagOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetLFTagInput, ...func(*lakeformation.Options)) *lakeformation.GetLFTagOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetLFTagOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetLFTagInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQueryState provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQueryState(ctx context.Context, params *lakeformation.GetQueryStateInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetQueryStateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQueryState")
	}

	var r0 *lakeformation.GetQueryStateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetQueryStateInput, ...func(*lakeformation.Options)) (*lakeformation.GetQueryStateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetQueryStateInput, ...func(*lakeformation.Options)) *lakeformation.GetQueryStateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetQueryStateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetQueryStateInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQueryStatistics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQueryStatistics(ctx context.Context, params *lakeformation.GetQueryStatisticsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetQueryStatisticsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQueryStatistics")
	}

	var r0 *lakeformation.GetQueryStatisticsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetQueryStatisticsInput, ...func(*lakeformation.Options)) (*lakeformation.GetQueryStatisticsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetQueryStatisticsInput, ...func(*lakeformation.Options)) *lakeformation.GetQueryStatisticsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetQueryStatisticsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetQueryStatisticsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourceLFTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourceLFTags(ctx context.Context, params *lakeformation.GetResourceLFTagsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetResourceLFTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourceLFTags")
	}

	var r0 *lakeformation.GetResourceLFTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetResourceLFTagsInput, ...func(*lakeformation.Options)) (*lakeformation.GetResourceLFTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetResourceLFTagsInput, ...func(*lakeformation.Options)) *lakeformation.GetResourceLFTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetResourceLFTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetResourceLFTagsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableObjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableObjects(ctx context.Context, params *lakeformation.GetTableObjectsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetTableObjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableObjects")
	}

	var r0 *lakeformation.GetTableObjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTableObjectsInput, ...func(*lakeformation.Options)) (*lakeformation.GetTableObjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTableObjectsInput, ...func(*lakeformation.Options)) *lakeformation.GetTableObjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetTableObjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetTableObjectsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemporaryGluePartitionCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTemporaryGluePartitionCredentials(ctx context.Context, params *lakeformation.GetTemporaryGluePartitionCredentialsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetTemporaryGluePartitionCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTemporaryGluePartitionCredentials")
	}

	var r0 *lakeformation.GetTemporaryGluePartitionCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTemporaryGluePartitionCredentialsInput, ...func(*lakeformation.Options)) (*lakeformation.GetTemporaryGluePartitionCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTemporaryGluePartitionCredentialsInput, ...func(*lakeformation.Options)) *lakeformation.GetTemporaryGluePartitionCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetTemporaryGluePartitionCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetTemporaryGluePartitionCredentialsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemporaryGlueTableCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTemporaryGlueTableCredentials(ctx context.Context, params *lakeformation.GetTemporaryGlueTableCredentialsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetTemporaryGlueTableCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTemporaryGlueTableCredentials")
	}

	var r0 *lakeformation.GetTemporaryGlueTableCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTemporaryGlueTableCredentialsInput, ...func(*lakeformation.Options)) (*lakeformation.GetTemporaryGlueTableCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetTemporaryGlueTableCredentialsInput, ...func(*lakeformation.Options)) *lakeformation.GetTemporaryGlueTableCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetTemporaryGlueTableCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetTemporaryGlueTableCredentialsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkUnitResults provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkUnitResults(ctx context.Context, params *lakeformation.GetWorkUnitResultsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetWorkUnitResultsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkUnitResults")
	}

	var r0 *lakeformation.GetWorkUnitResultsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetWorkUnitResultsInput, ...func(*lakeformation.Options)) (*lakeformation.GetWorkUnitResultsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetWorkUnitResultsInput, ...func(*lakeformation.Options)) *lakeformation.GetWorkUnitResultsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetWorkUnitResultsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetWorkUnitResultsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkUnits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorkUnits(ctx context.Context, params *lakeformation.GetWorkUnitsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GetWorkUnitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkUnits")
	}

	var r0 *lakeformation.GetWorkUnitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetWorkUnitsInput, ...func(*lakeformation.Options)) (*lakeformation.GetWorkUnitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GetWorkUnitsInput, ...func(*lakeformation.Options)) *lakeformation.GetWorkUnitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GetWorkUnitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GetWorkUnitsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GrantPermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GrantPermissions(ctx context.Context, params *lakeformation.GrantPermissionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.GrantPermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GrantPermissions")
	}

	var r0 *lakeformation.GrantPermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GrantPermissionsInput, ...func(*lakeformation.Options)) (*lakeformation.GrantPermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.GrantPermissionsInput, ...func(*lakeformation.Options)) *lakeformation.GrantPermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.GrantPermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.GrantPermissionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataCellsFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataCellsFilter(ctx context.Context, params *lakeformation.ListDataCellsFilterInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListDataCellsFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataCellsFilter")
	}

	var r0 *lakeformation.ListDataCellsFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListDataCellsFilterInput, ...func(*lakeformation.Options)) (*lakeformation.ListDataCellsFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListDataCellsFilterInput, ...func(*lakeformation.Options)) *lakeformation.ListDataCellsFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListDataCellsFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListDataCellsFilterInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLFTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLFTags(ctx context.Context, params *lakeformation.ListLFTagsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListLFTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLFTags")
	}

	var r0 *lakeformation.ListLFTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListLFTagsInput, ...func(*lakeformation.Options)) (*lakeformation.ListLFTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListLFTagsInput, ...func(*lakeformation.Options)) *lakeformation.ListLFTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListLFTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListLFTagsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLakeFormationOptIns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLakeFormationOptIns(ctx context.Context, params *lakeformation.ListLakeFormationOptInsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListLakeFormationOptInsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLakeFormationOptIns")
	}

	var r0 *lakeformation.ListLakeFormationOptInsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListLakeFormationOptInsInput, ...func(*lakeformation.Options)) (*lakeformation.ListLakeFormationOptInsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListLakeFormationOptInsInput, ...func(*lakeformation.Options)) *lakeformation.ListLakeFormationOptInsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListLakeFormationOptInsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListLakeFormationOptInsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPermissions(ctx context.Context, params *lakeformation.ListPermissionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListPermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPermissions")
	}

	var r0 *lakeformation.ListPermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListPermissionsInput, ...func(*lakeformation.Options)) (*lakeformation.ListPermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListPermissionsInput, ...func(*lakeformation.Options)) *lakeformation.ListPermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListPermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListPermissionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResources(ctx context.Context, params *lakeformation.ListResourcesInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListResourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResources")
	}

	var r0 *lakeformation.ListResourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListResourcesInput, ...func(*lakeformation.Options)) (*lakeformation.ListResourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListResourcesInput, ...func(*lakeformation.Options)) *lakeformation.ListResourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListResourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListResourcesInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTableStorageOptimizers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTableStorageOptimizers(ctx context.Context, params *lakeformation.ListTableStorageOptimizersInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListTableStorageOptimizersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTableStorageOptimizers")
	}

	var r0 *lakeformation.ListTableStorageOptimizersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListTableStorageOptimizersInput, ...func(*lakeformation.Options)) (*lakeformation.ListTableStorageOptimizersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListTableStorageOptimizersInput, ...func(*lakeformation.Options)) *lakeformation.ListTableStorageOptimizersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListTableStorageOptimizersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListTableStorageOptimizersInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTransactions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTransactions(ctx context.Context, params *lakeformation.ListTransactionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.ListTransactionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 *lakeformation.ListTransactionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListTransactionsInput, ...func(*lakeformation.Options)) (*lakeformation.ListTransactionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.ListTransactionsInput, ...func(*lakeformation.Options)) *lakeformation.ListTransactionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.ListTransactionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.ListTransactionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() lakeformation.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 lakeformation.Options
	if rf, ok := ret.Get(0).(func() lakeformation.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(lakeformation.Options)
	}

	return r0
}

// PutDataLakeSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutDataLakeSettings(ctx context.Context, params *lakeformation.PutDataLakeSettingsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.PutDataLakeSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutDataLakeSettings")
	}

	var r0 *lakeformation.PutDataLakeSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.PutDataLakeSettingsInput, ...func(*lakeformation.Options)) (*lakeformation.PutDataLakeSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.PutDataLakeSettingsInput, ...func(*lakeformation.Options)) *lakeformation.PutDataLakeSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.PutDataLakeSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.PutDataLakeSettingsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterResource(ctx context.Context, params *lakeformation.RegisterResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.RegisterResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterResource")
	}

	var r0 *lakeformation.RegisterResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RegisterResourceInput, ...func(*lakeformation.Options)) (*lakeformation.RegisterResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RegisterResourceInput, ...func(*lakeformation.Options)) *lakeformation.RegisterResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.RegisterResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.RegisterResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveLFTagsFromResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveLFTagsFromResource(ctx context.Context, params *lakeformation.RemoveLFTagsFromResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.RemoveLFTagsFromResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveLFTagsFromResource")
	}

	var r0 *lakeformation.RemoveLFTagsFromResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RemoveLFTagsFromResourceInput, ...func(*lakeformation.Options)) (*lakeformation.RemoveLFTagsFromResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RemoveLFTagsFromResourceInput, ...func(*lakeformation.Options)) *lakeformation.RemoveLFTagsFromResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.RemoveLFTagsFromResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.RemoveLFTagsFromResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokePermissions(ctx context.Context, params *lakeformation.RevokePermissionsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.RevokePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokePermissions")
	}

	var r0 *lakeformation.RevokePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RevokePermissionsInput, ...func(*lakeformation.Options)) (*lakeformation.RevokePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.RevokePermissionsInput, ...func(*lakeformation.Options)) *lakeformation.RevokePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.RevokePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.RevokePermissionsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchDatabasesByLFTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchDatabasesByLFTags(ctx context.Context, params *lakeformation.SearchDatabasesByLFTagsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.SearchDatabasesByLFTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchDatabasesByLFTags")
	}

	var r0 *lakeformation.SearchDatabasesByLFTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.SearchDatabasesByLFTagsInput, ...func(*lakeformation.Options)) (*lakeformation.SearchDatabasesByLFTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.SearchDatabasesByLFTagsInput, ...func(*lakeformation.Options)) *lakeformation.SearchDatabasesByLFTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.SearchDatabasesByLFTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.SearchDatabasesByLFTagsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTablesByLFTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SearchTablesByLFTags(ctx context.Context, params *lakeformation.SearchTablesByLFTagsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.SearchTablesByLFTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTablesByLFTags")
	}

	var r0 *lakeformation.SearchTablesByLFTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.SearchTablesByLFTagsInput, ...func(*lakeformation.Options)) (*lakeformation.SearchTablesByLFTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.SearchTablesByLFTagsInput, ...func(*lakeformation.Options)) *lakeformation.SearchTablesByLFTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.SearchTablesByLFTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.SearchTablesByLFTagsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartQueryPlanning provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartQueryPlanning(ctx context.Context, params *lakeformation.StartQueryPlanningInput, optFns ...func(*lakeformation.Options)) (*lakeformation.StartQueryPlanningOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartQueryPlanning")
	}

	var r0 *lakeformation.StartQueryPlanningOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.StartQueryPlanningInput, ...func(*lakeformation.Options)) (*lakeformation.StartQueryPlanningOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.StartQueryPlanningInput, ...func(*lakeformation.Options)) *lakeformation.StartQueryPlanningOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.StartQueryPlanningOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.StartQueryPlanningInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartTransaction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTransaction(ctx context.Context, params *lakeformation.StartTransactionInput, optFns ...func(*lakeformation.Options)) (*lakeformation.StartTransactionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTransaction")
	}

	var r0 *lakeformation.StartTransactionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.StartTransactionInput, ...func(*lakeformation.Options)) (*lakeformation.StartTransactionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.StartTransactionInput, ...func(*lakeformation.Options)) *lakeformation.StartTransactionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.StartTransactionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.StartTransactionInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataCellsFilter provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataCellsFilter(ctx context.Context, params *lakeformation.UpdateDataCellsFilterInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateDataCellsFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataCellsFilter")
	}

	var r0 *lakeformation.UpdateDataCellsFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateDataCellsFilterInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateDataCellsFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateDataCellsFilterInput, ...func(*lakeformation.Options)) *lakeformation.UpdateDataCellsFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateDataCellsFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateDataCellsFilterInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLFTag provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLFTag(ctx context.Context, params *lakeformation.UpdateLFTagInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateLFTagOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLFTag")
	}

	var r0 *lakeformation.UpdateLFTagOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateLFTagInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateLFTagOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateLFTagInput, ...func(*lakeformation.Options)) *lakeformation.UpdateLFTagOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateLFTagOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateLFTagInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLakeFormationIdentityCenterConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateLakeFormationIdentityCenterConfiguration(ctx context.Context, params *lakeformation.UpdateLakeFormationIdentityCenterConfigurationInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateLakeFormationIdentityCenterConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLakeFormationIdentityCenterConfiguration")
	}

	var r0 *lakeformation.UpdateLakeFormationIdentityCenterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateLakeFormationIdentityCenterConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) *lakeformation.UpdateLakeFormationIdentityCenterConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateLakeFormationIdentityCenterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateLakeFormationIdentityCenterConfigurationInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateResource(ctx context.Context, params *lakeformation.UpdateResourceInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResource")
	}

	var r0 *lakeformation.UpdateResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateResourceInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateResourceInput, ...func(*lakeformation.Options)) *lakeformation.UpdateResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateResourceInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTableObjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTableObjects(ctx context.Context, params *lakeformation.UpdateTableObjectsInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateTableObjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTableObjects")
	}

	var r0 *lakeformation.UpdateTableObjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateTableObjectsInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateTableObjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateTableObjectsInput, ...func(*lakeformation.Options)) *lakeformation.UpdateTableObjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateTableObjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateTableObjectsInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTableStorageOptimizer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTableStorageOptimizer(ctx context.Context, params *lakeformation.UpdateTableStorageOptimizerInput, optFns ...func(*lakeformation.Options)) (*lakeformation.UpdateTableStorageOptimizerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTableStorageOptimizer")
	}

	var r0 *lakeformation.UpdateTableStorageOptimizerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateTableStorageOptimizerInput, ...func(*lakeformation.Options)) (*lakeformation.UpdateTableStorageOptimizerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lakeformation.UpdateTableStorageOptimizerInput, ...func(*lakeformation.Options)) *lakeformation.UpdateTableStorageOptimizerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lakeformation.UpdateTableStorageOptimizerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lakeformation.UpdateTableStorageOptimizerInput, ...func(*lakeformation.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
