// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	datapipeline "github.com/aws/aws-sdk-go-v2/service/datapipeline"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// ActivatePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ActivatePipeline(ctx context.Context, params *datapipeline.ActivatePipelineInput, optFns ...func(*datapipeline.Options)) (*datapipeline.ActivatePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActivatePipeline")
	}

	var r0 *datapipeline.ActivatePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ActivatePipelineInput, ...func(*datapipeline.Options)) (*datapipeline.ActivatePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ActivatePipelineInput, ...func(*datapipeline.Options)) *datapipeline.ActivatePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.ActivatePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.ActivatePipelineInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddTags(ctx context.Context, params *datapipeline.AddTagsInput, optFns ...func(*datapipeline.Options)) (*datapipeline.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *datapipeline.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.AddTagsInput, ...func(*datapipeline.Options)) (*datapipeline.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.AddTagsInput, ...func(*datapipeline.Options)) *datapipeline.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.AddTagsInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreatePipeline(ctx context.Context, params *datapipeline.CreatePipelineInput, optFns ...func(*datapipeline.Options)) (*datapipeline.CreatePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePipeline")
	}

	var r0 *datapipeline.CreatePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.CreatePipelineInput, ...func(*datapipeline.Options)) (*datapipeline.CreatePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.CreatePipelineInput, ...func(*datapipeline.Options)) *datapipeline.CreatePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.CreatePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.CreatePipelineInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeactivatePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeactivatePipeline(ctx context.Context, params *datapipeline.DeactivatePipelineInput, optFns ...func(*datapipeline.Options)) (*datapipeline.DeactivatePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeactivatePipeline")
	}

	var r0 *datapipeline.DeactivatePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DeactivatePipelineInput, ...func(*datapipeline.Options)) (*datapipeline.DeactivatePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DeactivatePipelineInput, ...func(*datapipeline.Options)) *datapipeline.DeactivatePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.DeactivatePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.DeactivatePipelineInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePipeline provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePipeline(ctx context.Context, params *datapipeline.DeletePipelineInput, optFns ...func(*datapipeline.Options)) (*datapipeline.DeletePipelineOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipeline")
	}

	var r0 *datapipeline.DeletePipelineOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DeletePipelineInput, ...func(*datapipeline.Options)) (*datapipeline.DeletePipelineOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DeletePipelineInput, ...func(*datapipeline.Options)) *datapipeline.DeletePipelineOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.DeletePipelineOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.DeletePipelineInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeObjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeObjects(ctx context.Context, params *datapipeline.DescribeObjectsInput, optFns ...func(*datapipeline.Options)) (*datapipeline.DescribeObjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeObjects")
	}

	var r0 *datapipeline.DescribeObjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DescribeObjectsInput, ...func(*datapipeline.Options)) (*datapipeline.DescribeObjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DescribeObjectsInput, ...func(*datapipeline.Options)) *datapipeline.DescribeObjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.DescribeObjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.DescribeObjectsInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePipelines provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePipelines(ctx context.Context, params *datapipeline.DescribePipelinesInput, optFns ...func(*datapipeline.Options)) (*datapipeline.DescribePipelinesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePipelines")
	}

	var r0 *datapipeline.DescribePipelinesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DescribePipelinesInput, ...func(*datapipeline.Options)) (*datapipeline.DescribePipelinesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.DescribePipelinesInput, ...func(*datapipeline.Options)) *datapipeline.DescribePipelinesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.DescribePipelinesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.DescribePipelinesInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvaluateExpression provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EvaluateExpression(ctx context.Context, params *datapipeline.EvaluateExpressionInput, optFns ...func(*datapipeline.Options)) (*datapipeline.EvaluateExpressionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvaluateExpression")
	}

	var r0 *datapipeline.EvaluateExpressionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.EvaluateExpressionInput, ...func(*datapipeline.Options)) (*datapipeline.EvaluateExpressionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.EvaluateExpressionInput, ...func(*datapipeline.Options)) *datapipeline.EvaluateExpressionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.EvaluateExpressionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.EvaluateExpressionInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipelineDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPipelineDefinition(ctx context.Context, params *datapipeline.GetPipelineDefinitionInput, optFns ...func(*datapipeline.Options)) (*datapipeline.GetPipelineDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineDefinition")
	}

	var r0 *datapipeline.GetPipelineDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.GetPipelineDefinitionInput, ...func(*datapipeline.Options)) (*datapipeline.GetPipelineDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.GetPipelineDefinitionInput, ...func(*datapipeline.Options)) *datapipeline.GetPipelineDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.GetPipelineDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.GetPipelineDefinitionInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPipelines provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListPipelines(ctx context.Context, params *datapipeline.ListPipelinesInput, optFns ...func(*datapipeline.Options)) (*datapipeline.ListPipelinesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPipelines")
	}

	var r0 *datapipeline.ListPipelinesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ListPipelinesInput, ...func(*datapipeline.Options)) (*datapipeline.ListPipelinesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ListPipelinesInput, ...func(*datapipeline.Options)) *datapipeline.ListPipelinesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.ListPipelinesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.ListPipelinesInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() datapipeline.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 datapipeline.Options
	if rf, ok := ret.Get(0).(func() datapipeline.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(datapipeline.Options)
	}

	return r0
}

// PollForTask provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PollForTask(ctx context.Context, params *datapipeline.PollForTaskInput, optFns ...func(*datapipeline.Options)) (*datapipeline.PollForTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForTask")
	}

	var r0 *datapipeline.PollForTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.PollForTaskInput, ...func(*datapipeline.Options)) (*datapipeline.PollForTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.PollForTaskInput, ...func(*datapipeline.Options)) *datapipeline.PollForTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.PollForTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.PollForTaskInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPipelineDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPipelineDefinition(ctx context.Context, params *datapipeline.PutPipelineDefinitionInput, optFns ...func(*datapipeline.Options)) (*datapipeline.PutPipelineDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPipelineDefinition")
	}

	var r0 *datapipeline.PutPipelineDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.PutPipelineDefinitionInput, ...func(*datapipeline.Options)) (*datapipeline.PutPipelineDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.PutPipelineDefinitionInput, ...func(*datapipeline.Options)) *datapipeline.PutPipelineDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.PutPipelineDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.PutPipelineDefinitionInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryObjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) QueryObjects(ctx context.Context, params *datapipeline.QueryObjectsInput, optFns ...func(*datapipeline.Options)) (*datapipeline.QueryObjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryObjects")
	}

	var r0 *datapipeline.QueryObjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.QueryObjectsInput, ...func(*datapipeline.Options)) (*datapipeline.QueryObjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.QueryObjectsInput, ...func(*datapipeline.Options)) *datapipeline.QueryObjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.QueryObjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.QueryObjectsInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RemoveTags(ctx context.Context, params *datapipeline.RemoveTagsInput, optFns ...func(*datapipeline.Options)) (*datapipeline.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *datapipeline.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.RemoveTagsInput, ...func(*datapipeline.Options)) (*datapipeline.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.RemoveTagsInput, ...func(*datapipeline.Options)) *datapipeline.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.RemoveTagsInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReportTaskProgress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReportTaskProgress(ctx context.Context, params *datapipeline.ReportTaskProgressInput, optFns ...func(*datapipeline.Options)) (*datapipeline.ReportTaskProgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReportTaskProgress")
	}

	var r0 *datapipeline.ReportTaskProgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ReportTaskProgressInput, ...func(*datapipeline.Options)) (*datapipeline.ReportTaskProgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ReportTaskProgressInput, ...func(*datapipeline.Options)) *datapipeline.ReportTaskProgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.ReportTaskProgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.ReportTaskProgressInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReportTaskRunnerHeartbeat provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ReportTaskRunnerHeartbeat(ctx context.Context, params *datapipeline.ReportTaskRunnerHeartbeatInput, optFns ...func(*datapipeline.Options)) (*datapipeline.ReportTaskRunnerHeartbeatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReportTaskRunnerHeartbeat")
	}

	var r0 *datapipeline.ReportTaskRunnerHeartbeatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ReportTaskRunnerHeartbeatInput, ...func(*datapipeline.Options)) (*datapipeline.ReportTaskRunnerHeartbeatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ReportTaskRunnerHeartbeatInput, ...func(*datapipeline.Options)) *datapipeline.ReportTaskRunnerHeartbeatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.ReportTaskRunnerHeartbeatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.ReportTaskRunnerHeartbeatInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetStatus(ctx context.Context, params *datapipeline.SetStatusInput, optFns ...func(*datapipeline.Options)) (*datapipeline.SetStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetStatus")
	}

	var r0 *datapipeline.SetStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.SetStatusInput, ...func(*datapipeline.Options)) (*datapipeline.SetStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.SetStatusInput, ...func(*datapipeline.Options)) *datapipeline.SetStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.SetStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.SetStatusInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTaskStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SetTaskStatus(ctx context.Context, params *datapipeline.SetTaskStatusInput, optFns ...func(*datapipeline.Options)) (*datapipeline.SetTaskStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTaskStatus")
	}

	var r0 *datapipeline.SetTaskStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.SetTaskStatusInput, ...func(*datapipeline.Options)) (*datapipeline.SetTaskStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.SetTaskStatusInput, ...func(*datapipeline.Options)) *datapipeline.SetTaskStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.SetTaskStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.SetTaskStatusInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePipelineDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidatePipelineDefinition(ctx context.Context, params *datapipeline.ValidatePipelineDefinitionInput, optFns ...func(*datapipeline.Options)) (*datapipeline.ValidatePipelineDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePipelineDefinition")
	}

	var r0 *datapipeline.ValidatePipelineDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ValidatePipelineDefinitionInput, ...func(*datapipeline.Options)) (*datapipeline.ValidatePipelineDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datapipeline.ValidatePipelineDefinitionInput, ...func(*datapipeline.Options)) *datapipeline.ValidatePipelineDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*datapipeline.ValidatePipelineDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datapipeline.ValidatePipelineDefinitionInput, ...func(*datapipeline.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
