// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	translate "github.com/aws/aws-sdk-go-v2/service/translate"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateParallelData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateParallelData(ctx context.Context, params *translate.CreateParallelDataInput, optFns ...func(*translate.Options)) (*translate.CreateParallelDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParallelData")
	}

	var r0 *translate.CreateParallelDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.CreateParallelDataInput, ...func(*translate.Options)) (*translate.CreateParallelDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.CreateParallelDataInput, ...func(*translate.Options)) *translate.CreateParallelDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.CreateParallelDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.CreateParallelDataInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteParallelData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteParallelData(ctx context.Context, params *translate.DeleteParallelDataInput, optFns ...func(*translate.Options)) (*translate.DeleteParallelDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteParallelData")
	}

	var r0 *translate.DeleteParallelDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DeleteParallelDataInput, ...func(*translate.Options)) (*translate.DeleteParallelDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DeleteParallelDataInput, ...func(*translate.Options)) *translate.DeleteParallelDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.DeleteParallelDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.DeleteParallelDataInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTerminology provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTerminology(ctx context.Context, params *translate.DeleteTerminologyInput, optFns ...func(*translate.Options)) (*translate.DeleteTerminologyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTerminology")
	}

	var r0 *translate.DeleteTerminologyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DeleteTerminologyInput, ...func(*translate.Options)) (*translate.DeleteTerminologyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DeleteTerminologyInput, ...func(*translate.Options)) *translate.DeleteTerminologyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.DeleteTerminologyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.DeleteTerminologyInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTextTranslationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTextTranslationJob(ctx context.Context, params *translate.DescribeTextTranslationJobInput, optFns ...func(*translate.Options)) (*translate.DescribeTextTranslationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTextTranslationJob")
	}

	var r0 *translate.DescribeTextTranslationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DescribeTextTranslationJobInput, ...func(*translate.Options)) (*translate.DescribeTextTranslationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.DescribeTextTranslationJobInput, ...func(*translate.Options)) *translate.DescribeTextTranslationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.DescribeTextTranslationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.DescribeTextTranslationJobInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParallelData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetParallelData(ctx context.Context, params *translate.GetParallelDataInput, optFns ...func(*translate.Options)) (*translate.GetParallelDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParallelData")
	}

	var r0 *translate.GetParallelDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.GetParallelDataInput, ...func(*translate.Options)) (*translate.GetParallelDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.GetParallelDataInput, ...func(*translate.Options)) *translate.GetParallelDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.GetParallelDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.GetParallelDataInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTerminology provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTerminology(ctx context.Context, params *translate.GetTerminologyInput, optFns ...func(*translate.Options)) (*translate.GetTerminologyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTerminology")
	}

	var r0 *translate.GetTerminologyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.GetTerminologyInput, ...func(*translate.Options)) (*translate.GetTerminologyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.GetTerminologyInput, ...func(*translate.Options)) *translate.GetTerminologyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.GetTerminologyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.GetTerminologyInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportTerminology provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ImportTerminology(ctx context.Context, params *translate.ImportTerminologyInput, optFns ...func(*translate.Options)) (*translate.ImportTerminologyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportTerminology")
	}

	var r0 *translate.ImportTerminologyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ImportTerminologyInput, ...func(*translate.Options)) (*translate.ImportTerminologyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ImportTerminologyInput, ...func(*translate.Options)) *translate.ImportTerminologyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ImportTerminologyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ImportTerminologyInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLanguages provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLanguages(ctx context.Context, params *translate.ListLanguagesInput, optFns ...func(*translate.Options)) (*translate.ListLanguagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLanguages")
	}

	var r0 *translate.ListLanguagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListLanguagesInput, ...func(*translate.Options)) (*translate.ListLanguagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListLanguagesInput, ...func(*translate.Options)) *translate.ListLanguagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ListLanguagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ListLanguagesInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListParallelData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListParallelData(ctx context.Context, params *translate.ListParallelDataInput, optFns ...func(*translate.Options)) (*translate.ListParallelDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParallelData")
	}

	var r0 *translate.ListParallelDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListParallelDataInput, ...func(*translate.Options)) (*translate.ListParallelDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListParallelDataInput, ...func(*translate.Options)) *translate.ListParallelDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ListParallelDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ListParallelDataInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *translate.ListTagsForResourceInput, optFns ...func(*translate.Options)) (*translate.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *translate.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTagsForResourceInput, ...func(*translate.Options)) (*translate.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTagsForResourceInput, ...func(*translate.Options)) *translate.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ListTagsForResourceInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTerminologies provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTerminologies(ctx context.Context, params *translate.ListTerminologiesInput, optFns ...func(*translate.Options)) (*translate.ListTerminologiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTerminologies")
	}

	var r0 *translate.ListTerminologiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTerminologiesInput, ...func(*translate.Options)) (*translate.ListTerminologiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTerminologiesInput, ...func(*translate.Options)) *translate.ListTerminologiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ListTerminologiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ListTerminologiesInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTextTranslationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTextTranslationJobs(ctx context.Context, params *translate.ListTextTranslationJobsInput, optFns ...func(*translate.Options)) (*translate.ListTextTranslationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTextTranslationJobs")
	}

	var r0 *translate.ListTextTranslationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTextTranslationJobsInput, ...func(*translate.Options)) (*translate.ListTextTranslationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.ListTextTranslationJobsInput, ...func(*translate.Options)) *translate.ListTextTranslationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.ListTextTranslationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.ListTextTranslationJobsInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() translate.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 translate.Options
	if rf, ok := ret.Get(0).(func() translate.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(translate.Options)
	}

	return r0
}

// StartTextTranslationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartTextTranslationJob(ctx context.Context, params *translate.StartTextTranslationJobInput, optFns ...func(*translate.Options)) (*translate.StartTextTranslationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartTextTranslationJob")
	}

	var r0 *translate.StartTextTranslationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.StartTextTranslationJobInput, ...func(*translate.Options)) (*translate.StartTextTranslationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.StartTextTranslationJobInput, ...func(*translate.Options)) *translate.StartTextTranslationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.StartTextTranslationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.StartTextTranslationJobInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTextTranslationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopTextTranslationJob(ctx context.Context, params *translate.StopTextTranslationJobInput, optFns ...func(*translate.Options)) (*translate.StopTextTranslationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTextTranslationJob")
	}

	var r0 *translate.StopTextTranslationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.StopTextTranslationJobInput, ...func(*translate.Options)) (*translate.StopTextTranslationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.StopTextTranslationJobInput, ...func(*translate.Options)) *translate.StopTextTranslationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.StopTextTranslationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.StopTextTranslationJobInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *translate.TagResourceInput, optFns ...func(*translate.Options)) (*translate.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *translate.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TagResourceInput, ...func(*translate.Options)) (*translate.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TagResourceInput, ...func(*translate.Options)) *translate.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.TagResourceInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TranslateDocument provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TranslateDocument(ctx context.Context, params *translate.TranslateDocumentInput, optFns ...func(*translate.Options)) (*translate.TranslateDocumentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TranslateDocument")
	}

	var r0 *translate.TranslateDocumentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TranslateDocumentInput, ...func(*translate.Options)) (*translate.TranslateDocumentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TranslateDocumentInput, ...func(*translate.Options)) *translate.TranslateDocumentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.TranslateDocumentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.TranslateDocumentInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TranslateText provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TranslateText(ctx context.Context, params *translate.TranslateTextInput, optFns ...func(*translate.Options)) (*translate.TranslateTextOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TranslateText")
	}

	var r0 *translate.TranslateTextOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TranslateTextInput, ...func(*translate.Options)) (*translate.TranslateTextOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.TranslateTextInput, ...func(*translate.Options)) *translate.TranslateTextOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.TranslateTextOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.TranslateTextInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *translate.UntagResourceInput, optFns ...func(*translate.Options)) (*translate.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *translate.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.UntagResourceInput, ...func(*translate.Options)) (*translate.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.UntagResourceInput, ...func(*translate.Options)) *translate.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.UntagResourceInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateParallelData provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateParallelData(ctx context.Context, params *translate.UpdateParallelDataInput, optFns ...func(*translate.Options)) (*translate.UpdateParallelDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParallelData")
	}

	var r0 *translate.UpdateParallelDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *translate.UpdateParallelDataInput, ...func(*translate.Options)) (*translate.UpdateParallelDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *translate.UpdateParallelDataInput, ...func(*translate.Options)) *translate.UpdateParallelDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*translate.UpdateParallelDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *translate.UpdateParallelDataInput, ...func(*translate.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
