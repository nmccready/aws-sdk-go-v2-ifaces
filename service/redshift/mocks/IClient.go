// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	redshift "github.com/aws/aws-sdk-go-v2/service/redshift"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptReservedNodeExchange provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptReservedNodeExchange(ctx context.Context, params *redshift.AcceptReservedNodeExchangeInput, optFns ...func(*redshift.Options)) (*redshift.AcceptReservedNodeExchangeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptReservedNodeExchange")
	}

	var r0 *redshift.AcceptReservedNodeExchangeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AcceptReservedNodeExchangeInput, ...func(*redshift.Options)) (*redshift.AcceptReservedNodeExchangeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AcceptReservedNodeExchangeInput, ...func(*redshift.Options)) *redshift.AcceptReservedNodeExchangeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AcceptReservedNodeExchangeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AcceptReservedNodeExchangeInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPartner provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AddPartner(ctx context.Context, params *redshift.AddPartnerInput, optFns ...func(*redshift.Options)) (*redshift.AddPartnerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPartner")
	}

	var r0 *redshift.AddPartnerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AddPartnerInput, ...func(*redshift.Options)) (*redshift.AddPartnerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AddPartnerInput, ...func(*redshift.Options)) *redshift.AddPartnerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AddPartnerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AddPartnerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateDataShareConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateDataShareConsumer(ctx context.Context, params *redshift.AssociateDataShareConsumerInput, optFns ...func(*redshift.Options)) (*redshift.AssociateDataShareConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateDataShareConsumer")
	}

	var r0 *redshift.AssociateDataShareConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AssociateDataShareConsumerInput, ...func(*redshift.Options)) (*redshift.AssociateDataShareConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AssociateDataShareConsumerInput, ...func(*redshift.Options)) *redshift.AssociateDataShareConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AssociateDataShareConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AssociateDataShareConsumerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeClusterSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeClusterSecurityGroupIngress(ctx context.Context, params *redshift.AuthorizeClusterSecurityGroupIngressInput, optFns ...func(*redshift.Options)) (*redshift.AuthorizeClusterSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeClusterSecurityGroupIngress")
	}

	var r0 *redshift.AuthorizeClusterSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) (*redshift.AuthorizeClusterSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) *redshift.AuthorizeClusterSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AuthorizeClusterSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AuthorizeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeDataShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeDataShare(ctx context.Context, params *redshift.AuthorizeDataShareInput, optFns ...func(*redshift.Options)) (*redshift.AuthorizeDataShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeDataShare")
	}

	var r0 *redshift.AuthorizeDataShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeDataShareInput, ...func(*redshift.Options)) (*redshift.AuthorizeDataShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeDataShareInput, ...func(*redshift.Options)) *redshift.AuthorizeDataShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AuthorizeDataShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AuthorizeDataShareInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeEndpointAccess(ctx context.Context, params *redshift.AuthorizeEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.AuthorizeEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeEndpointAccess")
	}

	var r0 *redshift.AuthorizeEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeEndpointAccessInput, ...func(*redshift.Options)) (*redshift.AuthorizeEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeEndpointAccessInput, ...func(*redshift.Options)) *redshift.AuthorizeEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AuthorizeEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AuthorizeEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSnapshotAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AuthorizeSnapshotAccess(ctx context.Context, params *redshift.AuthorizeSnapshotAccessInput, optFns ...func(*redshift.Options)) (*redshift.AuthorizeSnapshotAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSnapshotAccess")
	}

	var r0 *redshift.AuthorizeSnapshotAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeSnapshotAccessInput, ...func(*redshift.Options)) (*redshift.AuthorizeSnapshotAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.AuthorizeSnapshotAccessInput, ...func(*redshift.Options)) *redshift.AuthorizeSnapshotAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.AuthorizeSnapshotAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.AuthorizeSnapshotAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteClusterSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteClusterSnapshots(ctx context.Context, params *redshift.BatchDeleteClusterSnapshotsInput, optFns ...func(*redshift.Options)) (*redshift.BatchDeleteClusterSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteClusterSnapshots")
	}

	var r0 *redshift.BatchDeleteClusterSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.BatchDeleteClusterSnapshotsInput, ...func(*redshift.Options)) (*redshift.BatchDeleteClusterSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.BatchDeleteClusterSnapshotsInput, ...func(*redshift.Options)) *redshift.BatchDeleteClusterSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.BatchDeleteClusterSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.BatchDeleteClusterSnapshotsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchModifyClusterSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchModifyClusterSnapshots(ctx context.Context, params *redshift.BatchModifyClusterSnapshotsInput, optFns ...func(*redshift.Options)) (*redshift.BatchModifyClusterSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchModifyClusterSnapshots")
	}

	var r0 *redshift.BatchModifyClusterSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.BatchModifyClusterSnapshotsInput, ...func(*redshift.Options)) (*redshift.BatchModifyClusterSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.BatchModifyClusterSnapshotsInput, ...func(*redshift.Options)) *redshift.BatchModifyClusterSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.BatchModifyClusterSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.BatchModifyClusterSnapshotsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelResize provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelResize(ctx context.Context, params *redshift.CancelResizeInput, optFns ...func(*redshift.Options)) (*redshift.CancelResizeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelResize")
	}

	var r0 *redshift.CancelResizeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CancelResizeInput, ...func(*redshift.Options)) (*redshift.CancelResizeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CancelResizeInput, ...func(*redshift.Options)) *redshift.CancelResizeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CancelResizeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CancelResizeInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CopyClusterSnapshot(ctx context.Context, params *redshift.CopyClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.CopyClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyClusterSnapshot")
	}

	var r0 *redshift.CopyClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CopyClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.CopyClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CopyClusterSnapshotInput, ...func(*redshift.Options)) *redshift.CopyClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CopyClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CopyClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAuthenticationProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAuthenticationProfile(ctx context.Context, params *redshift.CreateAuthenticationProfileInput, optFns ...func(*redshift.Options)) (*redshift.CreateAuthenticationProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAuthenticationProfile")
	}

	var r0 *redshift.CreateAuthenticationProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateAuthenticationProfileInput, ...func(*redshift.Options)) (*redshift.CreateAuthenticationProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateAuthenticationProfileInput, ...func(*redshift.Options)) *redshift.CreateAuthenticationProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateAuthenticationProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateAuthenticationProfileInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCluster(ctx context.Context, params *redshift.CreateClusterInput, optFns ...func(*redshift.Options)) (*redshift.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *redshift.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterInput, ...func(*redshift.Options)) (*redshift.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterInput, ...func(*redshift.Options)) *redshift.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClusterParameterGroup(ctx context.Context, params *redshift.CreateClusterParameterGroupInput, optFns ...func(*redshift.Options)) (*redshift.CreateClusterParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterParameterGroup")
	}

	var r0 *redshift.CreateClusterParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterParameterGroupInput, ...func(*redshift.Options)) (*redshift.CreateClusterParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterParameterGroupInput, ...func(*redshift.Options)) *redshift.CreateClusterParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateClusterParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateClusterParameterGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClusterSecurityGroup(ctx context.Context, params *redshift.CreateClusterSecurityGroupInput, optFns ...func(*redshift.Options)) (*redshift.CreateClusterSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterSecurityGroup")
	}

	var r0 *redshift.CreateClusterSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSecurityGroupInput, ...func(*redshift.Options)) (*redshift.CreateClusterSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSecurityGroupInput, ...func(*redshift.Options)) *redshift.CreateClusterSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateClusterSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateClusterSecurityGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClusterSnapshot(ctx context.Context, params *redshift.CreateClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.CreateClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterSnapshot")
	}

	var r0 *redshift.CreateClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.CreateClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSnapshotInput, ...func(*redshift.Options)) *redshift.CreateClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateClusterSubnetGroup(ctx context.Context, params *redshift.CreateClusterSubnetGroupInput, optFns ...func(*redshift.Options)) (*redshift.CreateClusterSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterSubnetGroup")
	}

	var r0 *redshift.CreateClusterSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSubnetGroupInput, ...func(*redshift.Options)) (*redshift.CreateClusterSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateClusterSubnetGroupInput, ...func(*redshift.Options)) *redshift.CreateClusterSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateClusterSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateClusterSubnetGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomDomainAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateCustomDomainAssociation(ctx context.Context, params *redshift.CreateCustomDomainAssociationInput, optFns ...func(*redshift.Options)) (*redshift.CreateCustomDomainAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomDomainAssociation")
	}

	var r0 *redshift.CreateCustomDomainAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateCustomDomainAssociationInput, ...func(*redshift.Options)) (*redshift.CreateCustomDomainAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateCustomDomainAssociationInput, ...func(*redshift.Options)) *redshift.CreateCustomDomainAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateCustomDomainAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateCustomDomainAssociationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEndpointAccess(ctx context.Context, params *redshift.CreateEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.CreateEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEndpointAccess")
	}

	var r0 *redshift.CreateEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateEndpointAccessInput, ...func(*redshift.Options)) (*redshift.CreateEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateEndpointAccessInput, ...func(*redshift.Options)) *redshift.CreateEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEventSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEventSubscription(ctx context.Context, params *redshift.CreateEventSubscriptionInput, optFns ...func(*redshift.Options)) (*redshift.CreateEventSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEventSubscription")
	}

	var r0 *redshift.CreateEventSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateEventSubscriptionInput, ...func(*redshift.Options)) (*redshift.CreateEventSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateEventSubscriptionInput, ...func(*redshift.Options)) *redshift.CreateEventSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateEventSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateEventSubscriptionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHsmClientCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateHsmClientCertificate(ctx context.Context, params *redshift.CreateHsmClientCertificateInput, optFns ...func(*redshift.Options)) (*redshift.CreateHsmClientCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHsmClientCertificate")
	}

	var r0 *redshift.CreateHsmClientCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateHsmClientCertificateInput, ...func(*redshift.Options)) (*redshift.CreateHsmClientCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateHsmClientCertificateInput, ...func(*redshift.Options)) *redshift.CreateHsmClientCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateHsmClientCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateHsmClientCertificateInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHsmConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateHsmConfiguration(ctx context.Context, params *redshift.CreateHsmConfigurationInput, optFns ...func(*redshift.Options)) (*redshift.CreateHsmConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHsmConfiguration")
	}

	var r0 *redshift.CreateHsmConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateHsmConfigurationInput, ...func(*redshift.Options)) (*redshift.CreateHsmConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateHsmConfigurationInput, ...func(*redshift.Options)) *redshift.CreateHsmConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateHsmConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateHsmConfigurationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRedshiftIdcApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRedshiftIdcApplication(ctx context.Context, params *redshift.CreateRedshiftIdcApplicationInput, optFns ...func(*redshift.Options)) (*redshift.CreateRedshiftIdcApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRedshiftIdcApplication")
	}

	var r0 *redshift.CreateRedshiftIdcApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateRedshiftIdcApplicationInput, ...func(*redshift.Options)) (*redshift.CreateRedshiftIdcApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateRedshiftIdcApplicationInput, ...func(*redshift.Options)) *redshift.CreateRedshiftIdcApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateRedshiftIdcApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateRedshiftIdcApplicationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateScheduledAction(ctx context.Context, params *redshift.CreateScheduledActionInput, optFns ...func(*redshift.Options)) (*redshift.CreateScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateScheduledAction")
	}

	var r0 *redshift.CreateScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateScheduledActionInput, ...func(*redshift.Options)) (*redshift.CreateScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateScheduledActionInput, ...func(*redshift.Options)) *redshift.CreateScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateScheduledActionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshotCopyGrant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshotCopyGrant(ctx context.Context, params *redshift.CreateSnapshotCopyGrantInput, optFns ...func(*redshift.Options)) (*redshift.CreateSnapshotCopyGrantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshotCopyGrant")
	}

	var r0 *redshift.CreateSnapshotCopyGrantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateSnapshotCopyGrantInput, ...func(*redshift.Options)) (*redshift.CreateSnapshotCopyGrantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateSnapshotCopyGrantInput, ...func(*redshift.Options)) *redshift.CreateSnapshotCopyGrantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateSnapshotCopyGrantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateSnapshotCopyGrantInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshotSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSnapshotSchedule(ctx context.Context, params *redshift.CreateSnapshotScheduleInput, optFns ...func(*redshift.Options)) (*redshift.CreateSnapshotScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshotSchedule")
	}

	var r0 *redshift.CreateSnapshotScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateSnapshotScheduleInput, ...func(*redshift.Options)) (*redshift.CreateSnapshotScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateSnapshotScheduleInput, ...func(*redshift.Options)) *redshift.CreateSnapshotScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateSnapshotScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateSnapshotScheduleInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTags(ctx context.Context, params *redshift.CreateTagsInput, optFns ...func(*redshift.Options)) (*redshift.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTags")
	}

	var r0 *redshift.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateTagsInput, ...func(*redshift.Options)) (*redshift.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateTagsInput, ...func(*redshift.Options)) *redshift.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateTagsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUsageLimit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUsageLimit(ctx context.Context, params *redshift.CreateUsageLimitInput, optFns ...func(*redshift.Options)) (*redshift.CreateUsageLimitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUsageLimit")
	}

	var r0 *redshift.CreateUsageLimitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateUsageLimitInput, ...func(*redshift.Options)) (*redshift.CreateUsageLimitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.CreateUsageLimitInput, ...func(*redshift.Options)) *redshift.CreateUsageLimitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.CreateUsageLimitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.CreateUsageLimitInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeauthorizeDataShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeauthorizeDataShare(ctx context.Context, params *redshift.DeauthorizeDataShareInput, optFns ...func(*redshift.Options)) (*redshift.DeauthorizeDataShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeauthorizeDataShare")
	}

	var r0 *redshift.DeauthorizeDataShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeauthorizeDataShareInput, ...func(*redshift.Options)) (*redshift.DeauthorizeDataShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeauthorizeDataShareInput, ...func(*redshift.Options)) *redshift.DeauthorizeDataShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeauthorizeDataShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeauthorizeDataShareInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAuthenticationProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAuthenticationProfile(ctx context.Context, params *redshift.DeleteAuthenticationProfileInput, optFns ...func(*redshift.Options)) (*redshift.DeleteAuthenticationProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAuthenticationProfile")
	}

	var r0 *redshift.DeleteAuthenticationProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteAuthenticationProfileInput, ...func(*redshift.Options)) (*redshift.DeleteAuthenticationProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteAuthenticationProfileInput, ...func(*redshift.Options)) *redshift.DeleteAuthenticationProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteAuthenticationProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteAuthenticationProfileInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCluster(ctx context.Context, params *redshift.DeleteClusterInput, optFns ...func(*redshift.Options)) (*redshift.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 *redshift.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterInput, ...func(*redshift.Options)) (*redshift.DeleteClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterInput, ...func(*redshift.Options)) *redshift.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClusterParameterGroup(ctx context.Context, params *redshift.DeleteClusterParameterGroupInput, optFns ...func(*redshift.Options)) (*redshift.DeleteClusterParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusterParameterGroup")
	}

	var r0 *redshift.DeleteClusterParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterParameterGroupInput, ...func(*redshift.Options)) (*redshift.DeleteClusterParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterParameterGroupInput, ...func(*redshift.Options)) *redshift.DeleteClusterParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteClusterParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteClusterParameterGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClusterSecurityGroup(ctx context.Context, params *redshift.DeleteClusterSecurityGroupInput, optFns ...func(*redshift.Options)) (*redshift.DeleteClusterSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusterSecurityGroup")
	}

	var r0 *redshift.DeleteClusterSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSecurityGroupInput, ...func(*redshift.Options)) (*redshift.DeleteClusterSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSecurityGroupInput, ...func(*redshift.Options)) *redshift.DeleteClusterSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteClusterSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteClusterSecurityGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClusterSnapshot(ctx context.Context, params *redshift.DeleteClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.DeleteClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusterSnapshot")
	}

	var r0 *redshift.DeleteClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.DeleteClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSnapshotInput, ...func(*redshift.Options)) *redshift.DeleteClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteClusterSubnetGroup(ctx context.Context, params *redshift.DeleteClusterSubnetGroupInput, optFns ...func(*redshift.Options)) (*redshift.DeleteClusterSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusterSubnetGroup")
	}

	var r0 *redshift.DeleteClusterSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSubnetGroupInput, ...func(*redshift.Options)) (*redshift.DeleteClusterSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteClusterSubnetGroupInput, ...func(*redshift.Options)) *redshift.DeleteClusterSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteClusterSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteClusterSubnetGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomDomainAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomDomainAssociation(ctx context.Context, params *redshift.DeleteCustomDomainAssociationInput, optFns ...func(*redshift.Options)) (*redshift.DeleteCustomDomainAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomDomainAssociation")
	}

	var r0 *redshift.DeleteCustomDomainAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteCustomDomainAssociationInput, ...func(*redshift.Options)) (*redshift.DeleteCustomDomainAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteCustomDomainAssociationInput, ...func(*redshift.Options)) *redshift.DeleteCustomDomainAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteCustomDomainAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteCustomDomainAssociationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEndpointAccess(ctx context.Context, params *redshift.DeleteEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.DeleteEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEndpointAccess")
	}

	var r0 *redshift.DeleteEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteEndpointAccessInput, ...func(*redshift.Options)) (*redshift.DeleteEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteEndpointAccessInput, ...func(*redshift.Options)) *redshift.DeleteEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEventSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteEventSubscription(ctx context.Context, params *redshift.DeleteEventSubscriptionInput, optFns ...func(*redshift.Options)) (*redshift.DeleteEventSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventSubscription")
	}

	var r0 *redshift.DeleteEventSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteEventSubscriptionInput, ...func(*redshift.Options)) (*redshift.DeleteEventSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteEventSubscriptionInput, ...func(*redshift.Options)) *redshift.DeleteEventSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteEventSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteEventSubscriptionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHsmClientCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteHsmClientCertificate(ctx context.Context, params *redshift.DeleteHsmClientCertificateInput, optFns ...func(*redshift.Options)) (*redshift.DeleteHsmClientCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHsmClientCertificate")
	}

	var r0 *redshift.DeleteHsmClientCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteHsmClientCertificateInput, ...func(*redshift.Options)) (*redshift.DeleteHsmClientCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteHsmClientCertificateInput, ...func(*redshift.Options)) *redshift.DeleteHsmClientCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteHsmClientCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteHsmClientCertificateInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHsmConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteHsmConfiguration(ctx context.Context, params *redshift.DeleteHsmConfigurationInput, optFns ...func(*redshift.Options)) (*redshift.DeleteHsmConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHsmConfiguration")
	}

	var r0 *redshift.DeleteHsmConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteHsmConfigurationInput, ...func(*redshift.Options)) (*redshift.DeleteHsmConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteHsmConfigurationInput, ...func(*redshift.Options)) *redshift.DeleteHsmConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteHsmConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteHsmConfigurationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePartner provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePartner(ctx context.Context, params *redshift.DeletePartnerInput, optFns ...func(*redshift.Options)) (*redshift.DeletePartnerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePartner")
	}

	var r0 *redshift.DeletePartnerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeletePartnerInput, ...func(*redshift.Options)) (*redshift.DeletePartnerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeletePartnerInput, ...func(*redshift.Options)) *redshift.DeletePartnerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeletePartnerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeletePartnerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRedshiftIdcApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRedshiftIdcApplication(ctx context.Context, params *redshift.DeleteRedshiftIdcApplicationInput, optFns ...func(*redshift.Options)) (*redshift.DeleteRedshiftIdcApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRedshiftIdcApplication")
	}

	var r0 *redshift.DeleteRedshiftIdcApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteRedshiftIdcApplicationInput, ...func(*redshift.Options)) (*redshift.DeleteRedshiftIdcApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteRedshiftIdcApplicationInput, ...func(*redshift.Options)) *redshift.DeleteRedshiftIdcApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteRedshiftIdcApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteRedshiftIdcApplicationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteResourcePolicy(ctx context.Context, params *redshift.DeleteResourcePolicyInput, optFns ...func(*redshift.Options)) (*redshift.DeleteResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteResourcePolicy")
	}

	var r0 *redshift.DeleteResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteResourcePolicyInput, ...func(*redshift.Options)) (*redshift.DeleteResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteResourcePolicyInput, ...func(*redshift.Options)) *redshift.DeleteResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteResourcePolicyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteScheduledAction(ctx context.Context, params *redshift.DeleteScheduledActionInput, optFns ...func(*redshift.Options)) (*redshift.DeleteScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteScheduledAction")
	}

	var r0 *redshift.DeleteScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteScheduledActionInput, ...func(*redshift.Options)) (*redshift.DeleteScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteScheduledActionInput, ...func(*redshift.Options)) *redshift.DeleteScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteScheduledActionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshotCopyGrant provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshotCopyGrant(ctx context.Context, params *redshift.DeleteSnapshotCopyGrantInput, optFns ...func(*redshift.Options)) (*redshift.DeleteSnapshotCopyGrantOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshotCopyGrant")
	}

	var r0 *redshift.DeleteSnapshotCopyGrantOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteSnapshotCopyGrantInput, ...func(*redshift.Options)) (*redshift.DeleteSnapshotCopyGrantOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteSnapshotCopyGrantInput, ...func(*redshift.Options)) *redshift.DeleteSnapshotCopyGrantOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteSnapshotCopyGrantOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteSnapshotCopyGrantInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshotSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSnapshotSchedule(ctx context.Context, params *redshift.DeleteSnapshotScheduleInput, optFns ...func(*redshift.Options)) (*redshift.DeleteSnapshotScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshotSchedule")
	}

	var r0 *redshift.DeleteSnapshotScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteSnapshotScheduleInput, ...func(*redshift.Options)) (*redshift.DeleteSnapshotScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteSnapshotScheduleInput, ...func(*redshift.Options)) *redshift.DeleteSnapshotScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteSnapshotScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteSnapshotScheduleInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTags(ctx context.Context, params *redshift.DeleteTagsInput, optFns ...func(*redshift.Options)) (*redshift.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTags")
	}

	var r0 *redshift.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteTagsInput, ...func(*redshift.Options)) (*redshift.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteTagsInput, ...func(*redshift.Options)) *redshift.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteTagsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUsageLimit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUsageLimit(ctx context.Context, params *redshift.DeleteUsageLimitInput, optFns ...func(*redshift.Options)) (*redshift.DeleteUsageLimitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUsageLimit")
	}

	var r0 *redshift.DeleteUsageLimitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteUsageLimitInput, ...func(*redshift.Options)) (*redshift.DeleteUsageLimitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DeleteUsageLimitInput, ...func(*redshift.Options)) *redshift.DeleteUsageLimitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DeleteUsageLimitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DeleteUsageLimitInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAccountAttributes(ctx context.Context, params *redshift.DescribeAccountAttributesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeAccountAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccountAttributes")
	}

	var r0 *redshift.DescribeAccountAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeAccountAttributesInput, ...func(*redshift.Options)) (*redshift.DescribeAccountAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeAccountAttributesInput, ...func(*redshift.Options)) *redshift.DescribeAccountAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeAccountAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeAccountAttributesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAuthenticationProfiles provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAuthenticationProfiles(ctx context.Context, params *redshift.DescribeAuthenticationProfilesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeAuthenticationProfilesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAuthenticationProfiles")
	}

	var r0 *redshift.DescribeAuthenticationProfilesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeAuthenticationProfilesInput, ...func(*redshift.Options)) (*redshift.DescribeAuthenticationProfilesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeAuthenticationProfilesInput, ...func(*redshift.Options)) *redshift.DescribeAuthenticationProfilesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeAuthenticationProfilesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeAuthenticationProfilesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterDbRevisions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterDbRevisions(ctx context.Context, params *redshift.DescribeClusterDbRevisionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterDbRevisionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterDbRevisions")
	}

	var r0 *redshift.DescribeClusterDbRevisionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterDbRevisionsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterDbRevisionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterDbRevisionsInput, ...func(*redshift.Options)) *redshift.DescribeClusterDbRevisionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterDbRevisionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterDbRevisionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterParameterGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterParameterGroups(ctx context.Context, params *redshift.DescribeClusterParameterGroupsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterParameterGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterParameterGroups")
	}

	var r0 *redshift.DescribeClusterParameterGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterParameterGroupsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterParameterGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterParameterGroupsInput, ...func(*redshift.Options)) *redshift.DescribeClusterParameterGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterParameterGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterParameterGroupsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterParameters(ctx context.Context, params *redshift.DescribeClusterParametersInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterParameters")
	}

	var r0 *redshift.DescribeClusterParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterParametersInput, ...func(*redshift.Options)) (*redshift.DescribeClusterParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterParametersInput, ...func(*redshift.Options)) *redshift.DescribeClusterParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterParametersInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterSecurityGroups(ctx context.Context, params *redshift.DescribeClusterSecurityGroupsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterSecurityGroups")
	}

	var r0 *redshift.DescribeClusterSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSecurityGroupsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSecurityGroupsInput, ...func(*redshift.Options)) *redshift.DescribeClusterSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterSecurityGroupsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterSnapshots(ctx context.Context, params *redshift.DescribeClusterSnapshotsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterSnapshots")
	}

	var r0 *redshift.DescribeClusterSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSnapshotsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSnapshotsInput, ...func(*redshift.Options)) *redshift.DescribeClusterSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterSnapshotsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterSubnetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterSubnetGroups(ctx context.Context, params *redshift.DescribeClusterSubnetGroupsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterSubnetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterSubnetGroups")
	}

	var r0 *redshift.DescribeClusterSubnetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSubnetGroupsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterSubnetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterSubnetGroupsInput, ...func(*redshift.Options)) *redshift.DescribeClusterSubnetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterSubnetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterSubnetGroupsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterTracks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterTracks(ctx context.Context, params *redshift.DescribeClusterTracksInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterTracksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterTracks")
	}

	var r0 *redshift.DescribeClusterTracksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterTracksInput, ...func(*redshift.Options)) (*redshift.DescribeClusterTracksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterTracksInput, ...func(*redshift.Options)) *redshift.DescribeClusterTracksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterTracksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterTracksInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusterVersions(ctx context.Context, params *redshift.DescribeClusterVersionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClusterVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusterVersions")
	}

	var r0 *redshift.DescribeClusterVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterVersionsInput, ...func(*redshift.Options)) (*redshift.DescribeClusterVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClusterVersionsInput, ...func(*redshift.Options)) *redshift.DescribeClusterVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClusterVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClusterVersionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeClusters(ctx context.Context, params *redshift.DescribeClustersInput, optFns ...func(*redshift.Options)) (*redshift.DescribeClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusters")
	}

	var r0 *redshift.DescribeClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClustersInput, ...func(*redshift.Options)) (*redshift.DescribeClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeClustersInput, ...func(*redshift.Options)) *redshift.DescribeClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeClustersInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeCustomDomainAssociations(ctx context.Context, params *redshift.DescribeCustomDomainAssociationsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeCustomDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomDomainAssociations")
	}

	var r0 *redshift.DescribeCustomDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeCustomDomainAssociationsInput, ...func(*redshift.Options)) (*redshift.DescribeCustomDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeCustomDomainAssociationsInput, ...func(*redshift.Options)) *redshift.DescribeCustomDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeCustomDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeCustomDomainAssociationsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataShares provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataShares(ctx context.Context, params *redshift.DescribeDataSharesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeDataSharesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataShares")
	}

	var r0 *redshift.DescribeDataSharesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesInput, ...func(*redshift.Options)) (*redshift.DescribeDataSharesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesInput, ...func(*redshift.Options)) *redshift.DescribeDataSharesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeDataSharesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeDataSharesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataSharesForConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataSharesForConsumer(ctx context.Context, params *redshift.DescribeDataSharesForConsumerInput, optFns ...func(*redshift.Options)) (*redshift.DescribeDataSharesForConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataSharesForConsumer")
	}

	var r0 *redshift.DescribeDataSharesForConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesForConsumerInput, ...func(*redshift.Options)) (*redshift.DescribeDataSharesForConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesForConsumerInput, ...func(*redshift.Options)) *redshift.DescribeDataSharesForConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeDataSharesForConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeDataSharesForConsumerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataSharesForProducer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataSharesForProducer(ctx context.Context, params *redshift.DescribeDataSharesForProducerInput, optFns ...func(*redshift.Options)) (*redshift.DescribeDataSharesForProducerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataSharesForProducer")
	}

	var r0 *redshift.DescribeDataSharesForProducerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesForProducerInput, ...func(*redshift.Options)) (*redshift.DescribeDataSharesForProducerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDataSharesForProducerInput, ...func(*redshift.Options)) *redshift.DescribeDataSharesForProducerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeDataSharesForProducerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeDataSharesForProducerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDefaultClusterParameters provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDefaultClusterParameters(ctx context.Context, params *redshift.DescribeDefaultClusterParametersInput, optFns ...func(*redshift.Options)) (*redshift.DescribeDefaultClusterParametersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDefaultClusterParameters")
	}

	var r0 *redshift.DescribeDefaultClusterParametersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDefaultClusterParametersInput, ...func(*redshift.Options)) (*redshift.DescribeDefaultClusterParametersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeDefaultClusterParametersInput, ...func(*redshift.Options)) *redshift.DescribeDefaultClusterParametersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeDefaultClusterParametersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeDefaultClusterParametersInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEndpointAccess(ctx context.Context, params *redshift.DescribeEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.DescribeEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEndpointAccess")
	}

	var r0 *redshift.DescribeEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEndpointAccessInput, ...func(*redshift.Options)) (*redshift.DescribeEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEndpointAccessInput, ...func(*redshift.Options)) *redshift.DescribeEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEndpointAuthorization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEndpointAuthorization(ctx context.Context, params *redshift.DescribeEndpointAuthorizationInput, optFns ...func(*redshift.Options)) (*redshift.DescribeEndpointAuthorizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEndpointAuthorization")
	}

	var r0 *redshift.DescribeEndpointAuthorizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEndpointAuthorizationInput, ...func(*redshift.Options)) (*redshift.DescribeEndpointAuthorizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEndpointAuthorizationInput, ...func(*redshift.Options)) *redshift.DescribeEndpointAuthorizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeEndpointAuthorizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeEndpointAuthorizationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEventCategories provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEventCategories(ctx context.Context, params *redshift.DescribeEventCategoriesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeEventCategoriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEventCategories")
	}

	var r0 *redshift.DescribeEventCategoriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventCategoriesInput, ...func(*redshift.Options)) (*redshift.DescribeEventCategoriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventCategoriesInput, ...func(*redshift.Options)) *redshift.DescribeEventCategoriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeEventCategoriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeEventCategoriesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEventSubscriptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEventSubscriptions(ctx context.Context, params *redshift.DescribeEventSubscriptionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeEventSubscriptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEventSubscriptions")
	}

	var r0 *redshift.DescribeEventSubscriptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventSubscriptionsInput, ...func(*redshift.Options)) (*redshift.DescribeEventSubscriptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventSubscriptionsInput, ...func(*redshift.Options)) *redshift.DescribeEventSubscriptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeEventSubscriptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeEventSubscriptionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEvents provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeEvents(ctx context.Context, params *redshift.DescribeEventsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeEventsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEvents")
	}

	var r0 *redshift.DescribeEventsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventsInput, ...func(*redshift.Options)) (*redshift.DescribeEventsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeEventsInput, ...func(*redshift.Options)) *redshift.DescribeEventsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeEventsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeEventsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHsmClientCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeHsmClientCertificates(ctx context.Context, params *redshift.DescribeHsmClientCertificatesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeHsmClientCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHsmClientCertificates")
	}

	var r0 *redshift.DescribeHsmClientCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeHsmClientCertificatesInput, ...func(*redshift.Options)) (*redshift.DescribeHsmClientCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeHsmClientCertificatesInput, ...func(*redshift.Options)) *redshift.DescribeHsmClientCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeHsmClientCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeHsmClientCertificatesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHsmConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeHsmConfigurations(ctx context.Context, params *redshift.DescribeHsmConfigurationsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeHsmConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHsmConfigurations")
	}

	var r0 *redshift.DescribeHsmConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeHsmConfigurationsInput, ...func(*redshift.Options)) (*redshift.DescribeHsmConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeHsmConfigurationsInput, ...func(*redshift.Options)) *redshift.DescribeHsmConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeHsmConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeHsmConfigurationsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInboundIntegrations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeInboundIntegrations(ctx context.Context, params *redshift.DescribeInboundIntegrationsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeInboundIntegrationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInboundIntegrations")
	}

	var r0 *redshift.DescribeInboundIntegrationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeInboundIntegrationsInput, ...func(*redshift.Options)) (*redshift.DescribeInboundIntegrationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeInboundIntegrationsInput, ...func(*redshift.Options)) *redshift.DescribeInboundIntegrationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeInboundIntegrationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeInboundIntegrationsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoggingStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeLoggingStatus(ctx context.Context, params *redshift.DescribeLoggingStatusInput, optFns ...func(*redshift.Options)) (*redshift.DescribeLoggingStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoggingStatus")
	}

	var r0 *redshift.DescribeLoggingStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeLoggingStatusInput, ...func(*redshift.Options)) (*redshift.DescribeLoggingStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeLoggingStatusInput, ...func(*redshift.Options)) *redshift.DescribeLoggingStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeLoggingStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeLoggingStatusInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNodeConfigurationOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeNodeConfigurationOptions(ctx context.Context, params *redshift.DescribeNodeConfigurationOptionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeNodeConfigurationOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNodeConfigurationOptions")
	}

	var r0 *redshift.DescribeNodeConfigurationOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeNodeConfigurationOptionsInput, ...func(*redshift.Options)) (*redshift.DescribeNodeConfigurationOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeNodeConfigurationOptionsInput, ...func(*redshift.Options)) *redshift.DescribeNodeConfigurationOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeNodeConfigurationOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeNodeConfigurationOptionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOrderableClusterOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeOrderableClusterOptions(ctx context.Context, params *redshift.DescribeOrderableClusterOptionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeOrderableClusterOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOrderableClusterOptions")
	}

	var r0 *redshift.DescribeOrderableClusterOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeOrderableClusterOptionsInput, ...func(*redshift.Options)) (*redshift.DescribeOrderableClusterOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeOrderableClusterOptionsInput, ...func(*redshift.Options)) *redshift.DescribeOrderableClusterOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeOrderableClusterOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeOrderableClusterOptionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePartners provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePartners(ctx context.Context, params *redshift.DescribePartnersInput, optFns ...func(*redshift.Options)) (*redshift.DescribePartnersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePartners")
	}

	var r0 *redshift.DescribePartnersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribePartnersInput, ...func(*redshift.Options)) (*redshift.DescribePartnersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribePartnersInput, ...func(*redshift.Options)) *redshift.DescribePartnersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribePartnersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribePartnersInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRedshiftIdcApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRedshiftIdcApplications(ctx context.Context, params *redshift.DescribeRedshiftIdcApplicationsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeRedshiftIdcApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRedshiftIdcApplications")
	}

	var r0 *redshift.DescribeRedshiftIdcApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeRedshiftIdcApplicationsInput, ...func(*redshift.Options)) (*redshift.DescribeRedshiftIdcApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeRedshiftIdcApplicationsInput, ...func(*redshift.Options)) *redshift.DescribeRedshiftIdcApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeRedshiftIdcApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeRedshiftIdcApplicationsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedNodeExchangeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedNodeExchangeStatus(ctx context.Context, params *redshift.DescribeReservedNodeExchangeStatusInput, optFns ...func(*redshift.Options)) (*redshift.DescribeReservedNodeExchangeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedNodeExchangeStatus")
	}

	var r0 *redshift.DescribeReservedNodeExchangeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodeExchangeStatusInput, ...func(*redshift.Options)) (*redshift.DescribeReservedNodeExchangeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodeExchangeStatusInput, ...func(*redshift.Options)) *redshift.DescribeReservedNodeExchangeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeReservedNodeExchangeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeReservedNodeExchangeStatusInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedNodeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedNodeOfferings(ctx context.Context, params *redshift.DescribeReservedNodeOfferingsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeReservedNodeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedNodeOfferings")
	}

	var r0 *redshift.DescribeReservedNodeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodeOfferingsInput, ...func(*redshift.Options)) (*redshift.DescribeReservedNodeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodeOfferingsInput, ...func(*redshift.Options)) *redshift.DescribeReservedNodeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeReservedNodeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeReservedNodeOfferingsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeReservedNodes(ctx context.Context, params *redshift.DescribeReservedNodesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeReservedNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedNodes")
	}

	var r0 *redshift.DescribeReservedNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodesInput, ...func(*redshift.Options)) (*redshift.DescribeReservedNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeReservedNodesInput, ...func(*redshift.Options)) *redshift.DescribeReservedNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeReservedNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeReservedNodesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResize provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeResize(ctx context.Context, params *redshift.DescribeResizeInput, optFns ...func(*redshift.Options)) (*redshift.DescribeResizeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResize")
	}

	var r0 *redshift.DescribeResizeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeResizeInput, ...func(*redshift.Options)) (*redshift.DescribeResizeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeResizeInput, ...func(*redshift.Options)) *redshift.DescribeResizeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeResizeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeResizeInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledActions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeScheduledActions(ctx context.Context, params *redshift.DescribeScheduledActionsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeScheduledActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScheduledActions")
	}

	var r0 *redshift.DescribeScheduledActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeScheduledActionsInput, ...func(*redshift.Options)) (*redshift.DescribeScheduledActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeScheduledActionsInput, ...func(*redshift.Options)) *redshift.DescribeScheduledActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeScheduledActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeScheduledActionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotCopyGrants provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshotCopyGrants(ctx context.Context, params *redshift.DescribeSnapshotCopyGrantsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeSnapshotCopyGrantsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotCopyGrants")
	}

	var r0 *redshift.DescribeSnapshotCopyGrantsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeSnapshotCopyGrantsInput, ...func(*redshift.Options)) (*redshift.DescribeSnapshotCopyGrantsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeSnapshotCopyGrantsInput, ...func(*redshift.Options)) *redshift.DescribeSnapshotCopyGrantsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeSnapshotCopyGrantsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeSnapshotCopyGrantsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotSchedules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSnapshotSchedules(ctx context.Context, params *redshift.DescribeSnapshotSchedulesInput, optFns ...func(*redshift.Options)) (*redshift.DescribeSnapshotSchedulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotSchedules")
	}

	var r0 *redshift.DescribeSnapshotSchedulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeSnapshotSchedulesInput, ...func(*redshift.Options)) (*redshift.DescribeSnapshotSchedulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeSnapshotSchedulesInput, ...func(*redshift.Options)) *redshift.DescribeSnapshotSchedulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeSnapshotSchedulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeSnapshotSchedulesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStorage provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeStorage(ctx context.Context, params *redshift.DescribeStorageInput, optFns ...func(*redshift.Options)) (*redshift.DescribeStorageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStorage")
	}

	var r0 *redshift.DescribeStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeStorageInput, ...func(*redshift.Options)) (*redshift.DescribeStorageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeStorageInput, ...func(*redshift.Options)) *redshift.DescribeStorageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeStorageInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTableRestoreStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTableRestoreStatus(ctx context.Context, params *redshift.DescribeTableRestoreStatusInput, optFns ...func(*redshift.Options)) (*redshift.DescribeTableRestoreStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTableRestoreStatus")
	}

	var r0 *redshift.DescribeTableRestoreStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeTableRestoreStatusInput, ...func(*redshift.Options)) (*redshift.DescribeTableRestoreStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeTableRestoreStatusInput, ...func(*redshift.Options)) *redshift.DescribeTableRestoreStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeTableRestoreStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeTableRestoreStatusInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeTags(ctx context.Context, params *redshift.DescribeTagsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTags")
	}

	var r0 *redshift.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeTagsInput, ...func(*redshift.Options)) (*redshift.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeTagsInput, ...func(*redshift.Options)) *redshift.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeTagsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUsageLimits provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUsageLimits(ctx context.Context, params *redshift.DescribeUsageLimitsInput, optFns ...func(*redshift.Options)) (*redshift.DescribeUsageLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUsageLimits")
	}

	var r0 *redshift.DescribeUsageLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeUsageLimitsInput, ...func(*redshift.Options)) (*redshift.DescribeUsageLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DescribeUsageLimitsInput, ...func(*redshift.Options)) *redshift.DescribeUsageLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DescribeUsageLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DescribeUsageLimitsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableLogging provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableLogging(ctx context.Context, params *redshift.DisableLoggingInput, optFns ...func(*redshift.Options)) (*redshift.DisableLoggingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableLogging")
	}

	var r0 *redshift.DisableLoggingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisableLoggingInput, ...func(*redshift.Options)) (*redshift.DisableLoggingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisableLoggingInput, ...func(*redshift.Options)) *redshift.DisableLoggingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DisableLoggingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DisableLoggingInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableSnapshotCopy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisableSnapshotCopy(ctx context.Context, params *redshift.DisableSnapshotCopyInput, optFns ...func(*redshift.Options)) (*redshift.DisableSnapshotCopyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableSnapshotCopy")
	}

	var r0 *redshift.DisableSnapshotCopyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisableSnapshotCopyInput, ...func(*redshift.Options)) (*redshift.DisableSnapshotCopyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisableSnapshotCopyInput, ...func(*redshift.Options)) *redshift.DisableSnapshotCopyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DisableSnapshotCopyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DisableSnapshotCopyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateDataShareConsumer provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateDataShareConsumer(ctx context.Context, params *redshift.DisassociateDataShareConsumerInput, optFns ...func(*redshift.Options)) (*redshift.DisassociateDataShareConsumerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateDataShareConsumer")
	}

	var r0 *redshift.DisassociateDataShareConsumerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisassociateDataShareConsumerInput, ...func(*redshift.Options)) (*redshift.DisassociateDataShareConsumerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.DisassociateDataShareConsumerInput, ...func(*redshift.Options)) *redshift.DisassociateDataShareConsumerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.DisassociateDataShareConsumerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.DisassociateDataShareConsumerInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableLogging provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableLogging(ctx context.Context, params *redshift.EnableLoggingInput, optFns ...func(*redshift.Options)) (*redshift.EnableLoggingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableLogging")
	}

	var r0 *redshift.EnableLoggingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.EnableLoggingInput, ...func(*redshift.Options)) (*redshift.EnableLoggingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.EnableLoggingInput, ...func(*redshift.Options)) *redshift.EnableLoggingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.EnableLoggingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.EnableLoggingInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableSnapshotCopy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) EnableSnapshotCopy(ctx context.Context, params *redshift.EnableSnapshotCopyInput, optFns ...func(*redshift.Options)) (*redshift.EnableSnapshotCopyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableSnapshotCopy")
	}

	var r0 *redshift.EnableSnapshotCopyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.EnableSnapshotCopyInput, ...func(*redshift.Options)) (*redshift.EnableSnapshotCopyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.EnableSnapshotCopyInput, ...func(*redshift.Options)) *redshift.EnableSnapshotCopyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.EnableSnapshotCopyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.EnableSnapshotCopyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FailoverPrimaryCompute provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) FailoverPrimaryCompute(ctx context.Context, params *redshift.FailoverPrimaryComputeInput, optFns ...func(*redshift.Options)) (*redshift.FailoverPrimaryComputeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FailoverPrimaryCompute")
	}

	var r0 *redshift.FailoverPrimaryComputeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.FailoverPrimaryComputeInput, ...func(*redshift.Options)) (*redshift.FailoverPrimaryComputeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.FailoverPrimaryComputeInput, ...func(*redshift.Options)) *redshift.FailoverPrimaryComputeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.FailoverPrimaryComputeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.FailoverPrimaryComputeInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClusterCredentials(ctx context.Context, params *redshift.GetClusterCredentialsInput, optFns ...func(*redshift.Options)) (*redshift.GetClusterCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterCredentials")
	}

	var r0 *redshift.GetClusterCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetClusterCredentialsInput, ...func(*redshift.Options)) (*redshift.GetClusterCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetClusterCredentialsInput, ...func(*redshift.Options)) *redshift.GetClusterCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.GetClusterCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.GetClusterCredentialsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCredentialsWithIAM provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetClusterCredentialsWithIAM(ctx context.Context, params *redshift.GetClusterCredentialsWithIAMInput, optFns ...func(*redshift.Options)) (*redshift.GetClusterCredentialsWithIAMOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterCredentialsWithIAM")
	}

	var r0 *redshift.GetClusterCredentialsWithIAMOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetClusterCredentialsWithIAMInput, ...func(*redshift.Options)) (*redshift.GetClusterCredentialsWithIAMOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetClusterCredentialsWithIAMInput, ...func(*redshift.Options)) *redshift.GetClusterCredentialsWithIAMOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.GetClusterCredentialsWithIAMOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.GetClusterCredentialsWithIAMInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReservedNodeExchangeConfigurationOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReservedNodeExchangeConfigurationOptions(ctx context.Context, params *redshift.GetReservedNodeExchangeConfigurationOptionsInput, optFns ...func(*redshift.Options)) (*redshift.GetReservedNodeExchangeConfigurationOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReservedNodeExchangeConfigurationOptions")
	}

	var r0 *redshift.GetReservedNodeExchangeConfigurationOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetReservedNodeExchangeConfigurationOptionsInput, ...func(*redshift.Options)) (*redshift.GetReservedNodeExchangeConfigurationOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetReservedNodeExchangeConfigurationOptionsInput, ...func(*redshift.Options)) *redshift.GetReservedNodeExchangeConfigurationOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.GetReservedNodeExchangeConfigurationOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.GetReservedNodeExchangeConfigurationOptionsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReservedNodeExchangeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetReservedNodeExchangeOfferings(ctx context.Context, params *redshift.GetReservedNodeExchangeOfferingsInput, optFns ...func(*redshift.Options)) (*redshift.GetReservedNodeExchangeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReservedNodeExchangeOfferings")
	}

	var r0 *redshift.GetReservedNodeExchangeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetReservedNodeExchangeOfferingsInput, ...func(*redshift.Options)) (*redshift.GetReservedNodeExchangeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetReservedNodeExchangeOfferingsInput, ...func(*redshift.Options)) *redshift.GetReservedNodeExchangeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.GetReservedNodeExchangeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.GetReservedNodeExchangeOfferingsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetResourcePolicy(ctx context.Context, params *redshift.GetResourcePolicyInput, optFns ...func(*redshift.Options)) (*redshift.GetResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetResourcePolicy")
	}

	var r0 *redshift.GetResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetResourcePolicyInput, ...func(*redshift.Options)) (*redshift.GetResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.GetResourcePolicyInput, ...func(*redshift.Options)) *redshift.GetResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.GetResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.GetResourcePolicyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRecommendations(ctx context.Context, params *redshift.ListRecommendationsInput, optFns ...func(*redshift.Options)) (*redshift.ListRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRecommendations")
	}

	var r0 *redshift.ListRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ListRecommendationsInput, ...func(*redshift.Options)) (*redshift.ListRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ListRecommendationsInput, ...func(*redshift.Options)) *redshift.ListRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ListRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ListRecommendationsInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAquaConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyAquaConfiguration(ctx context.Context, params *redshift.ModifyAquaConfigurationInput, optFns ...func(*redshift.Options)) (*redshift.ModifyAquaConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAquaConfiguration")
	}

	var r0 *redshift.ModifyAquaConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyAquaConfigurationInput, ...func(*redshift.Options)) (*redshift.ModifyAquaConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyAquaConfigurationInput, ...func(*redshift.Options)) *redshift.ModifyAquaConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyAquaConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyAquaConfigurationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAuthenticationProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyAuthenticationProfile(ctx context.Context, params *redshift.ModifyAuthenticationProfileInput, optFns ...func(*redshift.Options)) (*redshift.ModifyAuthenticationProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAuthenticationProfile")
	}

	var r0 *redshift.ModifyAuthenticationProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyAuthenticationProfileInput, ...func(*redshift.Options)) (*redshift.ModifyAuthenticationProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyAuthenticationProfileInput, ...func(*redshift.Options)) *redshift.ModifyAuthenticationProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyAuthenticationProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyAuthenticationProfileInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCluster(ctx context.Context, params *redshift.ModifyClusterInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCluster")
	}

	var r0 *redshift.ModifyClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterInput, ...func(*redshift.Options)) (*redshift.ModifyClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterInput, ...func(*redshift.Options)) *redshift.ModifyClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterDbRevision provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterDbRevision(ctx context.Context, params *redshift.ModifyClusterDbRevisionInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterDbRevisionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterDbRevision")
	}

	var r0 *redshift.ModifyClusterDbRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterDbRevisionInput, ...func(*redshift.Options)) (*redshift.ModifyClusterDbRevisionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterDbRevisionInput, ...func(*redshift.Options)) *redshift.ModifyClusterDbRevisionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterDbRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterDbRevisionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterIamRoles provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterIamRoles(ctx context.Context, params *redshift.ModifyClusterIamRolesInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterIamRolesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterIamRoles")
	}

	var r0 *redshift.ModifyClusterIamRolesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterIamRolesInput, ...func(*redshift.Options)) (*redshift.ModifyClusterIamRolesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterIamRolesInput, ...func(*redshift.Options)) *redshift.ModifyClusterIamRolesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterIamRolesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterIamRolesInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterMaintenance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterMaintenance(ctx context.Context, params *redshift.ModifyClusterMaintenanceInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterMaintenanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterMaintenance")
	}

	var r0 *redshift.ModifyClusterMaintenanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterMaintenanceInput, ...func(*redshift.Options)) (*redshift.ModifyClusterMaintenanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterMaintenanceInput, ...func(*redshift.Options)) *redshift.ModifyClusterMaintenanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterMaintenanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterMaintenanceInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterParameterGroup(ctx context.Context, params *redshift.ModifyClusterParameterGroupInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterParameterGroup")
	}

	var r0 *redshift.ModifyClusterParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterParameterGroupInput, ...func(*redshift.Options)) (*redshift.ModifyClusterParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterParameterGroupInput, ...func(*redshift.Options)) *redshift.ModifyClusterParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterParameterGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterSnapshot(ctx context.Context, params *redshift.ModifyClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterSnapshot")
	}

	var r0 *redshift.ModifyClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.ModifyClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSnapshotInput, ...func(*redshift.Options)) *redshift.ModifyClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterSnapshotSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterSnapshotSchedule(ctx context.Context, params *redshift.ModifyClusterSnapshotScheduleInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterSnapshotScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterSnapshotSchedule")
	}

	var r0 *redshift.ModifyClusterSnapshotScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSnapshotScheduleInput, ...func(*redshift.Options)) (*redshift.ModifyClusterSnapshotScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSnapshotScheduleInput, ...func(*redshift.Options)) *redshift.ModifyClusterSnapshotScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterSnapshotScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterSnapshotScheduleInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClusterSubnetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyClusterSubnetGroup(ctx context.Context, params *redshift.ModifyClusterSubnetGroupInput, optFns ...func(*redshift.Options)) (*redshift.ModifyClusterSubnetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClusterSubnetGroup")
	}

	var r0 *redshift.ModifyClusterSubnetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSubnetGroupInput, ...func(*redshift.Options)) (*redshift.ModifyClusterSubnetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyClusterSubnetGroupInput, ...func(*redshift.Options)) *redshift.ModifyClusterSubnetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyClusterSubnetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyClusterSubnetGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCustomDomainAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyCustomDomainAssociation(ctx context.Context, params *redshift.ModifyCustomDomainAssociationInput, optFns ...func(*redshift.Options)) (*redshift.ModifyCustomDomainAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCustomDomainAssociation")
	}

	var r0 *redshift.ModifyCustomDomainAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyCustomDomainAssociationInput, ...func(*redshift.Options)) (*redshift.ModifyCustomDomainAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyCustomDomainAssociationInput, ...func(*redshift.Options)) *redshift.ModifyCustomDomainAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyCustomDomainAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyCustomDomainAssociationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyEndpointAccess(ctx context.Context, params *redshift.ModifyEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.ModifyEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyEndpointAccess")
	}

	var r0 *redshift.ModifyEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyEndpointAccessInput, ...func(*redshift.Options)) (*redshift.ModifyEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyEndpointAccessInput, ...func(*redshift.Options)) *redshift.ModifyEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyEventSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyEventSubscription(ctx context.Context, params *redshift.ModifyEventSubscriptionInput, optFns ...func(*redshift.Options)) (*redshift.ModifyEventSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyEventSubscription")
	}

	var r0 *redshift.ModifyEventSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyEventSubscriptionInput, ...func(*redshift.Options)) (*redshift.ModifyEventSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyEventSubscriptionInput, ...func(*redshift.Options)) *redshift.ModifyEventSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyEventSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyEventSubscriptionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyRedshiftIdcApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyRedshiftIdcApplication(ctx context.Context, params *redshift.ModifyRedshiftIdcApplicationInput, optFns ...func(*redshift.Options)) (*redshift.ModifyRedshiftIdcApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyRedshiftIdcApplication")
	}

	var r0 *redshift.ModifyRedshiftIdcApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyRedshiftIdcApplicationInput, ...func(*redshift.Options)) (*redshift.ModifyRedshiftIdcApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyRedshiftIdcApplicationInput, ...func(*redshift.Options)) *redshift.ModifyRedshiftIdcApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyRedshiftIdcApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyRedshiftIdcApplicationInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyScheduledAction(ctx context.Context, params *redshift.ModifyScheduledActionInput, optFns ...func(*redshift.Options)) (*redshift.ModifyScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyScheduledAction")
	}

	var r0 *redshift.ModifyScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyScheduledActionInput, ...func(*redshift.Options)) (*redshift.ModifyScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyScheduledActionInput, ...func(*redshift.Options)) *redshift.ModifyScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyScheduledActionInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotCopyRetentionPeriod provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySnapshotCopyRetentionPeriod(ctx context.Context, params *redshift.ModifySnapshotCopyRetentionPeriodInput, optFns ...func(*redshift.Options)) (*redshift.ModifySnapshotCopyRetentionPeriodOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotCopyRetentionPeriod")
	}

	var r0 *redshift.ModifySnapshotCopyRetentionPeriodOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifySnapshotCopyRetentionPeriodInput, ...func(*redshift.Options)) (*redshift.ModifySnapshotCopyRetentionPeriodOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifySnapshotCopyRetentionPeriodInput, ...func(*redshift.Options)) *redshift.ModifySnapshotCopyRetentionPeriodOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifySnapshotCopyRetentionPeriodOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifySnapshotCopyRetentionPeriodInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifySnapshotSchedule(ctx context.Context, params *redshift.ModifySnapshotScheduleInput, optFns ...func(*redshift.Options)) (*redshift.ModifySnapshotScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotSchedule")
	}

	var r0 *redshift.ModifySnapshotScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifySnapshotScheduleInput, ...func(*redshift.Options)) (*redshift.ModifySnapshotScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifySnapshotScheduleInput, ...func(*redshift.Options)) *redshift.ModifySnapshotScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifySnapshotScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifySnapshotScheduleInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyUsageLimit provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ModifyUsageLimit(ctx context.Context, params *redshift.ModifyUsageLimitInput, optFns ...func(*redshift.Options)) (*redshift.ModifyUsageLimitOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyUsageLimit")
	}

	var r0 *redshift.ModifyUsageLimitOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyUsageLimitInput, ...func(*redshift.Options)) (*redshift.ModifyUsageLimitOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ModifyUsageLimitInput, ...func(*redshift.Options)) *redshift.ModifyUsageLimitOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ModifyUsageLimitOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ModifyUsageLimitInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() redshift.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 redshift.Options
	if rf, ok := ret.Get(0).(func() redshift.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(redshift.Options)
	}

	return r0
}

// PauseCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PauseCluster(ctx context.Context, params *redshift.PauseClusterInput, optFns ...func(*redshift.Options)) (*redshift.PauseClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PauseCluster")
	}

	var r0 *redshift.PauseClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PauseClusterInput, ...func(*redshift.Options)) (*redshift.PauseClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PauseClusterInput, ...func(*redshift.Options)) *redshift.PauseClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.PauseClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.PauseClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseReservedNodeOffering provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PurchaseReservedNodeOffering(ctx context.Context, params *redshift.PurchaseReservedNodeOfferingInput, optFns ...func(*redshift.Options)) (*redshift.PurchaseReservedNodeOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedNodeOffering")
	}

	var r0 *redshift.PurchaseReservedNodeOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PurchaseReservedNodeOfferingInput, ...func(*redshift.Options)) (*redshift.PurchaseReservedNodeOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PurchaseReservedNodeOfferingInput, ...func(*redshift.Options)) *redshift.PurchaseReservedNodeOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.PurchaseReservedNodeOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.PurchaseReservedNodeOfferingInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutResourcePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutResourcePolicy(ctx context.Context, params *redshift.PutResourcePolicyInput, optFns ...func(*redshift.Options)) (*redshift.PutResourcePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutResourcePolicy")
	}

	var r0 *redshift.PutResourcePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PutResourcePolicyInput, ...func(*redshift.Options)) (*redshift.PutResourcePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.PutResourcePolicyInput, ...func(*redshift.Options)) *redshift.PutResourcePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.PutResourcePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.PutResourcePolicyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootCluster(ctx context.Context, params *redshift.RebootClusterInput, optFns ...func(*redshift.Options)) (*redshift.RebootClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootCluster")
	}

	var r0 *redshift.RebootClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RebootClusterInput, ...func(*redshift.Options)) (*redshift.RebootClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RebootClusterInput, ...func(*redshift.Options)) *redshift.RebootClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RebootClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RebootClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectDataShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectDataShare(ctx context.Context, params *redshift.RejectDataShareInput, optFns ...func(*redshift.Options)) (*redshift.RejectDataShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectDataShare")
	}

	var r0 *redshift.RejectDataShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RejectDataShareInput, ...func(*redshift.Options)) (*redshift.RejectDataShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RejectDataShareInput, ...func(*redshift.Options)) *redshift.RejectDataShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RejectDataShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RejectDataShareInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetClusterParameterGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResetClusterParameterGroup(ctx context.Context, params *redshift.ResetClusterParameterGroupInput, optFns ...func(*redshift.Options)) (*redshift.ResetClusterParameterGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetClusterParameterGroup")
	}

	var r0 *redshift.ResetClusterParameterGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResetClusterParameterGroupInput, ...func(*redshift.Options)) (*redshift.ResetClusterParameterGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResetClusterParameterGroupInput, ...func(*redshift.Options)) *redshift.ResetClusterParameterGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ResetClusterParameterGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ResetClusterParameterGroupInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResizeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResizeCluster(ctx context.Context, params *redshift.ResizeClusterInput, optFns ...func(*redshift.Options)) (*redshift.ResizeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResizeCluster")
	}

	var r0 *redshift.ResizeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResizeClusterInput, ...func(*redshift.Options)) (*redshift.ResizeClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResizeClusterInput, ...func(*redshift.Options)) *redshift.ResizeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ResizeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ResizeClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreFromClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreFromClusterSnapshot(ctx context.Context, params *redshift.RestoreFromClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.RestoreFromClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreFromClusterSnapshot")
	}

	var r0 *redshift.RestoreFromClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RestoreFromClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.RestoreFromClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RestoreFromClusterSnapshotInput, ...func(*redshift.Options)) *redshift.RestoreFromClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RestoreFromClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RestoreFromClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreTableFromClusterSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestoreTableFromClusterSnapshot(ctx context.Context, params *redshift.RestoreTableFromClusterSnapshotInput, optFns ...func(*redshift.Options)) (*redshift.RestoreTableFromClusterSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreTableFromClusterSnapshot")
	}

	var r0 *redshift.RestoreTableFromClusterSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RestoreTableFromClusterSnapshotInput, ...func(*redshift.Options)) (*redshift.RestoreTableFromClusterSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RestoreTableFromClusterSnapshotInput, ...func(*redshift.Options)) *redshift.RestoreTableFromClusterSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RestoreTableFromClusterSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RestoreTableFromClusterSnapshotInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResumeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ResumeCluster(ctx context.Context, params *redshift.ResumeClusterInput, optFns ...func(*redshift.Options)) (*redshift.ResumeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeCluster")
	}

	var r0 *redshift.ResumeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResumeClusterInput, ...func(*redshift.Options)) (*redshift.ResumeClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.ResumeClusterInput, ...func(*redshift.Options)) *redshift.ResumeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.ResumeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.ResumeClusterInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeClusterSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeClusterSecurityGroupIngress(ctx context.Context, params *redshift.RevokeClusterSecurityGroupIngressInput, optFns ...func(*redshift.Options)) (*redshift.RevokeClusterSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeClusterSecurityGroupIngress")
	}

	var r0 *redshift.RevokeClusterSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) (*redshift.RevokeClusterSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) *redshift.RevokeClusterSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RevokeClusterSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RevokeClusterSecurityGroupIngressInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeEndpointAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeEndpointAccess(ctx context.Context, params *redshift.RevokeEndpointAccessInput, optFns ...func(*redshift.Options)) (*redshift.RevokeEndpointAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeEndpointAccess")
	}

	var r0 *redshift.RevokeEndpointAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeEndpointAccessInput, ...func(*redshift.Options)) (*redshift.RevokeEndpointAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeEndpointAccessInput, ...func(*redshift.Options)) *redshift.RevokeEndpointAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RevokeEndpointAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RevokeEndpointAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSnapshotAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RevokeSnapshotAccess(ctx context.Context, params *redshift.RevokeSnapshotAccessInput, optFns ...func(*redshift.Options)) (*redshift.RevokeSnapshotAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSnapshotAccess")
	}

	var r0 *redshift.RevokeSnapshotAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeSnapshotAccessInput, ...func(*redshift.Options)) (*redshift.RevokeSnapshotAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RevokeSnapshotAccessInput, ...func(*redshift.Options)) *redshift.RevokeSnapshotAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RevokeSnapshotAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RevokeSnapshotAccessInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RotateEncryptionKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RotateEncryptionKey(ctx context.Context, params *redshift.RotateEncryptionKeyInput, optFns ...func(*redshift.Options)) (*redshift.RotateEncryptionKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotateEncryptionKey")
	}

	var r0 *redshift.RotateEncryptionKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RotateEncryptionKeyInput, ...func(*redshift.Options)) (*redshift.RotateEncryptionKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.RotateEncryptionKeyInput, ...func(*redshift.Options)) *redshift.RotateEncryptionKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.RotateEncryptionKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.RotateEncryptionKeyInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePartnerStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdatePartnerStatus(ctx context.Context, params *redshift.UpdatePartnerStatusInput, optFns ...func(*redshift.Options)) (*redshift.UpdatePartnerStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePartnerStatus")
	}

	var r0 *redshift.UpdatePartnerStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.UpdatePartnerStatusInput, ...func(*redshift.Options)) (*redshift.UpdatePartnerStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *redshift.UpdatePartnerStatusInput, ...func(*redshift.Options)) *redshift.UpdatePartnerStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redshift.UpdatePartnerStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *redshift.UpdatePartnerStatusInput, ...func(*redshift.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
