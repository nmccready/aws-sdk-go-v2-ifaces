// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	computeoptimizer "github.com/aws/aws-sdk-go-v2/service/computeoptimizer"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// DeleteRecommendationPreferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRecommendationPreferences(ctx context.Context, params *computeoptimizer.DeleteRecommendationPreferencesInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.DeleteRecommendationPreferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRecommendationPreferences")
	}

	var r0 *computeoptimizer.DeleteRecommendationPreferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.DeleteRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.DeleteRecommendationPreferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.DeleteRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) *computeoptimizer.DeleteRecommendationPreferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.DeleteRecommendationPreferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.DeleteRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRecommendationExportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRecommendationExportJobs(ctx context.Context, params *computeoptimizer.DescribeRecommendationExportJobsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.DescribeRecommendationExportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRecommendationExportJobs")
	}

	var r0 *computeoptimizer.DescribeRecommendationExportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.DescribeRecommendationExportJobsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.DescribeRecommendationExportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.DescribeRecommendationExportJobsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.DescribeRecommendationExportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.DescribeRecommendationExportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.DescribeRecommendationExportJobsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportAutoScalingGroupRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportAutoScalingGroupRecommendations(ctx context.Context, params *computeoptimizer.ExportAutoScalingGroupRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportAutoScalingGroupRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportAutoScalingGroupRecommendations")
	}

	var r0 *computeoptimizer.ExportAutoScalingGroupRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportAutoScalingGroupRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportAutoScalingGroupRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportAutoScalingGroupRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportEBSVolumeRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportEBSVolumeRecommendations(ctx context.Context, params *computeoptimizer.ExportEBSVolumeRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportEBSVolumeRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportEBSVolumeRecommendations")
	}

	var r0 *computeoptimizer.ExportEBSVolumeRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportEBSVolumeRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportEBSVolumeRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportEBSVolumeRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportEC2InstanceRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportEC2InstanceRecommendations(ctx context.Context, params *computeoptimizer.ExportEC2InstanceRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportEC2InstanceRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportEC2InstanceRecommendations")
	}

	var r0 *computeoptimizer.ExportEC2InstanceRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportEC2InstanceRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportEC2InstanceRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportEC2InstanceRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportECSServiceRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportECSServiceRecommendations(ctx context.Context, params *computeoptimizer.ExportECSServiceRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportECSServiceRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportECSServiceRecommendations")
	}

	var r0 *computeoptimizer.ExportECSServiceRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportECSServiceRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportECSServiceRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportECSServiceRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportLambdaFunctionRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportLambdaFunctionRecommendations(ctx context.Context, params *computeoptimizer.ExportLambdaFunctionRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportLambdaFunctionRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportLambdaFunctionRecommendations")
	}

	var r0 *computeoptimizer.ExportLambdaFunctionRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportLambdaFunctionRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportLambdaFunctionRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportLambdaFunctionRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportLicenseRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportLicenseRecommendations(ctx context.Context, params *computeoptimizer.ExportLicenseRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportLicenseRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportLicenseRecommendations")
	}

	var r0 *computeoptimizer.ExportLicenseRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportLicenseRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportLicenseRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportLicenseRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportRDSDatabaseRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ExportRDSDatabaseRecommendations(ctx context.Context, params *computeoptimizer.ExportRDSDatabaseRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportRDSDatabaseRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportRDSDatabaseRecommendations")
	}

	var r0 *computeoptimizer.ExportRDSDatabaseRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.ExportRDSDatabaseRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.ExportRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.ExportRDSDatabaseRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.ExportRDSDatabaseRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.ExportRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAutoScalingGroupRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAutoScalingGroupRecommendations(ctx context.Context, params *computeoptimizer.GetAutoScalingGroupRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetAutoScalingGroupRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAutoScalingGroupRecommendations")
	}

	var r0 *computeoptimizer.GetAutoScalingGroupRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetAutoScalingGroupRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetAutoScalingGroupRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetAutoScalingGroupRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetAutoScalingGroupRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEBSVolumeRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEBSVolumeRecommendations(ctx context.Context, params *computeoptimizer.GetEBSVolumeRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEBSVolumeRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEBSVolumeRecommendations")
	}

	var r0 *computeoptimizer.GetEBSVolumeRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEBSVolumeRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEBSVolumeRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEBSVolumeRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEBSVolumeRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEC2InstanceRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEC2InstanceRecommendations(ctx context.Context, params *computeoptimizer.GetEC2InstanceRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEC2InstanceRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEC2InstanceRecommendations")
	}

	var r0 *computeoptimizer.GetEC2InstanceRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEC2InstanceRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEC2InstanceRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEC2InstanceRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEC2InstanceRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEC2RecommendationProjectedMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEC2RecommendationProjectedMetrics(ctx context.Context, params *computeoptimizer.GetEC2RecommendationProjectedMetricsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEC2RecommendationProjectedMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEC2RecommendationProjectedMetrics")
	}

	var r0 *computeoptimizer.GetEC2RecommendationProjectedMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEC2RecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEC2RecommendationProjectedMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEC2RecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEC2RecommendationProjectedMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEC2RecommendationProjectedMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEC2RecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetECSServiceRecommendationProjectedMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetECSServiceRecommendationProjectedMetrics(ctx context.Context, params *computeoptimizer.GetECSServiceRecommendationProjectedMetricsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetECSServiceRecommendationProjectedMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetECSServiceRecommendationProjectedMetrics")
	}

	var r0 *computeoptimizer.GetECSServiceRecommendationProjectedMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetECSServiceRecommendationProjectedMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetECSServiceRecommendationProjectedMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetECSServiceRecommendationProjectedMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetECSServiceRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetECSServiceRecommendations(ctx context.Context, params *computeoptimizer.GetECSServiceRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetECSServiceRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetECSServiceRecommendations")
	}

	var r0 *computeoptimizer.GetECSServiceRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetECSServiceRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetECSServiceRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetECSServiceRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetECSServiceRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEffectiveRecommendationPreferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEffectiveRecommendationPreferences(ctx context.Context, params *computeoptimizer.GetEffectiveRecommendationPreferencesInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEffectiveRecommendationPreferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEffectiveRecommendationPreferences")
	}

	var r0 *computeoptimizer.GetEffectiveRecommendationPreferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEffectiveRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEffectiveRecommendationPreferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEffectiveRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEffectiveRecommendationPreferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEffectiveRecommendationPreferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEffectiveRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnrollmentStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEnrollmentStatus(ctx context.Context, params *computeoptimizer.GetEnrollmentStatusInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEnrollmentStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEnrollmentStatus")
	}

	var r0 *computeoptimizer.GetEnrollmentStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEnrollmentStatusInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEnrollmentStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEnrollmentStatusInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEnrollmentStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEnrollmentStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEnrollmentStatusInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnrollmentStatusesForOrganization provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEnrollmentStatusesForOrganization(ctx context.Context, params *computeoptimizer.GetEnrollmentStatusesForOrganizationInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEnrollmentStatusesForOrganizationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEnrollmentStatusesForOrganization")
	}

	var r0 *computeoptimizer.GetEnrollmentStatusesForOrganizationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEnrollmentStatusesForOrganizationInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetEnrollmentStatusesForOrganizationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetEnrollmentStatusesForOrganizationInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetEnrollmentStatusesForOrganizationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetEnrollmentStatusesForOrganizationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetEnrollmentStatusesForOrganizationInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLambdaFunctionRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLambdaFunctionRecommendations(ctx context.Context, params *computeoptimizer.GetLambdaFunctionRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetLambdaFunctionRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLambdaFunctionRecommendations")
	}

	var r0 *computeoptimizer.GetLambdaFunctionRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetLambdaFunctionRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetLambdaFunctionRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetLambdaFunctionRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetLambdaFunctionRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLicenseRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLicenseRecommendations(ctx context.Context, params *computeoptimizer.GetLicenseRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetLicenseRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLicenseRecommendations")
	}

	var r0 *computeoptimizer.GetLicenseRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetLicenseRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetLicenseRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetLicenseRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetLicenseRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRDSDatabaseRecommendationProjectedMetrics provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRDSDatabaseRecommendationProjectedMetrics(ctx context.Context, params *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRDSDatabaseRecommendationProjectedMetrics")
	}

	var r0 *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationProjectedMetricsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRDSDatabaseRecommendations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRDSDatabaseRecommendations(ctx context.Context, params *computeoptimizer.GetRDSDatabaseRecommendationsInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRDSDatabaseRecommendationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRDSDatabaseRecommendations")
	}

	var r0 *computeoptimizer.GetRDSDatabaseRecommendationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRDSDatabaseRecommendationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetRDSDatabaseRecommendationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetRDSDatabaseRecommendationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetRDSDatabaseRecommendationsInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecommendationPreferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecommendationPreferences(ctx context.Context, params *computeoptimizer.GetRecommendationPreferencesInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRecommendationPreferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecommendationPreferences")
	}

	var r0 *computeoptimizer.GetRecommendationPreferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRecommendationPreferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetRecommendationPreferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetRecommendationPreferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecommendationSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRecommendationSummaries(ctx context.Context, params *computeoptimizer.GetRecommendationSummariesInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRecommendationSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecommendationSummaries")
	}

	var r0 *computeoptimizer.GetRecommendationSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRecommendationSummariesInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.GetRecommendationSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.GetRecommendationSummariesInput, ...func(*computeoptimizer.Options)) *computeoptimizer.GetRecommendationSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.GetRecommendationSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.GetRecommendationSummariesInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() computeoptimizer.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 computeoptimizer.Options
	if rf, ok := ret.Get(0).(func() computeoptimizer.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(computeoptimizer.Options)
	}

	return r0
}

// PutRecommendationPreferences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutRecommendationPreferences(ctx context.Context, params *computeoptimizer.PutRecommendationPreferencesInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.PutRecommendationPreferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRecommendationPreferences")
	}

	var r0 *computeoptimizer.PutRecommendationPreferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.PutRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.PutRecommendationPreferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.PutRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) *computeoptimizer.PutRecommendationPreferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.PutRecommendationPreferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.PutRecommendationPreferencesInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEnrollmentStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateEnrollmentStatus(ctx context.Context, params *computeoptimizer.UpdateEnrollmentStatusInput, optFns ...func(*computeoptimizer.Options)) (*computeoptimizer.UpdateEnrollmentStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEnrollmentStatus")
	}

	var r0 *computeoptimizer.UpdateEnrollmentStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.UpdateEnrollmentStatusInput, ...func(*computeoptimizer.Options)) (*computeoptimizer.UpdateEnrollmentStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *computeoptimizer.UpdateEnrollmentStatusInput, ...func(*computeoptimizer.Options)) *computeoptimizer.UpdateEnrollmentStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*computeoptimizer.UpdateEnrollmentStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *computeoptimizer.UpdateEnrollmentStatusInput, ...func(*computeoptimizer.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
