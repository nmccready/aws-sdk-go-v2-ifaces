// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mq "github.com/aws/aws-sdk-go-v2/service/mq"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateBroker(ctx context.Context, params *mq.CreateBrokerInput, optFns ...func(*mq.Options)) (*mq.CreateBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBroker")
	}

	var r0 *mq.CreateBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateBrokerInput, ...func(*mq.Options)) (*mq.CreateBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateBrokerInput, ...func(*mq.Options)) *mq.CreateBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.CreateBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.CreateBrokerInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateConfiguration(ctx context.Context, params *mq.CreateConfigurationInput, optFns ...func(*mq.Options)) (*mq.CreateConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfiguration")
	}

	var r0 *mq.CreateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateConfigurationInput, ...func(*mq.Options)) (*mq.CreateConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateConfigurationInput, ...func(*mq.Options)) *mq.CreateConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.CreateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.CreateConfigurationInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTags(ctx context.Context, params *mq.CreateTagsInput, optFns ...func(*mq.Options)) (*mq.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTags")
	}

	var r0 *mq.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateTagsInput, ...func(*mq.Options)) (*mq.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateTagsInput, ...func(*mq.Options)) *mq.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.CreateTagsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateUser(ctx context.Context, params *mq.CreateUserInput, optFns ...func(*mq.Options)) (*mq.CreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *mq.CreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateUserInput, ...func(*mq.Options)) (*mq.CreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.CreateUserInput, ...func(*mq.Options)) *mq.CreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.CreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.CreateUserInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteBroker(ctx context.Context, params *mq.DeleteBrokerInput, optFns ...func(*mq.Options)) (*mq.DeleteBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBroker")
	}

	var r0 *mq.DeleteBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteBrokerInput, ...func(*mq.Options)) (*mq.DeleteBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteBrokerInput, ...func(*mq.Options)) *mq.DeleteBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DeleteBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DeleteBrokerInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTags(ctx context.Context, params *mq.DeleteTagsInput, optFns ...func(*mq.Options)) (*mq.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTags")
	}

	var r0 *mq.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteTagsInput, ...func(*mq.Options)) (*mq.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteTagsInput, ...func(*mq.Options)) *mq.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DeleteTagsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteUser(ctx context.Context, params *mq.DeleteUserInput, optFns ...func(*mq.Options)) (*mq.DeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *mq.DeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteUserInput, ...func(*mq.Options)) (*mq.DeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DeleteUserInput, ...func(*mq.Options)) *mq.DeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DeleteUserInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBroker(ctx context.Context, params *mq.DescribeBrokerInput, optFns ...func(*mq.Options)) (*mq.DescribeBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBroker")
	}

	var r0 *mq.DescribeBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerInput, ...func(*mq.Options)) (*mq.DescribeBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerInput, ...func(*mq.Options)) *mq.DescribeBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeBrokerInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBrokerEngineTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBrokerEngineTypes(ctx context.Context, params *mq.DescribeBrokerEngineTypesInput, optFns ...func(*mq.Options)) (*mq.DescribeBrokerEngineTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBrokerEngineTypes")
	}

	var r0 *mq.DescribeBrokerEngineTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerEngineTypesInput, ...func(*mq.Options)) (*mq.DescribeBrokerEngineTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerEngineTypesInput, ...func(*mq.Options)) *mq.DescribeBrokerEngineTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeBrokerEngineTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeBrokerEngineTypesInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBrokerInstanceOptions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeBrokerInstanceOptions(ctx context.Context, params *mq.DescribeBrokerInstanceOptionsInput, optFns ...func(*mq.Options)) (*mq.DescribeBrokerInstanceOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBrokerInstanceOptions")
	}

	var r0 *mq.DescribeBrokerInstanceOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerInstanceOptionsInput, ...func(*mq.Options)) (*mq.DescribeBrokerInstanceOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeBrokerInstanceOptionsInput, ...func(*mq.Options)) *mq.DescribeBrokerInstanceOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeBrokerInstanceOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeBrokerInstanceOptionsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConfiguration(ctx context.Context, params *mq.DescribeConfigurationInput, optFns ...func(*mq.Options)) (*mq.DescribeConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConfiguration")
	}

	var r0 *mq.DescribeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeConfigurationInput, ...func(*mq.Options)) (*mq.DescribeConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeConfigurationInput, ...func(*mq.Options)) *mq.DescribeConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeConfigurationInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfigurationRevision provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeConfigurationRevision(ctx context.Context, params *mq.DescribeConfigurationRevisionInput, optFns ...func(*mq.Options)) (*mq.DescribeConfigurationRevisionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConfigurationRevision")
	}

	var r0 *mq.DescribeConfigurationRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeConfigurationRevisionInput, ...func(*mq.Options)) (*mq.DescribeConfigurationRevisionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeConfigurationRevisionInput, ...func(*mq.Options)) *mq.DescribeConfigurationRevisionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeConfigurationRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeConfigurationRevisionInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeUser(ctx context.Context, params *mq.DescribeUserInput, optFns ...func(*mq.Options)) (*mq.DescribeUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUser")
	}

	var r0 *mq.DescribeUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeUserInput, ...func(*mq.Options)) (*mq.DescribeUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.DescribeUserInput, ...func(*mq.Options)) *mq.DescribeUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.DescribeUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.DescribeUserInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBrokers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBrokers(ctx context.Context, params *mq.ListBrokersInput, optFns ...func(*mq.Options)) (*mq.ListBrokersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBrokers")
	}

	var r0 *mq.ListBrokersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListBrokersInput, ...func(*mq.Options)) (*mq.ListBrokersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListBrokersInput, ...func(*mq.Options)) *mq.ListBrokersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.ListBrokersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.ListBrokersInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurationRevisions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfigurationRevisions(ctx context.Context, params *mq.ListConfigurationRevisionsInput, optFns ...func(*mq.Options)) (*mq.ListConfigurationRevisionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfigurationRevisions")
	}

	var r0 *mq.ListConfigurationRevisionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListConfigurationRevisionsInput, ...func(*mq.Options)) (*mq.ListConfigurationRevisionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListConfigurationRevisionsInput, ...func(*mq.Options)) *mq.ListConfigurationRevisionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.ListConfigurationRevisionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.ListConfigurationRevisionsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListConfigurations(ctx context.Context, params *mq.ListConfigurationsInput, optFns ...func(*mq.Options)) (*mq.ListConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListConfigurations")
	}

	var r0 *mq.ListConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListConfigurationsInput, ...func(*mq.Options)) (*mq.ListConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListConfigurationsInput, ...func(*mq.Options)) *mq.ListConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.ListConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.ListConfigurationsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTags(ctx context.Context, params *mq.ListTagsInput, optFns ...func(*mq.Options)) (*mq.ListTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTags")
	}

	var r0 *mq.ListTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListTagsInput, ...func(*mq.Options)) (*mq.ListTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListTagsInput, ...func(*mq.Options)) *mq.ListTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.ListTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.ListTagsInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListUsers(ctx context.Context, params *mq.ListUsersInput, optFns ...func(*mq.Options)) (*mq.ListUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *mq.ListUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListUsersInput, ...func(*mq.Options)) (*mq.ListUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.ListUsersInput, ...func(*mq.Options)) *mq.ListUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.ListUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.ListUsersInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() mq.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 mq.Options
	if rf, ok := ret.Get(0).(func() mq.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(mq.Options)
	}

	return r0
}

// Promote provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Promote(ctx context.Context, params *mq.PromoteInput, optFns ...func(*mq.Options)) (*mq.PromoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Promote")
	}

	var r0 *mq.PromoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.PromoteInput, ...func(*mq.Options)) (*mq.PromoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.PromoteInput, ...func(*mq.Options)) *mq.PromoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.PromoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.PromoteInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RebootBroker(ctx context.Context, params *mq.RebootBrokerInput, optFns ...func(*mq.Options)) (*mq.RebootBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootBroker")
	}

	var r0 *mq.RebootBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.RebootBrokerInput, ...func(*mq.Options)) (*mq.RebootBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.RebootBrokerInput, ...func(*mq.Options)) *mq.RebootBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.RebootBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.RebootBrokerInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBroker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateBroker(ctx context.Context, params *mq.UpdateBrokerInput, optFns ...func(*mq.Options)) (*mq.UpdateBrokerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBroker")
	}

	var r0 *mq.UpdateBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateBrokerInput, ...func(*mq.Options)) (*mq.UpdateBrokerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateBrokerInput, ...func(*mq.Options)) *mq.UpdateBrokerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.UpdateBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.UpdateBrokerInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateConfiguration(ctx context.Context, params *mq.UpdateConfigurationInput, optFns ...func(*mq.Options)) (*mq.UpdateConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfiguration")
	}

	var r0 *mq.UpdateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateConfigurationInput, ...func(*mq.Options)) (*mq.UpdateConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateConfigurationInput, ...func(*mq.Options)) *mq.UpdateConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.UpdateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.UpdateConfigurationInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateUser(ctx context.Context, params *mq.UpdateUserInput, optFns ...func(*mq.Options)) (*mq.UpdateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *mq.UpdateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateUserInput, ...func(*mq.Options)) (*mq.UpdateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mq.UpdateUserInput, ...func(*mq.Options)) *mq.UpdateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mq.UpdateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mq.UpdateUserInput, ...func(*mq.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
