// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	auditmanager "github.com/aws/aws-sdk-go-v2/service/auditmanager"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateAssessmentReportEvidenceFolder provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateAssessmentReportEvidenceFolder(ctx context.Context, params *auditmanager.AssociateAssessmentReportEvidenceFolderInput, optFns ...func(*auditmanager.Options)) (*auditmanager.AssociateAssessmentReportEvidenceFolderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAssessmentReportEvidenceFolder")
	}

	var r0 *auditmanager.AssociateAssessmentReportEvidenceFolderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.AssociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) (*auditmanager.AssociateAssessmentReportEvidenceFolderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.AssociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) *auditmanager.AssociateAssessmentReportEvidenceFolderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.AssociateAssessmentReportEvidenceFolderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.AssociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchAssociateAssessmentReportEvidence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchAssociateAssessmentReportEvidence(ctx context.Context, params *auditmanager.BatchAssociateAssessmentReportEvidenceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.BatchAssociateAssessmentReportEvidenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchAssociateAssessmentReportEvidence")
	}

	var r0 *auditmanager.BatchAssociateAssessmentReportEvidenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchAssociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) (*auditmanager.BatchAssociateAssessmentReportEvidenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchAssociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) *auditmanager.BatchAssociateAssessmentReportEvidenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.BatchAssociateAssessmentReportEvidenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.BatchAssociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchCreateDelegationByAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchCreateDelegationByAssessment(ctx context.Context, params *auditmanager.BatchCreateDelegationByAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.BatchCreateDelegationByAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCreateDelegationByAssessment")
	}

	var r0 *auditmanager.BatchCreateDelegationByAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchCreateDelegationByAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.BatchCreateDelegationByAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchCreateDelegationByAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.BatchCreateDelegationByAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.BatchCreateDelegationByAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.BatchCreateDelegationByAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteDelegationByAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteDelegationByAssessment(ctx context.Context, params *auditmanager.BatchDeleteDelegationByAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.BatchDeleteDelegationByAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteDelegationByAssessment")
	}

	var r0 *auditmanager.BatchDeleteDelegationByAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchDeleteDelegationByAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.BatchDeleteDelegationByAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchDeleteDelegationByAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.BatchDeleteDelegationByAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.BatchDeleteDelegationByAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.BatchDeleteDelegationByAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDisassociateAssessmentReportEvidence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDisassociateAssessmentReportEvidence(ctx context.Context, params *auditmanager.BatchDisassociateAssessmentReportEvidenceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.BatchDisassociateAssessmentReportEvidenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDisassociateAssessmentReportEvidence")
	}

	var r0 *auditmanager.BatchDisassociateAssessmentReportEvidenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchDisassociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) (*auditmanager.BatchDisassociateAssessmentReportEvidenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchDisassociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) *auditmanager.BatchDisassociateAssessmentReportEvidenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.BatchDisassociateAssessmentReportEvidenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.BatchDisassociateAssessmentReportEvidenceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchImportEvidenceToAssessmentControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchImportEvidenceToAssessmentControl(ctx context.Context, params *auditmanager.BatchImportEvidenceToAssessmentControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.BatchImportEvidenceToAssessmentControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchImportEvidenceToAssessmentControl")
	}

	var r0 *auditmanager.BatchImportEvidenceToAssessmentControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchImportEvidenceToAssessmentControlInput, ...func(*auditmanager.Options)) (*auditmanager.BatchImportEvidenceToAssessmentControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.BatchImportEvidenceToAssessmentControlInput, ...func(*auditmanager.Options)) *auditmanager.BatchImportEvidenceToAssessmentControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.BatchImportEvidenceToAssessmentControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.BatchImportEvidenceToAssessmentControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssessment(ctx context.Context, params *auditmanager.CreateAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssessment")
	}

	var r0 *auditmanager.CreateAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.CreateAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.CreateAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.CreateAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssessmentFramework provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssessmentFramework(ctx context.Context, params *auditmanager.CreateAssessmentFrameworkInput, optFns ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentFrameworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssessmentFramework")
	}

	var r0 *auditmanager.CreateAssessmentFrameworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentFrameworkInput, ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentFrameworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentFrameworkInput, ...func(*auditmanager.Options)) *auditmanager.CreateAssessmentFrameworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.CreateAssessmentFrameworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.CreateAssessmentFrameworkInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssessmentReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAssessmentReport(ctx context.Context, params *auditmanager.CreateAssessmentReportInput, optFns ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssessmentReport")
	}

	var r0 *auditmanager.CreateAssessmentReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentReportInput, ...func(*auditmanager.Options)) (*auditmanager.CreateAssessmentReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateAssessmentReportInput, ...func(*auditmanager.Options)) *auditmanager.CreateAssessmentReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.CreateAssessmentReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.CreateAssessmentReportInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateControl(ctx context.Context, params *auditmanager.CreateControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.CreateControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateControl")
	}

	var r0 *auditmanager.CreateControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateControlInput, ...func(*auditmanager.Options)) (*auditmanager.CreateControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.CreateControlInput, ...func(*auditmanager.Options)) *auditmanager.CreateControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.CreateControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.CreateControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessment(ctx context.Context, params *auditmanager.DeleteAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessment")
	}

	var r0 *auditmanager.DeleteAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.DeleteAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeleteAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeleteAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentFramework provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentFramework(ctx context.Context, params *auditmanager.DeleteAssessmentFrameworkInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentFrameworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentFramework")
	}

	var r0 *auditmanager.DeleteAssessmentFrameworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkInput, ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentFrameworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkInput, ...func(*auditmanager.Options)) *auditmanager.DeleteAssessmentFrameworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeleteAssessmentFrameworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentFrameworkShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentFrameworkShare(ctx context.Context, params *auditmanager.DeleteAssessmentFrameworkShareInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentFrameworkShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentFrameworkShare")
	}

	var r0 *auditmanager.DeleteAssessmentFrameworkShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentFrameworkShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) *auditmanager.DeleteAssessmentFrameworkShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeleteAssessmentFrameworkShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeleteAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAssessmentReport provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAssessmentReport(ctx context.Context, params *auditmanager.DeleteAssessmentReportInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAssessmentReport")
	}

	var r0 *auditmanager.DeleteAssessmentReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentReportInput, ...func(*auditmanager.Options)) (*auditmanager.DeleteAssessmentReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteAssessmentReportInput, ...func(*auditmanager.Options)) *auditmanager.DeleteAssessmentReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeleteAssessmentReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeleteAssessmentReportInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteControl(ctx context.Context, params *auditmanager.DeleteControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeleteControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteControl")
	}

	var r0 *auditmanager.DeleteControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteControlInput, ...func(*auditmanager.Options)) (*auditmanager.DeleteControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeleteControlInput, ...func(*auditmanager.Options)) *auditmanager.DeleteControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeleteControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeleteControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterAccount(ctx context.Context, params *auditmanager.DeregisterAccountInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeregisterAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterAccount")
	}

	var r0 *auditmanager.DeregisterAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeregisterAccountInput, ...func(*auditmanager.Options)) (*auditmanager.DeregisterAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeregisterAccountInput, ...func(*auditmanager.Options)) *auditmanager.DeregisterAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeregisterAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeregisterAccountInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterOrganizationAdminAccount(ctx context.Context, params *auditmanager.DeregisterOrganizationAdminAccountInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DeregisterOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterOrganizationAdminAccount")
	}

	var r0 *auditmanager.DeregisterOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeregisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) (*auditmanager.DeregisterOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DeregisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) *auditmanager.DeregisterOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DeregisterOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DeregisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAssessmentReportEvidenceFolder provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateAssessmentReportEvidenceFolder(ctx context.Context, params *auditmanager.DisassociateAssessmentReportEvidenceFolderInput, optFns ...func(*auditmanager.Options)) (*auditmanager.DisassociateAssessmentReportEvidenceFolderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAssessmentReportEvidenceFolder")
	}

	var r0 *auditmanager.DisassociateAssessmentReportEvidenceFolderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DisassociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) (*auditmanager.DisassociateAssessmentReportEvidenceFolderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.DisassociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) *auditmanager.DisassociateAssessmentReportEvidenceFolderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.DisassociateAssessmentReportEvidenceFolderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.DisassociateAssessmentReportEvidenceFolderInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccountStatus(ctx context.Context, params *auditmanager.GetAccountStatusInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetAccountStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountStatus")
	}

	var r0 *auditmanager.GetAccountStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAccountStatusInput, ...func(*auditmanager.Options)) (*auditmanager.GetAccountStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAccountStatusInput, ...func(*auditmanager.Options)) *auditmanager.GetAccountStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetAccountStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetAccountStatusInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssessment(ctx context.Context, params *auditmanager.GetAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssessment")
	}

	var r0 *auditmanager.GetAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.GetAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssessmentFramework provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssessmentFramework(ctx context.Context, params *auditmanager.GetAssessmentFrameworkInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentFrameworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssessmentFramework")
	}

	var r0 *auditmanager.GetAssessmentFrameworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentFrameworkInput, ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentFrameworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentFrameworkInput, ...func(*auditmanager.Options)) *auditmanager.GetAssessmentFrameworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetAssessmentFrameworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetAssessmentFrameworkInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssessmentReportUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssessmentReportUrl(ctx context.Context, params *auditmanager.GetAssessmentReportUrlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentReportUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssessmentReportUrl")
	}

	var r0 *auditmanager.GetAssessmentReportUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentReportUrlInput, ...func(*auditmanager.Options)) (*auditmanager.GetAssessmentReportUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetAssessmentReportUrlInput, ...func(*auditmanager.Options)) *auditmanager.GetAssessmentReportUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetAssessmentReportUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetAssessmentReportUrlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChangeLogs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetChangeLogs(ctx context.Context, params *auditmanager.GetChangeLogsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetChangeLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChangeLogs")
	}

	var r0 *auditmanager.GetChangeLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetChangeLogsInput, ...func(*auditmanager.Options)) (*auditmanager.GetChangeLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetChangeLogsInput, ...func(*auditmanager.Options)) *auditmanager.GetChangeLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetChangeLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetChangeLogsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetControl(ctx context.Context, params *auditmanager.GetControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetControl")
	}

	var r0 *auditmanager.GetControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetControlInput, ...func(*auditmanager.Options)) (*auditmanager.GetControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetControlInput, ...func(*auditmanager.Options)) *auditmanager.GetControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDelegations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDelegations(ctx context.Context, params *auditmanager.GetDelegationsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetDelegationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDelegations")
	}

	var r0 *auditmanager.GetDelegationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetDelegationsInput, ...func(*auditmanager.Options)) (*auditmanager.GetDelegationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetDelegationsInput, ...func(*auditmanager.Options)) *auditmanager.GetDelegationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetDelegationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetDelegationsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidence provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidence(ctx context.Context, params *auditmanager.GetEvidenceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidence")
	}

	var r0 *auditmanager.GetEvidenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidenceByEvidenceFolder provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidenceByEvidenceFolder(ctx context.Context, params *auditmanager.GetEvidenceByEvidenceFolderInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceByEvidenceFolderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidenceByEvidenceFolder")
	}

	var r0 *auditmanager.GetEvidenceByEvidenceFolderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceByEvidenceFolderInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceByEvidenceFolderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceByEvidenceFolderInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceByEvidenceFolderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceByEvidenceFolderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceByEvidenceFolderInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidenceFileUploadUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidenceFileUploadUrl(ctx context.Context, params *auditmanager.GetEvidenceFileUploadUrlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFileUploadUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidenceFileUploadUrl")
	}

	var r0 *auditmanager.GetEvidenceFileUploadUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFileUploadUrlInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFileUploadUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFileUploadUrlInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceFileUploadUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceFileUploadUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceFileUploadUrlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidenceFolder provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidenceFolder(ctx context.Context, params *auditmanager.GetEvidenceFolderInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFolderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidenceFolder")
	}

	var r0 *auditmanager.GetEvidenceFolderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFolderInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFolderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFolderInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceFolderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceFolderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceFolderInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidenceFoldersByAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidenceFoldersByAssessment(ctx context.Context, params *auditmanager.GetEvidenceFoldersByAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFoldersByAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidenceFoldersByAssessment")
	}

	var r0 *auditmanager.GetEvidenceFoldersByAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFoldersByAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceFoldersByAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceFoldersByAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvidenceFoldersByAssessmentControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvidenceFoldersByAssessmentControl(ctx context.Context, params *auditmanager.GetEvidenceFoldersByAssessmentControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFoldersByAssessmentControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvidenceFoldersByAssessmentControl")
	}

	var r0 *auditmanager.GetEvidenceFoldersByAssessmentControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentControlInput, ...func(*auditmanager.Options)) (*auditmanager.GetEvidenceFoldersByAssessmentControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentControlInput, ...func(*auditmanager.Options)) *auditmanager.GetEvidenceFoldersByAssessmentControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetEvidenceFoldersByAssessmentControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetEvidenceFoldersByAssessmentControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsights provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsights(ctx context.Context, params *auditmanager.GetInsightsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetInsightsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsights")
	}

	var r0 *auditmanager.GetInsightsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetInsightsInput, ...func(*auditmanager.Options)) (*auditmanager.GetInsightsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetInsightsInput, ...func(*auditmanager.Options)) *auditmanager.GetInsightsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetInsightsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetInsightsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInsightsByAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetInsightsByAssessment(ctx context.Context, params *auditmanager.GetInsightsByAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetInsightsByAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInsightsByAssessment")
	}

	var r0 *auditmanager.GetInsightsByAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetInsightsByAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.GetInsightsByAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetInsightsByAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.GetInsightsByAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetInsightsByAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetInsightsByAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetOrganizationAdminAccount(ctx context.Context, params *auditmanager.GetOrganizationAdminAccountInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOrganizationAdminAccount")
	}

	var r0 *auditmanager.GetOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetOrganizationAdminAccountInput, ...func(*auditmanager.Options)) (*auditmanager.GetOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetOrganizationAdminAccountInput, ...func(*auditmanager.Options)) *auditmanager.GetOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetOrganizationAdminAccountInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServicesInScope provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetServicesInScope(ctx context.Context, params *auditmanager.GetServicesInScopeInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetServicesInScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesInScope")
	}

	var r0 *auditmanager.GetServicesInScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetServicesInScopeInput, ...func(*auditmanager.Options)) (*auditmanager.GetServicesInScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetServicesInScopeInput, ...func(*auditmanager.Options)) *auditmanager.GetServicesInScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetServicesInScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetServicesInScopeInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSettings(ctx context.Context, params *auditmanager.GetSettingsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.GetSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSettings")
	}

	var r0 *auditmanager.GetSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetSettingsInput, ...func(*auditmanager.Options)) (*auditmanager.GetSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.GetSettingsInput, ...func(*auditmanager.Options)) *auditmanager.GetSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.GetSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.GetSettingsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentControlInsightsByControlDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentControlInsightsByControlDomain(ctx context.Context, params *auditmanager.ListAssessmentControlInsightsByControlDomainInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentControlInsightsByControlDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentControlInsightsByControlDomain")
	}

	var r0 *auditmanager.ListAssessmentControlInsightsByControlDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentControlInsightsByControlDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) *auditmanager.ListAssessmentControlInsightsByControlDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListAssessmentControlInsightsByControlDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListAssessmentControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentFrameworkShareRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentFrameworkShareRequests(ctx context.Context, params *auditmanager.ListAssessmentFrameworkShareRequestsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentFrameworkShareRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentFrameworkShareRequests")
	}

	var r0 *auditmanager.ListAssessmentFrameworkShareRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentFrameworkShareRequestsInput, ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentFrameworkShareRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentFrameworkShareRequestsInput, ...func(*auditmanager.Options)) *auditmanager.ListAssessmentFrameworkShareRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListAssessmentFrameworkShareRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListAssessmentFrameworkShareRequestsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentFrameworks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentFrameworks(ctx context.Context, params *auditmanager.ListAssessmentFrameworksInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentFrameworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentFrameworks")
	}

	var r0 *auditmanager.ListAssessmentFrameworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentFrameworksInput, ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentFrameworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentFrameworksInput, ...func(*auditmanager.Options)) *auditmanager.ListAssessmentFrameworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListAssessmentFrameworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListAssessmentFrameworksInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessmentReports provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessmentReports(ctx context.Context, params *auditmanager.ListAssessmentReportsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentReportsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessmentReports")
	}

	var r0 *auditmanager.ListAssessmentReportsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentReportsInput, ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentReportsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentReportsInput, ...func(*auditmanager.Options)) *auditmanager.ListAssessmentReportsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListAssessmentReportsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListAssessmentReportsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssessments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssessments(ctx context.Context, params *auditmanager.ListAssessmentsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssessments")
	}

	var r0 *auditmanager.ListAssessmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentsInput, ...func(*auditmanager.Options)) (*auditmanager.ListAssessmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListAssessmentsInput, ...func(*auditmanager.Options)) *auditmanager.ListAssessmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListAssessmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListAssessmentsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListControlDomainInsights provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListControlDomainInsights(ctx context.Context, params *auditmanager.ListControlDomainInsightsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListControlDomainInsightsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListControlDomainInsights")
	}

	var r0 *auditmanager.ListControlDomainInsightsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlDomainInsightsInput, ...func(*auditmanager.Options)) (*auditmanager.ListControlDomainInsightsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlDomainInsightsInput, ...func(*auditmanager.Options)) *auditmanager.ListControlDomainInsightsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListControlDomainInsightsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListControlDomainInsightsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListControlDomainInsightsByAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListControlDomainInsightsByAssessment(ctx context.Context, params *auditmanager.ListControlDomainInsightsByAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListControlDomainInsightsByAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListControlDomainInsightsByAssessment")
	}

	var r0 *auditmanager.ListControlDomainInsightsByAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlDomainInsightsByAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.ListControlDomainInsightsByAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlDomainInsightsByAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.ListControlDomainInsightsByAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListControlDomainInsightsByAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListControlDomainInsightsByAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListControlInsightsByControlDomain provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListControlInsightsByControlDomain(ctx context.Context, params *auditmanager.ListControlInsightsByControlDomainInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListControlInsightsByControlDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListControlInsightsByControlDomain")
	}

	var r0 *auditmanager.ListControlInsightsByControlDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) (*auditmanager.ListControlInsightsByControlDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) *auditmanager.ListControlInsightsByControlDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListControlInsightsByControlDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListControlInsightsByControlDomainInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListControls provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListControls(ctx context.Context, params *auditmanager.ListControlsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListControlsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListControls")
	}

	var r0 *auditmanager.ListControlsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlsInput, ...func(*auditmanager.Options)) (*auditmanager.ListControlsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListControlsInput, ...func(*auditmanager.Options)) *auditmanager.ListControlsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListControlsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListControlsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeywordsForDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListKeywordsForDataSource(ctx context.Context, params *auditmanager.ListKeywordsForDataSourceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListKeywordsForDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKeywordsForDataSource")
	}

	var r0 *auditmanager.ListKeywordsForDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListKeywordsForDataSourceInput, ...func(*auditmanager.Options)) (*auditmanager.ListKeywordsForDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListKeywordsForDataSourceInput, ...func(*auditmanager.Options)) *auditmanager.ListKeywordsForDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListKeywordsForDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListKeywordsForDataSourceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNotifications(ctx context.Context, params *auditmanager.ListNotificationsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNotifications")
	}

	var r0 *auditmanager.ListNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListNotificationsInput, ...func(*auditmanager.Options)) (*auditmanager.ListNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListNotificationsInput, ...func(*auditmanager.Options)) *auditmanager.ListNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListNotificationsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *auditmanager.ListTagsForResourceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *auditmanager.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListTagsForResourceInput, ...func(*auditmanager.Options)) (*auditmanager.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ListTagsForResourceInput, ...func(*auditmanager.Options)) *auditmanager.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ListTagsForResourceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() auditmanager.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 auditmanager.Options
	if rf, ok := ret.Get(0).(func() auditmanager.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(auditmanager.Options)
	}

	return r0
}

// RegisterAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterAccount(ctx context.Context, params *auditmanager.RegisterAccountInput, optFns ...func(*auditmanager.Options)) (*auditmanager.RegisterAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterAccount")
	}

	var r0 *auditmanager.RegisterAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.RegisterAccountInput, ...func(*auditmanager.Options)) (*auditmanager.RegisterAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.RegisterAccountInput, ...func(*auditmanager.Options)) *auditmanager.RegisterAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.RegisterAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.RegisterAccountInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterOrganizationAdminAccount(ctx context.Context, params *auditmanager.RegisterOrganizationAdminAccountInput, optFns ...func(*auditmanager.Options)) (*auditmanager.RegisterOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterOrganizationAdminAccount")
	}

	var r0 *auditmanager.RegisterOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.RegisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) (*auditmanager.RegisterOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.RegisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) *auditmanager.RegisterOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.RegisterOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.RegisterOrganizationAdminAccountInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartAssessmentFrameworkShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartAssessmentFrameworkShare(ctx context.Context, params *auditmanager.StartAssessmentFrameworkShareInput, optFns ...func(*auditmanager.Options)) (*auditmanager.StartAssessmentFrameworkShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartAssessmentFrameworkShare")
	}

	var r0 *auditmanager.StartAssessmentFrameworkShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.StartAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) (*auditmanager.StartAssessmentFrameworkShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.StartAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) *auditmanager.StartAssessmentFrameworkShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.StartAssessmentFrameworkShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.StartAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *auditmanager.TagResourceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *auditmanager.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.TagResourceInput, ...func(*auditmanager.Options)) (*auditmanager.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.TagResourceInput, ...func(*auditmanager.Options)) *auditmanager.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.TagResourceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *auditmanager.UntagResourceInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *auditmanager.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UntagResourceInput, ...func(*auditmanager.Options)) (*auditmanager.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UntagResourceInput, ...func(*auditmanager.Options)) *auditmanager.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UntagResourceInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessment(ctx context.Context, params *auditmanager.UpdateAssessmentInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessment")
	}

	var r0 *auditmanager.UpdateAssessmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentControl(ctx context.Context, params *auditmanager.UpdateAssessmentControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentControl")
	}

	var r0 *auditmanager.UpdateAssessmentControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentControlInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentControlInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentControlSetStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentControlSetStatus(ctx context.Context, params *auditmanager.UpdateAssessmentControlSetStatusInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentControlSetStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentControlSetStatus")
	}

	var r0 *auditmanager.UpdateAssessmentControlSetStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentControlSetStatusInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentControlSetStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentControlSetStatusInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentControlSetStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentControlSetStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentControlSetStatusInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentFramework provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentFramework(ctx context.Context, params *auditmanager.UpdateAssessmentFrameworkInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentFrameworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentFramework")
	}

	var r0 *auditmanager.UpdateAssessmentFrameworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentFrameworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentFrameworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentFrameworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentFrameworkShare provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentFrameworkShare(ctx context.Context, params *auditmanager.UpdateAssessmentFrameworkShareInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentFrameworkShareOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentFrameworkShare")
	}

	var r0 *auditmanager.UpdateAssessmentFrameworkShareOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentFrameworkShareOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentFrameworkShareOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentFrameworkShareOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentFrameworkShareInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssessmentStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAssessmentStatus(ctx context.Context, params *auditmanager.UpdateAssessmentStatusInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAssessmentStatus")
	}

	var r0 *auditmanager.UpdateAssessmentStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentStatusInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateAssessmentStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateAssessmentStatusInput, ...func(*auditmanager.Options)) *auditmanager.UpdateAssessmentStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateAssessmentStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateAssessmentStatusInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateControl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateControl(ctx context.Context, params *auditmanager.UpdateControlInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateControlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateControl")
	}

	var r0 *auditmanager.UpdateControlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateControlInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateControlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateControlInput, ...func(*auditmanager.Options)) *auditmanager.UpdateControlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateControlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateControlInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSettings(ctx context.Context, params *auditmanager.UpdateSettingsInput, optFns ...func(*auditmanager.Options)) (*auditmanager.UpdateSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSettings")
	}

	var r0 *auditmanager.UpdateSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateSettingsInput, ...func(*auditmanager.Options)) (*auditmanager.UpdateSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.UpdateSettingsInput, ...func(*auditmanager.Options)) *auditmanager.UpdateSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.UpdateSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.UpdateSettingsInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateAssessmentReportIntegrity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ValidateAssessmentReportIntegrity(ctx context.Context, params *auditmanager.ValidateAssessmentReportIntegrityInput, optFns ...func(*auditmanager.Options)) (*auditmanager.ValidateAssessmentReportIntegrityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAssessmentReportIntegrity")
	}

	var r0 *auditmanager.ValidateAssessmentReportIntegrityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ValidateAssessmentReportIntegrityInput, ...func(*auditmanager.Options)) (*auditmanager.ValidateAssessmentReportIntegrityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *auditmanager.ValidateAssessmentReportIntegrityInput, ...func(*auditmanager.Options)) *auditmanager.ValidateAssessmentReportIntegrityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auditmanager.ValidateAssessmentReportIntegrityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *auditmanager.ValidateAssessmentReportIntegrityInput, ...func(*auditmanager.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
