// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	wafv2 "github.com/aws/aws-sdk-go-v2/service/wafv2"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateWebACL(ctx context.Context, params *wafv2.AssociateWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.AssociateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateWebACL")
	}

	var r0 *wafv2.AssociateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.AssociateWebACLInput, ...func(*wafv2.Options)) (*wafv2.AssociateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.AssociateWebACLInput, ...func(*wafv2.Options)) *wafv2.AssociateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.AssociateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.AssociateWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CheckCapacity(ctx context.Context, params *wafv2.CheckCapacityInput, optFns ...func(*wafv2.Options)) (*wafv2.CheckCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckCapacity")
	}

	var r0 *wafv2.CheckCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CheckCapacityInput, ...func(*wafv2.Options)) (*wafv2.CheckCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CheckCapacityInput, ...func(*wafv2.Options)) *wafv2.CheckCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CheckCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CheckCapacityInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAPIKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAPIKey(ctx context.Context, params *wafv2.CreateAPIKeyInput, optFns ...func(*wafv2.Options)) (*wafv2.CreateAPIKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAPIKey")
	}

	var r0 *wafv2.CreateAPIKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateAPIKeyInput, ...func(*wafv2.Options)) (*wafv2.CreateAPIKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateAPIKeyInput, ...func(*wafv2.Options)) *wafv2.CreateAPIKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CreateAPIKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CreateAPIKeyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIPSet(ctx context.Context, params *wafv2.CreateIPSetInput, optFns ...func(*wafv2.Options)) (*wafv2.CreateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIPSet")
	}

	var r0 *wafv2.CreateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateIPSetInput, ...func(*wafv2.Options)) (*wafv2.CreateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateIPSetInput, ...func(*wafv2.Options)) *wafv2.CreateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CreateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CreateIPSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRegexPatternSet(ctx context.Context, params *wafv2.CreateRegexPatternSetInput, optFns ...func(*wafv2.Options)) (*wafv2.CreateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRegexPatternSet")
	}

	var r0 *wafv2.CreateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateRegexPatternSetInput, ...func(*wafv2.Options)) (*wafv2.CreateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateRegexPatternSetInput, ...func(*wafv2.Options)) *wafv2.CreateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CreateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CreateRegexPatternSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRuleGroup(ctx context.Context, params *wafv2.CreateRuleGroupInput, optFns ...func(*wafv2.Options)) (*wafv2.CreateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRuleGroup")
	}

	var r0 *wafv2.CreateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateRuleGroupInput, ...func(*wafv2.Options)) (*wafv2.CreateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateRuleGroupInput, ...func(*wafv2.Options)) *wafv2.CreateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CreateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CreateRuleGroupInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWebACL(ctx context.Context, params *wafv2.CreateWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.CreateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWebACL")
	}

	var r0 *wafv2.CreateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateWebACLInput, ...func(*wafv2.Options)) (*wafv2.CreateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.CreateWebACLInput, ...func(*wafv2.Options)) *wafv2.CreateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.CreateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.CreateWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAPIKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAPIKey(ctx context.Context, params *wafv2.DeleteAPIKeyInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteAPIKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAPIKey")
	}

	var r0 *wafv2.DeleteAPIKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteAPIKeyInput, ...func(*wafv2.Options)) (*wafv2.DeleteAPIKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteAPIKeyInput, ...func(*wafv2.Options)) *wafv2.DeleteAPIKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteAPIKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteAPIKeyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFirewallManagerRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFirewallManagerRuleGroups(ctx context.Context, params *wafv2.DeleteFirewallManagerRuleGroupsInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteFirewallManagerRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallManagerRuleGroups")
	}

	var r0 *wafv2.DeleteFirewallManagerRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteFirewallManagerRuleGroupsInput, ...func(*wafv2.Options)) (*wafv2.DeleteFirewallManagerRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteFirewallManagerRuleGroupsInput, ...func(*wafv2.Options)) *wafv2.DeleteFirewallManagerRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteFirewallManagerRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteFirewallManagerRuleGroupsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIPSet(ctx context.Context, params *wafv2.DeleteIPSetInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIPSet")
	}

	var r0 *wafv2.DeleteIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteIPSetInput, ...func(*wafv2.Options)) (*wafv2.DeleteIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteIPSetInput, ...func(*wafv2.Options)) *wafv2.DeleteIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteIPSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteLoggingConfiguration(ctx context.Context, params *wafv2.DeleteLoggingConfigurationInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoggingConfiguration")
	}

	var r0 *wafv2.DeleteLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteLoggingConfigurationInput, ...func(*wafv2.Options)) (*wafv2.DeleteLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteLoggingConfigurationInput, ...func(*wafv2.Options)) *wafv2.DeleteLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteLoggingConfigurationInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePermissionPolicy(ctx context.Context, params *wafv2.DeletePermissionPolicyInput, optFns ...func(*wafv2.Options)) (*wafv2.DeletePermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionPolicy")
	}

	var r0 *wafv2.DeletePermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeletePermissionPolicyInput, ...func(*wafv2.Options)) (*wafv2.DeletePermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeletePermissionPolicyInput, ...func(*wafv2.Options)) *wafv2.DeletePermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeletePermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeletePermissionPolicyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRegexPatternSet(ctx context.Context, params *wafv2.DeleteRegexPatternSetInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegexPatternSet")
	}

	var r0 *wafv2.DeleteRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteRegexPatternSetInput, ...func(*wafv2.Options)) (*wafv2.DeleteRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteRegexPatternSetInput, ...func(*wafv2.Options)) *wafv2.DeleteRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteRegexPatternSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRuleGroup(ctx context.Context, params *wafv2.DeleteRuleGroupInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRuleGroup")
	}

	var r0 *wafv2.DeleteRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteRuleGroupInput, ...func(*wafv2.Options)) (*wafv2.DeleteRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteRuleGroupInput, ...func(*wafv2.Options)) *wafv2.DeleteRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteRuleGroupInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWebACL(ctx context.Context, params *wafv2.DeleteWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.DeleteWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWebACL")
	}

	var r0 *wafv2.DeleteWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteWebACLInput, ...func(*wafv2.Options)) (*wafv2.DeleteWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DeleteWebACLInput, ...func(*wafv2.Options)) *wafv2.DeleteWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DeleteWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DeleteWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAllManagedProducts provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAllManagedProducts(ctx context.Context, params *wafv2.DescribeAllManagedProductsInput, optFns ...func(*wafv2.Options)) (*wafv2.DescribeAllManagedProductsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAllManagedProducts")
	}

	var r0 *wafv2.DescribeAllManagedProductsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeAllManagedProductsInput, ...func(*wafv2.Options)) (*wafv2.DescribeAllManagedProductsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeAllManagedProductsInput, ...func(*wafv2.Options)) *wafv2.DescribeAllManagedProductsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DescribeAllManagedProductsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DescribeAllManagedProductsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedProductsByVendor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeManagedProductsByVendor(ctx context.Context, params *wafv2.DescribeManagedProductsByVendorInput, optFns ...func(*wafv2.Options)) (*wafv2.DescribeManagedProductsByVendorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeManagedProductsByVendor")
	}

	var r0 *wafv2.DescribeManagedProductsByVendorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeManagedProductsByVendorInput, ...func(*wafv2.Options)) (*wafv2.DescribeManagedProductsByVendorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeManagedProductsByVendorInput, ...func(*wafv2.Options)) *wafv2.DescribeManagedProductsByVendorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DescribeManagedProductsByVendorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DescribeManagedProductsByVendorInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeManagedRuleGroup(ctx context.Context, params *wafv2.DescribeManagedRuleGroupInput, optFns ...func(*wafv2.Options)) (*wafv2.DescribeManagedRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeManagedRuleGroup")
	}

	var r0 *wafv2.DescribeManagedRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeManagedRuleGroupInput, ...func(*wafv2.Options)) (*wafv2.DescribeManagedRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DescribeManagedRuleGroupInput, ...func(*wafv2.Options)) *wafv2.DescribeManagedRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DescribeManagedRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DescribeManagedRuleGroupInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateWebACL(ctx context.Context, params *wafv2.DisassociateWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.DisassociateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateWebACL")
	}

	var r0 *wafv2.DisassociateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DisassociateWebACLInput, ...func(*wafv2.Options)) (*wafv2.DisassociateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.DisassociateWebACLInput, ...func(*wafv2.Options)) *wafv2.DisassociateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.DisassociateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.DisassociateWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateMobileSdkReleaseUrl provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GenerateMobileSdkReleaseUrl(ctx context.Context, params *wafv2.GenerateMobileSdkReleaseUrlInput, optFns ...func(*wafv2.Options)) (*wafv2.GenerateMobileSdkReleaseUrlOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenerateMobileSdkReleaseUrl")
	}

	var r0 *wafv2.GenerateMobileSdkReleaseUrlOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GenerateMobileSdkReleaseUrlInput, ...func(*wafv2.Options)) (*wafv2.GenerateMobileSdkReleaseUrlOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GenerateMobileSdkReleaseUrlInput, ...func(*wafv2.Options)) *wafv2.GenerateMobileSdkReleaseUrlOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GenerateMobileSdkReleaseUrlOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GenerateMobileSdkReleaseUrlInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDecryptedAPIKey provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetDecryptedAPIKey(ctx context.Context, params *wafv2.GetDecryptedAPIKeyInput, optFns ...func(*wafv2.Options)) (*wafv2.GetDecryptedAPIKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDecryptedAPIKey")
	}

	var r0 *wafv2.GetDecryptedAPIKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetDecryptedAPIKeyInput, ...func(*wafv2.Options)) (*wafv2.GetDecryptedAPIKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetDecryptedAPIKeyInput, ...func(*wafv2.Options)) *wafv2.GetDecryptedAPIKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetDecryptedAPIKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetDecryptedAPIKeyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetIPSet(ctx context.Context, params *wafv2.GetIPSetInput, optFns ...func(*wafv2.Options)) (*wafv2.GetIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIPSet")
	}

	var r0 *wafv2.GetIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetIPSetInput, ...func(*wafv2.Options)) (*wafv2.GetIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetIPSetInput, ...func(*wafv2.Options)) *wafv2.GetIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetIPSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetLoggingConfiguration(ctx context.Context, params *wafv2.GetLoggingConfigurationInput, optFns ...func(*wafv2.Options)) (*wafv2.GetLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLoggingConfiguration")
	}

	var r0 *wafv2.GetLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetLoggingConfigurationInput, ...func(*wafv2.Options)) (*wafv2.GetLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetLoggingConfigurationInput, ...func(*wafv2.Options)) *wafv2.GetLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetLoggingConfigurationInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedRuleSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetManagedRuleSet(ctx context.Context, params *wafv2.GetManagedRuleSetInput, optFns ...func(*wafv2.Options)) (*wafv2.GetManagedRuleSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedRuleSet")
	}

	var r0 *wafv2.GetManagedRuleSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetManagedRuleSetInput, ...func(*wafv2.Options)) (*wafv2.GetManagedRuleSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetManagedRuleSetInput, ...func(*wafv2.Options)) *wafv2.GetManagedRuleSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetManagedRuleSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetManagedRuleSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMobileSdkRelease provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMobileSdkRelease(ctx context.Context, params *wafv2.GetMobileSdkReleaseInput, optFns ...func(*wafv2.Options)) (*wafv2.GetMobileSdkReleaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMobileSdkRelease")
	}

	var r0 *wafv2.GetMobileSdkReleaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetMobileSdkReleaseInput, ...func(*wafv2.Options)) (*wafv2.GetMobileSdkReleaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetMobileSdkReleaseInput, ...func(*wafv2.Options)) *wafv2.GetMobileSdkReleaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetMobileSdkReleaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetMobileSdkReleaseInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetPermissionPolicy(ctx context.Context, params *wafv2.GetPermissionPolicyInput, optFns ...func(*wafv2.Options)) (*wafv2.GetPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionPolicy")
	}

	var r0 *wafv2.GetPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetPermissionPolicyInput, ...func(*wafv2.Options)) (*wafv2.GetPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetPermissionPolicyInput, ...func(*wafv2.Options)) *wafv2.GetPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetPermissionPolicyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateBasedStatementManagedKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRateBasedStatementManagedKeys(ctx context.Context, params *wafv2.GetRateBasedStatementManagedKeysInput, optFns ...func(*wafv2.Options)) (*wafv2.GetRateBasedStatementManagedKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRateBasedStatementManagedKeys")
	}

	var r0 *wafv2.GetRateBasedStatementManagedKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRateBasedStatementManagedKeysInput, ...func(*wafv2.Options)) (*wafv2.GetRateBasedStatementManagedKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRateBasedStatementManagedKeysInput, ...func(*wafv2.Options)) *wafv2.GetRateBasedStatementManagedKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetRateBasedStatementManagedKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetRateBasedStatementManagedKeysInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRegexPatternSet(ctx context.Context, params *wafv2.GetRegexPatternSetInput, optFns ...func(*wafv2.Options)) (*wafv2.GetRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegexPatternSet")
	}

	var r0 *wafv2.GetRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRegexPatternSetInput, ...func(*wafv2.Options)) (*wafv2.GetRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRegexPatternSetInput, ...func(*wafv2.Options)) *wafv2.GetRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetRegexPatternSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetRuleGroup(ctx context.Context, params *wafv2.GetRuleGroupInput, optFns ...func(*wafv2.Options)) (*wafv2.GetRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRuleGroup")
	}

	var r0 *wafv2.GetRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRuleGroupInput, ...func(*wafv2.Options)) (*wafv2.GetRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetRuleGroupInput, ...func(*wafv2.Options)) *wafv2.GetRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetRuleGroupInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSampledRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSampledRequests(ctx context.Context, params *wafv2.GetSampledRequestsInput, optFns ...func(*wafv2.Options)) (*wafv2.GetSampledRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSampledRequests")
	}

	var r0 *wafv2.GetSampledRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetSampledRequestsInput, ...func(*wafv2.Options)) (*wafv2.GetSampledRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetSampledRequestsInput, ...func(*wafv2.Options)) *wafv2.GetSampledRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetSampledRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetSampledRequestsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWebACL(ctx context.Context, params *wafv2.GetWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.GetWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWebACL")
	}

	var r0 *wafv2.GetWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetWebACLInput, ...func(*wafv2.Options)) (*wafv2.GetWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetWebACLInput, ...func(*wafv2.Options)) *wafv2.GetWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebACLForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWebACLForResource(ctx context.Context, params *wafv2.GetWebACLForResourceInput, optFns ...func(*wafv2.Options)) (*wafv2.GetWebACLForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWebACLForResource")
	}

	var r0 *wafv2.GetWebACLForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetWebACLForResourceInput, ...func(*wafv2.Options)) (*wafv2.GetWebACLForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.GetWebACLForResourceInput, ...func(*wafv2.Options)) *wafv2.GetWebACLForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.GetWebACLForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.GetWebACLForResourceInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAPIKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAPIKeys(ctx context.Context, params *wafv2.ListAPIKeysInput, optFns ...func(*wafv2.Options)) (*wafv2.ListAPIKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAPIKeys")
	}

	var r0 *wafv2.ListAPIKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAPIKeysInput, ...func(*wafv2.Options)) (*wafv2.ListAPIKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAPIKeysInput, ...func(*wafv2.Options)) *wafv2.ListAPIKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListAPIKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListAPIKeysInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAvailableManagedRuleGroupVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAvailableManagedRuleGroupVersions(ctx context.Context, params *wafv2.ListAvailableManagedRuleGroupVersionsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListAvailableManagedRuleGroupVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAvailableManagedRuleGroupVersions")
	}

	var r0 *wafv2.ListAvailableManagedRuleGroupVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupVersionsInput, ...func(*wafv2.Options)) (*wafv2.ListAvailableManagedRuleGroupVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupVersionsInput, ...func(*wafv2.Options)) *wafv2.ListAvailableManagedRuleGroupVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListAvailableManagedRuleGroupVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupVersionsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAvailableManagedRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAvailableManagedRuleGroups(ctx context.Context, params *wafv2.ListAvailableManagedRuleGroupsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListAvailableManagedRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAvailableManagedRuleGroups")
	}

	var r0 *wafv2.ListAvailableManagedRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupsInput, ...func(*wafv2.Options)) (*wafv2.ListAvailableManagedRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupsInput, ...func(*wafv2.Options)) *wafv2.ListAvailableManagedRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListAvailableManagedRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListAvailableManagedRuleGroupsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIPSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIPSets(ctx context.Context, params *wafv2.ListIPSetsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListIPSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIPSets")
	}

	var r0 *wafv2.ListIPSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListIPSetsInput, ...func(*wafv2.Options)) (*wafv2.ListIPSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListIPSetsInput, ...func(*wafv2.Options)) *wafv2.ListIPSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListIPSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListIPSetsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLoggingConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListLoggingConfigurations(ctx context.Context, params *wafv2.ListLoggingConfigurationsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListLoggingConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLoggingConfigurations")
	}

	var r0 *wafv2.ListLoggingConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListLoggingConfigurationsInput, ...func(*wafv2.Options)) (*wafv2.ListLoggingConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListLoggingConfigurationsInput, ...func(*wafv2.Options)) *wafv2.ListLoggingConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListLoggingConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListLoggingConfigurationsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListManagedRuleSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListManagedRuleSets(ctx context.Context, params *wafv2.ListManagedRuleSetsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListManagedRuleSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListManagedRuleSets")
	}

	var r0 *wafv2.ListManagedRuleSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListManagedRuleSetsInput, ...func(*wafv2.Options)) (*wafv2.ListManagedRuleSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListManagedRuleSetsInput, ...func(*wafv2.Options)) *wafv2.ListManagedRuleSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListManagedRuleSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListManagedRuleSetsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMobileSdkReleases provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMobileSdkReleases(ctx context.Context, params *wafv2.ListMobileSdkReleasesInput, optFns ...func(*wafv2.Options)) (*wafv2.ListMobileSdkReleasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMobileSdkReleases")
	}

	var r0 *wafv2.ListMobileSdkReleasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListMobileSdkReleasesInput, ...func(*wafv2.Options)) (*wafv2.ListMobileSdkReleasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListMobileSdkReleasesInput, ...func(*wafv2.Options)) *wafv2.ListMobileSdkReleasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListMobileSdkReleasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListMobileSdkReleasesInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRegexPatternSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRegexPatternSets(ctx context.Context, params *wafv2.ListRegexPatternSetsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListRegexPatternSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegexPatternSets")
	}

	var r0 *wafv2.ListRegexPatternSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListRegexPatternSetsInput, ...func(*wafv2.Options)) (*wafv2.ListRegexPatternSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListRegexPatternSetsInput, ...func(*wafv2.Options)) *wafv2.ListRegexPatternSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListRegexPatternSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListRegexPatternSetsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResourcesForWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListResourcesForWebACL(ctx context.Context, params *wafv2.ListResourcesForWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.ListResourcesForWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListResourcesForWebACL")
	}

	var r0 *wafv2.ListResourcesForWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListResourcesForWebACLInput, ...func(*wafv2.Options)) (*wafv2.ListResourcesForWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListResourcesForWebACLInput, ...func(*wafv2.Options)) *wafv2.ListResourcesForWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListResourcesForWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListResourcesForWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRuleGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRuleGroups(ctx context.Context, params *wafv2.ListRuleGroupsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListRuleGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRuleGroups")
	}

	var r0 *wafv2.ListRuleGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListRuleGroupsInput, ...func(*wafv2.Options)) (*wafv2.ListRuleGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListRuleGroupsInput, ...func(*wafv2.Options)) *wafv2.ListRuleGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListRuleGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListRuleGroupsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *wafv2.ListTagsForResourceInput, optFns ...func(*wafv2.Options)) (*wafv2.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *wafv2.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListTagsForResourceInput, ...func(*wafv2.Options)) (*wafv2.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListTagsForResourceInput, ...func(*wafv2.Options)) *wafv2.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListTagsForResourceInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWebACLs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWebACLs(ctx context.Context, params *wafv2.ListWebACLsInput, optFns ...func(*wafv2.Options)) (*wafv2.ListWebACLsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWebACLs")
	}

	var r0 *wafv2.ListWebACLsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListWebACLsInput, ...func(*wafv2.Options)) (*wafv2.ListWebACLsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.ListWebACLsInput, ...func(*wafv2.Options)) *wafv2.ListWebACLsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.ListWebACLsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.ListWebACLsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() wafv2.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 wafv2.Options
	if rf, ok := ret.Get(0).(func() wafv2.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wafv2.Options)
	}

	return r0
}

// PutLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutLoggingConfiguration(ctx context.Context, params *wafv2.PutLoggingConfigurationInput, optFns ...func(*wafv2.Options)) (*wafv2.PutLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutLoggingConfiguration")
	}

	var r0 *wafv2.PutLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutLoggingConfigurationInput, ...func(*wafv2.Options)) (*wafv2.PutLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutLoggingConfigurationInput, ...func(*wafv2.Options)) *wafv2.PutLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.PutLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.PutLoggingConfigurationInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutManagedRuleSetVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutManagedRuleSetVersions(ctx context.Context, params *wafv2.PutManagedRuleSetVersionsInput, optFns ...func(*wafv2.Options)) (*wafv2.PutManagedRuleSetVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutManagedRuleSetVersions")
	}

	var r0 *wafv2.PutManagedRuleSetVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutManagedRuleSetVersionsInput, ...func(*wafv2.Options)) (*wafv2.PutManagedRuleSetVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutManagedRuleSetVersionsInput, ...func(*wafv2.Options)) *wafv2.PutManagedRuleSetVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.PutManagedRuleSetVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.PutManagedRuleSetVersionsInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutPermissionPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPermissionPolicy(ctx context.Context, params *wafv2.PutPermissionPolicyInput, optFns ...func(*wafv2.Options)) (*wafv2.PutPermissionPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPermissionPolicy")
	}

	var r0 *wafv2.PutPermissionPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutPermissionPolicyInput, ...func(*wafv2.Options)) (*wafv2.PutPermissionPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.PutPermissionPolicyInput, ...func(*wafv2.Options)) *wafv2.PutPermissionPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.PutPermissionPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.PutPermissionPolicyInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *wafv2.TagResourceInput, optFns ...func(*wafv2.Options)) (*wafv2.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *wafv2.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.TagResourceInput, ...func(*wafv2.Options)) (*wafv2.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.TagResourceInput, ...func(*wafv2.Options)) *wafv2.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.TagResourceInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *wafv2.UntagResourceInput, optFns ...func(*wafv2.Options)) (*wafv2.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *wafv2.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UntagResourceInput, ...func(*wafv2.Options)) (*wafv2.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UntagResourceInput, ...func(*wafv2.Options)) *wafv2.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UntagResourceInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIPSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIPSet(ctx context.Context, params *wafv2.UpdateIPSetInput, optFns ...func(*wafv2.Options)) (*wafv2.UpdateIPSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIPSet")
	}

	var r0 *wafv2.UpdateIPSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateIPSetInput, ...func(*wafv2.Options)) (*wafv2.UpdateIPSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateIPSetInput, ...func(*wafv2.Options)) *wafv2.UpdateIPSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UpdateIPSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UpdateIPSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateManagedRuleSetVersionExpiryDate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateManagedRuleSetVersionExpiryDate(ctx context.Context, params *wafv2.UpdateManagedRuleSetVersionExpiryDateInput, optFns ...func(*wafv2.Options)) (*wafv2.UpdateManagedRuleSetVersionExpiryDateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateManagedRuleSetVersionExpiryDate")
	}

	var r0 *wafv2.UpdateManagedRuleSetVersionExpiryDateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateManagedRuleSetVersionExpiryDateInput, ...func(*wafv2.Options)) (*wafv2.UpdateManagedRuleSetVersionExpiryDateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateManagedRuleSetVersionExpiryDateInput, ...func(*wafv2.Options)) *wafv2.UpdateManagedRuleSetVersionExpiryDateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UpdateManagedRuleSetVersionExpiryDateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UpdateManagedRuleSetVersionExpiryDateInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRegexPatternSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRegexPatternSet(ctx context.Context, params *wafv2.UpdateRegexPatternSetInput, optFns ...func(*wafv2.Options)) (*wafv2.UpdateRegexPatternSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegexPatternSet")
	}

	var r0 *wafv2.UpdateRegexPatternSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateRegexPatternSetInput, ...func(*wafv2.Options)) (*wafv2.UpdateRegexPatternSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateRegexPatternSetInput, ...func(*wafv2.Options)) *wafv2.UpdateRegexPatternSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UpdateRegexPatternSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UpdateRegexPatternSetInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleGroup(ctx context.Context, params *wafv2.UpdateRuleGroupInput, optFns ...func(*wafv2.Options)) (*wafv2.UpdateRuleGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleGroup")
	}

	var r0 *wafv2.UpdateRuleGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateRuleGroupInput, ...func(*wafv2.Options)) (*wafv2.UpdateRuleGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateRuleGroupInput, ...func(*wafv2.Options)) *wafv2.UpdateRuleGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UpdateRuleGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UpdateRuleGroupInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebACL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWebACL(ctx context.Context, params *wafv2.UpdateWebACLInput, optFns ...func(*wafv2.Options)) (*wafv2.UpdateWebACLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWebACL")
	}

	var r0 *wafv2.UpdateWebACLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateWebACLInput, ...func(*wafv2.Options)) (*wafv2.UpdateWebACLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *wafv2.UpdateWebACLInput, ...func(*wafv2.Options)) *wafv2.UpdateWebACLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wafv2.UpdateWebACLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *wafv2.UpdateWebACLInput, ...func(*wafv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
