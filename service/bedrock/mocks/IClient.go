// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	bedrock "github.com/aws/aws-sdk-go-v2/service/bedrock"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateEvaluationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateEvaluationJob(ctx context.Context, params *bedrock.CreateEvaluationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.CreateEvaluationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEvaluationJob")
	}

	var r0 *bedrock.CreateEvaluationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateEvaluationJobInput, ...func(*bedrock.Options)) (*bedrock.CreateEvaluationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateEvaluationJobInput, ...func(*bedrock.Options)) *bedrock.CreateEvaluationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.CreateEvaluationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.CreateEvaluationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGuardrail(ctx context.Context, params *bedrock.CreateGuardrailInput, optFns ...func(*bedrock.Options)) (*bedrock.CreateGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGuardrail")
	}

	var r0 *bedrock.CreateGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateGuardrailInput, ...func(*bedrock.Options)) (*bedrock.CreateGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateGuardrailInput, ...func(*bedrock.Options)) *bedrock.CreateGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.CreateGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.CreateGuardrailInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGuardrailVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateGuardrailVersion(ctx context.Context, params *bedrock.CreateGuardrailVersionInput, optFns ...func(*bedrock.Options)) (*bedrock.CreateGuardrailVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGuardrailVersion")
	}

	var r0 *bedrock.CreateGuardrailVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateGuardrailVersionInput, ...func(*bedrock.Options)) (*bedrock.CreateGuardrailVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateGuardrailVersionInput, ...func(*bedrock.Options)) *bedrock.CreateGuardrailVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.CreateGuardrailVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.CreateGuardrailVersionInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateModelCustomizationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateModelCustomizationJob(ctx context.Context, params *bedrock.CreateModelCustomizationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.CreateModelCustomizationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateModelCustomizationJob")
	}

	var r0 *bedrock.CreateModelCustomizationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateModelCustomizationJobInput, ...func(*bedrock.Options)) (*bedrock.CreateModelCustomizationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateModelCustomizationJobInput, ...func(*bedrock.Options)) *bedrock.CreateModelCustomizationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.CreateModelCustomizationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.CreateModelCustomizationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProvisionedModelThroughput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProvisionedModelThroughput(ctx context.Context, params *bedrock.CreateProvisionedModelThroughputInput, optFns ...func(*bedrock.Options)) (*bedrock.CreateProvisionedModelThroughputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProvisionedModelThroughput")
	}

	var r0 *bedrock.CreateProvisionedModelThroughputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateProvisionedModelThroughputInput, ...func(*bedrock.Options)) (*bedrock.CreateProvisionedModelThroughputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.CreateProvisionedModelThroughputInput, ...func(*bedrock.Options)) *bedrock.CreateProvisionedModelThroughputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.CreateProvisionedModelThroughputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.CreateProvisionedModelThroughputInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteCustomModel(ctx context.Context, params *bedrock.DeleteCustomModelInput, optFns ...func(*bedrock.Options)) (*bedrock.DeleteCustomModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomModel")
	}

	var r0 *bedrock.DeleteCustomModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteCustomModelInput, ...func(*bedrock.Options)) (*bedrock.DeleteCustomModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteCustomModelInput, ...func(*bedrock.Options)) *bedrock.DeleteCustomModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.DeleteCustomModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.DeleteCustomModelInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteGuardrail(ctx context.Context, params *bedrock.DeleteGuardrailInput, optFns ...func(*bedrock.Options)) (*bedrock.DeleteGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGuardrail")
	}

	var r0 *bedrock.DeleteGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteGuardrailInput, ...func(*bedrock.Options)) (*bedrock.DeleteGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteGuardrailInput, ...func(*bedrock.Options)) *bedrock.DeleteGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.DeleteGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.DeleteGuardrailInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteModelInvocationLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteModelInvocationLoggingConfiguration(ctx context.Context, params *bedrock.DeleteModelInvocationLoggingConfigurationInput, optFns ...func(*bedrock.Options)) (*bedrock.DeleteModelInvocationLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteModelInvocationLoggingConfiguration")
	}

	var r0 *bedrock.DeleteModelInvocationLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) (*bedrock.DeleteModelInvocationLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) *bedrock.DeleteModelInvocationLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.DeleteModelInvocationLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.DeleteModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProvisionedModelThroughput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProvisionedModelThroughput(ctx context.Context, params *bedrock.DeleteProvisionedModelThroughputInput, optFns ...func(*bedrock.Options)) (*bedrock.DeleteProvisionedModelThroughputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProvisionedModelThroughput")
	}

	var r0 *bedrock.DeleteProvisionedModelThroughputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteProvisionedModelThroughputInput, ...func(*bedrock.Options)) (*bedrock.DeleteProvisionedModelThroughputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.DeleteProvisionedModelThroughputInput, ...func(*bedrock.Options)) *bedrock.DeleteProvisionedModelThroughputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.DeleteProvisionedModelThroughputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.DeleteProvisionedModelThroughputInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCustomModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetCustomModel(ctx context.Context, params *bedrock.GetCustomModelInput, optFns ...func(*bedrock.Options)) (*bedrock.GetCustomModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomModel")
	}

	var r0 *bedrock.GetCustomModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetCustomModelInput, ...func(*bedrock.Options)) (*bedrock.GetCustomModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetCustomModelInput, ...func(*bedrock.Options)) *bedrock.GetCustomModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetCustomModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetCustomModelInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvaluationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetEvaluationJob(ctx context.Context, params *bedrock.GetEvaluationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.GetEvaluationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationJob")
	}

	var r0 *bedrock.GetEvaluationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetEvaluationJobInput, ...func(*bedrock.Options)) (*bedrock.GetEvaluationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetEvaluationJobInput, ...func(*bedrock.Options)) *bedrock.GetEvaluationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetEvaluationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetEvaluationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFoundationModel provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFoundationModel(ctx context.Context, params *bedrock.GetFoundationModelInput, optFns ...func(*bedrock.Options)) (*bedrock.GetFoundationModelOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFoundationModel")
	}

	var r0 *bedrock.GetFoundationModelOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetFoundationModelInput, ...func(*bedrock.Options)) (*bedrock.GetFoundationModelOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetFoundationModelInput, ...func(*bedrock.Options)) *bedrock.GetFoundationModelOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetFoundationModelOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetFoundationModelInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetGuardrail(ctx context.Context, params *bedrock.GetGuardrailInput, optFns ...func(*bedrock.Options)) (*bedrock.GetGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGuardrail")
	}

	var r0 *bedrock.GetGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetGuardrailInput, ...func(*bedrock.Options)) (*bedrock.GetGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetGuardrailInput, ...func(*bedrock.Options)) *bedrock.GetGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetGuardrailInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetModelCustomizationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetModelCustomizationJob(ctx context.Context, params *bedrock.GetModelCustomizationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.GetModelCustomizationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetModelCustomizationJob")
	}

	var r0 *bedrock.GetModelCustomizationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetModelCustomizationJobInput, ...func(*bedrock.Options)) (*bedrock.GetModelCustomizationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetModelCustomizationJobInput, ...func(*bedrock.Options)) *bedrock.GetModelCustomizationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetModelCustomizationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetModelCustomizationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetModelInvocationLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetModelInvocationLoggingConfiguration(ctx context.Context, params *bedrock.GetModelInvocationLoggingConfigurationInput, optFns ...func(*bedrock.Options)) (*bedrock.GetModelInvocationLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetModelInvocationLoggingConfiguration")
	}

	var r0 *bedrock.GetModelInvocationLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) (*bedrock.GetModelInvocationLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) *bedrock.GetModelInvocationLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetModelInvocationLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProvisionedModelThroughput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetProvisionedModelThroughput(ctx context.Context, params *bedrock.GetProvisionedModelThroughputInput, optFns ...func(*bedrock.Options)) (*bedrock.GetProvisionedModelThroughputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProvisionedModelThroughput")
	}

	var r0 *bedrock.GetProvisionedModelThroughputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetProvisionedModelThroughputInput, ...func(*bedrock.Options)) (*bedrock.GetProvisionedModelThroughputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.GetProvisionedModelThroughputInput, ...func(*bedrock.Options)) *bedrock.GetProvisionedModelThroughputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.GetProvisionedModelThroughputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.GetProvisionedModelThroughputInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCustomModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListCustomModels(ctx context.Context, params *bedrock.ListCustomModelsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListCustomModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCustomModels")
	}

	var r0 *bedrock.ListCustomModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListCustomModelsInput, ...func(*bedrock.Options)) (*bedrock.ListCustomModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListCustomModelsInput, ...func(*bedrock.Options)) *bedrock.ListCustomModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListCustomModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListCustomModelsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEvaluationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEvaluationJobs(ctx context.Context, params *bedrock.ListEvaluationJobsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListEvaluationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEvaluationJobs")
	}

	var r0 *bedrock.ListEvaluationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListEvaluationJobsInput, ...func(*bedrock.Options)) (*bedrock.ListEvaluationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListEvaluationJobsInput, ...func(*bedrock.Options)) *bedrock.ListEvaluationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListEvaluationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListEvaluationJobsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFoundationModels provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFoundationModels(ctx context.Context, params *bedrock.ListFoundationModelsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListFoundationModelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFoundationModels")
	}

	var r0 *bedrock.ListFoundationModelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListFoundationModelsInput, ...func(*bedrock.Options)) (*bedrock.ListFoundationModelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListFoundationModelsInput, ...func(*bedrock.Options)) *bedrock.ListFoundationModelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListFoundationModelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListFoundationModelsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGuardrails provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGuardrails(ctx context.Context, params *bedrock.ListGuardrailsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListGuardrailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGuardrails")
	}

	var r0 *bedrock.ListGuardrailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListGuardrailsInput, ...func(*bedrock.Options)) (*bedrock.ListGuardrailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListGuardrailsInput, ...func(*bedrock.Options)) *bedrock.ListGuardrailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListGuardrailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListGuardrailsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListModelCustomizationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListModelCustomizationJobs(ctx context.Context, params *bedrock.ListModelCustomizationJobsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListModelCustomizationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListModelCustomizationJobs")
	}

	var r0 *bedrock.ListModelCustomizationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListModelCustomizationJobsInput, ...func(*bedrock.Options)) (*bedrock.ListModelCustomizationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListModelCustomizationJobsInput, ...func(*bedrock.Options)) *bedrock.ListModelCustomizationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListModelCustomizationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListModelCustomizationJobsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProvisionedModelThroughputs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProvisionedModelThroughputs(ctx context.Context, params *bedrock.ListProvisionedModelThroughputsInput, optFns ...func(*bedrock.Options)) (*bedrock.ListProvisionedModelThroughputsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProvisionedModelThroughputs")
	}

	var r0 *bedrock.ListProvisionedModelThroughputsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListProvisionedModelThroughputsInput, ...func(*bedrock.Options)) (*bedrock.ListProvisionedModelThroughputsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListProvisionedModelThroughputsInput, ...func(*bedrock.Options)) *bedrock.ListProvisionedModelThroughputsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListProvisionedModelThroughputsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListProvisionedModelThroughputsInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *bedrock.ListTagsForResourceInput, optFns ...func(*bedrock.Options)) (*bedrock.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *bedrock.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListTagsForResourceInput, ...func(*bedrock.Options)) (*bedrock.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.ListTagsForResourceInput, ...func(*bedrock.Options)) *bedrock.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.ListTagsForResourceInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() bedrock.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 bedrock.Options
	if rf, ok := ret.Get(0).(func() bedrock.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bedrock.Options)
	}

	return r0
}

// PutModelInvocationLoggingConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutModelInvocationLoggingConfiguration(ctx context.Context, params *bedrock.PutModelInvocationLoggingConfigurationInput, optFns ...func(*bedrock.Options)) (*bedrock.PutModelInvocationLoggingConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutModelInvocationLoggingConfiguration")
	}

	var r0 *bedrock.PutModelInvocationLoggingConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.PutModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) (*bedrock.PutModelInvocationLoggingConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.PutModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) *bedrock.PutModelInvocationLoggingConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.PutModelInvocationLoggingConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.PutModelInvocationLoggingConfigurationInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopEvaluationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopEvaluationJob(ctx context.Context, params *bedrock.StopEvaluationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.StopEvaluationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopEvaluationJob")
	}

	var r0 *bedrock.StopEvaluationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.StopEvaluationJobInput, ...func(*bedrock.Options)) (*bedrock.StopEvaluationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.StopEvaluationJobInput, ...func(*bedrock.Options)) *bedrock.StopEvaluationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.StopEvaluationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.StopEvaluationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopModelCustomizationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopModelCustomizationJob(ctx context.Context, params *bedrock.StopModelCustomizationJobInput, optFns ...func(*bedrock.Options)) (*bedrock.StopModelCustomizationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopModelCustomizationJob")
	}

	var r0 *bedrock.StopModelCustomizationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.StopModelCustomizationJobInput, ...func(*bedrock.Options)) (*bedrock.StopModelCustomizationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.StopModelCustomizationJobInput, ...func(*bedrock.Options)) *bedrock.StopModelCustomizationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.StopModelCustomizationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.StopModelCustomizationJobInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *bedrock.TagResourceInput, optFns ...func(*bedrock.Options)) (*bedrock.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *bedrock.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.TagResourceInput, ...func(*bedrock.Options)) (*bedrock.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.TagResourceInput, ...func(*bedrock.Options)) *bedrock.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.TagResourceInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *bedrock.UntagResourceInput, optFns ...func(*bedrock.Options)) (*bedrock.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *bedrock.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UntagResourceInput, ...func(*bedrock.Options)) (*bedrock.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UntagResourceInput, ...func(*bedrock.Options)) *bedrock.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.UntagResourceInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGuardrail provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateGuardrail(ctx context.Context, params *bedrock.UpdateGuardrailInput, optFns ...func(*bedrock.Options)) (*bedrock.UpdateGuardrailOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGuardrail")
	}

	var r0 *bedrock.UpdateGuardrailOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UpdateGuardrailInput, ...func(*bedrock.Options)) (*bedrock.UpdateGuardrailOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UpdateGuardrailInput, ...func(*bedrock.Options)) *bedrock.UpdateGuardrailOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.UpdateGuardrailOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.UpdateGuardrailInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProvisionedModelThroughput provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProvisionedModelThroughput(ctx context.Context, params *bedrock.UpdateProvisionedModelThroughputInput, optFns ...func(*bedrock.Options)) (*bedrock.UpdateProvisionedModelThroughputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProvisionedModelThroughput")
	}

	var r0 *bedrock.UpdateProvisionedModelThroughputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UpdateProvisionedModelThroughputInput, ...func(*bedrock.Options)) (*bedrock.UpdateProvisionedModelThroughputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrock.UpdateProvisionedModelThroughputInput, ...func(*bedrock.Options)) *bedrock.UpdateProvisionedModelThroughputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrock.UpdateProvisionedModelThroughputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrock.UpdateProvisionedModelThroughputInput, ...func(*bedrock.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
