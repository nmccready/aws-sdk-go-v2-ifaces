// Code generated by mockery v2.39.2. DO NOT EDIT.

package mocks

import (
	context "context"

	databrew "github.com/aws/aws-sdk-go-v2/service/databrew"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchDeleteRecipeVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteRecipeVersion(ctx context.Context, params *databrew.BatchDeleteRecipeVersionInput, optFns ...func(*databrew.Options)) (*databrew.BatchDeleteRecipeVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteRecipeVersion")
	}

	var r0 *databrew.BatchDeleteRecipeVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.BatchDeleteRecipeVersionInput, ...func(*databrew.Options)) (*databrew.BatchDeleteRecipeVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.BatchDeleteRecipeVersionInput, ...func(*databrew.Options)) *databrew.BatchDeleteRecipeVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.BatchDeleteRecipeVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.BatchDeleteRecipeVersionInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataset(ctx context.Context, params *databrew.CreateDatasetInput, optFns ...func(*databrew.Options)) (*databrew.CreateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataset")
	}

	var r0 *databrew.CreateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateDatasetInput, ...func(*databrew.Options)) (*databrew.CreateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateDatasetInput, ...func(*databrew.Options)) *databrew.CreateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateDatasetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProfileJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProfileJob(ctx context.Context, params *databrew.CreateProfileJobInput, optFns ...func(*databrew.Options)) (*databrew.CreateProfileJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProfileJob")
	}

	var r0 *databrew.CreateProfileJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateProfileJobInput, ...func(*databrew.Options)) (*databrew.CreateProfileJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateProfileJobInput, ...func(*databrew.Options)) *databrew.CreateProfileJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateProfileJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateProfileJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProject(ctx context.Context, params *databrew.CreateProjectInput, optFns ...func(*databrew.Options)) (*databrew.CreateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *databrew.CreateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateProjectInput, ...func(*databrew.Options)) (*databrew.CreateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateProjectInput, ...func(*databrew.Options)) *databrew.CreateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateProjectInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRecipe provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRecipe(ctx context.Context, params *databrew.CreateRecipeInput, optFns ...func(*databrew.Options)) (*databrew.CreateRecipeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRecipe")
	}

	var r0 *databrew.CreateRecipeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRecipeInput, ...func(*databrew.Options)) (*databrew.CreateRecipeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRecipeInput, ...func(*databrew.Options)) *databrew.CreateRecipeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateRecipeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateRecipeInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRecipeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRecipeJob(ctx context.Context, params *databrew.CreateRecipeJobInput, optFns ...func(*databrew.Options)) (*databrew.CreateRecipeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRecipeJob")
	}

	var r0 *databrew.CreateRecipeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRecipeJobInput, ...func(*databrew.Options)) (*databrew.CreateRecipeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRecipeJobInput, ...func(*databrew.Options)) *databrew.CreateRecipeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateRecipeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateRecipeJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRuleset(ctx context.Context, params *databrew.CreateRulesetInput, optFns ...func(*databrew.Options)) (*databrew.CreateRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRuleset")
	}

	var r0 *databrew.CreateRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRulesetInput, ...func(*databrew.Options)) (*databrew.CreateRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateRulesetInput, ...func(*databrew.Options)) *databrew.CreateRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateRulesetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSchedule(ctx context.Context, params *databrew.CreateScheduleInput, optFns ...func(*databrew.Options)) (*databrew.CreateScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSchedule")
	}

	var r0 *databrew.CreateScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateScheduleInput, ...func(*databrew.Options)) (*databrew.CreateScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.CreateScheduleInput, ...func(*databrew.Options)) *databrew.CreateScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.CreateScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.CreateScheduleInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataset(ctx context.Context, params *databrew.DeleteDatasetInput, optFns ...func(*databrew.Options)) (*databrew.DeleteDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataset")
	}

	var r0 *databrew.DeleteDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteDatasetInput, ...func(*databrew.Options)) (*databrew.DeleteDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteDatasetInput, ...func(*databrew.Options)) *databrew.DeleteDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteDatasetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteJob(ctx context.Context, params *databrew.DeleteJobInput, optFns ...func(*databrew.Options)) (*databrew.DeleteJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 *databrew.DeleteJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteJobInput, ...func(*databrew.Options)) (*databrew.DeleteJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteJobInput, ...func(*databrew.Options)) *databrew.DeleteJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteProject(ctx context.Context, params *databrew.DeleteProjectInput, optFns ...func(*databrew.Options)) (*databrew.DeleteProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *databrew.DeleteProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteProjectInput, ...func(*databrew.Options)) (*databrew.DeleteProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteProjectInput, ...func(*databrew.Options)) *databrew.DeleteProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteProjectInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRecipeVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRecipeVersion(ctx context.Context, params *databrew.DeleteRecipeVersionInput, optFns ...func(*databrew.Options)) (*databrew.DeleteRecipeVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRecipeVersion")
	}

	var r0 *databrew.DeleteRecipeVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteRecipeVersionInput, ...func(*databrew.Options)) (*databrew.DeleteRecipeVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteRecipeVersionInput, ...func(*databrew.Options)) *databrew.DeleteRecipeVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteRecipeVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteRecipeVersionInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRuleset(ctx context.Context, params *databrew.DeleteRulesetInput, optFns ...func(*databrew.Options)) (*databrew.DeleteRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRuleset")
	}

	var r0 *databrew.DeleteRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteRulesetInput, ...func(*databrew.Options)) (*databrew.DeleteRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteRulesetInput, ...func(*databrew.Options)) *databrew.DeleteRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteRulesetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSchedule(ctx context.Context, params *databrew.DeleteScheduleInput, optFns ...func(*databrew.Options)) (*databrew.DeleteScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSchedule")
	}

	var r0 *databrew.DeleteScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteScheduleInput, ...func(*databrew.Options)) (*databrew.DeleteScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DeleteScheduleInput, ...func(*databrew.Options)) *databrew.DeleteScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DeleteScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DeleteScheduleInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataset(ctx context.Context, params *databrew.DescribeDatasetInput, optFns ...func(*databrew.Options)) (*databrew.DescribeDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataset")
	}

	var r0 *databrew.DescribeDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeDatasetInput, ...func(*databrew.Options)) (*databrew.DescribeDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeDatasetInput, ...func(*databrew.Options)) *databrew.DescribeDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeDatasetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJob(ctx context.Context, params *databrew.DescribeJobInput, optFns ...func(*databrew.Options)) (*databrew.DescribeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJob")
	}

	var r0 *databrew.DescribeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeJobInput, ...func(*databrew.Options)) (*databrew.DescribeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeJobInput, ...func(*databrew.Options)) *databrew.DescribeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeJobRun(ctx context.Context, params *databrew.DescribeJobRunInput, optFns ...func(*databrew.Options)) (*databrew.DescribeJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeJobRun")
	}

	var r0 *databrew.DescribeJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeJobRunInput, ...func(*databrew.Options)) (*databrew.DescribeJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeJobRunInput, ...func(*databrew.Options)) *databrew.DescribeJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeJobRunInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeProject(ctx context.Context, params *databrew.DescribeProjectInput, optFns ...func(*databrew.Options)) (*databrew.DescribeProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeProject")
	}

	var r0 *databrew.DescribeProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeProjectInput, ...func(*databrew.Options)) (*databrew.DescribeProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeProjectInput, ...func(*databrew.Options)) *databrew.DescribeProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeProjectInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRecipe provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRecipe(ctx context.Context, params *databrew.DescribeRecipeInput, optFns ...func(*databrew.Options)) (*databrew.DescribeRecipeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRecipe")
	}

	var r0 *databrew.DescribeRecipeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeRecipeInput, ...func(*databrew.Options)) (*databrew.DescribeRecipeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeRecipeInput, ...func(*databrew.Options)) *databrew.DescribeRecipeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeRecipeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeRecipeInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRuleset(ctx context.Context, params *databrew.DescribeRulesetInput, optFns ...func(*databrew.Options)) (*databrew.DescribeRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRuleset")
	}

	var r0 *databrew.DescribeRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeRulesetInput, ...func(*databrew.Options)) (*databrew.DescribeRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeRulesetInput, ...func(*databrew.Options)) *databrew.DescribeRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeRulesetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSchedule(ctx context.Context, params *databrew.DescribeScheduleInput, optFns ...func(*databrew.Options)) (*databrew.DescribeScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSchedule")
	}

	var r0 *databrew.DescribeScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeScheduleInput, ...func(*databrew.Options)) (*databrew.DescribeScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.DescribeScheduleInput, ...func(*databrew.Options)) *databrew.DescribeScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.DescribeScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.DescribeScheduleInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatasets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDatasets(ctx context.Context, params *databrew.ListDatasetsInput, optFns ...func(*databrew.Options)) (*databrew.ListDatasetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDatasets")
	}

	var r0 *databrew.ListDatasetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListDatasetsInput, ...func(*databrew.Options)) (*databrew.ListDatasetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListDatasetsInput, ...func(*databrew.Options)) *databrew.ListDatasetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListDatasetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListDatasetsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobRuns provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobRuns(ctx context.Context, params *databrew.ListJobRunsInput, optFns ...func(*databrew.Options)) (*databrew.ListJobRunsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobRuns")
	}

	var r0 *databrew.ListJobRunsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListJobRunsInput, ...func(*databrew.Options)) (*databrew.ListJobRunsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListJobRunsInput, ...func(*databrew.Options)) *databrew.ListJobRunsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListJobRunsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListJobRunsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListJobs(ctx context.Context, params *databrew.ListJobsInput, optFns ...func(*databrew.Options)) (*databrew.ListJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 *databrew.ListJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListJobsInput, ...func(*databrew.Options)) (*databrew.ListJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListJobsInput, ...func(*databrew.Options)) *databrew.ListJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListJobsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProjects(ctx context.Context, params *databrew.ListProjectsInput, optFns ...func(*databrew.Options)) (*databrew.ListProjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 *databrew.ListProjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListProjectsInput, ...func(*databrew.Options)) (*databrew.ListProjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListProjectsInput, ...func(*databrew.Options)) *databrew.ListProjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListProjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListProjectsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRecipeVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRecipeVersions(ctx context.Context, params *databrew.ListRecipeVersionsInput, optFns ...func(*databrew.Options)) (*databrew.ListRecipeVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRecipeVersions")
	}

	var r0 *databrew.ListRecipeVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRecipeVersionsInput, ...func(*databrew.Options)) (*databrew.ListRecipeVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRecipeVersionsInput, ...func(*databrew.Options)) *databrew.ListRecipeVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListRecipeVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListRecipeVersionsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRecipes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRecipes(ctx context.Context, params *databrew.ListRecipesInput, optFns ...func(*databrew.Options)) (*databrew.ListRecipesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRecipes")
	}

	var r0 *databrew.ListRecipesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRecipesInput, ...func(*databrew.Options)) (*databrew.ListRecipesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRecipesInput, ...func(*databrew.Options)) *databrew.ListRecipesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListRecipesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListRecipesInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRulesets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRulesets(ctx context.Context, params *databrew.ListRulesetsInput, optFns ...func(*databrew.Options)) (*databrew.ListRulesetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesets")
	}

	var r0 *databrew.ListRulesetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRulesetsInput, ...func(*databrew.Options)) (*databrew.ListRulesetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListRulesetsInput, ...func(*databrew.Options)) *databrew.ListRulesetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListRulesetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListRulesetsInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSchedules provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSchedules(ctx context.Context, params *databrew.ListSchedulesInput, optFns ...func(*databrew.Options)) (*databrew.ListSchedulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSchedules")
	}

	var r0 *databrew.ListSchedulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListSchedulesInput, ...func(*databrew.Options)) (*databrew.ListSchedulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListSchedulesInput, ...func(*databrew.Options)) *databrew.ListSchedulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListSchedulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListSchedulesInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *databrew.ListTagsForResourceInput, optFns ...func(*databrew.Options)) (*databrew.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *databrew.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListTagsForResourceInput, ...func(*databrew.Options)) (*databrew.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.ListTagsForResourceInput, ...func(*databrew.Options)) *databrew.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.ListTagsForResourceInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() databrew.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 databrew.Options
	if rf, ok := ret.Get(0).(func() databrew.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(databrew.Options)
	}

	return r0
}

// PublishRecipe provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PublishRecipe(ctx context.Context, params *databrew.PublishRecipeInput, optFns ...func(*databrew.Options)) (*databrew.PublishRecipeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishRecipe")
	}

	var r0 *databrew.PublishRecipeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.PublishRecipeInput, ...func(*databrew.Options)) (*databrew.PublishRecipeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.PublishRecipeInput, ...func(*databrew.Options)) *databrew.PublishRecipeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.PublishRecipeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.PublishRecipeInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendProjectSessionAction provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendProjectSessionAction(ctx context.Context, params *databrew.SendProjectSessionActionInput, optFns ...func(*databrew.Options)) (*databrew.SendProjectSessionActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendProjectSessionAction")
	}

	var r0 *databrew.SendProjectSessionActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.SendProjectSessionActionInput, ...func(*databrew.Options)) (*databrew.SendProjectSessionActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.SendProjectSessionActionInput, ...func(*databrew.Options)) *databrew.SendProjectSessionActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.SendProjectSessionActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.SendProjectSessionActionInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartJobRun(ctx context.Context, params *databrew.StartJobRunInput, optFns ...func(*databrew.Options)) (*databrew.StartJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartJobRun")
	}

	var r0 *databrew.StartJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StartJobRunInput, ...func(*databrew.Options)) (*databrew.StartJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StartJobRunInput, ...func(*databrew.Options)) *databrew.StartJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.StartJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.StartJobRunInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartProjectSession provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartProjectSession(ctx context.Context, params *databrew.StartProjectSessionInput, optFns ...func(*databrew.Options)) (*databrew.StartProjectSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartProjectSession")
	}

	var r0 *databrew.StartProjectSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StartProjectSessionInput, ...func(*databrew.Options)) (*databrew.StartProjectSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StartProjectSessionInput, ...func(*databrew.Options)) *databrew.StartProjectSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.StartProjectSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.StartProjectSessionInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopJobRun provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopJobRun(ctx context.Context, params *databrew.StopJobRunInput, optFns ...func(*databrew.Options)) (*databrew.StopJobRunOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopJobRun")
	}

	var r0 *databrew.StopJobRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StopJobRunInput, ...func(*databrew.Options)) (*databrew.StopJobRunOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.StopJobRunInput, ...func(*databrew.Options)) *databrew.StopJobRunOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.StopJobRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.StopJobRunInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *databrew.TagResourceInput, optFns ...func(*databrew.Options)) (*databrew.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *databrew.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.TagResourceInput, ...func(*databrew.Options)) (*databrew.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.TagResourceInput, ...func(*databrew.Options)) *databrew.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.TagResourceInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *databrew.UntagResourceInput, optFns ...func(*databrew.Options)) (*databrew.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *databrew.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UntagResourceInput, ...func(*databrew.Options)) (*databrew.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UntagResourceInput, ...func(*databrew.Options)) *databrew.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UntagResourceInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataset(ctx context.Context, params *databrew.UpdateDatasetInput, optFns ...func(*databrew.Options)) (*databrew.UpdateDatasetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataset")
	}

	var r0 *databrew.UpdateDatasetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateDatasetInput, ...func(*databrew.Options)) (*databrew.UpdateDatasetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateDatasetInput, ...func(*databrew.Options)) *databrew.UpdateDatasetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateDatasetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateDatasetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProfileJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProfileJob(ctx context.Context, params *databrew.UpdateProfileJobInput, optFns ...func(*databrew.Options)) (*databrew.UpdateProfileJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProfileJob")
	}

	var r0 *databrew.UpdateProfileJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateProfileJobInput, ...func(*databrew.Options)) (*databrew.UpdateProfileJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateProfileJobInput, ...func(*databrew.Options)) *databrew.UpdateProfileJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateProfileJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateProfileJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProject provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateProject(ctx context.Context, params *databrew.UpdateProjectInput, optFns ...func(*databrew.Options)) (*databrew.UpdateProjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 *databrew.UpdateProjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateProjectInput, ...func(*databrew.Options)) (*databrew.UpdateProjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateProjectInput, ...func(*databrew.Options)) *databrew.UpdateProjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateProjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateProjectInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRecipe provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRecipe(ctx context.Context, params *databrew.UpdateRecipeInput, optFns ...func(*databrew.Options)) (*databrew.UpdateRecipeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRecipe")
	}

	var r0 *databrew.UpdateRecipeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRecipeInput, ...func(*databrew.Options)) (*databrew.UpdateRecipeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRecipeInput, ...func(*databrew.Options)) *databrew.UpdateRecipeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateRecipeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateRecipeInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRecipeJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRecipeJob(ctx context.Context, params *databrew.UpdateRecipeJobInput, optFns ...func(*databrew.Options)) (*databrew.UpdateRecipeJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRecipeJob")
	}

	var r0 *databrew.UpdateRecipeJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRecipeJobInput, ...func(*databrew.Options)) (*databrew.UpdateRecipeJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRecipeJobInput, ...func(*databrew.Options)) *databrew.UpdateRecipeJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateRecipeJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateRecipeJobInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRuleset provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRuleset(ctx context.Context, params *databrew.UpdateRulesetInput, optFns ...func(*databrew.Options)) (*databrew.UpdateRulesetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuleset")
	}

	var r0 *databrew.UpdateRulesetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRulesetInput, ...func(*databrew.Options)) (*databrew.UpdateRulesetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateRulesetInput, ...func(*databrew.Options)) *databrew.UpdateRulesetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateRulesetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateRulesetInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSchedule provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSchedule(ctx context.Context, params *databrew.UpdateScheduleInput, optFns ...func(*databrew.Options)) (*databrew.UpdateScheduleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSchedule")
	}

	var r0 *databrew.UpdateScheduleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateScheduleInput, ...func(*databrew.Options)) (*databrew.UpdateScheduleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *databrew.UpdateScheduleInput, ...func(*databrew.Options)) *databrew.UpdateScheduleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*databrew.UpdateScheduleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *databrew.UpdateScheduleInput, ...func(*databrew.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
