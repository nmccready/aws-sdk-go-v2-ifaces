// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	kendra "github.com/aws/aws-sdk-go-v2/service/kendra"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AssociateEntitiesToExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateEntitiesToExperience(ctx context.Context, params *kendra.AssociateEntitiesToExperienceInput, optFns ...func(*kendra.Options)) (*kendra.AssociateEntitiesToExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateEntitiesToExperience")
	}

	var r0 *kendra.AssociateEntitiesToExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.AssociateEntitiesToExperienceInput, ...func(*kendra.Options)) (*kendra.AssociateEntitiesToExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.AssociateEntitiesToExperienceInput, ...func(*kendra.Options)) *kendra.AssociateEntitiesToExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.AssociateEntitiesToExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.AssociateEntitiesToExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociatePersonasToEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociatePersonasToEntities(ctx context.Context, params *kendra.AssociatePersonasToEntitiesInput, optFns ...func(*kendra.Options)) (*kendra.AssociatePersonasToEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociatePersonasToEntities")
	}

	var r0 *kendra.AssociatePersonasToEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.AssociatePersonasToEntitiesInput, ...func(*kendra.Options)) (*kendra.AssociatePersonasToEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.AssociatePersonasToEntitiesInput, ...func(*kendra.Options)) *kendra.AssociatePersonasToEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.AssociatePersonasToEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.AssociatePersonasToEntitiesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteDocument provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteDocument(ctx context.Context, params *kendra.BatchDeleteDocumentInput, optFns ...func(*kendra.Options)) (*kendra.BatchDeleteDocumentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteDocument")
	}

	var r0 *kendra.BatchDeleteDocumentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchDeleteDocumentInput, ...func(*kendra.Options)) (*kendra.BatchDeleteDocumentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchDeleteDocumentInput, ...func(*kendra.Options)) *kendra.BatchDeleteDocumentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.BatchDeleteDocumentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.BatchDeleteDocumentInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteFeaturedResultsSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteFeaturedResultsSet(ctx context.Context, params *kendra.BatchDeleteFeaturedResultsSetInput, optFns ...func(*kendra.Options)) (*kendra.BatchDeleteFeaturedResultsSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteFeaturedResultsSet")
	}

	var r0 *kendra.BatchDeleteFeaturedResultsSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchDeleteFeaturedResultsSetInput, ...func(*kendra.Options)) (*kendra.BatchDeleteFeaturedResultsSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchDeleteFeaturedResultsSetInput, ...func(*kendra.Options)) *kendra.BatchDeleteFeaturedResultsSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.BatchDeleteFeaturedResultsSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.BatchDeleteFeaturedResultsSetInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetDocumentStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchGetDocumentStatus(ctx context.Context, params *kendra.BatchGetDocumentStatusInput, optFns ...func(*kendra.Options)) (*kendra.BatchGetDocumentStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchGetDocumentStatus")
	}

	var r0 *kendra.BatchGetDocumentStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchGetDocumentStatusInput, ...func(*kendra.Options)) (*kendra.BatchGetDocumentStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchGetDocumentStatusInput, ...func(*kendra.Options)) *kendra.BatchGetDocumentStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.BatchGetDocumentStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.BatchGetDocumentStatusInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchPutDocument provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchPutDocument(ctx context.Context, params *kendra.BatchPutDocumentInput, optFns ...func(*kendra.Options)) (*kendra.BatchPutDocumentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchPutDocument")
	}

	var r0 *kendra.BatchPutDocumentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchPutDocumentInput, ...func(*kendra.Options)) (*kendra.BatchPutDocumentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.BatchPutDocumentInput, ...func(*kendra.Options)) *kendra.BatchPutDocumentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.BatchPutDocumentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.BatchPutDocumentInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClearQuerySuggestions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ClearQuerySuggestions(ctx context.Context, params *kendra.ClearQuerySuggestionsInput, optFns ...func(*kendra.Options)) (*kendra.ClearQuerySuggestionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClearQuerySuggestions")
	}

	var r0 *kendra.ClearQuerySuggestionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ClearQuerySuggestionsInput, ...func(*kendra.Options)) (*kendra.ClearQuerySuggestionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ClearQuerySuggestionsInput, ...func(*kendra.Options)) *kendra.ClearQuerySuggestionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ClearQuerySuggestionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ClearQuerySuggestionsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessControlConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessControlConfiguration(ctx context.Context, params *kendra.CreateAccessControlConfigurationInput, optFns ...func(*kendra.Options)) (*kendra.CreateAccessControlConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessControlConfiguration")
	}

	var r0 *kendra.CreateAccessControlConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateAccessControlConfigurationInput, ...func(*kendra.Options)) (*kendra.CreateAccessControlConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateAccessControlConfigurationInput, ...func(*kendra.Options)) *kendra.CreateAccessControlConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateAccessControlConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateAccessControlConfigurationInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDataSource(ctx context.Context, params *kendra.CreateDataSourceInput, optFns ...func(*kendra.Options)) (*kendra.CreateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataSource")
	}

	var r0 *kendra.CreateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateDataSourceInput, ...func(*kendra.Options)) (*kendra.CreateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateDataSourceInput, ...func(*kendra.Options)) *kendra.CreateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateDataSourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateExperience(ctx context.Context, params *kendra.CreateExperienceInput, optFns ...func(*kendra.Options)) (*kendra.CreateExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperience")
	}

	var r0 *kendra.CreateExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateExperienceInput, ...func(*kendra.Options)) (*kendra.CreateExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateExperienceInput, ...func(*kendra.Options)) *kendra.CreateExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFaq provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFaq(ctx context.Context, params *kendra.CreateFaqInput, optFns ...func(*kendra.Options)) (*kendra.CreateFaqOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFaq")
	}

	var r0 *kendra.CreateFaqOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateFaqInput, ...func(*kendra.Options)) (*kendra.CreateFaqOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateFaqInput, ...func(*kendra.Options)) *kendra.CreateFaqOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateFaqOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateFaqInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFeaturedResultsSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFeaturedResultsSet(ctx context.Context, params *kendra.CreateFeaturedResultsSetInput, optFns ...func(*kendra.Options)) (*kendra.CreateFeaturedResultsSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFeaturedResultsSet")
	}

	var r0 *kendra.CreateFeaturedResultsSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateFeaturedResultsSetInput, ...func(*kendra.Options)) (*kendra.CreateFeaturedResultsSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateFeaturedResultsSetInput, ...func(*kendra.Options)) *kendra.CreateFeaturedResultsSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateFeaturedResultsSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateFeaturedResultsSetInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateIndex(ctx context.Context, params *kendra.CreateIndexInput, optFns ...func(*kendra.Options)) (*kendra.CreateIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIndex")
	}

	var r0 *kendra.CreateIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateIndexInput, ...func(*kendra.Options)) (*kendra.CreateIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateIndexInput, ...func(*kendra.Options)) *kendra.CreateIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateIndexInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateQuerySuggestionsBlockList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateQuerySuggestionsBlockList(ctx context.Context, params *kendra.CreateQuerySuggestionsBlockListInput, optFns ...func(*kendra.Options)) (*kendra.CreateQuerySuggestionsBlockListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateQuerySuggestionsBlockList")
	}

	var r0 *kendra.CreateQuerySuggestionsBlockListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) (*kendra.CreateQuerySuggestionsBlockListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) *kendra.CreateQuerySuggestionsBlockListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateQuerySuggestionsBlockListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateThesaurus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateThesaurus(ctx context.Context, params *kendra.CreateThesaurusInput, optFns ...func(*kendra.Options)) (*kendra.CreateThesaurusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateThesaurus")
	}

	var r0 *kendra.CreateThesaurusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateThesaurusInput, ...func(*kendra.Options)) (*kendra.CreateThesaurusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.CreateThesaurusInput, ...func(*kendra.Options)) *kendra.CreateThesaurusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.CreateThesaurusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.CreateThesaurusInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessControlConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccessControlConfiguration(ctx context.Context, params *kendra.DeleteAccessControlConfigurationInput, optFns ...func(*kendra.Options)) (*kendra.DeleteAccessControlConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessControlConfiguration")
	}

	var r0 *kendra.DeleteAccessControlConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteAccessControlConfigurationInput, ...func(*kendra.Options)) (*kendra.DeleteAccessControlConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteAccessControlConfigurationInput, ...func(*kendra.Options)) *kendra.DeleteAccessControlConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteAccessControlConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteAccessControlConfigurationInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteDataSource(ctx context.Context, params *kendra.DeleteDataSourceInput, optFns ...func(*kendra.Options)) (*kendra.DeleteDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataSource")
	}

	var r0 *kendra.DeleteDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteDataSourceInput, ...func(*kendra.Options)) (*kendra.DeleteDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteDataSourceInput, ...func(*kendra.Options)) *kendra.DeleteDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteDataSourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteExperience(ctx context.Context, params *kendra.DeleteExperienceInput, optFns ...func(*kendra.Options)) (*kendra.DeleteExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExperience")
	}

	var r0 *kendra.DeleteExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteExperienceInput, ...func(*kendra.Options)) (*kendra.DeleteExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteExperienceInput, ...func(*kendra.Options)) *kendra.DeleteExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFaq provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFaq(ctx context.Context, params *kendra.DeleteFaqInput, optFns ...func(*kendra.Options)) (*kendra.DeleteFaqOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFaq")
	}

	var r0 *kendra.DeleteFaqOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteFaqInput, ...func(*kendra.Options)) (*kendra.DeleteFaqOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteFaqInput, ...func(*kendra.Options)) *kendra.DeleteFaqOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteFaqOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteFaqInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteIndex(ctx context.Context, params *kendra.DeleteIndexInput, optFns ...func(*kendra.Options)) (*kendra.DeleteIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIndex")
	}

	var r0 *kendra.DeleteIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteIndexInput, ...func(*kendra.Options)) (*kendra.DeleteIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteIndexInput, ...func(*kendra.Options)) *kendra.DeleteIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteIndexInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePrincipalMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeletePrincipalMapping(ctx context.Context, params *kendra.DeletePrincipalMappingInput, optFns ...func(*kendra.Options)) (*kendra.DeletePrincipalMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePrincipalMapping")
	}

	var r0 *kendra.DeletePrincipalMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeletePrincipalMappingInput, ...func(*kendra.Options)) (*kendra.DeletePrincipalMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeletePrincipalMappingInput, ...func(*kendra.Options)) *kendra.DeletePrincipalMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeletePrincipalMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeletePrincipalMappingInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQuerySuggestionsBlockList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQuerySuggestionsBlockList(ctx context.Context, params *kendra.DeleteQuerySuggestionsBlockListInput, optFns ...func(*kendra.Options)) (*kendra.DeleteQuerySuggestionsBlockListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQuerySuggestionsBlockList")
	}

	var r0 *kendra.DeleteQuerySuggestionsBlockListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteQuerySuggestionsBlockListInput, ...func(*kendra.Options)) (*kendra.DeleteQuerySuggestionsBlockListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteQuerySuggestionsBlockListInput, ...func(*kendra.Options)) *kendra.DeleteQuerySuggestionsBlockListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteQuerySuggestionsBlockListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteQuerySuggestionsBlockListInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteThesaurus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteThesaurus(ctx context.Context, params *kendra.DeleteThesaurusInput, optFns ...func(*kendra.Options)) (*kendra.DeleteThesaurusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteThesaurus")
	}

	var r0 *kendra.DeleteThesaurusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteThesaurusInput, ...func(*kendra.Options)) (*kendra.DeleteThesaurusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DeleteThesaurusInput, ...func(*kendra.Options)) *kendra.DeleteThesaurusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DeleteThesaurusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DeleteThesaurusInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccessControlConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeAccessControlConfiguration(ctx context.Context, params *kendra.DescribeAccessControlConfigurationInput, optFns ...func(*kendra.Options)) (*kendra.DescribeAccessControlConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccessControlConfiguration")
	}

	var r0 *kendra.DescribeAccessControlConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeAccessControlConfigurationInput, ...func(*kendra.Options)) (*kendra.DescribeAccessControlConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeAccessControlConfigurationInput, ...func(*kendra.Options)) *kendra.DescribeAccessControlConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeAccessControlConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeAccessControlConfigurationInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDataSource(ctx context.Context, params *kendra.DescribeDataSourceInput, optFns ...func(*kendra.Options)) (*kendra.DescribeDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDataSource")
	}

	var r0 *kendra.DescribeDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeDataSourceInput, ...func(*kendra.Options)) (*kendra.DescribeDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeDataSourceInput, ...func(*kendra.Options)) *kendra.DescribeDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeDataSourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeExperience(ctx context.Context, params *kendra.DescribeExperienceInput, optFns ...func(*kendra.Options)) (*kendra.DescribeExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExperience")
	}

	var r0 *kendra.DescribeExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeExperienceInput, ...func(*kendra.Options)) (*kendra.DescribeExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeExperienceInput, ...func(*kendra.Options)) *kendra.DescribeExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFaq provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFaq(ctx context.Context, params *kendra.DescribeFaqInput, optFns ...func(*kendra.Options)) (*kendra.DescribeFaqOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFaq")
	}

	var r0 *kendra.DescribeFaqOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeFaqInput, ...func(*kendra.Options)) (*kendra.DescribeFaqOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeFaqInput, ...func(*kendra.Options)) *kendra.DescribeFaqOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeFaqOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeFaqInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFeaturedResultsSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFeaturedResultsSet(ctx context.Context, params *kendra.DescribeFeaturedResultsSetInput, optFns ...func(*kendra.Options)) (*kendra.DescribeFeaturedResultsSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFeaturedResultsSet")
	}

	var r0 *kendra.DescribeFeaturedResultsSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeFeaturedResultsSetInput, ...func(*kendra.Options)) (*kendra.DescribeFeaturedResultsSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeFeaturedResultsSetInput, ...func(*kendra.Options)) *kendra.DescribeFeaturedResultsSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeFeaturedResultsSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeFeaturedResultsSetInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeIndex(ctx context.Context, params *kendra.DescribeIndexInput, optFns ...func(*kendra.Options)) (*kendra.DescribeIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIndex")
	}

	var r0 *kendra.DescribeIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeIndexInput, ...func(*kendra.Options)) (*kendra.DescribeIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeIndexInput, ...func(*kendra.Options)) *kendra.DescribeIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeIndexInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrincipalMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribePrincipalMapping(ctx context.Context, params *kendra.DescribePrincipalMappingInput, optFns ...func(*kendra.Options)) (*kendra.DescribePrincipalMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrincipalMapping")
	}

	var r0 *kendra.DescribePrincipalMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribePrincipalMappingInput, ...func(*kendra.Options)) (*kendra.DescribePrincipalMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribePrincipalMappingInput, ...func(*kendra.Options)) *kendra.DescribePrincipalMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribePrincipalMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribePrincipalMappingInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeQuerySuggestionsBlockList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeQuerySuggestionsBlockList(ctx context.Context, params *kendra.DescribeQuerySuggestionsBlockListInput, optFns ...func(*kendra.Options)) (*kendra.DescribeQuerySuggestionsBlockListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeQuerySuggestionsBlockList")
	}

	var r0 *kendra.DescribeQuerySuggestionsBlockListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeQuerySuggestionsBlockListInput, ...func(*kendra.Options)) (*kendra.DescribeQuerySuggestionsBlockListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeQuerySuggestionsBlockListInput, ...func(*kendra.Options)) *kendra.DescribeQuerySuggestionsBlockListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeQuerySuggestionsBlockListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeQuerySuggestionsBlockListInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeQuerySuggestionsConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeQuerySuggestionsConfig(ctx context.Context, params *kendra.DescribeQuerySuggestionsConfigInput, optFns ...func(*kendra.Options)) (*kendra.DescribeQuerySuggestionsConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeQuerySuggestionsConfig")
	}

	var r0 *kendra.DescribeQuerySuggestionsConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeQuerySuggestionsConfigInput, ...func(*kendra.Options)) (*kendra.DescribeQuerySuggestionsConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeQuerySuggestionsConfigInput, ...func(*kendra.Options)) *kendra.DescribeQuerySuggestionsConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeQuerySuggestionsConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeQuerySuggestionsConfigInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeThesaurus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeThesaurus(ctx context.Context, params *kendra.DescribeThesaurusInput, optFns ...func(*kendra.Options)) (*kendra.DescribeThesaurusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeThesaurus")
	}

	var r0 *kendra.DescribeThesaurusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeThesaurusInput, ...func(*kendra.Options)) (*kendra.DescribeThesaurusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DescribeThesaurusInput, ...func(*kendra.Options)) *kendra.DescribeThesaurusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DescribeThesaurusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DescribeThesaurusInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateEntitiesFromExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateEntitiesFromExperience(ctx context.Context, params *kendra.DisassociateEntitiesFromExperienceInput, optFns ...func(*kendra.Options)) (*kendra.DisassociateEntitiesFromExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateEntitiesFromExperience")
	}

	var r0 *kendra.DisassociateEntitiesFromExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DisassociateEntitiesFromExperienceInput, ...func(*kendra.Options)) (*kendra.DisassociateEntitiesFromExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DisassociateEntitiesFromExperienceInput, ...func(*kendra.Options)) *kendra.DisassociateEntitiesFromExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DisassociateEntitiesFromExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DisassociateEntitiesFromExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociatePersonasFromEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociatePersonasFromEntities(ctx context.Context, params *kendra.DisassociatePersonasFromEntitiesInput, optFns ...func(*kendra.Options)) (*kendra.DisassociatePersonasFromEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociatePersonasFromEntities")
	}

	var r0 *kendra.DisassociatePersonasFromEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DisassociatePersonasFromEntitiesInput, ...func(*kendra.Options)) (*kendra.DisassociatePersonasFromEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.DisassociatePersonasFromEntitiesInput, ...func(*kendra.Options)) *kendra.DisassociatePersonasFromEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.DisassociatePersonasFromEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.DisassociatePersonasFromEntitiesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQuerySuggestions provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQuerySuggestions(ctx context.Context, params *kendra.GetQuerySuggestionsInput, optFns ...func(*kendra.Options)) (*kendra.GetQuerySuggestionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuerySuggestions")
	}

	var r0 *kendra.GetQuerySuggestionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.GetQuerySuggestionsInput, ...func(*kendra.Options)) (*kendra.GetQuerySuggestionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.GetQuerySuggestionsInput, ...func(*kendra.Options)) *kendra.GetQuerySuggestionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.GetQuerySuggestionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.GetQuerySuggestionsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetSnapshots(ctx context.Context, params *kendra.GetSnapshotsInput, optFns ...func(*kendra.Options)) (*kendra.GetSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnapshots")
	}

	var r0 *kendra.GetSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.GetSnapshotsInput, ...func(*kendra.Options)) (*kendra.GetSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.GetSnapshotsInput, ...func(*kendra.Options)) *kendra.GetSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.GetSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.GetSnapshotsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessControlConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessControlConfigurations(ctx context.Context, params *kendra.ListAccessControlConfigurationsInput, optFns ...func(*kendra.Options)) (*kendra.ListAccessControlConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessControlConfigurations")
	}

	var r0 *kendra.ListAccessControlConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListAccessControlConfigurationsInput, ...func(*kendra.Options)) (*kendra.ListAccessControlConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListAccessControlConfigurationsInput, ...func(*kendra.Options)) *kendra.ListAccessControlConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListAccessControlConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListAccessControlConfigurationsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSourceSyncJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSourceSyncJobs(ctx context.Context, params *kendra.ListDataSourceSyncJobsInput, optFns ...func(*kendra.Options)) (*kendra.ListDataSourceSyncJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSourceSyncJobs")
	}

	var r0 *kendra.ListDataSourceSyncJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListDataSourceSyncJobsInput, ...func(*kendra.Options)) (*kendra.ListDataSourceSyncJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListDataSourceSyncJobsInput, ...func(*kendra.Options)) *kendra.ListDataSourceSyncJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListDataSourceSyncJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListDataSourceSyncJobsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSources provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDataSources(ctx context.Context, params *kendra.ListDataSourcesInput, optFns ...func(*kendra.Options)) (*kendra.ListDataSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSources")
	}

	var r0 *kendra.ListDataSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListDataSourcesInput, ...func(*kendra.Options)) (*kendra.ListDataSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListDataSourcesInput, ...func(*kendra.Options)) *kendra.ListDataSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListDataSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListDataSourcesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntityPersonas provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListEntityPersonas(ctx context.Context, params *kendra.ListEntityPersonasInput, optFns ...func(*kendra.Options)) (*kendra.ListEntityPersonasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityPersonas")
	}

	var r0 *kendra.ListEntityPersonasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListEntityPersonasInput, ...func(*kendra.Options)) (*kendra.ListEntityPersonasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListEntityPersonasInput, ...func(*kendra.Options)) *kendra.ListEntityPersonasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListEntityPersonasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListEntityPersonasInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExperienceEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExperienceEntities(ctx context.Context, params *kendra.ListExperienceEntitiesInput, optFns ...func(*kendra.Options)) (*kendra.ListExperienceEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperienceEntities")
	}

	var r0 *kendra.ListExperienceEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListExperienceEntitiesInput, ...func(*kendra.Options)) (*kendra.ListExperienceEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListExperienceEntitiesInput, ...func(*kendra.Options)) *kendra.ListExperienceEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListExperienceEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListExperienceEntitiesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListExperiences provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListExperiences(ctx context.Context, params *kendra.ListExperiencesInput, optFns ...func(*kendra.Options)) (*kendra.ListExperiencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiences")
	}

	var r0 *kendra.ListExperiencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListExperiencesInput, ...func(*kendra.Options)) (*kendra.ListExperiencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListExperiencesInput, ...func(*kendra.Options)) *kendra.ListExperiencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListExperiencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListExperiencesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFaqs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFaqs(ctx context.Context, params *kendra.ListFaqsInput, optFns ...func(*kendra.Options)) (*kendra.ListFaqsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFaqs")
	}

	var r0 *kendra.ListFaqsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListFaqsInput, ...func(*kendra.Options)) (*kendra.ListFaqsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListFaqsInput, ...func(*kendra.Options)) *kendra.ListFaqsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListFaqsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListFaqsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFeaturedResultsSets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFeaturedResultsSets(ctx context.Context, params *kendra.ListFeaturedResultsSetsInput, optFns ...func(*kendra.Options)) (*kendra.ListFeaturedResultsSetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFeaturedResultsSets")
	}

	var r0 *kendra.ListFeaturedResultsSetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListFeaturedResultsSetsInput, ...func(*kendra.Options)) (*kendra.ListFeaturedResultsSetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListFeaturedResultsSetsInput, ...func(*kendra.Options)) *kendra.ListFeaturedResultsSetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListFeaturedResultsSetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListFeaturedResultsSetsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGroupsOlderThanOrderingId provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListGroupsOlderThanOrderingId(ctx context.Context, params *kendra.ListGroupsOlderThanOrderingIdInput, optFns ...func(*kendra.Options)) (*kendra.ListGroupsOlderThanOrderingIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupsOlderThanOrderingId")
	}

	var r0 *kendra.ListGroupsOlderThanOrderingIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListGroupsOlderThanOrderingIdInput, ...func(*kendra.Options)) (*kendra.ListGroupsOlderThanOrderingIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListGroupsOlderThanOrderingIdInput, ...func(*kendra.Options)) *kendra.ListGroupsOlderThanOrderingIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListGroupsOlderThanOrderingIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListGroupsOlderThanOrderingIdInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIndices provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListIndices(ctx context.Context, params *kendra.ListIndicesInput, optFns ...func(*kendra.Options)) (*kendra.ListIndicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIndices")
	}

	var r0 *kendra.ListIndicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListIndicesInput, ...func(*kendra.Options)) (*kendra.ListIndicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListIndicesInput, ...func(*kendra.Options)) *kendra.ListIndicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListIndicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListIndicesInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQuerySuggestionsBlockLists provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQuerySuggestionsBlockLists(ctx context.Context, params *kendra.ListQuerySuggestionsBlockListsInput, optFns ...func(*kendra.Options)) (*kendra.ListQuerySuggestionsBlockListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQuerySuggestionsBlockLists")
	}

	var r0 *kendra.ListQuerySuggestionsBlockListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListQuerySuggestionsBlockListsInput, ...func(*kendra.Options)) (*kendra.ListQuerySuggestionsBlockListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListQuerySuggestionsBlockListsInput, ...func(*kendra.Options)) *kendra.ListQuerySuggestionsBlockListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListQuerySuggestionsBlockListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListQuerySuggestionsBlockListsInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *kendra.ListTagsForResourceInput, optFns ...func(*kendra.Options)) (*kendra.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *kendra.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListTagsForResourceInput, ...func(*kendra.Options)) (*kendra.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListTagsForResourceInput, ...func(*kendra.Options)) *kendra.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListTagsForResourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListThesauri provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListThesauri(ctx context.Context, params *kendra.ListThesauriInput, optFns ...func(*kendra.Options)) (*kendra.ListThesauriOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListThesauri")
	}

	var r0 *kendra.ListThesauriOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListThesauriInput, ...func(*kendra.Options)) (*kendra.ListThesauriOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.ListThesauriInput, ...func(*kendra.Options)) *kendra.ListThesauriOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.ListThesauriOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.ListThesauriInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() kendra.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 kendra.Options
	if rf, ok := ret.Get(0).(func() kendra.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kendra.Options)
	}

	return r0
}

// PutPrincipalMapping provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutPrincipalMapping(ctx context.Context, params *kendra.PutPrincipalMappingInput, optFns ...func(*kendra.Options)) (*kendra.PutPrincipalMappingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutPrincipalMapping")
	}

	var r0 *kendra.PutPrincipalMappingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.PutPrincipalMappingInput, ...func(*kendra.Options)) (*kendra.PutPrincipalMappingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.PutPrincipalMappingInput, ...func(*kendra.Options)) *kendra.PutPrincipalMappingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.PutPrincipalMappingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.PutPrincipalMappingInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Query(ctx context.Context, params *kendra.QueryInput, optFns ...func(*kendra.Options)) (*kendra.QueryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *kendra.QueryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.QueryInput, ...func(*kendra.Options)) (*kendra.QueryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.QueryInput, ...func(*kendra.Options)) *kendra.QueryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.QueryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.QueryInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Retrieve provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) Retrieve(ctx context.Context, params *kendra.RetrieveInput, optFns ...func(*kendra.Options)) (*kendra.RetrieveOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Retrieve")
	}

	var r0 *kendra.RetrieveOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.RetrieveInput, ...func(*kendra.Options)) (*kendra.RetrieveOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.RetrieveInput, ...func(*kendra.Options)) *kendra.RetrieveOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.RetrieveOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.RetrieveInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartDataSourceSyncJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartDataSourceSyncJob(ctx context.Context, params *kendra.StartDataSourceSyncJobInput, optFns ...func(*kendra.Options)) (*kendra.StartDataSourceSyncJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartDataSourceSyncJob")
	}

	var r0 *kendra.StartDataSourceSyncJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.StartDataSourceSyncJobInput, ...func(*kendra.Options)) (*kendra.StartDataSourceSyncJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.StartDataSourceSyncJobInput, ...func(*kendra.Options)) *kendra.StartDataSourceSyncJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.StartDataSourceSyncJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.StartDataSourceSyncJobInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopDataSourceSyncJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StopDataSourceSyncJob(ctx context.Context, params *kendra.StopDataSourceSyncJobInput, optFns ...func(*kendra.Options)) (*kendra.StopDataSourceSyncJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopDataSourceSyncJob")
	}

	var r0 *kendra.StopDataSourceSyncJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.StopDataSourceSyncJobInput, ...func(*kendra.Options)) (*kendra.StopDataSourceSyncJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.StopDataSourceSyncJobInput, ...func(*kendra.Options)) *kendra.StopDataSourceSyncJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.StopDataSourceSyncJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.StopDataSourceSyncJobInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitFeedback provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SubmitFeedback(ctx context.Context, params *kendra.SubmitFeedbackInput, optFns ...func(*kendra.Options)) (*kendra.SubmitFeedbackOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubmitFeedback")
	}

	var r0 *kendra.SubmitFeedbackOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.SubmitFeedbackInput, ...func(*kendra.Options)) (*kendra.SubmitFeedbackOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.SubmitFeedbackInput, ...func(*kendra.Options)) *kendra.SubmitFeedbackOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.SubmitFeedbackOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.SubmitFeedbackInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *kendra.TagResourceInput, optFns ...func(*kendra.Options)) (*kendra.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *kendra.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.TagResourceInput, ...func(*kendra.Options)) (*kendra.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.TagResourceInput, ...func(*kendra.Options)) *kendra.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.TagResourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *kendra.UntagResourceInput, optFns ...func(*kendra.Options)) (*kendra.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *kendra.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UntagResourceInput, ...func(*kendra.Options)) (*kendra.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UntagResourceInput, ...func(*kendra.Options)) *kendra.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UntagResourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccessControlConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateAccessControlConfiguration(ctx context.Context, params *kendra.UpdateAccessControlConfigurationInput, optFns ...func(*kendra.Options)) (*kendra.UpdateAccessControlConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccessControlConfiguration")
	}

	var r0 *kendra.UpdateAccessControlConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateAccessControlConfigurationInput, ...func(*kendra.Options)) (*kendra.UpdateAccessControlConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateAccessControlConfigurationInput, ...func(*kendra.Options)) *kendra.UpdateAccessControlConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateAccessControlConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateAccessControlConfigurationInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateDataSource(ctx context.Context, params *kendra.UpdateDataSourceInput, optFns ...func(*kendra.Options)) (*kendra.UpdateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataSource")
	}

	var r0 *kendra.UpdateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateDataSourceInput, ...func(*kendra.Options)) (*kendra.UpdateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateDataSourceInput, ...func(*kendra.Options)) *kendra.UpdateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateDataSourceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateExperience provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateExperience(ctx context.Context, params *kendra.UpdateExperienceInput, optFns ...func(*kendra.Options)) (*kendra.UpdateExperienceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperience")
	}

	var r0 *kendra.UpdateExperienceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateExperienceInput, ...func(*kendra.Options)) (*kendra.UpdateExperienceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateExperienceInput, ...func(*kendra.Options)) *kendra.UpdateExperienceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateExperienceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateExperienceInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFeaturedResultsSet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateFeaturedResultsSet(ctx context.Context, params *kendra.UpdateFeaturedResultsSetInput, optFns ...func(*kendra.Options)) (*kendra.UpdateFeaturedResultsSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFeaturedResultsSet")
	}

	var r0 *kendra.UpdateFeaturedResultsSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateFeaturedResultsSetInput, ...func(*kendra.Options)) (*kendra.UpdateFeaturedResultsSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateFeaturedResultsSetInput, ...func(*kendra.Options)) *kendra.UpdateFeaturedResultsSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateFeaturedResultsSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateFeaturedResultsSetInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIndex provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateIndex(ctx context.Context, params *kendra.UpdateIndexInput, optFns ...func(*kendra.Options)) (*kendra.UpdateIndexOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIndex")
	}

	var r0 *kendra.UpdateIndexOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateIndexInput, ...func(*kendra.Options)) (*kendra.UpdateIndexOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateIndexInput, ...func(*kendra.Options)) *kendra.UpdateIndexOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateIndexOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateIndexInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuerySuggestionsBlockList provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQuerySuggestionsBlockList(ctx context.Context, params *kendra.UpdateQuerySuggestionsBlockListInput, optFns ...func(*kendra.Options)) (*kendra.UpdateQuerySuggestionsBlockListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQuerySuggestionsBlockList")
	}

	var r0 *kendra.UpdateQuerySuggestionsBlockListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) (*kendra.UpdateQuerySuggestionsBlockListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) *kendra.UpdateQuerySuggestionsBlockListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateQuerySuggestionsBlockListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateQuerySuggestionsBlockListInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuerySuggestionsConfig provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQuerySuggestionsConfig(ctx context.Context, params *kendra.UpdateQuerySuggestionsConfigInput, optFns ...func(*kendra.Options)) (*kendra.UpdateQuerySuggestionsConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQuerySuggestionsConfig")
	}

	var r0 *kendra.UpdateQuerySuggestionsConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateQuerySuggestionsConfigInput, ...func(*kendra.Options)) (*kendra.UpdateQuerySuggestionsConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateQuerySuggestionsConfigInput, ...func(*kendra.Options)) *kendra.UpdateQuerySuggestionsConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateQuerySuggestionsConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateQuerySuggestionsConfigInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateThesaurus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateThesaurus(ctx context.Context, params *kendra.UpdateThesaurusInput, optFns ...func(*kendra.Options)) (*kendra.UpdateThesaurusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateThesaurus")
	}

	var r0 *kendra.UpdateThesaurusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateThesaurusInput, ...func(*kendra.Options)) (*kendra.UpdateThesaurusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kendra.UpdateThesaurusInput, ...func(*kendra.Options)) *kendra.UpdateThesaurusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kendra.UpdateThesaurusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kendra.UpdateThesaurusInput, ...func(*kendra.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
