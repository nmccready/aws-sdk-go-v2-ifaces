// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	mturk "github.com/aws/aws-sdk-go-v2/service/mturk"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// AcceptQualificationRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AcceptQualificationRequest(ctx context.Context, params *mturk.AcceptQualificationRequestInput, optFns ...func(*mturk.Options)) (*mturk.AcceptQualificationRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptQualificationRequest")
	}

	var r0 *mturk.AcceptQualificationRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.AcceptQualificationRequestInput, ...func(*mturk.Options)) (*mturk.AcceptQualificationRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.AcceptQualificationRequestInput, ...func(*mturk.Options)) *mturk.AcceptQualificationRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.AcceptQualificationRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.AcceptQualificationRequestInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApproveAssignment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ApproveAssignment(ctx context.Context, params *mturk.ApproveAssignmentInput, optFns ...func(*mturk.Options)) (*mturk.ApproveAssignmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApproveAssignment")
	}

	var r0 *mturk.ApproveAssignmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ApproveAssignmentInput, ...func(*mturk.Options)) (*mturk.ApproveAssignmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ApproveAssignmentInput, ...func(*mturk.Options)) *mturk.ApproveAssignmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ApproveAssignmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ApproveAssignmentInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateQualificationWithWorker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) AssociateQualificationWithWorker(ctx context.Context, params *mturk.AssociateQualificationWithWorkerInput, optFns ...func(*mturk.Options)) (*mturk.AssociateQualificationWithWorkerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateQualificationWithWorker")
	}

	var r0 *mturk.AssociateQualificationWithWorkerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.AssociateQualificationWithWorkerInput, ...func(*mturk.Options)) (*mturk.AssociateQualificationWithWorkerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.AssociateQualificationWithWorkerInput, ...func(*mturk.Options)) *mturk.AssociateQualificationWithWorkerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.AssociateQualificationWithWorkerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.AssociateQualificationWithWorkerInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAdditionalAssignmentsForHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAdditionalAssignmentsForHIT(ctx context.Context, params *mturk.CreateAdditionalAssignmentsForHITInput, optFns ...func(*mturk.Options)) (*mturk.CreateAdditionalAssignmentsForHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAdditionalAssignmentsForHIT")
	}

	var r0 *mturk.CreateAdditionalAssignmentsForHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateAdditionalAssignmentsForHITInput, ...func(*mturk.Options)) (*mturk.CreateAdditionalAssignmentsForHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateAdditionalAssignmentsForHITInput, ...func(*mturk.Options)) *mturk.CreateAdditionalAssignmentsForHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateAdditionalAssignmentsForHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateAdditionalAssignmentsForHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateHIT(ctx context.Context, params *mturk.CreateHITInput, optFns ...func(*mturk.Options)) (*mturk.CreateHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHIT")
	}

	var r0 *mturk.CreateHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITInput, ...func(*mturk.Options)) (*mturk.CreateHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITInput, ...func(*mturk.Options)) *mturk.CreateHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHITType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateHITType(ctx context.Context, params *mturk.CreateHITTypeInput, optFns ...func(*mturk.Options)) (*mturk.CreateHITTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHITType")
	}

	var r0 *mturk.CreateHITTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITTypeInput, ...func(*mturk.Options)) (*mturk.CreateHITTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITTypeInput, ...func(*mturk.Options)) *mturk.CreateHITTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateHITTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateHITTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHITWithHITType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateHITWithHITType(ctx context.Context, params *mturk.CreateHITWithHITTypeInput, optFns ...func(*mturk.Options)) (*mturk.CreateHITWithHITTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHITWithHITType")
	}

	var r0 *mturk.CreateHITWithHITTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITWithHITTypeInput, ...func(*mturk.Options)) (*mturk.CreateHITWithHITTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateHITWithHITTypeInput, ...func(*mturk.Options)) *mturk.CreateHITWithHITTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateHITWithHITTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateHITWithHITTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateQualificationType(ctx context.Context, params *mturk.CreateQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.CreateQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateQualificationType")
	}

	var r0 *mturk.CreateQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateQualificationTypeInput, ...func(*mturk.Options)) (*mturk.CreateQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateQualificationTypeInput, ...func(*mturk.Options)) *mturk.CreateQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkerBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorkerBlock(ctx context.Context, params *mturk.CreateWorkerBlockInput, optFns ...func(*mturk.Options)) (*mturk.CreateWorkerBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkerBlock")
	}

	var r0 *mturk.CreateWorkerBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateWorkerBlockInput, ...func(*mturk.Options)) (*mturk.CreateWorkerBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.CreateWorkerBlockInput, ...func(*mturk.Options)) *mturk.CreateWorkerBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.CreateWorkerBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.CreateWorkerBlockInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteHIT(ctx context.Context, params *mturk.DeleteHITInput, optFns ...func(*mturk.Options)) (*mturk.DeleteHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHIT")
	}

	var r0 *mturk.DeleteHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteHITInput, ...func(*mturk.Options)) (*mturk.DeleteHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteHITInput, ...func(*mturk.Options)) *mturk.DeleteHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.DeleteHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.DeleteHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteQualificationType(ctx context.Context, params *mturk.DeleteQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.DeleteQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQualificationType")
	}

	var r0 *mturk.DeleteQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteQualificationTypeInput, ...func(*mturk.Options)) (*mturk.DeleteQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteQualificationTypeInput, ...func(*mturk.Options)) *mturk.DeleteQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.DeleteQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.DeleteQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorkerBlock provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorkerBlock(ctx context.Context, params *mturk.DeleteWorkerBlockInput, optFns ...func(*mturk.Options)) (*mturk.DeleteWorkerBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkerBlock")
	}

	var r0 *mturk.DeleteWorkerBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteWorkerBlockInput, ...func(*mturk.Options)) (*mturk.DeleteWorkerBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DeleteWorkerBlockInput, ...func(*mturk.Options)) *mturk.DeleteWorkerBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.DeleteWorkerBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.DeleteWorkerBlockInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateQualificationFromWorker provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DisassociateQualificationFromWorker(ctx context.Context, params *mturk.DisassociateQualificationFromWorkerInput, optFns ...func(*mturk.Options)) (*mturk.DisassociateQualificationFromWorkerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateQualificationFromWorker")
	}

	var r0 *mturk.DisassociateQualificationFromWorkerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DisassociateQualificationFromWorkerInput, ...func(*mturk.Options)) (*mturk.DisassociateQualificationFromWorkerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.DisassociateQualificationFromWorkerInput, ...func(*mturk.Options)) *mturk.DisassociateQualificationFromWorkerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.DisassociateQualificationFromWorkerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.DisassociateQualificationFromWorkerInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountBalance provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccountBalance(ctx context.Context, params *mturk.GetAccountBalanceInput, optFns ...func(*mturk.Options)) (*mturk.GetAccountBalanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountBalance")
	}

	var r0 *mturk.GetAccountBalanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetAccountBalanceInput, ...func(*mturk.Options)) (*mturk.GetAccountBalanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetAccountBalanceInput, ...func(*mturk.Options)) *mturk.GetAccountBalanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetAccountBalanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetAccountBalanceInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssignment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAssignment(ctx context.Context, params *mturk.GetAssignmentInput, optFns ...func(*mturk.Options)) (*mturk.GetAssignmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssignment")
	}

	var r0 *mturk.GetAssignmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetAssignmentInput, ...func(*mturk.Options)) (*mturk.GetAssignmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetAssignmentInput, ...func(*mturk.Options)) *mturk.GetAssignmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetAssignmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetAssignmentInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileUploadURL provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetFileUploadURL(ctx context.Context, params *mturk.GetFileUploadURLInput, optFns ...func(*mturk.Options)) (*mturk.GetFileUploadURLOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFileUploadURL")
	}

	var r0 *mturk.GetFileUploadURLOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetFileUploadURLInput, ...func(*mturk.Options)) (*mturk.GetFileUploadURLOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetFileUploadURLInput, ...func(*mturk.Options)) *mturk.GetFileUploadURLOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetFileUploadURLOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetFileUploadURLInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetHIT(ctx context.Context, params *mturk.GetHITInput, optFns ...func(*mturk.Options)) (*mturk.GetHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHIT")
	}

	var r0 *mturk.GetHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetHITInput, ...func(*mturk.Options)) (*mturk.GetHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetHITInput, ...func(*mturk.Options)) *mturk.GetHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQualificationScore provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQualificationScore(ctx context.Context, params *mturk.GetQualificationScoreInput, optFns ...func(*mturk.Options)) (*mturk.GetQualificationScoreOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQualificationScore")
	}

	var r0 *mturk.GetQualificationScoreOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetQualificationScoreInput, ...func(*mturk.Options)) (*mturk.GetQualificationScoreOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetQualificationScoreInput, ...func(*mturk.Options)) *mturk.GetQualificationScoreOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetQualificationScoreOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetQualificationScoreInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetQualificationType(ctx context.Context, params *mturk.GetQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.GetQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQualificationType")
	}

	var r0 *mturk.GetQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetQualificationTypeInput, ...func(*mturk.Options)) (*mturk.GetQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.GetQualificationTypeInput, ...func(*mturk.Options)) *mturk.GetQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.GetQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.GetQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssignmentsForHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAssignmentsForHIT(ctx context.Context, params *mturk.ListAssignmentsForHITInput, optFns ...func(*mturk.Options)) (*mturk.ListAssignmentsForHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssignmentsForHIT")
	}

	var r0 *mturk.ListAssignmentsForHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListAssignmentsForHITInput, ...func(*mturk.Options)) (*mturk.ListAssignmentsForHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListAssignmentsForHITInput, ...func(*mturk.Options)) *mturk.ListAssignmentsForHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListAssignmentsForHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListAssignmentsForHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBonusPayments provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListBonusPayments(ctx context.Context, params *mturk.ListBonusPaymentsInput, optFns ...func(*mturk.Options)) (*mturk.ListBonusPaymentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBonusPayments")
	}

	var r0 *mturk.ListBonusPaymentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListBonusPaymentsInput, ...func(*mturk.Options)) (*mturk.ListBonusPaymentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListBonusPaymentsInput, ...func(*mturk.Options)) *mturk.ListBonusPaymentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListBonusPaymentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListBonusPaymentsInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHITs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListHITs(ctx context.Context, params *mturk.ListHITsInput, optFns ...func(*mturk.Options)) (*mturk.ListHITsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListHITs")
	}

	var r0 *mturk.ListHITsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListHITsInput, ...func(*mturk.Options)) (*mturk.ListHITsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListHITsInput, ...func(*mturk.Options)) *mturk.ListHITsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListHITsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListHITsInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHITsForQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListHITsForQualificationType(ctx context.Context, params *mturk.ListHITsForQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.ListHITsForQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListHITsForQualificationType")
	}

	var r0 *mturk.ListHITsForQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListHITsForQualificationTypeInput, ...func(*mturk.Options)) (*mturk.ListHITsForQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListHITsForQualificationTypeInput, ...func(*mturk.Options)) *mturk.ListHITsForQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListHITsForQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListHITsForQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQualificationRequests provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQualificationRequests(ctx context.Context, params *mturk.ListQualificationRequestsInput, optFns ...func(*mturk.Options)) (*mturk.ListQualificationRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQualificationRequests")
	}

	var r0 *mturk.ListQualificationRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListQualificationRequestsInput, ...func(*mturk.Options)) (*mturk.ListQualificationRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListQualificationRequestsInput, ...func(*mturk.Options)) *mturk.ListQualificationRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListQualificationRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListQualificationRequestsInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListQualificationTypes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListQualificationTypes(ctx context.Context, params *mturk.ListQualificationTypesInput, optFns ...func(*mturk.Options)) (*mturk.ListQualificationTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListQualificationTypes")
	}

	var r0 *mturk.ListQualificationTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListQualificationTypesInput, ...func(*mturk.Options)) (*mturk.ListQualificationTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListQualificationTypesInput, ...func(*mturk.Options)) *mturk.ListQualificationTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListQualificationTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListQualificationTypesInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReviewPolicyResultsForHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReviewPolicyResultsForHIT(ctx context.Context, params *mturk.ListReviewPolicyResultsForHITInput, optFns ...func(*mturk.Options)) (*mturk.ListReviewPolicyResultsForHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReviewPolicyResultsForHIT")
	}

	var r0 *mturk.ListReviewPolicyResultsForHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListReviewPolicyResultsForHITInput, ...func(*mturk.Options)) (*mturk.ListReviewPolicyResultsForHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListReviewPolicyResultsForHITInput, ...func(*mturk.Options)) *mturk.ListReviewPolicyResultsForHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListReviewPolicyResultsForHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListReviewPolicyResultsForHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReviewableHITs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListReviewableHITs(ctx context.Context, params *mturk.ListReviewableHITsInput, optFns ...func(*mturk.Options)) (*mturk.ListReviewableHITsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReviewableHITs")
	}

	var r0 *mturk.ListReviewableHITsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListReviewableHITsInput, ...func(*mturk.Options)) (*mturk.ListReviewableHITsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListReviewableHITsInput, ...func(*mturk.Options)) *mturk.ListReviewableHITsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListReviewableHITsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListReviewableHITsInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkerBlocks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkerBlocks(ctx context.Context, params *mturk.ListWorkerBlocksInput, optFns ...func(*mturk.Options)) (*mturk.ListWorkerBlocksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkerBlocks")
	}

	var r0 *mturk.ListWorkerBlocksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListWorkerBlocksInput, ...func(*mturk.Options)) (*mturk.ListWorkerBlocksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListWorkerBlocksInput, ...func(*mturk.Options)) *mturk.ListWorkerBlocksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListWorkerBlocksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListWorkerBlocksInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkersWithQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorkersWithQualificationType(ctx context.Context, params *mturk.ListWorkersWithQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.ListWorkersWithQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkersWithQualificationType")
	}

	var r0 *mturk.ListWorkersWithQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListWorkersWithQualificationTypeInput, ...func(*mturk.Options)) (*mturk.ListWorkersWithQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.ListWorkersWithQualificationTypeInput, ...func(*mturk.Options)) *mturk.ListWorkersWithQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.ListWorkersWithQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.ListWorkersWithQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyWorkers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) NotifyWorkers(ctx context.Context, params *mturk.NotifyWorkersInput, optFns ...func(*mturk.Options)) (*mturk.NotifyWorkersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotifyWorkers")
	}

	var r0 *mturk.NotifyWorkersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.NotifyWorkersInput, ...func(*mturk.Options)) (*mturk.NotifyWorkersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.NotifyWorkersInput, ...func(*mturk.Options)) *mturk.NotifyWorkersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.NotifyWorkersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.NotifyWorkersInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() mturk.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 mturk.Options
	if rf, ok := ret.Get(0).(func() mturk.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(mturk.Options)
	}

	return r0
}

// RejectAssignment provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectAssignment(ctx context.Context, params *mturk.RejectAssignmentInput, optFns ...func(*mturk.Options)) (*mturk.RejectAssignmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectAssignment")
	}

	var r0 *mturk.RejectAssignmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.RejectAssignmentInput, ...func(*mturk.Options)) (*mturk.RejectAssignmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.RejectAssignmentInput, ...func(*mturk.Options)) *mturk.RejectAssignmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.RejectAssignmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.RejectAssignmentInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectQualificationRequest provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectQualificationRequest(ctx context.Context, params *mturk.RejectQualificationRequestInput, optFns ...func(*mturk.Options)) (*mturk.RejectQualificationRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectQualificationRequest")
	}

	var r0 *mturk.RejectQualificationRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.RejectQualificationRequestInput, ...func(*mturk.Options)) (*mturk.RejectQualificationRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.RejectQualificationRequestInput, ...func(*mturk.Options)) *mturk.RejectQualificationRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.RejectQualificationRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.RejectQualificationRequestInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendBonus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendBonus(ctx context.Context, params *mturk.SendBonusInput, optFns ...func(*mturk.Options)) (*mturk.SendBonusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendBonus")
	}

	var r0 *mturk.SendBonusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.SendBonusInput, ...func(*mturk.Options)) (*mturk.SendBonusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.SendBonusInput, ...func(*mturk.Options)) *mturk.SendBonusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.SendBonusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.SendBonusInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTestEventNotification provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SendTestEventNotification(ctx context.Context, params *mturk.SendTestEventNotificationInput, optFns ...func(*mturk.Options)) (*mturk.SendTestEventNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTestEventNotification")
	}

	var r0 *mturk.SendTestEventNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.SendTestEventNotificationInput, ...func(*mturk.Options)) (*mturk.SendTestEventNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.SendTestEventNotificationInput, ...func(*mturk.Options)) *mturk.SendTestEventNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.SendTestEventNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.SendTestEventNotificationInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateExpirationForHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateExpirationForHIT(ctx context.Context, params *mturk.UpdateExpirationForHITInput, optFns ...func(*mturk.Options)) (*mturk.UpdateExpirationForHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExpirationForHIT")
	}

	var r0 *mturk.UpdateExpirationForHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateExpirationForHITInput, ...func(*mturk.Options)) (*mturk.UpdateExpirationForHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateExpirationForHITInput, ...func(*mturk.Options)) *mturk.UpdateExpirationForHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.UpdateExpirationForHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.UpdateExpirationForHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHITReviewStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateHITReviewStatus(ctx context.Context, params *mturk.UpdateHITReviewStatusInput, optFns ...func(*mturk.Options)) (*mturk.UpdateHITReviewStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHITReviewStatus")
	}

	var r0 *mturk.UpdateHITReviewStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateHITReviewStatusInput, ...func(*mturk.Options)) (*mturk.UpdateHITReviewStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateHITReviewStatusInput, ...func(*mturk.Options)) *mturk.UpdateHITReviewStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.UpdateHITReviewStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.UpdateHITReviewStatusInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHITTypeOfHIT provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateHITTypeOfHIT(ctx context.Context, params *mturk.UpdateHITTypeOfHITInput, optFns ...func(*mturk.Options)) (*mturk.UpdateHITTypeOfHITOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHITTypeOfHIT")
	}

	var r0 *mturk.UpdateHITTypeOfHITOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateHITTypeOfHITInput, ...func(*mturk.Options)) (*mturk.UpdateHITTypeOfHITOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateHITTypeOfHITInput, ...func(*mturk.Options)) *mturk.UpdateHITTypeOfHITOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.UpdateHITTypeOfHITOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.UpdateHITTypeOfHITInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNotificationSettings provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateNotificationSettings(ctx context.Context, params *mturk.UpdateNotificationSettingsInput, optFns ...func(*mturk.Options)) (*mturk.UpdateNotificationSettingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNotificationSettings")
	}

	var r0 *mturk.UpdateNotificationSettingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateNotificationSettingsInput, ...func(*mturk.Options)) (*mturk.UpdateNotificationSettingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateNotificationSettingsInput, ...func(*mturk.Options)) *mturk.UpdateNotificationSettingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.UpdateNotificationSettingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.UpdateNotificationSettingsInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQualificationType provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateQualificationType(ctx context.Context, params *mturk.UpdateQualificationTypeInput, optFns ...func(*mturk.Options)) (*mturk.UpdateQualificationTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateQualificationType")
	}

	var r0 *mturk.UpdateQualificationTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateQualificationTypeInput, ...func(*mturk.Options)) (*mturk.UpdateQualificationTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *mturk.UpdateQualificationTypeInput, ...func(*mturk.Options)) *mturk.UpdateQualificationTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mturk.UpdateQualificationTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *mturk.UpdateQualificationTypeInput, ...func(*mturk.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
