// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	robomaker "github.com/aws/aws-sdk-go-v2/service/robomaker"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// BatchDeleteWorlds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDeleteWorlds(ctx context.Context, params *robomaker.BatchDeleteWorldsInput, optFns ...func(*robomaker.Options)) (*robomaker.BatchDeleteWorldsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDeleteWorlds")
	}

	var r0 *robomaker.BatchDeleteWorldsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.BatchDeleteWorldsInput, ...func(*robomaker.Options)) (*robomaker.BatchDeleteWorldsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.BatchDeleteWorldsInput, ...func(*robomaker.Options)) *robomaker.BatchDeleteWorldsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.BatchDeleteWorldsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.BatchDeleteWorldsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDescribeSimulationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) BatchDescribeSimulationJob(ctx context.Context, params *robomaker.BatchDescribeSimulationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.BatchDescribeSimulationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchDescribeSimulationJob")
	}

	var r0 *robomaker.BatchDescribeSimulationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.BatchDescribeSimulationJobInput, ...func(*robomaker.Options)) (*robomaker.BatchDescribeSimulationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.BatchDescribeSimulationJobInput, ...func(*robomaker.Options)) *robomaker.BatchDescribeSimulationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.BatchDescribeSimulationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.BatchDescribeSimulationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelDeploymentJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelDeploymentJob(ctx context.Context, params *robomaker.CancelDeploymentJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CancelDeploymentJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelDeploymentJob")
	}

	var r0 *robomaker.CancelDeploymentJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelDeploymentJobInput, ...func(*robomaker.Options)) (*robomaker.CancelDeploymentJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelDeploymentJobInput, ...func(*robomaker.Options)) *robomaker.CancelDeploymentJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CancelDeploymentJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CancelDeploymentJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSimulationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSimulationJob(ctx context.Context, params *robomaker.CancelSimulationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CancelSimulationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSimulationJob")
	}

	var r0 *robomaker.CancelSimulationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelSimulationJobInput, ...func(*robomaker.Options)) (*robomaker.CancelSimulationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelSimulationJobInput, ...func(*robomaker.Options)) *robomaker.CancelSimulationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CancelSimulationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CancelSimulationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSimulationJobBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelSimulationJobBatch(ctx context.Context, params *robomaker.CancelSimulationJobBatchInput, optFns ...func(*robomaker.Options)) (*robomaker.CancelSimulationJobBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSimulationJobBatch")
	}

	var r0 *robomaker.CancelSimulationJobBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelSimulationJobBatchInput, ...func(*robomaker.Options)) (*robomaker.CancelSimulationJobBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelSimulationJobBatchInput, ...func(*robomaker.Options)) *robomaker.CancelSimulationJobBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CancelSimulationJobBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CancelSimulationJobBatchInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelWorldExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelWorldExportJob(ctx context.Context, params *robomaker.CancelWorldExportJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CancelWorldExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelWorldExportJob")
	}

	var r0 *robomaker.CancelWorldExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelWorldExportJobInput, ...func(*robomaker.Options)) (*robomaker.CancelWorldExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelWorldExportJobInput, ...func(*robomaker.Options)) *robomaker.CancelWorldExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CancelWorldExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CancelWorldExportJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelWorldGenerationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CancelWorldGenerationJob(ctx context.Context, params *robomaker.CancelWorldGenerationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CancelWorldGenerationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelWorldGenerationJob")
	}

	var r0 *robomaker.CancelWorldGenerationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelWorldGenerationJobInput, ...func(*robomaker.Options)) (*robomaker.CancelWorldGenerationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CancelWorldGenerationJobInput, ...func(*robomaker.Options)) *robomaker.CancelWorldGenerationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CancelWorldGenerationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CancelWorldGenerationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDeploymentJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateDeploymentJob(ctx context.Context, params *robomaker.CreateDeploymentJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateDeploymentJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDeploymentJob")
	}

	var r0 *robomaker.CreateDeploymentJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateDeploymentJobInput, ...func(*robomaker.Options)) (*robomaker.CreateDeploymentJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateDeploymentJobInput, ...func(*robomaker.Options)) *robomaker.CreateDeploymentJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateDeploymentJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateDeploymentJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateFleet(ctx context.Context, params *robomaker.CreateFleetInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleet")
	}

	var r0 *robomaker.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateFleetInput, ...func(*robomaker.Options)) (*robomaker.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateFleetInput, ...func(*robomaker.Options)) *robomaker.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateFleetInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRobot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRobot(ctx context.Context, params *robomaker.CreateRobotInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateRobotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRobot")
	}

	var r0 *robomaker.CreateRobotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotInput, ...func(*robomaker.Options)) (*robomaker.CreateRobotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotInput, ...func(*robomaker.Options)) *robomaker.CreateRobotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateRobotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateRobotInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRobotApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRobotApplication(ctx context.Context, params *robomaker.CreateRobotApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateRobotApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRobotApplication")
	}

	var r0 *robomaker.CreateRobotApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotApplicationInput, ...func(*robomaker.Options)) (*robomaker.CreateRobotApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotApplicationInput, ...func(*robomaker.Options)) *robomaker.CreateRobotApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateRobotApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateRobotApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRobotApplicationVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateRobotApplicationVersion(ctx context.Context, params *robomaker.CreateRobotApplicationVersionInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateRobotApplicationVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRobotApplicationVersion")
	}

	var r0 *robomaker.CreateRobotApplicationVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotApplicationVersionInput, ...func(*robomaker.Options)) (*robomaker.CreateRobotApplicationVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateRobotApplicationVersionInput, ...func(*robomaker.Options)) *robomaker.CreateRobotApplicationVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateRobotApplicationVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateRobotApplicationVersionInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSimulationApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSimulationApplication(ctx context.Context, params *robomaker.CreateSimulationApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateSimulationApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSimulationApplication")
	}

	var r0 *robomaker.CreateSimulationApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationApplicationInput, ...func(*robomaker.Options)) (*robomaker.CreateSimulationApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationApplicationInput, ...func(*robomaker.Options)) *robomaker.CreateSimulationApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateSimulationApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateSimulationApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSimulationApplicationVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSimulationApplicationVersion(ctx context.Context, params *robomaker.CreateSimulationApplicationVersionInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateSimulationApplicationVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSimulationApplicationVersion")
	}

	var r0 *robomaker.CreateSimulationApplicationVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationApplicationVersionInput, ...func(*robomaker.Options)) (*robomaker.CreateSimulationApplicationVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationApplicationVersionInput, ...func(*robomaker.Options)) *robomaker.CreateSimulationApplicationVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateSimulationApplicationVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateSimulationApplicationVersionInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSimulationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateSimulationJob(ctx context.Context, params *robomaker.CreateSimulationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateSimulationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSimulationJob")
	}

	var r0 *robomaker.CreateSimulationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationJobInput, ...func(*robomaker.Options)) (*robomaker.CreateSimulationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateSimulationJobInput, ...func(*robomaker.Options)) *robomaker.CreateSimulationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateSimulationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateSimulationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorldExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorldExportJob(ctx context.Context, params *robomaker.CreateWorldExportJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateWorldExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorldExportJob")
	}

	var r0 *robomaker.CreateWorldExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldExportJobInput, ...func(*robomaker.Options)) (*robomaker.CreateWorldExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldExportJobInput, ...func(*robomaker.Options)) *robomaker.CreateWorldExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateWorldExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateWorldExportJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorldGenerationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorldGenerationJob(ctx context.Context, params *robomaker.CreateWorldGenerationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateWorldGenerationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorldGenerationJob")
	}

	var r0 *robomaker.CreateWorldGenerationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldGenerationJobInput, ...func(*robomaker.Options)) (*robomaker.CreateWorldGenerationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldGenerationJobInput, ...func(*robomaker.Options)) *robomaker.CreateWorldGenerationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateWorldGenerationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateWorldGenerationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorldTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateWorldTemplate(ctx context.Context, params *robomaker.CreateWorldTemplateInput, optFns ...func(*robomaker.Options)) (*robomaker.CreateWorldTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorldTemplate")
	}

	var r0 *robomaker.CreateWorldTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldTemplateInput, ...func(*robomaker.Options)) (*robomaker.CreateWorldTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.CreateWorldTemplateInput, ...func(*robomaker.Options)) *robomaker.CreateWorldTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.CreateWorldTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.CreateWorldTemplateInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteFleet(ctx context.Context, params *robomaker.DeleteFleetInput, optFns ...func(*robomaker.Options)) (*robomaker.DeleteFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleet")
	}

	var r0 *robomaker.DeleteFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteFleetInput, ...func(*robomaker.Options)) (*robomaker.DeleteFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteFleetInput, ...func(*robomaker.Options)) *robomaker.DeleteFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeleteFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeleteFleetInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRobot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRobot(ctx context.Context, params *robomaker.DeleteRobotInput, optFns ...func(*robomaker.Options)) (*robomaker.DeleteRobotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRobot")
	}

	var r0 *robomaker.DeleteRobotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteRobotInput, ...func(*robomaker.Options)) (*robomaker.DeleteRobotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteRobotInput, ...func(*robomaker.Options)) *robomaker.DeleteRobotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeleteRobotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeleteRobotInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRobotApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteRobotApplication(ctx context.Context, params *robomaker.DeleteRobotApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.DeleteRobotApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRobotApplication")
	}

	var r0 *robomaker.DeleteRobotApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteRobotApplicationInput, ...func(*robomaker.Options)) (*robomaker.DeleteRobotApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteRobotApplicationInput, ...func(*robomaker.Options)) *robomaker.DeleteRobotApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeleteRobotApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeleteRobotApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSimulationApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteSimulationApplication(ctx context.Context, params *robomaker.DeleteSimulationApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.DeleteSimulationApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSimulationApplication")
	}

	var r0 *robomaker.DeleteSimulationApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteSimulationApplicationInput, ...func(*robomaker.Options)) (*robomaker.DeleteSimulationApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteSimulationApplicationInput, ...func(*robomaker.Options)) *robomaker.DeleteSimulationApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeleteSimulationApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeleteSimulationApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWorldTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteWorldTemplate(ctx context.Context, params *robomaker.DeleteWorldTemplateInput, optFns ...func(*robomaker.Options)) (*robomaker.DeleteWorldTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorldTemplate")
	}

	var r0 *robomaker.DeleteWorldTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteWorldTemplateInput, ...func(*robomaker.Options)) (*robomaker.DeleteWorldTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeleteWorldTemplateInput, ...func(*robomaker.Options)) *robomaker.DeleteWorldTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeleteWorldTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeleteWorldTemplateInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterRobot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeregisterRobot(ctx context.Context, params *robomaker.DeregisterRobotInput, optFns ...func(*robomaker.Options)) (*robomaker.DeregisterRobotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterRobot")
	}

	var r0 *robomaker.DeregisterRobotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeregisterRobotInput, ...func(*robomaker.Options)) (*robomaker.DeregisterRobotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DeregisterRobotInput, ...func(*robomaker.Options)) *robomaker.DeregisterRobotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DeregisterRobotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DeregisterRobotInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDeploymentJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeDeploymentJob(ctx context.Context, params *robomaker.DescribeDeploymentJobInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeDeploymentJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDeploymentJob")
	}

	var r0 *robomaker.DescribeDeploymentJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeDeploymentJobInput, ...func(*robomaker.Options)) (*robomaker.DescribeDeploymentJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeDeploymentJobInput, ...func(*robomaker.Options)) *robomaker.DescribeDeploymentJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeDeploymentJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeDeploymentJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleet provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeFleet(ctx context.Context, params *robomaker.DescribeFleetInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleet")
	}

	var r0 *robomaker.DescribeFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeFleetInput, ...func(*robomaker.Options)) (*robomaker.DescribeFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeFleetInput, ...func(*robomaker.Options)) *robomaker.DescribeFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeFleetInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRobot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRobot(ctx context.Context, params *robomaker.DescribeRobotInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeRobotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRobot")
	}

	var r0 *robomaker.DescribeRobotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeRobotInput, ...func(*robomaker.Options)) (*robomaker.DescribeRobotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeRobotInput, ...func(*robomaker.Options)) *robomaker.DescribeRobotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeRobotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeRobotInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRobotApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeRobotApplication(ctx context.Context, params *robomaker.DescribeRobotApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeRobotApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRobotApplication")
	}

	var r0 *robomaker.DescribeRobotApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeRobotApplicationInput, ...func(*robomaker.Options)) (*robomaker.DescribeRobotApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeRobotApplicationInput, ...func(*robomaker.Options)) *robomaker.DescribeRobotApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeRobotApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeRobotApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSimulationApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSimulationApplication(ctx context.Context, params *robomaker.DescribeSimulationApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeSimulationApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSimulationApplication")
	}

	var r0 *robomaker.DescribeSimulationApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationApplicationInput, ...func(*robomaker.Options)) (*robomaker.DescribeSimulationApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationApplicationInput, ...func(*robomaker.Options)) *robomaker.DescribeSimulationApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeSimulationApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeSimulationApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSimulationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSimulationJob(ctx context.Context, params *robomaker.DescribeSimulationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeSimulationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSimulationJob")
	}

	var r0 *robomaker.DescribeSimulationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationJobInput, ...func(*robomaker.Options)) (*robomaker.DescribeSimulationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationJobInput, ...func(*robomaker.Options)) *robomaker.DescribeSimulationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeSimulationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeSimulationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSimulationJobBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeSimulationJobBatch(ctx context.Context, params *robomaker.DescribeSimulationJobBatchInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeSimulationJobBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSimulationJobBatch")
	}

	var r0 *robomaker.DescribeSimulationJobBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationJobBatchInput, ...func(*robomaker.Options)) (*robomaker.DescribeSimulationJobBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeSimulationJobBatchInput, ...func(*robomaker.Options)) *robomaker.DescribeSimulationJobBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeSimulationJobBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeSimulationJobBatchInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorld provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorld(ctx context.Context, params *robomaker.DescribeWorldInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeWorldOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorld")
	}

	var r0 *robomaker.DescribeWorldOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldInput, ...func(*robomaker.Options)) (*robomaker.DescribeWorldOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldInput, ...func(*robomaker.Options)) *robomaker.DescribeWorldOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeWorldOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeWorldInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorldExportJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorldExportJob(ctx context.Context, params *robomaker.DescribeWorldExportJobInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeWorldExportJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorldExportJob")
	}

	var r0 *robomaker.DescribeWorldExportJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldExportJobInput, ...func(*robomaker.Options)) (*robomaker.DescribeWorldExportJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldExportJobInput, ...func(*robomaker.Options)) *robomaker.DescribeWorldExportJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeWorldExportJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeWorldExportJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorldGenerationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorldGenerationJob(ctx context.Context, params *robomaker.DescribeWorldGenerationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeWorldGenerationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorldGenerationJob")
	}

	var r0 *robomaker.DescribeWorldGenerationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldGenerationJobInput, ...func(*robomaker.Options)) (*robomaker.DescribeWorldGenerationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldGenerationJobInput, ...func(*robomaker.Options)) *robomaker.DescribeWorldGenerationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeWorldGenerationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeWorldGenerationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorldTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DescribeWorldTemplate(ctx context.Context, params *robomaker.DescribeWorldTemplateInput, optFns ...func(*robomaker.Options)) (*robomaker.DescribeWorldTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorldTemplate")
	}

	var r0 *robomaker.DescribeWorldTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldTemplateInput, ...func(*robomaker.Options)) (*robomaker.DescribeWorldTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.DescribeWorldTemplateInput, ...func(*robomaker.Options)) *robomaker.DescribeWorldTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.DescribeWorldTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.DescribeWorldTemplateInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorldTemplateBody provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetWorldTemplateBody(ctx context.Context, params *robomaker.GetWorldTemplateBodyInput, optFns ...func(*robomaker.Options)) (*robomaker.GetWorldTemplateBodyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorldTemplateBody")
	}

	var r0 *robomaker.GetWorldTemplateBodyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.GetWorldTemplateBodyInput, ...func(*robomaker.Options)) (*robomaker.GetWorldTemplateBodyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.GetWorldTemplateBodyInput, ...func(*robomaker.Options)) *robomaker.GetWorldTemplateBodyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.GetWorldTemplateBodyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.GetWorldTemplateBodyInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDeploymentJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListDeploymentJobs(ctx context.Context, params *robomaker.ListDeploymentJobsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListDeploymentJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDeploymentJobs")
	}

	var r0 *robomaker.ListDeploymentJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListDeploymentJobsInput, ...func(*robomaker.Options)) (*robomaker.ListDeploymentJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListDeploymentJobsInput, ...func(*robomaker.Options)) *robomaker.ListDeploymentJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListDeploymentJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListDeploymentJobsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFleets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListFleets(ctx context.Context, params *robomaker.ListFleetsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFleets")
	}

	var r0 *robomaker.ListFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListFleetsInput, ...func(*robomaker.Options)) (*robomaker.ListFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListFleetsInput, ...func(*robomaker.Options)) *robomaker.ListFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListFleetsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRobotApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRobotApplications(ctx context.Context, params *robomaker.ListRobotApplicationsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListRobotApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRobotApplications")
	}

	var r0 *robomaker.ListRobotApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListRobotApplicationsInput, ...func(*robomaker.Options)) (*robomaker.ListRobotApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListRobotApplicationsInput, ...func(*robomaker.Options)) *robomaker.ListRobotApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListRobotApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListRobotApplicationsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRobots provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListRobots(ctx context.Context, params *robomaker.ListRobotsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListRobotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRobots")
	}

	var r0 *robomaker.ListRobotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListRobotsInput, ...func(*robomaker.Options)) (*robomaker.ListRobotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListRobotsInput, ...func(*robomaker.Options)) *robomaker.ListRobotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListRobotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListRobotsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSimulationApplications provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSimulationApplications(ctx context.Context, params *robomaker.ListSimulationApplicationsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListSimulationApplicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSimulationApplications")
	}

	var r0 *robomaker.ListSimulationApplicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationApplicationsInput, ...func(*robomaker.Options)) (*robomaker.ListSimulationApplicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationApplicationsInput, ...func(*robomaker.Options)) *robomaker.ListSimulationApplicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListSimulationApplicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListSimulationApplicationsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSimulationJobBatches provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSimulationJobBatches(ctx context.Context, params *robomaker.ListSimulationJobBatchesInput, optFns ...func(*robomaker.Options)) (*robomaker.ListSimulationJobBatchesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSimulationJobBatches")
	}

	var r0 *robomaker.ListSimulationJobBatchesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationJobBatchesInput, ...func(*robomaker.Options)) (*robomaker.ListSimulationJobBatchesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationJobBatchesInput, ...func(*robomaker.Options)) *robomaker.ListSimulationJobBatchesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListSimulationJobBatchesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListSimulationJobBatchesInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSimulationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListSimulationJobs(ctx context.Context, params *robomaker.ListSimulationJobsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListSimulationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSimulationJobs")
	}

	var r0 *robomaker.ListSimulationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationJobsInput, ...func(*robomaker.Options)) (*robomaker.ListSimulationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListSimulationJobsInput, ...func(*robomaker.Options)) *robomaker.ListSimulationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListSimulationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListSimulationJobsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *robomaker.ListTagsForResourceInput, optFns ...func(*robomaker.Options)) (*robomaker.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *robomaker.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListTagsForResourceInput, ...func(*robomaker.Options)) (*robomaker.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListTagsForResourceInput, ...func(*robomaker.Options)) *robomaker.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListTagsForResourceInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorldExportJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorldExportJobs(ctx context.Context, params *robomaker.ListWorldExportJobsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListWorldExportJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorldExportJobs")
	}

	var r0 *robomaker.ListWorldExportJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldExportJobsInput, ...func(*robomaker.Options)) (*robomaker.ListWorldExportJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldExportJobsInput, ...func(*robomaker.Options)) *robomaker.ListWorldExportJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListWorldExportJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListWorldExportJobsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorldGenerationJobs provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorldGenerationJobs(ctx context.Context, params *robomaker.ListWorldGenerationJobsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListWorldGenerationJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorldGenerationJobs")
	}

	var r0 *robomaker.ListWorldGenerationJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldGenerationJobsInput, ...func(*robomaker.Options)) (*robomaker.ListWorldGenerationJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldGenerationJobsInput, ...func(*robomaker.Options)) *robomaker.ListWorldGenerationJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListWorldGenerationJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListWorldGenerationJobsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorldTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorldTemplates(ctx context.Context, params *robomaker.ListWorldTemplatesInput, optFns ...func(*robomaker.Options)) (*robomaker.ListWorldTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorldTemplates")
	}

	var r0 *robomaker.ListWorldTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldTemplatesInput, ...func(*robomaker.Options)) (*robomaker.ListWorldTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldTemplatesInput, ...func(*robomaker.Options)) *robomaker.ListWorldTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListWorldTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListWorldTemplatesInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorlds provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListWorlds(ctx context.Context, params *robomaker.ListWorldsInput, optFns ...func(*robomaker.Options)) (*robomaker.ListWorldsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorlds")
	}

	var r0 *robomaker.ListWorldsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldsInput, ...func(*robomaker.Options)) (*robomaker.ListWorldsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.ListWorldsInput, ...func(*robomaker.Options)) *robomaker.ListWorldsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.ListWorldsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.ListWorldsInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() robomaker.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 robomaker.Options
	if rf, ok := ret.Get(0).(func() robomaker.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(robomaker.Options)
	}

	return r0
}

// RegisterRobot provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RegisterRobot(ctx context.Context, params *robomaker.RegisterRobotInput, optFns ...func(*robomaker.Options)) (*robomaker.RegisterRobotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterRobot")
	}

	var r0 *robomaker.RegisterRobotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.RegisterRobotInput, ...func(*robomaker.Options)) (*robomaker.RegisterRobotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.RegisterRobotInput, ...func(*robomaker.Options)) *robomaker.RegisterRobotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.RegisterRobotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.RegisterRobotInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartSimulationJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RestartSimulationJob(ctx context.Context, params *robomaker.RestartSimulationJobInput, optFns ...func(*robomaker.Options)) (*robomaker.RestartSimulationJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestartSimulationJob")
	}

	var r0 *robomaker.RestartSimulationJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.RestartSimulationJobInput, ...func(*robomaker.Options)) (*robomaker.RestartSimulationJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.RestartSimulationJobInput, ...func(*robomaker.Options)) *robomaker.RestartSimulationJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.RestartSimulationJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.RestartSimulationJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartSimulationJobBatch provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) StartSimulationJobBatch(ctx context.Context, params *robomaker.StartSimulationJobBatchInput, optFns ...func(*robomaker.Options)) (*robomaker.StartSimulationJobBatchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartSimulationJobBatch")
	}

	var r0 *robomaker.StartSimulationJobBatchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.StartSimulationJobBatchInput, ...func(*robomaker.Options)) (*robomaker.StartSimulationJobBatchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.StartSimulationJobBatchInput, ...func(*robomaker.Options)) *robomaker.StartSimulationJobBatchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.StartSimulationJobBatchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.StartSimulationJobBatchInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncDeploymentJob provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) SyncDeploymentJob(ctx context.Context, params *robomaker.SyncDeploymentJobInput, optFns ...func(*robomaker.Options)) (*robomaker.SyncDeploymentJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SyncDeploymentJob")
	}

	var r0 *robomaker.SyncDeploymentJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.SyncDeploymentJobInput, ...func(*robomaker.Options)) (*robomaker.SyncDeploymentJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.SyncDeploymentJobInput, ...func(*robomaker.Options)) *robomaker.SyncDeploymentJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.SyncDeploymentJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.SyncDeploymentJobInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *robomaker.TagResourceInput, optFns ...func(*robomaker.Options)) (*robomaker.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *robomaker.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.TagResourceInput, ...func(*robomaker.Options)) (*robomaker.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.TagResourceInput, ...func(*robomaker.Options)) *robomaker.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.TagResourceInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *robomaker.UntagResourceInput, optFns ...func(*robomaker.Options)) (*robomaker.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *robomaker.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UntagResourceInput, ...func(*robomaker.Options)) (*robomaker.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UntagResourceInput, ...func(*robomaker.Options)) *robomaker.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.UntagResourceInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRobotApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateRobotApplication(ctx context.Context, params *robomaker.UpdateRobotApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.UpdateRobotApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRobotApplication")
	}

	var r0 *robomaker.UpdateRobotApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateRobotApplicationInput, ...func(*robomaker.Options)) (*robomaker.UpdateRobotApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateRobotApplicationInput, ...func(*robomaker.Options)) *robomaker.UpdateRobotApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.UpdateRobotApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.UpdateRobotApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSimulationApplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateSimulationApplication(ctx context.Context, params *robomaker.UpdateSimulationApplicationInput, optFns ...func(*robomaker.Options)) (*robomaker.UpdateSimulationApplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSimulationApplication")
	}

	var r0 *robomaker.UpdateSimulationApplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateSimulationApplicationInput, ...func(*robomaker.Options)) (*robomaker.UpdateSimulationApplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateSimulationApplicationInput, ...func(*robomaker.Options)) *robomaker.UpdateSimulationApplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.UpdateSimulationApplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.UpdateSimulationApplicationInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWorldTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateWorldTemplate(ctx context.Context, params *robomaker.UpdateWorldTemplateInput, optFns ...func(*robomaker.Options)) (*robomaker.UpdateWorldTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorldTemplate")
	}

	var r0 *robomaker.UpdateWorldTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateWorldTemplateInput, ...func(*robomaker.Options)) (*robomaker.UpdateWorldTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *robomaker.UpdateWorldTemplateInput, ...func(*robomaker.Options)) *robomaker.UpdateWorldTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*robomaker.UpdateWorldTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *robomaker.UpdateWorldTemplateInput, ...func(*robomaker.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
