// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	managedblockchain "github.com/aws/aws-sdk-go-v2/service/managedblockchain"

	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateAccessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateAccessor(ctx context.Context, params *managedblockchain.CreateAccessorInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.CreateAccessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessor")
	}

	var r0 *managedblockchain.CreateAccessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateAccessorInput, ...func(*managedblockchain.Options)) (*managedblockchain.CreateAccessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateAccessorInput, ...func(*managedblockchain.Options)) *managedblockchain.CreateAccessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.CreateAccessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.CreateAccessorInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateMember(ctx context.Context, params *managedblockchain.CreateMemberInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.CreateMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMember")
	}

	var r0 *managedblockchain.CreateMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateMemberInput, ...func(*managedblockchain.Options)) (*managedblockchain.CreateMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateMemberInput, ...func(*managedblockchain.Options)) *managedblockchain.CreateMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.CreateMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.CreateMemberInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNetwork(ctx context.Context, params *managedblockchain.CreateNetworkInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.CreateNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetwork")
	}

	var r0 *managedblockchain.CreateNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateNetworkInput, ...func(*managedblockchain.Options)) (*managedblockchain.CreateNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateNetworkInput, ...func(*managedblockchain.Options)) *managedblockchain.CreateNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.CreateNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.CreateNetworkInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNode(ctx context.Context, params *managedblockchain.CreateNodeInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.CreateNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNode")
	}

	var r0 *managedblockchain.CreateNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateNodeInput, ...func(*managedblockchain.Options)) (*managedblockchain.CreateNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateNodeInput, ...func(*managedblockchain.Options)) *managedblockchain.CreateNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.CreateNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.CreateNodeInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProposal provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateProposal(ctx context.Context, params *managedblockchain.CreateProposalInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.CreateProposalOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProposal")
	}

	var r0 *managedblockchain.CreateProposalOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateProposalInput, ...func(*managedblockchain.Options)) (*managedblockchain.CreateProposalOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.CreateProposalInput, ...func(*managedblockchain.Options)) *managedblockchain.CreateProposalOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.CreateProposalOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.CreateProposalInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteAccessor(ctx context.Context, params *managedblockchain.DeleteAccessorInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.DeleteAccessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessor")
	}

	var r0 *managedblockchain.DeleteAccessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteAccessorInput, ...func(*managedblockchain.Options)) (*managedblockchain.DeleteAccessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteAccessorInput, ...func(*managedblockchain.Options)) *managedblockchain.DeleteAccessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.DeleteAccessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.DeleteAccessorInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteMember(ctx context.Context, params *managedblockchain.DeleteMemberInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.DeleteMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMember")
	}

	var r0 *managedblockchain.DeleteMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteMemberInput, ...func(*managedblockchain.Options)) (*managedblockchain.DeleteMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteMemberInput, ...func(*managedblockchain.Options)) *managedblockchain.DeleteMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.DeleteMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.DeleteMemberInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNode(ctx context.Context, params *managedblockchain.DeleteNodeInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.DeleteNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNode")
	}

	var r0 *managedblockchain.DeleteNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteNodeInput, ...func(*managedblockchain.Options)) (*managedblockchain.DeleteNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.DeleteNodeInput, ...func(*managedblockchain.Options)) *managedblockchain.DeleteNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.DeleteNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.DeleteNodeInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccessor provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetAccessor(ctx context.Context, params *managedblockchain.GetAccessorInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.GetAccessorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessor")
	}

	var r0 *managedblockchain.GetAccessorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetAccessorInput, ...func(*managedblockchain.Options)) (*managedblockchain.GetAccessorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetAccessorInput, ...func(*managedblockchain.Options)) *managedblockchain.GetAccessorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.GetAccessorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.GetAccessorInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetMember(ctx context.Context, params *managedblockchain.GetMemberInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.GetMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMember")
	}

	var r0 *managedblockchain.GetMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetMemberInput, ...func(*managedblockchain.Options)) (*managedblockchain.GetMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetMemberInput, ...func(*managedblockchain.Options)) *managedblockchain.GetMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.GetMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.GetMemberInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNetwork(ctx context.Context, params *managedblockchain.GetNetworkInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.GetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetwork")
	}

	var r0 *managedblockchain.GetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetNetworkInput, ...func(*managedblockchain.Options)) (*managedblockchain.GetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetNetworkInput, ...func(*managedblockchain.Options)) *managedblockchain.GetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.GetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.GetNetworkInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNode(ctx context.Context, params *managedblockchain.GetNodeInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.GetNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNode")
	}

	var r0 *managedblockchain.GetNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetNodeInput, ...func(*managedblockchain.Options)) (*managedblockchain.GetNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetNodeInput, ...func(*managedblockchain.Options)) *managedblockchain.GetNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.GetNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.GetNodeInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProposal provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetProposal(ctx context.Context, params *managedblockchain.GetProposalInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.GetProposalOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProposal")
	}

	var r0 *managedblockchain.GetProposalOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetProposalInput, ...func(*managedblockchain.Options)) (*managedblockchain.GetProposalOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.GetProposalInput, ...func(*managedblockchain.Options)) *managedblockchain.GetProposalOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.GetProposalOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.GetProposalInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessors provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListAccessors(ctx context.Context, params *managedblockchain.ListAccessorsInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListAccessorsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessors")
	}

	var r0 *managedblockchain.ListAccessorsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListAccessorsInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListAccessorsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListAccessorsInput, ...func(*managedblockchain.Options)) *managedblockchain.ListAccessorsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListAccessorsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListAccessorsInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInvitations provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListInvitations(ctx context.Context, params *managedblockchain.ListInvitationsInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListInvitationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListInvitations")
	}

	var r0 *managedblockchain.ListInvitationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListInvitationsInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListInvitationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListInvitationsInput, ...func(*managedblockchain.Options)) *managedblockchain.ListInvitationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListInvitationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListInvitationsInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMembers provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListMembers(ctx context.Context, params *managedblockchain.ListMembersInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMembers")
	}

	var r0 *managedblockchain.ListMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListMembersInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListMembersInput, ...func(*managedblockchain.Options)) *managedblockchain.ListMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListMembersInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNetworks provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNetworks(ctx context.Context, params *managedblockchain.ListNetworksInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListNetworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNetworks")
	}

	var r0 *managedblockchain.ListNetworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListNetworksInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListNetworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListNetworksInput, ...func(*managedblockchain.Options)) *managedblockchain.ListNetworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListNetworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListNetworksInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNodes(ctx context.Context, params *managedblockchain.ListNodesInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListNodesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNodes")
	}

	var r0 *managedblockchain.ListNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListNodesInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListNodesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListNodesInput, ...func(*managedblockchain.Options)) *managedblockchain.ListNodesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListNodesInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProposalVotes provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProposalVotes(ctx context.Context, params *managedblockchain.ListProposalVotesInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListProposalVotesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProposalVotes")
	}

	var r0 *managedblockchain.ListProposalVotesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListProposalVotesInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListProposalVotesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListProposalVotesInput, ...func(*managedblockchain.Options)) *managedblockchain.ListProposalVotesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListProposalVotesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListProposalVotesInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProposals provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListProposals(ctx context.Context, params *managedblockchain.ListProposalsInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListProposalsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProposals")
	}

	var r0 *managedblockchain.ListProposalsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListProposalsInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListProposalsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListProposalsInput, ...func(*managedblockchain.Options)) *managedblockchain.ListProposalsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListProposalsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListProposalsInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *managedblockchain.ListTagsForResourceInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *managedblockchain.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListTagsForResourceInput, ...func(*managedblockchain.Options)) (*managedblockchain.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.ListTagsForResourceInput, ...func(*managedblockchain.Options)) *managedblockchain.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.ListTagsForResourceInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *IClient) Options() managedblockchain.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 managedblockchain.Options
	if rf, ok := ret.Get(0).(func() managedblockchain.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(managedblockchain.Options)
	}

	return r0
}

// RejectInvitation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RejectInvitation(ctx context.Context, params *managedblockchain.RejectInvitationInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.RejectInvitationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectInvitation")
	}

	var r0 *managedblockchain.RejectInvitationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.RejectInvitationInput, ...func(*managedblockchain.Options)) (*managedblockchain.RejectInvitationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.RejectInvitationInput, ...func(*managedblockchain.Options)) *managedblockchain.RejectInvitationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.RejectInvitationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.RejectInvitationInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *managedblockchain.TagResourceInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *managedblockchain.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.TagResourceInput, ...func(*managedblockchain.Options)) (*managedblockchain.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.TagResourceInput, ...func(*managedblockchain.Options)) *managedblockchain.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.TagResourceInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *managedblockchain.UntagResourceInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *managedblockchain.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UntagResourceInput, ...func(*managedblockchain.Options)) (*managedblockchain.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UntagResourceInput, ...func(*managedblockchain.Options)) *managedblockchain.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.UntagResourceInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMember provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateMember(ctx context.Context, params *managedblockchain.UpdateMemberInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.UpdateMemberOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMember")
	}

	var r0 *managedblockchain.UpdateMemberOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UpdateMemberInput, ...func(*managedblockchain.Options)) (*managedblockchain.UpdateMemberOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UpdateMemberInput, ...func(*managedblockchain.Options)) *managedblockchain.UpdateMemberOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.UpdateMemberOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.UpdateMemberInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNode provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateNode(ctx context.Context, params *managedblockchain.UpdateNodeInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.UpdateNodeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNode")
	}

	var r0 *managedblockchain.UpdateNodeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UpdateNodeInput, ...func(*managedblockchain.Options)) (*managedblockchain.UpdateNodeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.UpdateNodeInput, ...func(*managedblockchain.Options)) *managedblockchain.UpdateNodeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.UpdateNodeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.UpdateNodeInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VoteOnProposal provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) VoteOnProposal(ctx context.Context, params *managedblockchain.VoteOnProposalInput, optFns ...func(*managedblockchain.Options)) (*managedblockchain.VoteOnProposalOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VoteOnProposal")
	}

	var r0 *managedblockchain.VoteOnProposalOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.VoteOnProposalInput, ...func(*managedblockchain.Options)) (*managedblockchain.VoteOnProposalOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *managedblockchain.VoteOnProposalInput, ...func(*managedblockchain.Options)) *managedblockchain.VoteOnProposalOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*managedblockchain.VoteOnProposalOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *managedblockchain.VoteOnProposalInput, ...func(*managedblockchain.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
