// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	s3tables "github.com/aws/aws-sdk-go-v2/service/s3tables"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNamespace(ctx context.Context, params *s3tables.CreateNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNamespace")
	}

	var r0 *s3tables.CreateNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) (*s3tables.CreateNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) *s3tables.CreateNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTable(ctx context.Context, params *s3tables.CreateTableInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTable")
	}

	var r0 *s3tables.CreateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) (*s3tables.CreateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) *s3tables.CreateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTableBucket(ctx context.Context, params *s3tables.CreateTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTableBucket")
	}

	var r0 *s3tables.CreateTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) (*s3tables.CreateTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) *s3tables.CreateTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNamespace(ctx context.Context, params *s3tables.DeleteNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNamespace")
	}

	var r0 *s3tables.DeleteNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) (*s3tables.DeleteNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) *s3tables.DeleteNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTable(ctx context.Context, params *s3tables.DeleteTableInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTable")
	}

	var r0 *s3tables.DeleteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) *s3tables.DeleteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucket(ctx context.Context, params *s3tables.DeleteTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucket")
	}

	var r0 *s3tables.DeleteTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketEncryption(ctx context.Context, params *s3tables.DeleteTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketEncryption")
	}

	var r0 *s3tables.DeleteTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketMetricsConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketMetricsConfiguration(ctx context.Context, params *s3tables.DeleteTableBucketMetricsConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketMetricsConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketMetricsConfiguration")
	}

	var r0 *s3tables.DeleteTableBucketMetricsConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketMetricsConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketMetricsConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketMetricsConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketPolicy(ctx context.Context, params *s3tables.DeleteTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketPolicy")
	}

	var r0 *s3tables.DeleteTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketReplication(ctx context.Context, params *s3tables.DeleteTableBucketReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketReplication")
	}

	var r0 *s3tables.DeleteTableBucketReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketReplicationInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketReplicationInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTablePolicy(ctx context.Context, params *s3tables.DeleteTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTablePolicy")
	}

	var r0 *s3tables.DeleteTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.DeleteTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) *s3tables.DeleteTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableReplication(ctx context.Context, params *s3tables.DeleteTableReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableReplication")
	}

	var r0 *s3tables.DeleteTableReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableReplicationInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableReplicationInput, ...func(*s3tables.Options)) *s3tables.DeleteTableReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNamespace(ctx context.Context, params *s3tables.GetNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.GetNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespace")
	}

	var r0 *s3tables.GetNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) (*s3tables.GetNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) *s3tables.GetNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTable(ctx context.Context, params *s3tables.GetTableInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTable")
	}

	var r0 *s3tables.GetTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) (*s3tables.GetTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) *s3tables.GetTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucket(ctx context.Context, params *s3tables.GetTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucket")
	}

	var r0 *s3tables.GetTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketEncryption(ctx context.Context, params *s3tables.GetTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketEncryption")
	}

	var r0 *s3tables.GetTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketMaintenanceConfiguration(ctx context.Context, params *s3tables.GetTableBucketMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketMaintenanceConfiguration")
	}

	var r0 *s3tables.GetTableBucketMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketMetricsConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketMetricsConfiguration(ctx context.Context, params *s3tables.GetTableBucketMetricsConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketMetricsConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketMetricsConfiguration")
	}

	var r0 *s3tables.GetTableBucketMetricsConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketMetricsConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketMetricsConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketMetricsConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketPolicy(ctx context.Context, params *s3tables.GetTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketPolicy")
	}

	var r0 *s3tables.GetTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketReplication(ctx context.Context, params *s3tables.GetTableBucketReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketReplication")
	}

	var r0 *s3tables.GetTableBucketReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketReplicationInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketReplicationInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketStorageClass provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketStorageClass(ctx context.Context, params *s3tables.GetTableBucketStorageClassInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketStorageClassOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketStorageClass")
	}

	var r0 *s3tables.GetTableBucketStorageClassOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketStorageClassInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketStorageClassOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketStorageClassInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketStorageClassOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketStorageClassOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketStorageClassInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableEncryption(ctx context.Context, params *s3tables.GetTableEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableEncryption")
	}

	var r0 *s3tables.GetTableEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) (*s3tables.GetTableEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) *s3tables.GetTableEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMaintenanceConfiguration(ctx context.Context, params *s3tables.GetTableMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMaintenanceConfiguration")
	}

	var r0 *s3tables.GetTableMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMaintenanceJobStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMaintenanceJobStatus(ctx context.Context, params *s3tables.GetTableMaintenanceJobStatusInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceJobStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMaintenanceJobStatus")
	}

	var r0 *s3tables.GetTableMaintenanceJobStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceJobStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) *s3tables.GetTableMaintenanceJobStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMaintenanceJobStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMetadataLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMetadataLocation(ctx context.Context, params *s3tables.GetTableMetadataLocationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMetadataLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMetadataLocation")
	}

	var r0 *s3tables.GetTableMetadataLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) (*s3tables.GetTableMetadataLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) *s3tables.GetTableMetadataLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMetadataLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTablePolicy(ctx context.Context, params *s3tables.GetTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTablePolicy")
	}

	var r0 *s3tables.GetTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.GetTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) *s3tables.GetTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableRecordExpirationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableRecordExpirationConfiguration(ctx context.Context, params *s3tables.GetTableRecordExpirationConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableRecordExpirationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableRecordExpirationConfiguration")
	}

	var r0 *s3tables.GetTableRecordExpirationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableRecordExpirationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableRecordExpirationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableRecordExpirationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableRecordExpirationJobStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableRecordExpirationJobStatus(ctx context.Context, params *s3tables.GetTableRecordExpirationJobStatusInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableRecordExpirationJobStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableRecordExpirationJobStatus")
	}

	var r0 *s3tables.GetTableRecordExpirationJobStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableRecordExpirationJobStatusInput, ...func(*s3tables.Options)) (*s3tables.GetTableRecordExpirationJobStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableRecordExpirationJobStatusInput, ...func(*s3tables.Options)) *s3tables.GetTableRecordExpirationJobStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableRecordExpirationJobStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableRecordExpirationJobStatusInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableReplication(ctx context.Context, params *s3tables.GetTableReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableReplication")
	}

	var r0 *s3tables.GetTableReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableReplicationInput, ...func(*s3tables.Options)) (*s3tables.GetTableReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableReplicationInput, ...func(*s3tables.Options)) *s3tables.GetTableReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableReplicationStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableReplicationStatus(ctx context.Context, params *s3tables.GetTableReplicationStatusInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableReplicationStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableReplicationStatus")
	}

	var r0 *s3tables.GetTableReplicationStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableReplicationStatusInput, ...func(*s3tables.Options)) (*s3tables.GetTableReplicationStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableReplicationStatusInput, ...func(*s3tables.Options)) *s3tables.GetTableReplicationStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableReplicationStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableReplicationStatusInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableStorageClass provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableStorageClass(ctx context.Context, params *s3tables.GetTableStorageClassInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableStorageClassOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableStorageClass")
	}

	var r0 *s3tables.GetTableStorageClassOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableStorageClassInput, ...func(*s3tables.Options)) (*s3tables.GetTableStorageClassOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableStorageClassInput, ...func(*s3tables.Options)) *s3tables.GetTableStorageClassOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableStorageClassOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableStorageClassInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNamespaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNamespaces(ctx context.Context, params *s3tables.ListNamespacesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListNamespacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNamespaces")
	}

	var r0 *s3tables.ListNamespacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) (*s3tables.ListNamespacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) *s3tables.ListNamespacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListNamespacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTableBuckets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTableBuckets(ctx context.Context, params *s3tables.ListTableBucketsInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTableBucketsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTableBuckets")
	}

	var r0 *s3tables.ListTableBucketsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) (*s3tables.ListTableBucketsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) *s3tables.ListTableBucketsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListTableBucketsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTables(ctx context.Context, params *s3tables.ListTablesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTables")
	}

	var r0 *s3tables.ListTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) (*s3tables.ListTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) *s3tables.ListTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTagsForResource(ctx context.Context, params *s3tables.ListTagsForResourceInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *s3tables.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTagsForResourceInput, ...func(*s3tables.Options)) (*s3tables.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTagsForResourceInput, ...func(*s3tables.Options)) *s3tables.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListTagsForResourceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() s3tables.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 s3tables.Options
	if rf, ok := ret.Get(0).(func() s3tables.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(s3tables.Options)
	}

	return r0
}

// PutTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketEncryption(ctx context.Context, params *s3tables.PutTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketEncryption")
	}

	var r0 *s3tables.PutTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketMaintenanceConfiguration(ctx context.Context, params *s3tables.PutTableBucketMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketMaintenanceConfiguration")
	}

	var r0 *s3tables.PutTableBucketMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketMetricsConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketMetricsConfiguration(ctx context.Context, params *s3tables.PutTableBucketMetricsConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketMetricsConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketMetricsConfiguration")
	}

	var r0 *s3tables.PutTableBucketMetricsConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketMetricsConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketMetricsConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketMetricsConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketMetricsConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketPolicy(ctx context.Context, params *s3tables.PutTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketPolicy")
	}

	var r0 *s3tables.PutTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketReplication(ctx context.Context, params *s3tables.PutTableBucketReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketReplication")
	}

	var r0 *s3tables.PutTableBucketReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketReplicationInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketReplicationInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketStorageClass provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketStorageClass(ctx context.Context, params *s3tables.PutTableBucketStorageClassInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketStorageClassOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketStorageClass")
	}

	var r0 *s3tables.PutTableBucketStorageClassOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketStorageClassInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketStorageClassOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketStorageClassInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketStorageClassOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketStorageClassOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketStorageClassInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableMaintenanceConfiguration(ctx context.Context, params *s3tables.PutTableMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableMaintenanceConfiguration")
	}

	var r0 *s3tables.PutTableMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTablePolicy(ctx context.Context, params *s3tables.PutTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTablePolicy")
	}

	var r0 *s3tables.PutTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.PutTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) *s3tables.PutTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableRecordExpirationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableRecordExpirationConfiguration(ctx context.Context, params *s3tables.PutTableRecordExpirationConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableRecordExpirationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableRecordExpirationConfiguration")
	}

	var r0 *s3tables.PutTableRecordExpirationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableRecordExpirationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableRecordExpirationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableRecordExpirationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableRecordExpirationConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableReplication provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableReplication(ctx context.Context, params *s3tables.PutTableReplicationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableReplicationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableReplication")
	}

	var r0 *s3tables.PutTableReplicationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableReplicationInput, ...func(*s3tables.Options)) (*s3tables.PutTableReplicationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableReplicationInput, ...func(*s3tables.Options)) *s3tables.PutTableReplicationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableReplicationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableReplicationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenameTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RenameTable(ctx context.Context, params *s3tables.RenameTableInput, optFns ...func(*s3tables.Options)) (*s3tables.RenameTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RenameTable")
	}

	var r0 *s3tables.RenameTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) (*s3tables.RenameTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) *s3tables.RenameTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.RenameTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) TagResource(ctx context.Context, params *s3tables.TagResourceInput, optFns ...func(*s3tables.Options)) (*s3tables.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *s3tables.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.TagResourceInput, ...func(*s3tables.Options)) (*s3tables.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.TagResourceInput, ...func(*s3tables.Options)) *s3tables.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.TagResourceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UntagResource(ctx context.Context, params *s3tables.UntagResourceInput, optFns ...func(*s3tables.Options)) (*s3tables.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *s3tables.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UntagResourceInput, ...func(*s3tables.Options)) (*s3tables.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UntagResourceInput, ...func(*s3tables.Options)) *s3tables.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.UntagResourceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTableMetadataLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTableMetadataLocation(ctx context.Context, params *s3tables.UpdateTableMetadataLocationInput, optFns ...func(*s3tables.Options)) (*s3tables.UpdateTableMetadataLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTableMetadataLocation")
	}

	var r0 *s3tables.UpdateTableMetadataLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) (*s3tables.UpdateTableMetadataLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) *s3tables.UpdateTableMetadataLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.UpdateTableMetadataLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
