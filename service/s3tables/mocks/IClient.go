// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	s3tables "github.com/aws/aws-sdk-go-v2/service/s3tables"
	mock "github.com/stretchr/testify/mock"
)

// IClient is an autogenerated mock type for the IClient type
type IClient struct {
	mock.Mock
}

// CreateNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateNamespace(ctx context.Context, params *s3tables.CreateNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNamespace")
	}

	var r0 *s3tables.CreateNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) (*s3tables.CreateNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) *s3tables.CreateNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTable(ctx context.Context, params *s3tables.CreateTableInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTable")
	}

	var r0 *s3tables.CreateTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) (*s3tables.CreateTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) *s3tables.CreateTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) CreateTableBucket(ctx context.Context, params *s3tables.CreateTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTableBucket")
	}

	var r0 *s3tables.CreateTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) (*s3tables.CreateTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) *s3tables.CreateTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.CreateTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.CreateTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteNamespace(ctx context.Context, params *s3tables.DeleteNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNamespace")
	}

	var r0 *s3tables.DeleteNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) (*s3tables.DeleteNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) *s3tables.DeleteNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTable(ctx context.Context, params *s3tables.DeleteTableInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTable")
	}

	var r0 *s3tables.DeleteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) *s3tables.DeleteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucket(ctx context.Context, params *s3tables.DeleteTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucket")
	}

	var r0 *s3tables.DeleteTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketEncryption(ctx context.Context, params *s3tables.DeleteTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketEncryption")
	}

	var r0 *s3tables.DeleteTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTableBucketPolicy(ctx context.Context, params *s3tables.DeleteTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTableBucketPolicy")
	}

	var r0 *s3tables.DeleteTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.DeleteTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.DeleteTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) DeleteTablePolicy(ctx context.Context, params *s3tables.DeleteTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.DeleteTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTablePolicy")
	}

	var r0 *s3tables.DeleteTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.DeleteTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) *s3tables.DeleteTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.DeleteTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.DeleteTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamespace provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetNamespace(ctx context.Context, params *s3tables.GetNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.GetNamespaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespace")
	}

	var r0 *s3tables.GetNamespaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) (*s3tables.GetNamespaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) *s3tables.GetNamespaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetNamespaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetNamespaceInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTable(ctx context.Context, params *s3tables.GetTableInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTable")
	}

	var r0 *s3tables.GetTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) (*s3tables.GetTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) *s3tables.GetTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucket provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucket(ctx context.Context, params *s3tables.GetTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucket")
	}

	var r0 *s3tables.GetTableBucketOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketEncryption(ctx context.Context, params *s3tables.GetTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketEncryption")
	}

	var r0 *s3tables.GetTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketMaintenanceConfiguration(ctx context.Context, params *s3tables.GetTableBucketMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketMaintenanceConfiguration")
	}

	var r0 *s3tables.GetTableBucketMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableBucketPolicy(ctx context.Context, params *s3tables.GetTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableBucketPolicy")
	}

	var r0 *s3tables.GetTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.GetTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.GetTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableEncryption(ctx context.Context, params *s3tables.GetTableEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableEncryption")
	}

	var r0 *s3tables.GetTableEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) (*s3tables.GetTableEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) *s3tables.GetTableEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMaintenanceConfiguration(ctx context.Context, params *s3tables.GetTableMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMaintenanceConfiguration")
	}

	var r0 *s3tables.GetTableMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.GetTableMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMaintenanceJobStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMaintenanceJobStatus(ctx context.Context, params *s3tables.GetTableMaintenanceJobStatusInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceJobStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMaintenanceJobStatus")
	}

	var r0 *s3tables.GetTableMaintenanceJobStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) (*s3tables.GetTableMaintenanceJobStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) *s3tables.GetTableMaintenanceJobStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMaintenanceJobStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMaintenanceJobStatusInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTableMetadataLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTableMetadataLocation(ctx context.Context, params *s3tables.GetTableMetadataLocationInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableMetadataLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTableMetadataLocation")
	}

	var r0 *s3tables.GetTableMetadataLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) (*s3tables.GetTableMetadataLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) *s3tables.GetTableMetadataLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTableMetadataLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTableMetadataLocationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) GetTablePolicy(ctx context.Context, params *s3tables.GetTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTablePolicy")
	}

	var r0 *s3tables.GetTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.GetTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) *s3tables.GetTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.GetTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.GetTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNamespaces provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListNamespaces(ctx context.Context, params *s3tables.ListNamespacesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListNamespacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNamespaces")
	}

	var r0 *s3tables.ListNamespacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) (*s3tables.ListNamespacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) *s3tables.ListNamespacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListNamespacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListNamespacesInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTableBuckets provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTableBuckets(ctx context.Context, params *s3tables.ListTableBucketsInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTableBucketsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTableBuckets")
	}

	var r0 *s3tables.ListTableBucketsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) (*s3tables.ListTableBucketsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) *s3tables.ListTableBucketsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListTableBucketsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListTableBucketsInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTables provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) ListTables(ctx context.Context, params *s3tables.ListTablesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTables")
	}

	var r0 *s3tables.ListTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) (*s3tables.ListTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) *s3tables.ListTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.ListTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.ListTablesInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *IClient) Options() s3tables.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 s3tables.Options
	if rf, ok := ret.Get(0).(func() s3tables.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(s3tables.Options)
	}

	return r0
}

// PutTableBucketEncryption provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketEncryption(ctx context.Context, params *s3tables.PutTableBucketEncryptionInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketEncryptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketEncryption")
	}

	var r0 *s3tables.PutTableBucketEncryptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketEncryptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketEncryptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketEncryptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketEncryptionInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketMaintenanceConfiguration(ctx context.Context, params *s3tables.PutTableBucketMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketMaintenanceConfiguration")
	}

	var r0 *s3tables.PutTableBucketMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableBucketPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableBucketPolicy(ctx context.Context, params *s3tables.PutTableBucketPolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableBucketPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableBucketPolicy")
	}

	var r0 *s3tables.PutTableBucketPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) (*s3tables.PutTableBucketPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) *s3tables.PutTableBucketPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableBucketPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableBucketPolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTableMaintenanceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTableMaintenanceConfiguration(ctx context.Context, params *s3tables.PutTableMaintenanceConfigurationInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTableMaintenanceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTableMaintenanceConfiguration")
	}

	var r0 *s3tables.PutTableMaintenanceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) (*s3tables.PutTableMaintenanceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) *s3tables.PutTableMaintenanceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTableMaintenanceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTableMaintenanceConfigurationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutTablePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) PutTablePolicy(ctx context.Context, params *s3tables.PutTablePolicyInput, optFns ...func(*s3tables.Options)) (*s3tables.PutTablePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutTablePolicy")
	}

	var r0 *s3tables.PutTablePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) (*s3tables.PutTablePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) *s3tables.PutTablePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.PutTablePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.PutTablePolicyInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenameTable provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) RenameTable(ctx context.Context, params *s3tables.RenameTableInput, optFns ...func(*s3tables.Options)) (*s3tables.RenameTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RenameTable")
	}

	var r0 *s3tables.RenameTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) (*s3tables.RenameTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) *s3tables.RenameTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.RenameTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.RenameTableInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTableMetadataLocation provides a mock function with given fields: ctx, params, optFns
func (_m *IClient) UpdateTableMetadataLocation(ctx context.Context, params *s3tables.UpdateTableMetadataLocationInput, optFns ...func(*s3tables.Options)) (*s3tables.UpdateTableMetadataLocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTableMetadataLocation")
	}

	var r0 *s3tables.UpdateTableMetadataLocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) (*s3tables.UpdateTableMetadataLocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) *s3tables.UpdateTableMetadataLocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3tables.UpdateTableMetadataLocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *s3tables.UpdateTableMetadataLocationInput, ...func(*s3tables.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIClient creates a new instance of IClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IClient {
	mock := &IClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
